/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Pd = function(e, n) {
  return (Pd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var a in r) r.hasOwnProperty(a) && (t[a] = r[a]);
  })(e, n);
};
function en(e, n) {
  function t() {
    this.constructor = e;
  }
  Pd(e, n), e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
}
function Y(e, n, t, r) {
  return new (t || (t = Promise))(function(a, o) {
    function i(l) {
      try {
        u(r.next(l));
      } catch (c) {
        o(c);
      }
    }
    function s(l) {
      try {
        u(r.throw(l));
      } catch (c) {
        o(c);
      }
    }
    function u(l) {
      l.done ? a(l.value) : new t(function(c) {
        c(l.value);
      }).then(i, s);
    }
    u((r = r.apply(e, [])).next());
  });
}
function Z(e, n) {
  var t, r, a, o, i = { label: 0, sent: function() {
    if (1 & a[0]) throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(u) {
    return function(l) {
      return function(c) {
        if (t) throw new TypeError("Generator is already executing.");
        for (; i; ) try {
          if (t = 1, r && (a = 2 & c[0] ? r.return : c[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, c[1])).done) return a;
          switch (r = 0, a && (c = [2 & c[0], a.value]), c[0]) {
            case 0:
            case 1:
              a = c;
              break;
            case 4:
              return i.label++, { value: c[1], done: !1 };
            case 5:
              i.label++, r = c[1], c = [0];
              continue;
            case 7:
              c = i.ops.pop(), i.trys.pop();
              continue;
            default:
              if (!(a = (a = i.trys).length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                i = 0;
                continue;
              }
              if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
                i.label = c[1];
                break;
              }
              if (c[0] === 6 && i.label < a[1]) {
                i.label = a[1], a = c;
                break;
              }
              if (a && i.label < a[2]) {
                i.label = a[2], i.ops.push(c);
                break;
              }
              a[2] && i.ops.pop(), i.trys.pop();
              continue;
          }
          c = n.call(e, i);
        } catch (h) {
          c = [6, h], r = 0;
        } finally {
          t = a = 0;
        }
        if (5 & c[0]) throw c[1];
        return { value: c[0] ? c[1] : void 0, done: !0 };
      }([u, l]);
    };
  }
}
var Ag = function() {
  function e(n) {
    this.global = n, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();
  }
  return e.prototype.setPlatform = function(n, t) {
    this.platform != null && console.warn("Platform " + this.platformName + " has already been set. Overwriting the platform with " + t + "."), this.platformName = n, this.platform = t;
  }, e.prototype.registerFlag = function(n, t, r) {
    if (this.flagRegistry[n] = { evaluationFn: t, setHook: r }, this.urlFlags[n] != null) {
      var a = this.urlFlags[n];
      console.warn("Setting feature override from URL " + n + ": " + a + "."), this.set(n, a);
    }
  }, e.prototype.get = function(n) {
    return n in this.flags ? this.flags[n] : (this.flags[n] = this.evaluateFlag(n), this.flags[n]);
  }, e.prototype.getNumber = function(n) {
    return this.get(n);
  }, e.prototype.getBool = function(n) {
    return this.get(n);
  }, e.prototype.getFlags = function() {
    return this.flags;
  }, Object.defineProperty(e.prototype, "features", { get: function() {
    return this.flags;
  }, enumerable: !0, configurable: !0 }), e.prototype.set = function(n, t) {
    if (this.flagRegistry[n] == null) throw new Error("Cannot set flag " + n + " as it has not been registered.");
    this.flags[n] = t, this.flagRegistry[n].setHook != null && this.flagRegistry[n].setHook(t);
  }, e.prototype.evaluateFlag = function(n) {
    if (this.flagRegistry[n] == null) throw new Error("Cannot evaluate flag '" + n + "': no evaluation function found.");
    return this.flagRegistry[n].evaluationFn();
  }, e.prototype.setFlags = function(n) {
    this.flags = Object.assign({}, n);
  }, e.prototype.reset = function() {
    this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
  }, e.prototype.populateURLFlags = function() {
    var n = this;
    if (this.global !== void 0 && this.global.location !== void 0 && this.global.location.search !== void 0) {
      var t, r, a = (t = this.global.location.search, r = {}, t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(o) {
        for (var i = [], s = 1; s < arguments.length; s++) i[s - 1] = arguments[s];
        return Ig(r, i[0], i[1]), i.join("=");
      }), r);
      "tfjsflags" in a && a.tfjsflags.split(",").forEach(function(o) {
        var i = o.split(":"), s = i[0], u = i[1];
        n.urlFlags[s] = function(l, c) {
          if ((c = c.toLowerCase()) === "true" || c === "false") return c === "true";
          if ("" + +c === c) return +c;
          throw new Error("Could not parse value flag value " + c + " for flag " + l + ".");
        }(s, u);
      });
    }
  }, e;
}();
function Ig(e, n, t) {
  e[decodeURIComponent(n)] = decodeURIComponent(t || "");
}
function _() {
  return Sd;
}
var Sd = null, jo = /* @__PURE__ */ new Map(), Ns = /* @__PURE__ */ new Map();
function Dd(e, n) {
  var t = Rd(e, n);
  return jo.get(t);
}
function Pl(e) {
  return Ns.get(e);
}
function Sl(e) {
  for (var n = jo.entries(), t = []; ; ) {
    var r = n.next(), a = r.done, o = r.value;
    if (a) break;
    var i = o[0], s = o[1];
    i.split("_")[0] === e && t.push(s);
  }
  return t;
}
function Od(e) {
  var n = e.kernelName, t = e.backendName, r = Rd(n, t);
  if (jo.has(r)) throw new Error("The kernel '" + n + "' for backend '" + t + "' is already registered");
  jo.set(r, e);
}
function Eg(e) {
  var n = e.kernelName;
  Ns.has(n) && console.warn("Overriding the gradient for '" + n + "'"), Ns.set(n, e);
}
function Rd(e, n) {
  return n + "_" + e;
}
function Dl(e) {
  for (var n = e.length, t = 0, r = 0; n > 0; ) r = Math.random() * n | 0, t = e[--n], e[n] = e[r], e[r] = t;
}
function Vo(e, n, t) {
  return Math.max(e, Math.min(n, t));
}
function wu(e) {
  return e % 2 == 0 ? e : e + 1;
}
function Fd(e) {
  for (var n = 0, t = 0; t < e.length; t++) n += e[t];
  return n;
}
function A(e, n) {
  if (!e) throw new Error(typeof n == "string" ? n : n());
}
function ke(e, n, t) {
  t === void 0 && (t = ""), A(Ye(e, n), function() {
    return t + " Shapes " + e + " and " + n + " must match";
  });
}
function Tr(e) {
  A(e != null, function() {
    return "The input to the tensor constructor must be a non-null value.";
  });
}
function Nr(e, n, t) {
  if (n === void 0 && (n = []), t === void 0 && (t = !1), n == null && (n = []), Array.isArray(e) || Qt(e) && !t) for (var r = 0; r < e.length; ++r) Nr(e[r], n, t);
  else n.push(e);
  return n;
}
function Q(e) {
  if (e.length === 0) return 1;
  for (var n = e[0], t = 1; t < e.length; t++) n *= e[t];
  return n;
}
function Ye(e, n) {
  if (e === n) return !0;
  if (e == null || n == null || e.length !== n.length) return !1;
  for (var t = 0; t < e.length; t++) if (e[t] !== n[t]) return !1;
  return !0;
}
function He(e) {
  return e % 1 == 0;
}
function Md(e) {
  if (Math.tanh != null) return Math.tanh(e);
  if (e === 1 / 0) return 1;
  if (e === -1 / 0) return -1;
  var n = Math.exp(2 * e);
  return (n - 1) / (n + 1);
}
function Lo(e) {
  var n = Math.ceil(Math.sqrt(e));
  return [n, Math.ceil(e / n)];
}
function wr(e, n) {
  return n <= e.length ? e : e + " ".repeat(n - e.length);
}
function As(e, n, t) {
  return n === void 0 && (n = function(r) {
    return 0;
  }), new Promise(function(r, a) {
    var o = 0, i = function() {
      if (e()) r();
      else {
        o++;
        var s = n(o);
        t != null && o >= t ? a() : setTimeout(i, s);
      }
    };
    i();
  });
}
function _d(e, n) {
  for (var t = 1, r = -1, a = 0; a < e.length; ++a) if (e[a] >= 0) t *= e[a];
  else if (e[a] === -1) {
    if (r !== -1) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + r + " and dim " + a);
    r = a;
  } else if (e[a] < 0) throw Error("Shapes can not be < 0. Found " + e[a] + " at dim " + a);
  if (r === -1) {
    if (n > 0 && n !== t) throw Error("Size(" + n + ") must match the product of shape " + e);
    return e;
  }
  if (t === 0) throw Error("Cannot infer the missing size in [" + e + "] when there are 0 elements");
  if (n % t != 0) throw Error("The implicit shape can't be a fractional number. Got " + n + " / " + t);
  var o = e.slice();
  return o[r] = n / t, o;
}
function Xe(e, n) {
  var t = n.length;
  return A((e = e == null ? n.map(function(r, a) {
    return a;
  }) : [].concat(e)).every(function(r) {
    return r >= -t && r < t;
  }), function() {
    return "All values in axis param must be in range [-" + t + ", " + t + ") but got axis " + e;
  }), A(e.every(function(r) {
    return He(r);
  }), function() {
    return "All values in axis param must be integers but got axis " + e;
  }), e.map(function(r) {
    return r < 0 ? t + r : r;
  });
}
function Un(e, n) {
  for (var t = [], r = [], a = n != null && Array.isArray(n) && n.length === 0, o = n == null || a ? null : Xe(n, e).sort(), i = 0, s = 0; s < e.length; ++s) {
    if (o != null) {
      if (o[i] === s && e[s] !== 1) throw new Error("Can't squeeze axis " + s + " since its dim '" + e[s] + "' is not 1");
      (o[i] == null || o[i] > s) && e[s] === 1 && (t.push(e[s]), r.push(s)), o[i] <= s && i++;
    }
    e[s] !== 1 && (t.push(e[s]), r.push(s));
  }
  return { newShape: t, keptDims: r };
}
function Ar(e, n) {
  var t = null;
  if (e == null || e === "float32") t = new Float32Array(n);
  else if (e === "int32") t = new Int32Array(n);
  else {
    if (e !== "bool") throw new Error("Unknown data type " + e);
    t = new Uint8Array(n);
  }
  return t;
}
function Ma(e, n) {
  var t = null;
  if (e == null || e === "float32") t = new Float32Array(n);
  else if (e === "int32") t = new Int32Array(n);
  else if (e === "bool") t = new Uint8Array(n);
  else {
    if (e !== "string") throw new Error("Unknown data type " + e);
    t = new Array(n);
  }
  return t;
}
function Bd(e, n) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type " + n + " being uploaded contains " + r + ".");
  }
}
function jd(e) {
  return e === "bool" || e === "complex64" || e === "float32" || e === "int32" || e === "string";
}
function Vd(e, n) {
  return n !== "complex64" && (n !== "float32" || e === "complex64") && (n !== "int32" || e === "float32" || e === "complex64") && (n !== "bool" || e !== "bool");
}
function Qt(e) {
  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array;
}
function Cu(e) {
  if (e === "float32" || e === "int32") return 4;
  if (e === "complex64") return 8;
  if (e === "bool") return 1;
  throw new Error("Unknown dtype " + e);
}
function Ld(e) {
  if (e == null) return 0;
  var n = 0;
  return e.forEach(function(t) {
    return n += t.length;
  }), n;
}
function ui(e) {
  return typeof e == "string" || e instanceof String;
}
function zd(e) {
  return typeof e == "boolean";
}
function Gd(e) {
  return typeof e == "number";
}
function da(e) {
  return Array.isArray(e) ? da(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array ? "int32" : Gd(e) ? "float32" : ui(e) ? "string" : zd(e) ? "bool" : "float32";
}
function zo(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function Go(e, n) {
  for (var t = n; t < e; ++t) if (e % t == 0) return t;
  return e;
}
function bt(e) {
  var n = e.length;
  if (n < 2) return [];
  var t = new Array(n - 1);
  t[n - 2] = e[n - 1];
  for (var r = n - 3; r >= 0; --r) t[r] = t[r + 1] * e[r + 1];
  return t;
}
function ku(e, n, t) {
  if (n === "string") throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array.isArray(e) && (e = Nr(e)), t && Bd(e, n), function(o, i) {
    return o instanceof Float32Array && i === "float32" || o instanceof Int32Array && i === "int32" || o instanceof Uint8Array && i === "bool";
  }(e, n)) return e;
  if (n == null || n === "float32" || n === "complex64") return new Float32Array(e);
  if (n === "int32") return new Int32Array(e);
  if (n === "bool") {
    for (var r = new Uint8Array(e.length), a = 0; a < r.length; ++a) Math.round(e[a]) !== 0 && (r[a] = 1);
    return r;
  }
  throw new Error("Unknown data type " + n);
}
function Is(e, n) {
  if (e.length === 0) return n[0];
  var t = e.reduce(function(r, a) {
    return r * a;
  });
  if (t === 0) return [];
  if (t !== n.length) throw new Error("[" + e + "] does not match the input size.");
  return function r(a, o, i) {
    var s = new Array();
    if (o.length === 1) for (var u = o[0], l = 0; l < u; l++) s[l] = i[a + l];
    else {
      u = o[0];
      var c = o.slice(1), h = c.reduce(function(d, p) {
        return d * p;
      });
      for (l = 0; l < u; l++) s[l] = r(a + l * h, c, i);
    }
    return s;
  }(0, e, n);
}
function Nu(e, n) {
  for (var t = pa(e, n), r = 0; r < t.length; r++) t[r] = 1;
  return t;
}
function pa(e, n) {
  if (n == null || n === "float32" || n === "complex64") return new Float32Array(e);
  if (n === "int32") return new Int32Array(e);
  if (n === "bool") return new Uint8Array(e);
  throw new Error("Unknown data type " + n);
}
function Jt() {
  return _().platform.now();
}
function Au(e) {
  e.forEach(function(n) {
    A(Number.isInteger(n) && n >= 0, function() {
      return "Tensor must have a shape comprised of positive integers but got shape [" + e + "].";
    });
  });
}
function Hd(e, n) {
  return n === void 0 && (n = "utf-8"), n = n || "utf-8", _().platform.encode(e, n);
}
function _a(e, n) {
  return n === void 0 && (n = "utf-8"), n = n || "utf-8", _().platform.decode(e, n);
}
function Ho(e, n, t) {
  if (n === 0) return 0;
  if (n === 1) return e[0];
  for (var r = e[e.length - 1], a = 0; a < e.length - 1; ++a) r += t[a] * e[a];
  return r;
}
function Iu(e, n, t) {
  if (n === 0) return [];
  if (n === 1) return [e];
  for (var r = new Array(n), a = 0; a < r.length - 1; ++a) r[a] = Math.floor(e / t[a]), e -= r[a] * t[a];
  return r[r.length - 1] = e, r;
}
var tr = Object.freeze({ shuffle: Dl, clamp: Vo, nearestLargerEven: wu, sum: Fd, randUniform: function(e, n) {
  var t = Math.random();
  return n * t + (1 - t) * e;
}, distSquared: function(e, n) {
  for (var t = 0, r = 0; r < e.length; r++) {
    var a = Number(e[r]) - Number(n[r]);
    t += a * a;
  }
  return t;
}, assert: A, assertShapesMatch: ke, assertNonNull: Tr, flatten: Nr, sizeFromShape: Q, isScalarShape: function(e) {
  return e.length === 0;
}, arraysEqual: Ye, isInt: He, tanh: Md, sizeToSquarishShape: Lo, createShuffledIndices: function(e) {
  for (var n = new Uint32Array(e), t = 0; t < e; ++t) n[t] = t;
  return Dl(n), n;
}, rightPad: wr, repeatedTry: As, inferFromImplicitShape: _d, parseAxisParam: Xe, squeezeShape: Un, getTypedArrayFromDType: Ar, getArrayFromDType: Ma, checkConversionForErrors: Bd, isValidDtype: jd, hasEncodingLoss: Vd, isTypedArray: Qt, bytesPerElement: Cu, bytesFromStringArray: Ld, isString: ui, isBoolean: zd, isNumber: Gd, inferDtype: da, isFunction: zo, nearestDivisor: Go, computeStrides: bt, toTypedArray: ku, toNestedArray: Is, makeOnesTypedArray: Nu, makeZerosTypedArray: pa, now: Jt, assertNonNegativeIntegerDimensions: Au, fetch: function(e, n) {
  return _().platform.fetch(e, n);
}, encodeString: Hd, decodeString: _a, locToIndex: Ho, indexToLoc: Iu }), Tg = function() {
  function e(n, t) {
    this.backendTimer = n, this.logger = t, t == null && (this.logger = new Pg());
  }
  return e.prototype.profileKernel = function(n, t, r) {
    var a, o = this, i = this.backendTimer.time(function() {
      a = r();
    });
    return a.forEach(function(s) {
      s.data().then(function(u) {
        (function(l, c, h) {
          if (c !== "float32") return !1;
          for (var d = 0; d < l.length; d++) {
            var p = l[d];
            if (isNaN(p) || !isFinite(p)) return console.warn("Found " + p + " in the result of '" + h + "'"), !0;
          }
        })(u, s.dtype, n), i.then(function(l) {
          var c = "";
          l.getExtraProfileInfo != null && (c = l.getExtraProfileInfo()), o.logger.logKernelProfile(n, s, u, l.kernelMs, t, c);
        });
      });
    }), a;
  }, e;
}(), Pg = function() {
  function e() {
  }
  return e.prototype.logKernelProfile = function(n, t, r, a, o, i) {
    var s = typeof a == "number" ? wr(a + "ms", 9) : a.error, u = wr(n, 25), l = t.rank, c = t.size, h = wr(t.shape.toString(), 14), d = "";
    for (var p in o) {
      var f = o[p].shape || t.shape, m = f.length;
      d += p + ": " + m + "D " + (m > 0 ? f : "") + " ";
    }
    console.log("%c" + u + "	%c" + s + "	%c" + l + "D " + h + "	%c" + c + "	%c" + d + "	%c" + i, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }, e;
}(), Ol = 20, ba = 3, Ri = 7;
function Sg(e, n, t, r) {
  var a = bt(n), o = function(l, c, h, d) {
    var p = Q(c), f = d[d.length - 1], m = new Array(f).fill(0), g = c.length, v = h === "complex64" ? wa(l) : l;
    if (g > 1) for (var y = 0; y < p / f; y++) for (var b = y * f, x = 0; x < f; x++) m[x] = Math.max(m[x], xa(v[b + x], 0, h).length);
    return m;
  }(e, n, t, a), i = n.length, s = function l(c, h, d, p, f, m) {
    m === void 0 && (m = !0);
    var g = d === "complex64" ? 2 : 1, v = h[0], y = h.length;
    if (y === 0)
      return d === "complex64" ? [xa(wa(c)[0], 0, d)] : d === "bool" ? [Wd(c[0])] : [c[0].toString()];
    if (y === 1) {
      if (v > Ol) {
        var b = ba * g, x = Array.from(c.slice(0, b)), C = Array.from(c.slice((v - ba) * g, v * g));
        return d === "complex64" && (x = wa(x), C = wa(C)), ["[" + x.map(function(B, H) {
          return xa(B, f[H], d);
        }).join(", ") + ", ..., " + C.map(function(B, H) {
          return xa(B, f[v - ba + H], d);
        }).join(", ") + "]"];
      }
      return ["[" + (d === "complex64" ? wa(c) : Array.from(c)).map(function(B, H) {
        return xa(B, f[H], d);
      }).join(", ") + "]"];
    }
    var N = h.slice(1), T = p.slice(1), I = p[0] * g, E = [];
    if (v > Ol) {
      for (var P = 0; P < ba; P++) {
        var O = (R = P * I) + I;
        E.push.apply(E, l(c.slice(R, O), N, d, T, f, !1));
      }
      for (E.push("..."), P = v - ba; P < v; P++)
        O = (R = P * I) + I, E.push.apply(E, l(c.slice(R, O), N, d, T, f, P === v - 1));
    } else for (P = 0; P < v; P++) {
      var R;
      O = (R = P * I) + I, E.push.apply(E, l(c.slice(R, O), N, d, T, f, P === v - 1));
    }
    var z = y === 2 ? "," : "";
    for (E[0] = "[" + E[0] + z, P = 1; P < E.length - 1; P++) E[P] = " " + E[P] + z;
    var j = `,
`;
    for (P = 2; P < y; P++) j += `
`;
    return E[E.length - 1] = " " + E[E.length - 1] + "]" + (m ? "" : j), E;
  }(e, n, t, a, o), u = ["Tensor"];
  return r && (u.push("  dtype: " + t), u.push("  rank: " + i), u.push("  shape: [" + n + "]"), u.push("  values:")), u.push(s.map(function(l) {
    return "    " + l;
  }).join(`
`)), u.join(`
`);
}
function xa(e, n, t) {
  return wr(Array.isArray(e) ? parseFloat(e[0].toFixed(Ri)) + " + " + parseFloat(e[1].toFixed(Ri)) + "j" : ui(e) ? "'" + e + "'" : t === "bool" ? Wd(e) : parseFloat(e.toFixed(Ri)).toString(), n);
}
function Wd(e) {
  return e === 0 ? "false" : "true";
}
function wa(e) {
  for (var n = [], t = 0; t < e.length; t += 2) n.push([e[t], e[t + 1]]);
  return n;
}
var Ba = function() {
  function e(n, t, r) {
    var a = this;
    if (this.dtype = t, this.shape = n.slice(), this.size = Q(n), r != null) {
      var o = r.length;
      A(o === this.size, function() {
        return "Length of values '" + o + "' does not match the size inferred by the shape '" + a.size + "'.";
      });
    }
    if (t === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this.values = r || Ma(t, this.size), this.strides = bt(n);
  }
  return e.prototype.set = function(n) {
    for (var t = this, r = [], a = 1; a < arguments.length; a++) r[a - 1] = arguments[a];
    r.length === 0 && (r = [0]), A(r.length === this.rank, function() {
      return "The number of provided coordinates (" + r.length + ") must match the rank (" + t.rank + ")";
    });
    var o = this.locToIndex(r);
    this.values[o] = n;
  }, e.prototype.get = function() {
    for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];
    n.length === 0 && (n = [0]);
    for (var r = 0, a = 0, o = n; a < o.length; a++) {
      var i = o[a];
      if (i < 0 || i >= this.shape[r]) {
        var s = "Requested out of range element at " + n + ".   Buffer shape=" + this.shape;
        throw new Error(s);
      }
      r++;
    }
    for (var u = n[n.length - 1], l = 0; l < n.length - 1; ++l) u += this.strides[l] * n[l];
    return this.values[u];
  }, e.prototype.locToIndex = function(n) {
    if (this.rank === 0) return 0;
    if (this.rank === 1) return n[0];
    for (var t = n[n.length - 1], r = 0; r < n.length - 1; ++r) t += this.strides[r] * n[r];
    return t;
  }, e.prototype.indexToLoc = function(n) {
    if (this.rank === 0) return [];
    if (this.rank === 1) return [n];
    for (var t = new Array(this.shape.length), r = 0; r < t.length - 1; ++r) t[r] = Math.floor(n / this.strides[r]), n -= t[r] * this.strides[r];
    return t[t.length - 1] = n, t;
  }, Object.defineProperty(e.prototype, "rank", { get: function() {
    return this.shape.length;
  }, enumerable: !0, configurable: !0 }), e.prototype.toTensor = function() {
    return ln().makeTensor(this.values, this.shape, this.dtype);
  }, e;
}(), ln = null, M = null, $d = null, Ve = function() {
  function e(n, t, r, a) {
    this.kept = !1, this.isDisposedInternal = !1, this.shape = n.slice(), this.dtype = t || "float32", this.size = Q(n), this.strides = bt(n), this.dataId = r, this.id = a, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  return e.prototype.flatten = function() {
    return this.throwIfDisposed(), this.as1D();
  }, e.prototype.asScalar = function() {
    return this.throwIfDisposed(), A(this.size === 1, function() {
      return "The array must have only 1 element.";
    }), this.reshape([]);
  }, e.prototype.as1D = function() {
    return this.throwIfDisposed(), this.reshape([this.size]);
  }, e.prototype.as2D = function(n, t) {
    return this.throwIfDisposed(), this.reshape([n, t]);
  }, e.prototype.as3D = function(n, t, r) {
    return this.throwIfDisposed(), this.reshape([n, t, r]);
  }, e.prototype.as4D = function(n, t, r, a) {
    return this.throwIfDisposed(), this.reshape([n, t, r, a]);
  }, e.prototype.as5D = function(n, t, r, a, o) {
    return this.throwIfDisposed(), this.reshape([n, t, r, a, o]);
  }, e.prototype.asType = function(n) {
    return this.throwIfDisposed(), M.cast(this, n);
  }, Object.defineProperty(e.prototype, "rank", { get: function() {
    return this.shape.length;
  }, enumerable: !0, configurable: !0 }), e.prototype.buffer = function() {
    return Y(this, void 0, void 0, function() {
      var n;
      return Z(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return n = t.sent(), [2, M.buffer(this.shape, this.dtype, n)];
        }
      });
    });
  }, e.prototype.bufferSync = function() {
    return M.buffer(this.shape, this.dtype, this.dataSync());
  }, e.prototype.array = function() {
    return Y(this, void 0, void 0, function() {
      var n;
      return Z(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.data()];
          case 1:
            return n = t.sent(), [2, Is(this.shape, n)];
        }
      });
    });
  }, e.prototype.arraySync = function() {
    return Is(this.shape, this.dataSync());
  }, e.prototype.data = function() {
    return Y(this, void 0, void 0, function() {
      var n, t;
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return this.throwIfDisposed(), n = ln().read(this.dataId), this.dtype !== "string" ? [3, 2] : [4, n];
          case 1:
            t = r.sent();
            try {
              return [2, t.map(function(a) {
                return _a(a);
              })];
            } catch {
              throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
            r.label = 2;
          case 2:
            return [2, n];
        }
      });
    });
  }, e.prototype.dataSync = function() {
    this.throwIfDisposed();
    var n = ln().readSync(this.dataId);
    if (this.dtype === "string") try {
      return n.map(function(t) {
        return _a(t);
      });
    } catch {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return n;
  }, e.prototype.bytes = function() {
    return Y(this, void 0, void 0, function() {
      var n;
      return Z(this, function(t) {
        switch (t.label) {
          case 0:
            return this.throwIfDisposed(), [4, ln().read(this.dataId)];
          case 1:
            return n = t.sent(), this.dtype === "string" ? [2, n] : [2, new Uint8Array(n.buffer)];
        }
      });
    });
  }, e.prototype.dispose = function() {
    this.isDisposed || (ln().disposeTensor(this), this.isDisposedInternal = !0);
  }, Object.defineProperty(e.prototype, "isDisposed", { get: function() {
    return this.isDisposedInternal;
  }, enumerable: !0, configurable: !0 }), e.prototype.throwIfDisposed = function() {
    if (this.isDisposed) throw new Error("Tensor is disposed.");
  }, e.prototype.toFloat = function() {
    return this.asType("float32");
  }, e.prototype.toInt = function() {
    return this.asType("int32");
  }, e.prototype.toBool = function() {
    return this.asType("bool");
  }, e.prototype.print = function(n) {
    return n === void 0 && (n = !1), M.print(this, n);
  }, e.prototype.reshape = function(n) {
    return this.throwIfDisposed(), M.reshape(this, n);
  }, e.prototype.reshapeAs = function(n) {
    return this.throwIfDisposed(), this.reshape(n.shape);
  }, e.prototype.expandDims = function(n) {
    return n === void 0 && (n = 0), M.expandDims(this, n);
  }, e.prototype.cumsum = function(n, t, r) {
    return n === void 0 && (n = 0), t === void 0 && (t = !1), r === void 0 && (r = !1), M.cumsum(this, n, t, r);
  }, e.prototype.squeeze = function(n) {
    return this.throwIfDisposed(), M.squeeze(this, n);
  }, e.prototype.clone = function() {
    return this.throwIfDisposed(), M.clone(this);
  }, e.prototype.toString = function(n) {
    return n === void 0 && (n = !1), Sg(this.dataSync(), this.shape, this.dtype, n);
  }, e.prototype.gather = function(n, t) {
    return t === void 0 && (t = 0), this.throwIfDisposed(), M.gather(this, n, t);
  }, e.prototype.matMul = function(n, t, r) {
    return t === void 0 && (t = !1), r === void 0 && (r = !1), this.throwIfDisposed(), M.matMul(this, n, t, r);
  }, e.prototype.dot = function(n) {
    return this.throwIfDisposed(), M.dot(this, n);
  }, e.prototype.norm = function(n, t, r) {
    return n === void 0 && (n = "euclidean"), t === void 0 && (t = null), r === void 0 && (r = !1), this.throwIfDisposed(), M.norm(this, n, t, r);
  }, e.prototype.slice = function(n, t) {
    return this.throwIfDisposed(), M.slice(this, n, t);
  }, e.prototype.reverse = function(n) {
    return this.throwIfDisposed(), M.reverse(this, n);
  }, e.prototype.concat = function(n, t) {
    return t === void 0 && (t = 0), this.throwIfDisposed(), n instanceof e && (n = [n]), M.concat([this].concat(n), t);
  }, e.prototype.split = function(n, t) {
    return t === void 0 && (t = 0), this.throwIfDisposed(), M.split(this, n, t);
  }, e.prototype.stack = function(n, t) {
    return t === void 0 && (t = 0), M.stack([this, n], t);
  }, e.prototype.unstack = function(n) {
    return n === void 0 && (n = 0), M.unstack(this, n);
  }, e.prototype.batchNormalization = function(n, t, r, a, o) {
    return r === void 0 && (r = 1e-3), $d("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"), this.batchNorm(n, t, o, a, r);
  }, e.prototype.all = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.all(this, n, t);
  }, e.prototype.any = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.any(this, n, t);
  }, e.prototype.logSumExp = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.logSumExp(this, n, t);
  }, e.prototype.sum = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.sum(this, n, t);
  }, e.prototype.prod = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.prod(this, n, t);
  }, e.prototype.mean = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.mean(this, n, t);
  }, e.prototype.min = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.min(this, n, t);
  }, e.prototype.max = function(n, t) {
    return n === void 0 && (n = null), t === void 0 && (t = !1), this.throwIfDisposed(), M.max(this, n, t);
  }, e.prototype.argMin = function(n) {
    return n === void 0 && (n = null), this.throwIfDisposed(), M.argMin(this, n);
  }, e.prototype.argMax = function(n) {
    return n === void 0 && (n = null), this.throwIfDisposed(), M.argMax(this, n);
  }, e.prototype.cast = function(n) {
    return this.throwIfDisposed(), M.cast(this, n);
  }, e.prototype.addStrict = function(n) {
    return this.throwIfDisposed(), M.addStrict(this, n);
  }, e.prototype.atan2 = function(n) {
    return this.throwIfDisposed(), M.atan2(this, n);
  }, e.prototype.sub = function(n) {
    return this.throwIfDisposed(), M.sub(this, n);
  }, e.prototype.subStrict = function(n) {
    return this.throwIfDisposed(), M.subStrict(this, n);
  }, e.prototype.pow = function(n) {
    return this.throwIfDisposed(), M.pow(this, n);
  }, e.prototype.powStrict = function(n) {
    return this.throwIfDisposed(), M.powStrict(this, n);
  }, e.prototype.mul = function(n) {
    return this.throwIfDisposed(), M.mul(this, n);
  }, e.prototype.mulStrict = function(n) {
    return this.throwIfDisposed(), M.mulStrict(this, n);
  }, e.prototype.floorDiv = function(n) {
    return this.throwIfDisposed(), M.floorDiv(this, n);
  }, e.prototype.divStrict = function(n) {
    return this.throwIfDisposed(), M.divStrict(this, n);
  }, e.prototype.minimum = function(n) {
    return this.throwIfDisposed(), M.minimum(this, n);
  }, e.prototype.minimumStrict = function(n) {
    return this.throwIfDisposed(), M.minimumStrict(this, n);
  }, e.prototype.maximum = function(n) {
    return this.throwIfDisposed(), M.maximum(this, n);
  }, e.prototype.maximumStrict = function(n) {
    return this.throwIfDisposed(), M.maximumStrict(this, n);
  }, e.prototype.mod = function(n) {
    return this.throwIfDisposed(), M.mod(this, n);
  }, e.prototype.modStrict = function(n) {
    return this.throwIfDisposed(), M.modStrict(this, n);
  }, e.prototype.squaredDifferenceStrict = function(n) {
    return this.throwIfDisposed(), M.squaredDifferenceStrict(this, n);
  }, e.prototype.notEqual = function(n) {
    return this.throwIfDisposed(), M.notEqual(this, n);
  }, e.prototype.notEqualStrict = function(n) {
    return this.throwIfDisposed(), M.notEqualStrict(this, n);
  }, e.prototype.less = function(n) {
    return this.throwIfDisposed(), M.less(this, n);
  }, e.prototype.lessStrict = function(n) {
    return this.throwIfDisposed(), M.lessStrict(this, n);
  }, e.prototype.equal = function(n) {
    return this.throwIfDisposed(), M.equal(this, n);
  }, e.prototype.equalStrict = function(n) {
    return this.throwIfDisposed(), M.equalStrict(this, n);
  }, e.prototype.lessEqual = function(n) {
    return this.throwIfDisposed(), M.lessEqual(this, n);
  }, e.prototype.lessEqualStrict = function(n) {
    return this.throwIfDisposed(), M.lessEqualStrict(this, n);
  }, e.prototype.greater = function(n) {
    return this.throwIfDisposed(), M.greater(this, n);
  }, e.prototype.greaterStrict = function(n) {
    return this.throwIfDisposed(), M.greaterStrict(this, n);
  }, e.prototype.greaterEqual = function(n) {
    return this.throwIfDisposed(), M.greaterEqual(this, n);
  }, e.prototype.greaterEqualStrict = function(n) {
    return this.throwIfDisposed(), M.greaterEqualStrict(this, n);
  }, e.prototype.logicalAnd = function(n) {
    return this.throwIfDisposed(), M.logicalAnd(this, n);
  }, e.prototype.logicalOr = function(n) {
    return this.throwIfDisposed(), M.logicalOr(this, n);
  }, e.prototype.logicalNot = function() {
    return this.throwIfDisposed(), M.logicalNot(this);
  }, e.prototype.logicalXor = function(n) {
    return this.throwIfDisposed(), M.logicalXor(this, n);
  }, e.prototype.where = function(n, t) {
    return this.throwIfDisposed(), M.where(n, this, t);
  }, e.prototype.neg = function() {
    return this.throwIfDisposed(), M.neg(this);
  }, e.prototype.ceil = function() {
    return this.throwIfDisposed(), M.ceil(this);
  }, e.prototype.floor = function() {
    return this.throwIfDisposed(), M.floor(this);
  }, e.prototype.sign = function() {
    return this.throwIfDisposed(), M.sign(this);
  }, e.prototype.isNaN = function() {
    return this.throwIfDisposed(), M.isNaN(this);
  }, e.prototype.isInf = function() {
    return this.throwIfDisposed(), M.isInf(this);
  }, e.prototype.isFinite = function() {
    return this.throwIfDisposed(), M.isFinite(this);
  }, e.prototype.exp = function() {
    return this.throwIfDisposed(), M.exp(this);
  }, e.prototype.expm1 = function() {
    return this.throwIfDisposed(), M.expm1(this);
  }, e.prototype.log = function() {
    return this.throwIfDisposed(), M.log(this);
  }, e.prototype.log1p = function() {
    return this.throwIfDisposed(), M.log1p(this);
  }, e.prototype.sqrt = function() {
    return this.throwIfDisposed(), M.sqrt(this);
  }, e.prototype.rsqrt = function() {
    return this.throwIfDisposed(), M.rsqrt(this);
  }, e.prototype.square = function() {
    return this.throwIfDisposed(), M.square(this);
  }, e.prototype.reciprocal = function() {
    return this.throwIfDisposed(), M.reciprocal(this);
  }, e.prototype.abs = function() {
    return this.throwIfDisposed(), M.abs(this);
  }, e.prototype.clipByValue = function(n, t) {
    return this.throwIfDisposed(), M.clipByValue(this, n, t);
  }, e.prototype.relu = function() {
    return this.throwIfDisposed(), M.relu(this);
  }, e.prototype.relu6 = function() {
    return this.throwIfDisposed(), M.relu6(this);
  }, e.prototype.elu = function() {
    return this.throwIfDisposed(), M.elu(this);
  }, e.prototype.selu = function() {
    return this.throwIfDisposed(), M.selu(this);
  }, e.prototype.leakyRelu = function(n) {
    return n === void 0 && (n = 0.2), this.throwIfDisposed(), M.leakyRelu(this, n);
  }, e.prototype.prelu = function(n) {
    return this.throwIfDisposed(), M.prelu(this, n);
  }, e.prototype.sigmoid = function() {
    return this.throwIfDisposed(), M.sigmoid(this);
  }, e.prototype.logSigmoid = function() {
    return this.throwIfDisposed(), M.logSigmoid(this);
  }, e.prototype.softplus = function() {
    return this.throwIfDisposed(), M.softplus(this);
  }, e.prototype.zerosLike = function() {
    return this.throwIfDisposed(), M.zerosLike(this);
  }, e.prototype.onesLike = function() {
    return this.throwIfDisposed(), M.onesLike(this);
  }, e.prototype.sin = function() {
    return this.throwIfDisposed(), M.sin(this);
  }, e.prototype.cos = function() {
    return this.throwIfDisposed(), M.cos(this);
  }, e.prototype.tan = function() {
    return this.throwIfDisposed(), M.tan(this);
  }, e.prototype.asin = function() {
    return this.throwIfDisposed(), M.asin(this);
  }, e.prototype.acos = function() {
    return this.throwIfDisposed(), M.acos(this);
  }, e.prototype.atan = function() {
    return this.throwIfDisposed(), M.atan(this);
  }, e.prototype.sinh = function() {
    return this.throwIfDisposed(), M.sinh(this);
  }, e.prototype.cosh = function() {
    return this.throwIfDisposed(), M.cosh(this);
  }, e.prototype.tanh = function() {
    return this.throwIfDisposed(), M.tanh(this);
  }, e.prototype.asinh = function() {
    return this.throwIfDisposed(), M.asinh(this);
  }, e.prototype.acosh = function() {
    return this.throwIfDisposed(), M.acosh(this);
  }, e.prototype.atanh = function() {
    return this.throwIfDisposed(), M.atanh(this);
  }, e.prototype.erf = function() {
    return this.throwIfDisposed(), M.erf(this);
  }, e.prototype.round = function() {
    return this.throwIfDisposed(), M.round(this);
  }, e.prototype.step = function(n) {
    return n === void 0 && (n = 0), this.throwIfDisposed(), M.step(this, n);
  }, e.prototype.softmax = function(n) {
    return n === void 0 && (n = -1), this.throwIfDisposed(), M.softmax(this, n);
  }, e.prototype.logSoftmax = function(n) {
    return n === void 0 && (n = -1), this.throwIfDisposed(), M.logSoftmax(this, n);
  }, e.prototype.resizeBilinear = function(n, t) {
    return t === void 0 && (t = !1), this.throwIfDisposed(), M.image.resizeBilinear(this, n, t);
  }, e.prototype.resizeNearestNeighbor = function(n, t) {
    return t === void 0 && (t = !1), this.throwIfDisposed(), M.image.resizeNearestNeighbor(this, n, t);
  }, e.prototype.conv1d = function(n, t, r, a, o, i) {
    return a === void 0 && (a = "NWC"), o === void 0 && (o = 1), this.throwIfDisposed(), M.conv1d(this, n, t, r, a, o, i);
  }, e.prototype.conv2d = function(n, t, r, a, o, i) {
    return a === void 0 && (a = "NHWC"), o === void 0 && (o = [1, 1]), this.throwIfDisposed(), M.conv2d(this, n, t, r, a, o, i);
  }, e.prototype.conv2dTranspose = function(n, t, r, a, o) {
    return this.throwIfDisposed(), M.conv2dTranspose(this, n, t, r, a, o);
  }, e.prototype.depthwiseConv2D = function(n, t, r, a, o, i) {
    return a === void 0 && (a = "NHWC"), o === void 0 && (o = [1, 1]), this.throwIfDisposed(), M.depthwiseConv2d(this, n, t, r, a, o, i);
  }, e.prototype.separableConv2d = function(n, t, r, a, o, i) {
    return o === void 0 && (o = [1, 1]), i === void 0 && (i = "NHWC"), this.throwIfDisposed(), M.separableConv2d(this, n, t, r, a, o, i);
  }, e.prototype.avgPool = function(n, t, r, a) {
    return this.throwIfDisposed(), M.avgPool(this, n, t, r, a);
  }, e.prototype.maxPool = function(n, t, r, a) {
    return this.throwIfDisposed(), M.maxPool(this, n, t, r, a);
  }, e.prototype.localResponseNormalization = function(n, t, r, a) {
    return n === void 0 && (n = 5), t === void 0 && (t = 1), r === void 0 && (r = 1), a === void 0 && (a = 0.5), M.localResponseNormalization(this, n, t, r, a);
  }, e.prototype.pool = function(n, t, r, a, o) {
    return this.throwIfDisposed(), M.pool(this, n, t, r, a, o);
  }, e.prototype.variable = function(n, t, r) {
    return n === void 0 && (n = !0), this.throwIfDisposed(), ln().makeVariable(this, n, t, r);
  }, e.prototype.unsortedSegmentSum = function(n, t) {
    return this.throwIfDisposed(), M.unsortedSegmentSum(this, n, t);
  }, e.prototype.batchToSpaceND = function(n, t) {
    return this.throwIfDisposed(), M.batchToSpaceND(this, n, t);
  }, e.prototype.spaceToBatchND = function(n, t) {
    return this.throwIfDisposed(), M.spaceToBatchND(this, n, t);
  }, e.prototype.topk = function(n, t) {
    return n === void 0 && (n = 1), t === void 0 && (t = !0), this.throwIfDisposed(), M.topk(this, n, t);
  }, e.prototype.stridedSlice = function(n, t, r, a, o, i, s, u) {
    return a === void 0 && (a = 0), o === void 0 && (o = 0), i === void 0 && (i = 0), s === void 0 && (s = 0), u === void 0 && (u = 0), this.throwIfDisposed(), M.stridedSlice(this, n, t, r, a, o, i, s, u);
  }, e.prototype.depthToSpace = function(n, t) {
    return this.throwIfDisposed(), M.depthToSpace(this, n, t);
  }, e.prototype.fft = function() {
    return this.throwIfDisposed(), M.spectral.fft(this);
  }, e.prototype.ifft = function() {
    return this.throwIfDisposed(), M.spectral.ifft(this);
  }, e.prototype.rfft = function() {
    return this.throwIfDisposed(), M.spectral.rfft(this);
  }, e.prototype.irfft = function() {
    return this.throwIfDisposed(), M.spectral.irfft(this);
  }, e;
}();
Object.defineProperty(Ve, Symbol.hasInstance, { value: function(e) {
  return !!e && e.dataId != null && e.shape != null && e.dtype != null;
} });
var Rl, Es, Ts, Ps, Ss, Wo = function(e) {
  function n(t, r, a, o) {
    var i = e.call(this, t.shape, t.dtype, t.dataId, o) || this;
    return i.trainable = r, i.name = a, i;
  }
  return en(n, e), n.prototype.assign = function(t) {
    if (t.dtype !== this.dtype) throw new Error("dtype of the new value (" + t.dtype + ") and previous value (" + this.dtype + ") must match");
    if (!Ye(t.shape, this.shape)) throw new Error("shape of the new value (" + t.shape + ") and previous value (" + this.shape + ") must match");
    ln().disposeTensor(this), this.dataId = t.dataId, ln().incRef(this, null);
  }, n.prototype.dispose = function() {
    ln().disposeVariable(this), this.isDisposedInternal = !0;
  }, n;
}(Ve);
Object.defineProperty(Wo, Symbol.hasInstance, { value: function(e) {
  return e instanceof Ve && e.assign != null && e.assign instanceof Function;
} }), function(e) {
  e.R0 = "R0", e.R1 = "R1", e.R2 = "R2", e.R3 = "R3", e.R4 = "R4", e.R5 = "R5", e.R6 = "R6";
}(Rl || (Rl = {})), function(e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64";
}(Es || (Es = {})), function(e) {
  e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64";
}(Ts || (Ts = {})), function(e) {
  e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64";
}(Ps || (Ps = {})), function(e) {
  e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64";
}(Ss || (Ss = {}));
var Dg = { float32: Ps, int32: Es, bool: Ts, complex64: Ss };
function st(e, n) {
  if (e === "string" || n === "string") {
    if (e === "string" && n === "string") return "string";
    throw new Error("Can not upcast " + e + " with " + n);
  }
  return Dg[e][n];
}
function Fi(e) {
  return st(e, "int32");
}
function Le(e, n) {
  if (e.dtype === n.dtype) return [e, n];
  var t = st(e.dtype, n.dtype);
  return [e.cast(t), n.cast(t)];
}
function Og(e, n) {
  A(e.dtype === n.dtype, function() {
    return "The dtypes of the first(" + e.dtype + ") and second(" + n.dtype + ") input must match";
  });
}
function Ud(e) {
  var n = [];
  return function t(r, a, o) {
    if (r != null) {
      if (r instanceof Ve) return void a.push(r);
      if (i = r, !(!Array.isArray(i) && typeof i != "object")) {
        var i, s = r;
        for (var u in s) {
          var l = s[u];
          o.has(l) || (o.add(l), t(l, a, o));
        }
      }
    }
  }(e, n, /* @__PURE__ */ new Set()), n;
}
var Mi, Fl = function() {
  function e() {
    this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = /* @__PURE__ */ new WeakMap(), this.profiling = !1, this.activeProfile = { newBytes: 0, newTensors: 0, peakBytes: 0, kernels: [], result: null };
  }
  return e.prototype.dispose = function() {
    for (var n in this.registeredVariables) this.registeredVariables[n].dispose();
  }, e;
}(), Rg = function() {
  function e(n) {
    this.ENV = n, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Fl();
  }
  return e.prototype.ready = function() {
    return Y(this, void 0, void 0, function() {
      var n, t, r;
      return Z(this, function(a) {
        switch (a.label) {
          case 0:
            if (this.pendingBackendInit != null) return [2, this.pendingBackendInit.then(function() {
            })];
            if (this.backendInstance != null) return [2];
            n = this.getSortedBackends(), t = 0, a.label = 1;
          case 1:
            return t < n.length ? (r = n[t], [4, this.initializeBackend(r).success]) : [3, 5];
          case 2:
            return a.sent() ? [4, this.setBackend(r)] : [3, 4];
          case 3:
            return a.sent(), [2];
          case 4:
            return t++, [3, 1];
          case 5:
            throw new Error("Could not initialize any backends, all backend initializations failed.");
        }
      });
    });
  }, Object.defineProperty(e.prototype, "backend", { get: function() {
    if (this.pendingBackendInit != null) throw new Error("Backend '" + this.backendName + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
    if (this.backendInstance == null) {
      var n = this.initializeBackendsAndReturnBest(), t = n.name;
      if (n.asyncInit) throw new Error("The highest priority backend '" + t + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
      this.setBackend(t);
    }
    return this.backendInstance;
  }, enumerable: !0, configurable: !0 }), e.prototype.backendNames = function() {
    return Object.keys(this.registryFactory);
  }, e.prototype.findBackend = function(n) {
    return !(n in this.registry) && (!(n in this.registryFactory) || this.initializeBackend(n).asyncInit) ? null : this.registry[n];
  }, e.prototype.findBackendFactory = function(n) {
    return n in this.registryFactory ? this.registryFactory[n].factory : null;
  }, e.prototype.registerBackend = function(n, t, r) {
    return r === void 0 && (r = 1), n in this.registryFactory ? (console.warn(n + " backend was already registered. Reusing existing backend factory."), !1) : (this.registryFactory[n] = { factory: t, priority: r }, !0);
  }, e.prototype.setBackend = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r, a;
      return Z(this, function(o) {
        switch (o.label) {
          case 0:
            if (this.registryFactory[n] == null) throw new Error("Backend name '" + n + "' not found in registry");
            return this.backendName = n, this.registry[n] != null ? [3, 4] : (this.backendInstance = null, t = this.initializeBackend(n), r = t.success, t.asyncInit ? [4, r] : [3, 2]);
          case 1:
            return a = o.sent(), [3, 3];
          case 2:
            a = r, o.label = 3;
          case 3:
            if (!a) return [2, !1];
            o.label = 4;
          case 4:
            return this.backendInstance = this.registry[n], this.setupRegisteredKernels(), this.profiler = new Tg(this.backendInstance), [2, !0];
        }
      });
    });
  }, e.prototype.setupRegisteredKernels = function() {
    var n = this;
    Sl(this.backendName).forEach(function(t) {
      t.setupFunc != null && t.setupFunc(n.backendInstance);
    });
  }, e.prototype.disposeRegisteredKernels = function(n) {
    var t = this;
    Sl(n).forEach(function(r) {
      r.disposeFunc != null && r.disposeFunc(t.registry[n]);
    });
  }, e.prototype.initializeBackend = function(n) {
    var t = this, r = this.registryFactory[n];
    if (r == null) throw new Error("Cannot initialize backend " + n + ", no registration found.");
    try {
      var a = r.factory();
      if (Promise.resolve(a) === a) {
        var o = ++this.pendingBackendInitId, i = a.then(function(s) {
          return !(o < t.pendingBackendInitId) && (t.registry[n] = s, t.pendingBackendInit = null, !0);
        }).catch(function(s) {
          return !(o < t.pendingBackendInitId) && (t.pendingBackendInit = null, console.warn("Initialization of backend " + n + " failed"), console.warn(s.stack || s.message), !1);
        });
        return this.pendingBackendInit = i, { success: i, asyncInit: !0 };
      }
      return this.registry[n] = a, { success: !0, asyncInit: !1 };
    } catch (s) {
      return console.warn("Initialization of backend " + n + " failed"), console.warn(s.stack || s.message), { success: !1, asyncInit: !1 };
    }
  }, e.prototype.removeBackend = function(n) {
    if (!(n in this.registryFactory)) throw new Error(n + " backend not found in registry");
    this.backendName === n && this.pendingBackendInit != null && this.pendingBackendInitId++, n in this.registry && (this.disposeRegisteredKernels(n), this.registry[n].dispose(), delete this.registry[n]), delete this.registryFactory[n], this.backendName === n && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);
  }, e.prototype.getSortedBackends = function() {
    var n = this;
    if (Object.keys(this.registryFactory).length === 0) throw new Error("No backend found in registry.");
    return Object.keys(this.registryFactory).sort(function(t, r) {
      return n.registryFactory[r].priority - n.registryFactory[t].priority;
    });
  }, e.prototype.initializeBackendsAndReturnBest = function() {
    for (var n = this.getSortedBackends(), t = 0; t < n.length; t++) {
      var r = n[t], a = this.initializeBackend(r), o = a.success, i = a.asyncInit;
      if (i || o) return { name: r, asyncInit: i };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }, e.prototype.moveData = function(n, t) {
    var r = this.state.tensorInfo.get(t), a = r.backend, o = this.readSync(t);
    a.disposeData(t), r.backend = n, n.move(t, o, r.shape, r.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
  }, e.prototype.tidy = function(n, t) {
    var r, a = this, o = null;
    if (t == null) {
      if (typeof n != "function") throw new Error("Please provide a function to tidy()");
      t = n;
    } else {
      if (typeof n != "string" && !(n instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof t != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      o = n;
    }
    return this.scopedRun(function() {
      return a.startScope(o);
    }, function() {
      return a.endScope(r);
    }, function() {
      return (r = t()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), r;
    });
  }, e.prototype.scopedRun = function(n, t, r) {
    n();
    try {
      var a = r();
      return t(), a;
    } catch (o) {
      throw t(), o;
    }
  }, e.prototype.nextTensorId = function() {
    return e.nextTensorId++;
  }, e.prototype.nextVariableId = function() {
    return e.nextVariableId++;
  }, e.prototype.clone = function(n) {
    var t = this.makeTensorFromDataId(n.dataId, n.shape, n.dtype), r = { x: n };
    return this.addTapeNode(this.state.activeScope.name, r, [t], function(a) {
      return { x: function() {
        return a.toFloat();
      } };
    }, [], {}), t;
  }, e.prototype.runKernel = function(n, t, r, a, o) {
    return this.runKernelFunc(null, t, null, n, r, a, o);
  }, e.prototype.shouldCheckForMemLeaks = function() {
    return this.ENV.getBool("IS_TEST");
  }, e.prototype.checkKernelForMemLeak = function(n, t, r) {
    var a = this.backend.numDataIds(), o = 0;
    r.forEach(function(u) {
      o += u.dtype === "complex64" ? 3 : 1;
    });
    var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], s = a - t - o - i;
    if (s > 0) throw new Error("Backend '" + this.backendName + "' has an internal memory leak (" + s + " data ids) after running '" + n + "'");
  }, e.prototype.runKernelFunc = function(n, t, r, a, o, i, s) {
    var u, l = this, c = [], h = this.isTapeOn();
    a == null && (a = this.state.activeScope != null ? this.state.activeScope.name : "");
    var d, p = this.state.numBytes, f = this.state.numTensors;
    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);
    var m, g = Dd(a, this.backendName);
    if (g != null) d = function() {
      var y = l.backend.numDataIds();
      m = g.kernelFunc({ inputs: t, attrs: o, backend: l.backend });
      var b = Array.isArray(m) ? m : [m];
      l.shouldCheckForMemLeaks() && l.checkKernelForMemLeak(a, y, b);
      var x = b.map(function(T) {
        var I = T.dataId, E = T.shape, P = T.dtype;
        return l.makeTensorFromDataId(I, E, P);
      });
      if (h) {
        var C = l.getTensorsForGradient(a, t, x);
        if (C == null) {
          s == null && (s = []);
          var N = x.filter(function(T, I) {
            return s[I];
          });
          C = (i || []).slice().concat(N);
        }
        c = l.saveTensorsForBackwardMode(C);
      }
      return x;
    };
    else {
      var v = function(y) {
        h && (c = y.map(function(b) {
          return l.keep(l.clone(b));
        }));
      };
      d = function() {
        var y = l.backend.numDataIds();
        m = l.tidy(function() {
          return n(l.backend, v);
        });
        var b = Array.isArray(m) ? m : [m];
        return l.shouldCheckForMemLeaks() && l.checkKernelForMemLeak(a, y, b), b;
      };
    }
    return this.scopedRun(function() {
      return l.state.kernelDepth++;
    }, function() {
      return l.state.kernelDepth--;
    }, function() {
      u = l.ENV.getBool("DEBUG") ? l.profiler.profileKernel(a, t, function() {
        return d();
      }) : d();
    }), h && this.addTapeNode(a, t, u, r, c, o), this.state.profiling && this.state.activeProfile.kernels.push({ name: a, bytesAdded: this.state.numBytes - p, totalBytesSnapshot: this.state.numBytes, tensorsAdded: this.state.numTensors - f, totalTensorsSnapshot: this.state.numTensors, inputShapes: Object.keys(t).map(function(y) {
      return t[y].shape;
    }), outputShapes: u.map(function(y) {
      return y.shape;
    }) }), Array.isArray(m) ? u : u[0];
  }, e.prototype.saveTensorsForBackwardMode = function(n) {
    var t = this;
    return n.map(function(r) {
      return t.keep(t.clone(r));
    });
  }, e.prototype.getTensorsForGradient = function(n, t, r) {
    var a = Pl(n);
    if (a != null) {
      var o = a.inputsToSave || [], i = a.outputsToSave || [], s = void 0;
      a.saveAllInputs ? (A(Array.isArray(t), function() {
        return "saveAllInputs is true, expected inputs to be an array.";
      }), s = Object.keys(t).map(function(l) {
        return t[l];
      })) : s = o.map(function(l) {
        return t[l];
      });
      var u = r.filter(function(l, c) {
        return i[c];
      });
      return s.concat(u);
    }
    return null;
  }, e.prototype.makeTensor = function(n, t, r, a) {
    if (n == null) throw new Error("Values passed to engine.makeTensor() are null");
    r = r || "float32", a = a || this.backend;
    var o = n;
    r === "string" && ui(n[0]) && (o = n.map(function(c) {
      return Hd(c);
    }));
    var i = a.write(o, t, r), s = new Ve(t, r, i, this.nextTensorId());
    if (this.incRef(s, a), r === "string") {
      var u = this.state.tensorInfo.get(i), l = Ld(o);
      this.state.numBytes += l - u.bytes, u.bytes = l;
    }
    return s;
  }, e.prototype.makeTensorFromDataId = function(n, t, r, a) {
    var o = new Ve(t, r = r || "float32", n, this.nextTensorId());
    return this.incRef(o, a), o;
  }, e.prototype.makeVariable = function(n, t, r, a) {
    t === void 0 && (t = !0), r = r || this.nextVariableId().toString(), a != null && a !== n.dtype && (n = n.asType(a));
    var o = new Wo(n, t, r, this.nextTensorId());
    if (this.state.registeredVariables[o.name] != null) throw new Error("Variable with name " + o.name + " was already registered");
    return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;
  }, e.prototype.incRef = function(n, t) {
    var r = this.state.tensorInfo.has(n.dataId) ? this.state.tensorInfo.get(n.dataId).refCount : 0;
    if (this.state.numTensors++, n.dtype === "string" && this.state.numStringTensors++, r === 0) {
      this.state.numDataBuffers++;
      var a = 0;
      n.dtype !== "complex64" && n.dtype !== "string" && (a = n.size * Cu(n.dtype)), this.state.tensorInfo.set(n.dataId, { backend: t || this.backend, dtype: n.dtype, shape: n.shape, bytes: a, refCount: 0 }), this.state.numBytes += a;
    }
    this.state.tensorInfo.get(n.dataId).refCount++, n instanceof Wo || this.track(n);
  }, e.prototype.disposeTensor = function(n) {
    if (this.state.tensorInfo.has(n.dataId)) {
      this.state.numTensors--, n.dtype === "string" && this.state.numStringTensors--;
      var t = this.state.tensorInfo.get(n.dataId);
      t.refCount <= 1 ? (n.dtype !== "complex64" && (this.state.numBytes -= t.bytes), this.state.numDataBuffers--, t.backend.disposeData(n.dataId), this.state.tensorInfo.delete(n.dataId)) : this.state.tensorInfo.get(n.dataId).refCount--;
    }
  }, e.prototype.disposeVariables = function() {
    for (var n in this.state.registeredVariables) {
      var t = this.state.registeredVariables[n];
      this.disposeVariable(t);
    }
  }, e.prototype.disposeVariable = function(n) {
    this.disposeTensor(n), this.state.registeredVariables[n.name] != null && delete this.state.registeredVariables[n.name];
  }, e.prototype.memory = function() {
    var n = this.backend.memory();
    return n.numTensors = this.state.numTensors, n.numDataBuffers = this.state.numDataBuffers, n.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (n.unreliable = !0, n.reasons == null && (n.reasons = []), n.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), n;
  }, e.prototype.profile = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r;
      return Z(this, function(a) {
        return this.state.profiling = !0, t = this.state.numBytes, r = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = n(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(o) {
          return o.totalBytesSnapshot;
        })), this.state.activeProfile.newBytes = this.state.numBytes - t, this.state.activeProfile.newTensors = this.state.numTensors - r, [2, this.state.activeProfile];
      });
    });
  }, e.prototype.isTapeOn = function() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }, e.prototype.addTapeNode = function(n, t, r, a, o, i) {
    var s = this, u = { id: this.state.nextTapeNodeId++, kernelName: n, inputs: t, outputs: r, saved: o }, l = Pl(n);
    l != null && (a = l.gradFunc), a != null && (u.gradient = function(c) {
      return c = c.map(function(h, d) {
        if (h == null) {
          var p = r[d], f = pa(p.size, p.dtype);
          return s.makeTensor(f, p.shape, p.dtype);
        }
        return h;
      }), a(c.length > 1 ? c : c[0], o, i);
    }), this.state.activeTape.push(u);
  }, e.prototype.keep = function(n) {
    return n.kept = !0, n;
  }, e.prototype.startTape = function() {
    this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
  }, e.prototype.endTape = function() {
    this.state.gradientDepth--;
  }, e.prototype.startScope = function(n) {
    var t = { track: [], name: "unnamed scope", id: this.state.nextScopeId++ };
    n && (t.name = n), this.state.scopeStack.push(t), this.state.activeScope = t;
  }, e.prototype.endScope = function(n) {
    for (var t = this, r = Ud(n), a = new Set(r.map(function(u) {
      return u.id;
    })), o = 0; o < this.state.activeScope.track.length; o++) {
      var i = this.state.activeScope.track[o];
      i.kept || a.has(i.id) || i.dispose();
    }
    var s = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], r.forEach(function(u) {
      u.kept || u.scopeId !== s.id || t.track(u);
    });
  }, e.prototype.gradients = function(n, t, r, a) {
    var o = this;
    if (a === void 0 && (a = !1), A(t.length > 0, function() {
      return "gradients() received an empty list of xs.";
    }), r != null && r.dtype !== "float32") throw new Error("dy must have 'float32' dtype, but has '" + r.dtype + "'");
    var i = this.scopedRun(function() {
      return o.startTape();
    }, function() {
      return o.endTape();
    }, function() {
      return o.tidy("forward", n);
    });
    A(i instanceof Ve, function() {
      return "The result y returned by f() must be a tensor.";
    });
    var s = function(u, l, c) {
      for (var h = {}, d = {}, p = 0; p < l.length; p++) h[l[p].id] = !0;
      for (p = 0; p < u.length; p++) {
        var f = (N = u[p]).inputs;
        for (var m in f) {
          for (var g = f[m], v = !1, y = 0; y < l.length; y++) if (h[g.id]) {
            N.outputs.forEach(function(P) {
              return h[P.id] = !0;
            }), v = !0, d[N.id] = !0;
            break;
          }
          if (v) break;
        }
      }
      var b = {};
      b[c.id] = !0;
      var x = {};
      for (p = u.length - 1; p >= 0; p--) for (f = (N = u[p]).inputs, y = 0; y < N.outputs.length; y++) if (b[N.outputs[y].id]) {
        for (var m in f) b[f[m].id] = !0, x[N.id] = !0;
        break;
      }
      var C = [];
      for (p = 0; p < u.length; p++) {
        var N;
        if (d[(N = u[p]).id] && x[N.id]) {
          var T = {};
          for (var m in N.inputs) {
            var I = N.inputs[m];
            h[I.id] && (T[m] = I);
          }
          var E = Object.assign({}, N);
          E.inputs = T, E.outputs = N.outputs, C.push(E);
        }
      }
      return C;
    }(this.state.activeTape, t, i);
    if (!a && s.length === 0 && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this.tidy("backward", function() {
      var u, l, c = {};
      c[i.id] = r ?? (u = i.shape, l = Nu(Q(u), "float32"), D.makeTensor(l, u, "float32")), function(d, p, f) {
        for (var m = function(v) {
          var y = p[v], b = [];
          if (y.outputs.forEach(function(T) {
            var I = d[T.id];
            I != null ? b.push(I) : b.push(null);
          }), y.gradient == null) throw new Error("Cannot compute gradient: gradient function not found for " + y.kernelName + ".");
          var x = y.gradient(b), C = function(T) {
            if (!(T in x)) throw new Error("Cannot backprop through input " + T + ". Available gradients found: " + Object.keys(x) + ".");
            var I = f(function() {
              return x[T]();
            });
            if (I.dtype !== "float32") throw new Error("Error in gradient for op " + y.kernelName + ". The gradient of input " + T + " must have 'float32' dtype, but has '" + I.dtype + "'");
            var E = y.inputs[T];
            if (!Ye(I.shape, E.shape)) throw new Error("Error in gradient for op " + y.kernelName + ". The gradient of input '" + T + "' has shape '" + I.shape + "', which does not match the shape of the input '" + E.shape + "'");
            if (d[E.id] == null) d[E.id] = I;
            else {
              var P = d[E.id];
              d[E.id] = P.add(I), P.dispose();
            }
          };
          for (var N in y.inputs) C(N);
        }, g = p.length - 1; g >= 0; g--) m(g);
      }(c, s, function(d) {
        return o.tidy(d);
      });
      var h = t.map(function(d) {
        return c[d.id];
      });
      return o.state.gradientDepth === 0 && (o.state.activeTape.forEach(function(d) {
        for (var p = 0, f = d.saved; p < f.length; p++)
          f[p].dispose();
      }), o.state.activeTape = null), { value: i, grads: h };
    });
  }, e.prototype.customGrad = function(n) {
    var t = this;
    return A(zo(n), function() {
      return "The f passed in customGrad(f) must be a function.";
    }), function() {
      for (var r, a = [], o = 0; o < arguments.length; o++) a[o] = arguments[o];
      A(a.every(function(s) {
        return s instanceof Ve;
      }), function() {
        return "The args passed in customGrad(f)(x1, x2,...) must all be tensors";
      });
      var i = {};
      return a.forEach(function(s, u) {
        i[u] = s;
      }), t.runKernelFunc(function(s, u) {
        return A((r = n.apply(void 0, a.concat([u]))).value instanceof Ve, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor";
        }), A(zo(r.gradFunc), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.";
        }), r.value;
      }, i, function(s, u) {
        var l = r.gradFunc(s, u), c = Array.isArray(l) ? l : [l];
        A(c.length === a.length, function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).";
        }), A(c.every(function(d) {
          return d instanceof Ve;
        }), function() {
          return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.";
        });
        var h = {};
        return c.forEach(function(d, p) {
          h[p] = function() {
            return d;
          };
        }), h;
      });
    };
  }, e.prototype.readSync = function(n) {
    return this.state.tensorInfo.get(n).backend.readSync(n);
  }, e.prototype.read = function(n) {
    return this.state.tensorInfo.get(n).backend.read(n);
  }, e.prototype.time = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r;
      return Z(this, function(a) {
        switch (a.label) {
          case 0:
            return t = Jt(), [4, this.backend.time(n)];
          case 1:
            return (r = a.sent()).wallMs = Jt() - t, [2, r];
        }
      });
    });
  }, e.prototype.track = function(n) {
    return this.state.activeScope != null && (n.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(n)), n;
  }, Object.defineProperty(e.prototype, "registeredVariables", { get: function() {
    return this.state.registeredVariables;
  }, enumerable: !0, configurable: !0 }), e.prototype.reset = function() {
    for (var n in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Fl(), this.registry) this.disposeRegisteredKernels(n), this.registry[n].dispose(), delete this.registry[n];
    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
  }, e.nextTensorId = 0, e.nextVariableId = 0, e;
}(), D = function() {
  var e = function() {
    if (Mi == null) {
      var t = void 0;
      if (typeof window < "u") t = window;
      else if (typeof global < "u") t = global;
      else if (typeof process < "u") t = process;
      else {
        if (typeof self > "u") throw new Error("Could not find a global object");
        t = self;
      }
      Mi = t;
    }
    return Mi;
  }();
  if (e._tfengine == null) {
    var n = new Ag(e);
    e._tfengine = new Rg(n);
  }
  return function(t) {
    Sd = t;
  }(e._tfengine.ENV), ln = function() {
    return e._tfengine;
  }, e._tfengine;
}();
function Kd() {
  return typeof window < "u" && window.document != null || typeof WorkerGlobalScope < "u";
}
var bn = _();
bn.registerFlag("DEBUG", function() {
  return !1;
}, function(e) {
  e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), bn.registerFlag("IS_BROWSER", function() {
  return Kd();
}), bn.registerFlag("IS_NODE", function() {
  return typeof process < "u" && process.versions !== void 0 && process.versions.node !== void 0;
}), bn.registerFlag("IS_CHROME", function() {
  return typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}), bn.registerFlag("PROD", function() {
  return !1;
}), bn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", function() {
  return bn.getBool("DEBUG");
}), bn.registerFlag("DEPRECATION_WARNINGS_ENABLED", function() {
  return !0;
}), bn.registerFlag("IS_TEST", function() {
  return !1;
});
var ja, Ot, St, dr = {}, _i = { alpha: !1, antialias: !1, premultipliedAlpha: !1, preserveDrawingBuffer: !1, depth: !1, stencil: !1, failIfMajorPerformanceCaveat: !0 };
function Fg(e, n) {
  dr[e] = n;
}
function pn(e) {
  e in dr || (dr[e] = function(t) {
    if (t !== 1 && t !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    var r = function(a) {
      if (typeof OffscreenCanvas < "u" && a === 2) return new OffscreenCanvas(300, 150);
      if (typeof document < "u") return document.createElement("canvas");
      throw new Error("Cannot create a canvas in this context");
    }(t);
    return r.addEventListener("webglcontextlost", function(a) {
      a.preventDefault(), delete dr[t];
    }, !1), t === 1 ? r.getContext("webgl", _i) || r.getContext("experimental-webgl", _i) : r.getContext("webgl2", _i);
  }(e));
  var n = dr[e];
  return n.isContextLost() ? (delete dr[e], pn(e)) : (n.disable(n.DEPTH_TEST), n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), n.cullFace(n.BACK), dr[e]);
}
function li(e, n) {
  return [n, e];
}
function Sa(e) {
  var n = Q(e);
  return Lo(Math.ceil(n / 4));
}
function Ka(e, n) {
  return [Math.max(1, Math.ceil(n / 2)), Math.max(1, Math.ceil(e / 2))];
}
function Eu(e, n) {
  var t, r, a, o, i, s, u, l, c, h = e;
  return _().getNumber("WEBGL_VERSION") === 2 ? (t = h.R32F, r = h.R16F, a = h.RGBA16F, o = h.RGBA32F, i = h.RED, s = 4, u = 1, l = h.HALF_FLOAT, c = h.FLOAT) : (t = e.RGBA, r = e.RGBA, a = e.RGBA, o = h.RGBA, i = e.RGBA, s = 4, u = 4, l = n != null ? n.HALF_FLOAT_OES : null, c = e.FLOAT), { internalFormatFloat: t, internalFormatHalfFloat: r, internalFormatPackedHalfFloat: a, internalFormatPackedFloat: o, textureFormatFloat: i, downloadTextureFormat: e.RGBA, downloadUnpackNumChannels: s, defaultNumChannels: u, textureTypeHalfFloat: l, textureTypeFloat: c };
}
function te(e, n, t) {
  var r = t();
  return n && function(a) {
    var o = a.getError();
    if (o !== a.NO_ERROR) throw new Error("WebGL Error: " + jg(a, o));
  }(e), r;
}
(function(e) {
  e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH";
})(ja || (ja = {})), function(e) {
  e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD";
}(Ot || (Ot = {})), function(e) {
  e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(St || (St = {}));
var Mg = 596e-10, _g = 65504;
function Bg(e) {
  return !!(_().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || e === 0 || Mg < Math.abs(e) && Math.abs(e) < _g);
}
function jg(e, n) {
  switch (n) {
    case e.NO_ERROR:
      return "NO_ERROR";
    case e.INVALID_ENUM:
      return "INVALID_ENUM";
    case e.INVALID_VALUE:
      return "INVALID_VALUE";
    case e.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case e.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case e.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case e.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + n;
  }
}
function ro(e, n, t) {
  return Vn(e, n, function() {
    return e.getExtension(t);
  }, 'Extension "' + t + '" not supported on this browser.');
}
function Vg(e, n, t) {
  var r = Vn(e, n, function() {
    return e.createShader(e.VERTEX_SHADER);
  }, "Unable to create vertex WebGLShader.");
  if (te(e, n, function() {
    return e.shaderSource(r, t);
  }), te(e, n, function() {
    return e.compileShader(r);
  }), e.getShaderParameter(r, e.COMPILE_STATUS) === !1) throw console.log(e.getShaderInfoLog(r)), new Error("Failed to compile vertex shader.");
  return r;
}
function Lg(e, n, t) {
  var r = Vn(e, n, function() {
    return e.createShader(e.FRAGMENT_SHADER);
  }, "Unable to create fragment WebGLShader.");
  if (te(e, n, function() {
    return e.shaderSource(r, t);
  }), te(e, n, function() {
    return e.compileShader(r);
  }), e.getShaderParameter(r, e.COMPILE_STATUS) === !1) throw function(a, o) {
    var i = zg.exec(o);
    if (i == null) return console.log("Couldn't parse line number in error: " + o), void console.log(a);
    for (var s = +i[1], u = a.split(`
`), l = u.length.toString().length + 2, c = u.map(function(g, v) {
      return wr((v + 1).toString(), l) + g;
    }), h = 0, d = 0; d < c.length; d++) h = Math.max(c[d].length, h);
    var p = c.slice(0, s - 1), f = c.slice(s - 1, s), m = c.slice(s);
    console.log(p.join(`
`)), console.log(o.split(`
`)[0]), console.log("%c " + wr(f[0], h), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(m.join(`
`));
  }(t, e.getShaderInfoLog(r)), new Error("Failed to compile fragment shader.");
  return r;
}
var Bi, ji, zg = /ERROR: [0-9]+:([0-9]+):/g;
function Gg(e, n) {
  return Vn(e, n, function() {
    return e.createProgram();
  }, "Unable to create WebGLProgram.");
}
function Hg(e, n, t) {
  if (te(e, n, function() {
    return e.linkProgram(t);
  }), e.getProgramParameter(t, e.LINK_STATUS) === !1) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.");
}
function Vi(e, n, t) {
  if (te(e, n, function() {
    return e.validateProgram(t);
  }), e.getProgramParameter(t, e.VALIDATE_STATUS) === !1) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.");
}
function Wg(e, n, t) {
  var r = Vn(e, n, function() {
    return e.createBuffer();
  }, "Unable to create WebGLBuffer");
  return te(e, n, function() {
    return e.bindBuffer(e.ARRAY_BUFFER, r);
  }), te(e, n, function() {
    return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);
  }), r;
}
function $g(e, n, t) {
  var r = Vn(e, n, function() {
    return e.createBuffer();
  }, "Unable to create WebGLBuffer");
  return te(e, n, function() {
    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r);
  }), te(e, n, function() {
    return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW);
  }), r;
}
function Ug(e, n) {
  return Vn(e, n, function() {
    return e.createTexture();
  }, "Unable to create WebGLTexture.");
}
function Kg(e, n) {
  var t = _().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (e <= 0 || n <= 0) {
    var r = "[" + e + "x" + n + "]";
    throw new Error("Requested texture size " + r + " is invalid.");
  }
  if (e > t || n > t)
    throw r = "[" + e + "x" + n + "]", new Error("Requested texture size " + r + " greater than WebGL maximum on this browser / GPU " + ("[" + t + "x" + t + "]") + ".");
}
function qg(e, n) {
  return Vn(e, n, function() {
    return e.createFramebuffer();
  }, "Unable to create WebGLFramebuffer.");
}
function Ml(e, n, t, r, a, o, i, s) {
  var u = e.getAttribLocation(t, r);
  return u !== -1 && (te(e, n, function() {
    return e.bindBuffer(e.ARRAY_BUFFER, a);
  }), te(e, n, function() {
    return e.vertexAttribPointer(u, o, e.FLOAT, !1, i, s);
  }), te(e, n, function() {
    return e.enableVertexAttribArray(u);
  }), !0);
}
function Jg(e, n, t, r) {
  ev(e, r), te(e, n, function() {
    return e.activeTexture(e.TEXTURE0 + r);
  }), te(e, n, function() {
    return e.bindTexture(e.TEXTURE_2D, t);
  });
}
function Xg(e, n, t, r) {
  return Vn(e, n, function() {
    return e.getUniformLocation(t, r);
  }, 'uniform "' + r + '" not present in program.');
}
function Qg(e, n, t) {
  return e.getUniformLocation(n, t);
}
function Yg(e, n, t, r, a, o) {
  te(e, n, function() {
    return Jg(e, n, r, o);
  }), te(e, n, function() {
    return e.uniform1i(a, o);
  });
}
function Li(e, n, t, r) {
  te(e, n, function() {
    return e.bindFramebuffer(e.FRAMEBUFFER, r);
  }), te(e, n, function() {
    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
  });
}
function _l(e, n, t) {
  te(e, n, function() {
    return e.bindFramebuffer(e.FRAMEBUFFER, t);
  }), te(e, n, function() {
    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0);
  });
}
function ao(e) {
  var n = e.checkFramebufferStatus(e.FRAMEBUFFER);
  if (n !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + Zg(e, n));
}
function Zg(e, n) {
  switch (n) {
    case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case e.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + n;
  }
}
function Vn(e, n, t, r) {
  var a = te(e, n, function() {
    return t();
  });
  if (a == null) throw new Error(r);
  return a;
}
function ev(e, n) {
  var t = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r = n + e.TEXTURE0;
  if (r < e.TEXTURE0 || r > t) throw new Error("textureUnit must be in " + ("[gl.TEXTURE0, gl.TEXTURE" + t + "]") + ".");
}
function $o(e, n) {
  return n === void 0 && (n = 2), Q(e.slice(0, e.length - n));
}
function Uo(e) {
  if (e.length === 0) throw Error("Cannot get rows and columns of an empty shape array.");
  return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];
}
function zi(e) {
  var n = [1, 1, 1];
  return e.length === 0 || e.length === 1 && e[0] === 1 || (n = [$o(e)].concat(Uo(e))), n;
}
function tv(e, n) {
  var t;
  n === void 0 && (n = !1);
  var r = _().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (n && (r *= 2, (e = e.map(function(l, c) {
    return c >= e.length - 2 ? wu(e[c]) : e[c];
  })).length === 1 && (e = [2, e[0]])), e.length !== 2) {
    var a = Un(e);
    e = a.newShape;
  }
  var o = Q(e);
  if (e.length <= 1 && o <= r) return [1, o];
  if (e.length === 2 && e[0] <= r && e[1] <= r) return e;
  if (e.length === 3 && e[0] * e[1] <= r && e[2] <= r) return [e[0] * e[1], e[2]];
  if (e.length === 3 && e[0] <= r && e[1] * e[2] <= r) return [e[0], e[1] * e[2]];
  if (e.length === 4 && e[0] * e[1] * e[2] <= r && e[3] <= r) return [e[0] * e[1] * e[2], e[3]];
  if (e.length === 4 && e[0] <= r && e[1] * e[2] * e[3] <= r) return [e[0], e[1] * e[2] * e[3]];
  if (n) {
    var i = $o(e), s = 2, u = 2;
    return e.length && (s = (t = Uo(e))[0], u = t[1]), Lo(o = i * (s / 2) * (u / 2)).map(function(l) {
      return 2 * l;
    });
  }
  return Lo(o);
}
function oo(e) {
  return e % 2 == 0;
}
function io(e, n) {
  if (Ye(e = e.slice(-2), n = n.slice(-2)) || !e.length || !n.length || e[0] === 0 || e[1] === 0 || n[0] === 0 || n[1] === 0) return !0;
  if (e.length !== n.length) {
    var t = e.slice(-1)[0], r = n.slice(-1)[0];
    if (t === r || oo(t) && oo(r) && (e[0] === 1 || n[0] === 1)) return !0;
  }
  return e[1] === n[1] && oo(e[0]) && oo(n[0]);
}
function nv(e) {
  if (Bi == null) {
    var n = pn(e);
    Bi = n.getParameter(n.MAX_TEXTURE_SIZE);
  }
  return Bi;
}
function rv(e) {
  if (ji == null) {
    var n = pn(e);
    ji = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, ji);
}
function av(e) {
  if (e === 0) return 0;
  var n = pn(e);
  return zt(n, "EXT_disjoint_timer_query_webgl2") && e === 2 ? 2 : zt(n, "EXT_disjoint_timer_query") ? 1 : 0;
}
function zt(e, n) {
  return e.getExtension(n) != null;
}
function Bl(e) {
  try {
    if (pn(e) != null) return !0;
  } catch {
    return !1;
  }
  return !1;
}
function ov(e) {
  if (e === 0) return !1;
  var n = pn(e);
  if (e === 1) {
    if (!zt(n, "OES_texture_float")) return !1;
  } else if (!zt(n, "EXT_color_buffer_float")) return !1;
  return Ds(n);
}
function iv(e) {
  if (e === 0) return !1;
  var n = pn(e);
  if (e !== 1) {
    if (zt(n, "EXT_color_buffer_float")) return Ds(n);
    if (zt(n, "EXT_color_buffer_half_float")) {
      var t = n.getExtension("EXT_color_buffer_half_float");
      return function(r, a) {
        var o = Eu(r, a), i = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, i), r.texImage2D(r.TEXTURE_2D, 0, o.internalFormatHalfFloat, 1, 1, 0, o.textureFormatFloat, o.textureTypeHalfFloat, null);
        var s = r.createFramebuffer();
        r.bindFramebuffer(r.FRAMEBUFFER, s), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, i, 0);
        var u = r.checkFramebufferStatus(r.FRAMEBUFFER) === r.FRAMEBUFFER_COMPLETE;
        return r.bindTexture(r.TEXTURE_2D, null), r.bindFramebuffer(r.FRAMEBUFFER, null), r.deleteTexture(i), r.deleteFramebuffer(s), u;
      }(n, t);
    }
    return !1;
  }
  return !!zt(n, "OES_texture_float") && !!zt(n, "WEBGL_color_buffer_float") && Ds(n);
}
function Ds(e) {
  var n = Eu(e), t = e.createTexture();
  e.bindTexture(e.TEXTURE_2D, t), e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeFloat, null);
  var r = e.createFramebuffer();
  e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);
  var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(t), e.deleteFramebuffer(r), a;
}
function sv(e) {
  return e === 2 && pn(e).fenceSync != null;
}
var ae = _();
function qd(e) {
  _().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
}
function de(e, n) {
  return D.tidy(e, n);
}
function xt(e) {
  Ud(e).forEach(function(n) {
    return n.dispose();
  });
}
function uv(e) {
  return D.keep(e);
}
function Ko() {
  for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
  _().getBool("IS_TEST") || console.warn.apply(console, e);
}
function ar(e, n) {
  var t = e;
  if (Qt(e)) return n === "string" ? [] : [e.length];
  if (!Array.isArray(e)) return [];
  for (var r = []; Array.isArray(t) || Qt(t) && n !== "string"; ) r.push(t.length), t = t[0];
  return Array.isArray(e) && _().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && function a(o, i, s) {
    if (s = s || [], !Array.isArray(o) && !Qt(o)) return void A(i.length === 0, function() {
      return "Element arr[" + s.join("][") + "] is a primitive, but should be an array/TypedArray of " + i[0] + " elements";
    });
    A(i.length > 0, function() {
      return "Element arr[" + s.join("][") + "] should be a primitive, but is an array of " + o.length + " elements";
    }), A(o.length === i[0], function() {
      return "Element arr[" + s.join("][") + "] should have " + i[0] + " elements, but has " + o.length + " elements";
    });
    for (var u = i.slice(1), l = 0; l < o.length; ++l) a(o[l], u, s.concat(l));
  }(e, r, []), r;
}
function jl(e, n, t, r) {
  if (e != null && (e !== "numeric" && e !== n || e === "numeric" && n === "string")) throw new Error("Argument '" + t + "' passed to '" + r + "' must be " + e + " tensor, but got " + n + " tensor");
}
function k(e, n, t, r) {
  if (r === void 0 && (r = "numeric"), e instanceof Ve) return jl(r, e.dtype, n, t), e;
  var a = da(e);
  if (a !== "string" && ["bool", "int32", "float32"].indexOf(r) >= 0 && (a = r), jl(r, a, n, t), e == null || !Qt(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") {
    var o = e == null ? "null" : e.constructor.name;
    throw new Error("Argument '" + n + "' passed to '" + t + "' must be a Tensor or TensorLike, but got '" + o + "'");
  }
  var i = ar(e, a);
  Qt(e) || Array.isArray(e) || (e = [e]);
  var s = a !== "string" ? ku(e, a, _().getBool("DEBUG")) : Nr(e, [], !0);
  return D.makeTensor(s, i, a);
}
function qo(e, n, t, r) {
  if (r === void 0 && (r = "numeric"), !Array.isArray(e)) throw new Error("Argument " + n + " passed to " + t + " must be a `Tensor[]` or `TensorLike[]`");
  return e.map(function(a, o) {
    return k(a, n + "[" + o + "]", t);
  }, r);
}
function Jd(e, n) {
  for (var t = 0; t < e.length; ++t) if (e[e.length - t - 1] !== n - 1 - t) return !1;
  return !0;
}
function lv(e, n, t) {
  for (var r = e.length + n.length, a = [], o = 0, i = 0, s = 0; s < r; s++) t.indexOf(s) === -1 ? a.push(e[o++]) : a.push(n[i++]);
  return a;
}
function ct(e, n) {
  for (var t = [], r = e.length, a = 0; a < r; a++) n.indexOf(a) === -1 && t.push(e[a]);
  return [t, n.map(function(o) {
    return e[o];
  })];
}
function wt(e, n) {
  return lv(e, n.map(function(t) {
    return 1;
  }), n);
}
function Tt(e, n, t) {
  A(Jd(n, t), function() {
    return e + " supports only inner-most axes for now. Got axes " + n + " and rank-" + t + " input.";
  });
}
function fn(e, n) {
  if (Jd(e, n)) return null;
  for (var t = [], r = 0; r < n; ++r) e.indexOf(r) === -1 && t.push(r);
  return e.forEach(function(a) {
    return t.push(a);
  }), t;
}
function Tu(e) {
  return e.map(function(n, t) {
    return [t, n];
  }).sort(function(n, t) {
    return n[1] - t[1];
  }).map(function(n) {
    return n[0];
  });
}
function mn(e, n) {
  for (var t = [], r = n - e; r < n; ++r) t.push(r);
  return t;
}
function cv(e, n) {
  var t = e[0].length;
  e.forEach(function(a, o) {
    A(a.length === t, function() {
      return "Error in concat" + t + "D: rank of tensors[" + o + "] must be the same as the rank of the rest (" + t + ")";
    });
  }), A(n >= 0 && n < t, function() {
    return "Error in concat" + t + "D: axis must be between 0 and " + (t - 1) + ".";
  });
  var r = e[0];
  e.forEach(function(a, o) {
    for (var i = 0; i < t; i++) A(i === n || a[i] === r[i], function() {
      return "Error in concat" + t + "D: Shape of tensors[" + o + "] (" + a + ") does not match the shape of the rest (" + r + ") along the non-concatenated axis " + o + ".";
    });
  });
}
function la(e, n) {
  for (var t = e[0].slice(), r = 1; r < e.length; r++) t[n] += e[r][n];
  return t;
}
function S(e) {
  var n = Object.keys(e);
  if (n.length !== 1) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + n.length + " keys.");
  var t = n[0], r = e[t];
  t.endsWith("_") && (t = t.substring(0, t.length - 1));
  var a = function() {
    for (var o = [], i = 0; i < arguments.length; i++) o[i] = arguments[i];
    D.startScope(t);
    try {
      var s = r.apply(void 0, o);
      return s instanceof Promise && console.error("Cannot return a Promise inside of tidy."), D.endScope(s), s;
    } catch (u) {
      throw D.endScope(null), u;
    }
  };
  return Object.defineProperty(a, "name", { value: t, configurable: !0 }), a;
}
ae.registerFlag("HAS_WEBGL", function() {
  return ae.getNumber("WEBGL_VERSION") > 0;
}), ae.registerFlag("WEBGL_VERSION", function() {
  return Bl(2) ? 2 : Bl(1) ? 1 : 0;
}), ae.registerFlag("WEBGL_BUFFER_SUPPORTED", function() {
  return ae.get("WEBGL_VERSION") === 2;
}), ae.registerFlag("WEBGL_CPU_FORWARD", function() {
  return !0;
}), ae.registerFlag("WEBGL_FORCE_F16_TEXTURES", function() {
  return !1;
}), ae.registerFlag("WEBGL_PACK", function() {
  return ae.getBool("HAS_WEBGL");
}), ae.registerFlag("WEBGL_PACK_NORMALIZATION", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_PACK_CLIP", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_PACK_DEPTHWISECONV", function() {
  return !1;
}), ae.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_PACK_REDUCE", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_LAZILY_UNPACK", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_CONV_IM2COL", function() {
  return ae.getBool("WEBGL_PACK");
}), ae.registerFlag("WEBGL_MAX_TEXTURE_SIZE", function() {
  return nv(ae.getNumber("WEBGL_VERSION"));
}), ae.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", function() {
  return rv(ae.getNumber("WEBGL_VERSION"));
}), ae.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", function() {
  var e = ae.getNumber("WEBGL_VERSION");
  return e === 0 ? 0 : av(e);
}), ae.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", function() {
  return ae.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && (e = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))));
  var e;
}), ae.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", function() {
  return ov(ae.getNumber("WEBGL_VERSION"));
}), ae.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", function() {
  return !ae.getBool("WEBGL_FORCE_F16_TEXTURES") && ae.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
}), ae.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", function() {
  return iv(ae.getNumber("WEBGL_VERSION"));
}), ae.registerFlag("WEBGL_FENCE_API_ENABLED", function() {
  return sv(ae.getNumber("WEBGL_VERSION"));
}), ae.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", function() {
  return ae.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0;
}), $d = qd;
var nt = S({ complex_: function(e, n) {
  var t = k(e, "real", "complex"), r = k(n, "imag", "complex");
  return ke(t.shape, r.shape, "real and imag shapes, " + t.shape + " and " + r.shape + ", must match in call to tf.complex()."), D.runKernelFunc(function(a) {
    return a.complex(t, r);
  }, { $real: t, $imag: r });
} }), Dt = S({ real_: function(e) {
  var n = k(e, "input", "real");
  return D.runKernelFunc(function(t) {
    return t.real(n);
  }, { $input: n });
} }), Xt = S({ imag_: function(e) {
  var n = k(e, "input", "imag");
  return D.runKernelFunc(function(t) {
    return t.imag(n);
  }, { $input: n });
} });
function rt(e, n, t) {
  return or(e, n, ar(e, t), t);
}
function or(e, n, t, r) {
  if (r == null && (r = da(e)), r === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  if (!Qt(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (n != null) {
    Au(n);
    var a = Q(n), o = Q(t);
    A(a === o, function() {
      return "Based on the provided shape, [" + n + "], the tensor should have " + a + " values but has " + o;
    });
    for (var i = 0; i < t.length; ++i) {
      var s = t[i], u = i !== t.length - 1 || s !== Q(n.slice(i));
      A(t[i] === n[i] || !u, function() {
        return "Error creating a new Tensor. Inferred shape (" + t + ") does not match the provided shape (" + n + "). ";
      });
    }
  }
  return Qt(e) || Array.isArray(e) || (e = [e]), n = n || t, e = r !== "string" ? ku(e, r, _().getBool("DEBUG")) : Nr(e, [], !0), D.makeTensor(e, n, r);
}
function X(e, n) {
  if ((Qt(e) && n !== "string" || Array.isArray(e)) && n !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (n === "string" && Qt(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return or(e, [], [], n);
}
function Fn(e, n) {
  Tr(e);
  var t = ar(e, n);
  if (t.length !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return or(e, null, t, n);
}
function Cr(e, n, t) {
  if (Tr(e), n != null && n.length !== 2) throw new Error("tensor2d() requires shape to have two numbers");
  var r = ar(e, t);
  if (r.length !== 2 && r.length !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (r.length === 1 && n == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return or(e, n, r, t);
}
function Xd(e, n, t) {
  if (Tr(e), n != null && n.length !== 3) throw new Error("tensor3d() requires shape to have three numbers");
  var r = ar(e, t);
  if (r.length !== 3 && r.length !== 1) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (r.length === 1 && n == null) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return or(e, n, r, t);
}
function pr(e, n, t) {
  if (Tr(e), n != null && n.length !== 4) throw new Error("tensor4d() requires shape to have four numbers");
  var r = ar(e, t);
  if (r.length !== 4 && r.length !== 1) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  if (r.length === 1 && n == null) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  return or(e, n, r, t);
}
function hv(e, n, t) {
  if (Tr(e), n != null && n.length !== 5) throw new Error("tensor5d() requires shape to have five numbers");
  var r = ar(e, t);
  if (r.length !== 5 && r.length !== 1) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  if (r.length === 1 && n == null) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  return or(e, n, r, t);
}
function dv(e, n, t) {
  if (Tr(e), n != null && n.length !== 6) throw new Error("tensor6d() requires shape to have six numbers");
  var r = ar(e, t);
  if (r.length !== 6 && r.length !== 1) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  if (r.length === 1 && n == null) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  return or(e, n = n || r, r, t);
}
function pv(e, n, t, r) {
  return n === void 0 && (n = !0), D.makeVariable(e, n, t, r);
}
function Pr(e, n) {
  if (n === void 0 && (n = "float32"), n === "complex64") {
    var t = Pr(e, "float32"), r = je(e, "float32");
    return nt(t, r);
  }
  var a = Nu(Q(e), n);
  return D.makeTensor(a, e, n);
}
function je(e, n) {
  if (n === void 0 && (n = "float32"), n === "complex64") {
    var t = je(e, "float32"), r = je(e, "float32");
    return nt(t, r);
  }
  var a = pa(Q(e), n);
  return D.makeTensor(a, e, n);
}
function ci(e, n, t) {
  return D.runKernelFunc(function(r) {
    return r.fill(e, n, t);
  }, {});
}
function Qd(e, n, t) {
  if (t <= 0) throw new Error("The number of values should be positive.");
  return D.runKernelFunc(function(r) {
    return r.linspace(e, n, t);
  }, {});
}
function Va(e, n, t, r) {
  if (t === void 0 && (t = 1), r === void 0 && (r = "float32"), t === 0) throw new Error("Cannot have a step of zero");
  if (e === n || e < n && t < 0 || n < e && t > 1) return je([0], r);
  var a = pa(Math.abs(Math.ceil((n - e) / t)), r);
  n < e && t === 1 && (t = -1), a[0] = e;
  for (var o = 1; o < a.length; o++) a[o] = a[o - 1] + t;
  return Fn(a, r);
}
var Pu = S({ onesLike_: function(e) {
  var n = k(e, "x", "onesLike");
  if (n.dtype === "complex64") {
    var t = Pu(Dt(n)), r = ve(Xt(n));
    return nt(t, r);
  }
  return D.runKernelFunc(function(a) {
    return a.onesLike(n);
  }, { x: n }, function(a, o) {
    return { x: function() {
      return ve(a);
    } };
  }, "OnesLike");
} }), ve = S({ zerosLike_: function(e) {
  var n = k(e, "x", "zerosLike");
  return D.runKernelFunc(function(t) {
    return t.zerosLike(n);
  }, { x: n }, function(t, r) {
    return { x: function() {
      return ve(t);
    } };
  }, "ZerosLike");
} }), Gt = S({ concat_: function(e, n) {
  n === void 0 && (n = 0), A(e.length >= 1, function() {
    return "Pass at least one tensor to concat";
  });
  var t = qo(e, "tensors", "concat");
  t[0].dtype === "complex64" && t.forEach(function(s) {
    if (s.dtype !== "complex64") throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ` + s.dtype + ". ");
  }), n = Xe(n, t[0].shape)[0];
  var r = la(t.map(function(s) {
    return s.shape;
  }), n);
  if (Q(r) === 0) return rt([], r);
  if ((t = t.filter(function(s) {
    return s.size > 0;
  })).length === 1) return t[0];
  var a = t.map(function(s) {
    return s.shape;
  });
  cv(a, n);
  var o = t, i = { axis: n };
  return D.runKernelFunc(function(s) {
    return s.concat(t, n);
  }, o, function(s) {
    var u = a.map(function(l) {
      return l[n];
    });
    return hi(s, u, n).map(function(l) {
      return function() {
        return l;
      };
    });
  }, "Concat", i);
} }), fv = S({ concat1d_: function(e) {
  return Gt(e, 0);
} }), mv = S({ concat2d_: function(e, n) {
  return Gt(e, n);
} }), gv = S({ concat3d_: function(e, n) {
  return Gt(e, n);
} }), vv = S({ concat4d_: function(e, n) {
  return Gt(e, n);
} }), hi = S({ split_: function(e, n, t) {
  t === void 0 && (t = 0);
  var r, a = k(e, "x", "split");
  return t = Xe(t, a.shape)[0], typeof n == "number" ? (A(a.shape[t] % n == 0, function() {
    return "Number of splits must evenly divide the axis.";
  }), r = new Array(n).fill(a.shape[t] / n)) : (A(a.shape[t] === n.reduce(function(o, i) {
    return o + i;
  }), function() {
    return "The sum of sizes must match the size of the axis dimension.";
  }), r = n), D.runKernelFunc(function(o) {
    return o.split(a, r, t);
  }, { $x: a }, function(o) {
    return { $x: function() {
      return Gt(o, t);
    } };
  });
} });
function oe(e, n, t) {
  return n === void 0 && (n = "float32"), n = n || "float32", Au(e), new Ba(e, n, t);
}
function yv(e, n) {
  n === void 0 && (n = !1), console.log(e.toString(n));
}
var Su = S({ batchToSpaceND_: function(e, n, t) {
  var r = k(e, "x", "batchToSpaceND"), a = n.reduce(function(o, i) {
    return o * i;
  });
  return A(r.rank >= 1 + n.length, function() {
    return "input rank is " + r.rank + " but should be > than blockShape.length " + n.length;
  }), A(t.length === n.length, function() {
    return "crops.length is " + t.length + " but should be equal to blockShape.length  " + n.length;
  }), A(r.shape[0] % a == 0, function() {
    return "input tensor batch is " + r.shape[0] + " but is not divisible by the product of the elements of blockShape " + n.join(" * ") + " === " + a;
  }), D.runKernelFunc(function(o) {
    return o.batchToSpaceND(r, n, t);
  }, { $x: r }, function(o) {
    return { $x: function() {
      return o.spaceToBatchND(n, t);
    } };
  });
} }), Yd = S({ cast_: function(e, n) {
  var t = k(e, "x", "cast");
  if (!jd(n)) throw new Error("Failed to cast to unknown dtype " + n);
  if (n === "string" && t.dtype !== "string" || n !== "string" && t.dtype === "string") throw new Error("Only strings can be casted to strings");
  var r = { dtype: n };
  return D.runKernelFunc(function(a) {
    return a.cast(t, n);
  }, { x: t }, function(a) {
    return { x: function() {
      return a.clone();
    } };
  }, "Cast", r);
} }), bv = S({ cumsum_: function(e, n, t, r) {
  n === void 0 && (n = 0), t === void 0 && (t = !1), r === void 0 && (r = !1);
  var a = k(e, "x", "cumsum"), o = fn([n |= 0], a.rank), i = a;
  o != null && (i = a.transpose(o));
  var s = mn(1, a.rank)[0], u = D.runKernelFunc(function(l) {
    return l.cumsum(i, s, t, r);
  }, { permutedX: i }, function(l) {
    return { permutedX: function() {
      return l.cumsum(n, t, !r);
    } };
  });
  return o != null && (u = u.transpose(o)), u;
} }), Zd = S({ depthToSpace_: function(e, n, t) {
  t === void 0 && (t = "NHWC");
  var r = k(e, "x", "depthToSpace"), a = t === "NHWC" ? r.shape[1] : r.shape[2], o = t === "NHWC" ? r.shape[2] : r.shape[3], i = t === "NHWC" ? r.shape[3] : r.shape[1];
  return A(a * n >= 0, function() {
    return `Negative dimension size caused by overflow when multiplying
      ` + a + " and " + n + `  for depthToSpace with input shape
      ` + r.shape;
  }), A(o * n >= 0, function() {
    return `Negative dimension size caused by overflow when multiplying
      ` + o + " and " + n + ` for depthToSpace with input shape
          ` + r.shape;
  }), A(i % (n * n) == 0, function() {
    return "Dimension size must be evenly divisible by " + n * n + " but is " + i + " for depthToSpace with input shape " + r.shape;
  }), D.runKernelFunc(function(s) {
    return s.depthToSpace(r, n, t);
  }, { $x: r });
} }), Tn = S({ expandDims_: function(e, n) {
  n === void 0 && (n = 0);
  var t = k(e, "x", "expandDims", null);
  A(n <= t.rank, function() {
    return "Axis must be <= rank of the tensor";
  });
  var r = t.shape.slice();
  return n < 0 && (A(-(t.rank + 1) <= n, function() {
    return "Axis must be in the interval [" + -(t.rank + 1) + ", " + t.rank + "]";
  }), n = t.rank + n + 1), r.splice(n, 0, 1), un(t, r);
} }), un = S({ reshape_: function(e, n) {
  var t = k(e, "x", "reshape", null);
  n = _d(n, t.size), A(t.size === Q(n), function() {
    return "new shape and old shape must have the same number of elements.";
  });
  var r = { shape: n };
  return D.runKernelFunc(function(a) {
    return a.reshape(t, n);
  }, { x: t }, function(a) {
    return { x: function() {
      return a.reshape(t.shape);
    } };
  }, "Reshape", r);
} }), Du = S({ spaceToBatchND_: function(e, n, t) {
  var r = k(e, "x", "spaceToBatchND");
  return A(r.rank >= 1 + n.length, function() {
    return "input rank " + r.rank + " should be > than [blockShape] " + n.length;
  }), A(t.length === n.length, function() {
    return "paddings.shape[0] " + t.length + " must be equal to [blockShape] " + n.length;
  }), A(r.shape.reduce(function(a, o, i) {
    return i > 0 && i <= n.length ? a && (o + t[i - 1][0] + t[i - 1][1]) % n[i - 1] == 0 : a;
  }, !0), function() {
    return "input spatial dimensions " + r.shape.slice(1) + " with paddings " + t.toString() + " must be divisible by blockShapes " + n.toString();
  }), D.runKernelFunc(function(a) {
    return a.spaceToBatchND(r, n, t);
  }, { $x: r }, function(a) {
    return { $x: function() {
      return a.batchToSpaceND(n, t);
    } };
  });
} }), Ou = S({ squeeze_: function(e, n) {
  var t = k(e, "x", "squeeze");
  return un(t, Un(t.shape, n).newShape);
} }), Mn = S({ stack_: function(e, n) {
  n === void 0 && (n = 0);
  var t = qo(e, "tensors", "stack");
  if (A(t.length >= 1, function() {
    return "Pass at least one tensor to tf.stack";
  }), t.length === 1) return t[0].expandDims(n);
  var r = t[0].rank, a = t[0].shape, o = t[0].dtype;
  A(n <= r, function() {
    return "Axis must be <= rank of the tensor";
  }), t.forEach(function(s) {
    ke(a, s.shape, "All tensors passed to stack must have matching shapes");
  }), t.forEach(function(s) {
    A(o === s.dtype, function() {
      return "All tensors passed to stack must have matching dtypes";
    });
  });
  var i = t.map(function(s) {
    return s.expandDims(n);
  });
  return Gt(i, n);
} }), qa = S({ unstack_: function(e, n) {
  n === void 0 && (n = 0), n = n || 0;
  var t = k(e, "x", "unstack");
  A(n >= -t.shape.length && n < t.shape.length, function() {
    return "Axis = " + n + " is not in [-" + t.shape.length + ", " + t.shape.length + ")";
  }), n < 0 && (n += t.shape.length);
  var r = { axis: n };
  return D.runKernelFunc(function(a) {
    return a.unstack(t, n);
  }, { x: t }, function(a) {
    return { x: function() {
      return Mn(a, n);
    } };
  }, "Unpack", r);
} }), ep = function(e, n) {
  return Y(this, void 0, void 0, function() {
    var t, r, a, o, i, s, u, l, c, h;
    return Z(this, function(d) {
      switch (d.label) {
        case 0:
          return t = k(e, "x", "setdiff1d"), r = k(n, "y", "setdiff1d"), A(t.dtype === r.dtype, function() {
            return "x and y should have the same dtype, but got x (" + t.dtype + ") and y (" + r.dtype + ").";
          }), A(t.rank === 1, function() {
            return "x should be 1D tensor, but got x (" + t.shape + ").";
          }), A(r.rank === 1, function() {
            return "y should be 1D tensor, but got y (" + r.shape + ").";
          }), [4, t.data()];
        case 1:
          return a = d.sent(), [4, r.data()];
        case 2:
          for (o = d.sent(), i = new Set(o), s = 0, c = 0; c < a.length; c++) i.has(a[c]) || s++;
          for (u = new Ba([s], t.dtype), l = new Ba([s], "int32"), c = 0, h = 0; c < a.length; c++) i.has(a[c]) || (u.values[h] = a[c], l.values[h] = c, h++);
          return [2, [u.toTensor(), l.toTensor()]];
      }
    });
  });
};
function Jo(e, n, t, r) {
  r === void 0 && (r = !0);
  var a = [];
  if (r) (a = a.concat(n.slice(0))).push(e[0] / t), a = a.concat(e.slice(1));
  else {
    a = a.concat(e[0]);
    for (var o = n.length, i = 0; i < o; ++i) a = a.concat([e[i + 1] / n[i], n[i]]);
    a = a.concat(e.slice(o + 1));
  }
  return a;
}
function Xo(e, n, t) {
  t === void 0 && (t = !0);
  var r = [];
  if (t) {
    r.push(n);
    for (var a = n + 1; a < e; ++a) a <= 2 * n ? (r.push(a), r.push(a - (n + 1))) : r.push(a);
  } else {
    var o = [], i = [];
    for (a = 1; a < e; ++a) a >= 2 * n + 1 || a % 2 == 1 ? i.push(a) : o.push(a);
    r.push.apply(r, o), r.push(0), r.push.apply(r, i);
  }
  return r;
}
function Qo(e, n, t, r) {
  r === void 0 && (r = !0);
  var a = [];
  r ? a.push(e[0] / t) : a.push(e[0] * t);
  for (var o = 1; o < e.length; ++o) o <= n.length ? r ? a.push(n[o - 1] * e[o]) : a.push(e[o] / n[o - 1]) : a.push(e[o]);
  return a;
}
function tp(e, n) {
  for (var t = [0], r = 0; r < n; ++r) t.push(e[r][0]);
  return t;
}
function np(e, n, t) {
  for (var r = e.slice(0, 1), a = 0; a < t; ++a) r.push(e[a + 1] - n[a][0] - n[a][1]);
  return r;
}
var rp = "Add", di = "Div", pi = "SquaredDifference", ap = "BroadcastTo", op = "OneHot", ip = "Identity", sp = "Tile", up = "PadV2", _n = S({ add_: function(e, n) {
  var t, r = k(e, "a", "add"), a = k(n, "b", "add");
  t = Le(r, a), r = t[0], a = t[1];
  var o = { a: r, b: a };
  return D.runKernelFunc(function(i, s) {
    var u = i.add(r, a);
    return s([r, a]), u;
  }, o, null, rp);
} });
function Kn(e, n) {
  for (var t = e.length, r = [], a = 0; a < t; a++) {
    var o = t - 1 - a, i = e[o] || 1;
    (n[n.length - 1 - a] || 1) > 1 && i === 1 && r.unshift(o);
  }
  return r;
}
function Qe(e, n) {
  for (var t = [], r = 0; r < n.length; r++) {
    var a = e[e.length - r - 1], o = n.length - r - 1, i = n[o];
    (a == null || a === 1 && i > 1) && t.unshift(o);
  }
  return t;
}
function fe(e, n) {
  for (var t = [], r = Math.max(e.length, n.length), a = 0; a < r; a++) {
    var o = e[e.length - a - 1];
    o == null && (o = 1);
    var i = n[n.length - a - 1];
    if (i == null && (i = 1), o === 1) t.unshift(i);
    else if (i === 1) t.unshift(o);
    else {
      if (o !== i) throw Error("Operands could not be broadcast together with shapes " + e + " and " + n + ".");
      t.unshift(o);
    }
  }
  return t;
}
var lp = S({ abs_: function(e) {
  var n = k(e, "x", "abs");
  return n.dtype === "complex64" ? D.runKernelFunc(function(t) {
    return t.complexAbs(n);
  }, { $x: n }) : D.runKernelFunc(function(t, r) {
    var a = t.abs(n);
    return r([n]), a;
  }, { x: n }, function(t, r) {
    var a = r[0];
    return { x: function() {
      return t.mul(a.toFloat().step(-1));
    } };
  }, "Abs");
} }), cp = S({ acos_: function(e) {
  var n = k(e, "x", "acos");
  return D.runKernelFunc(function(t, r) {
    var a = t.acos(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.divStrict(X(1).sub(a.toFloat().square()).sqrt()).neg();
    } };
  });
} }), hp = S({ acosh_: function(e) {
  var n = k(e, "x", "acosh");
  return D.runKernelFunc(function(t, r) {
    var a = t.acosh(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.divStrict(a.toFloat().square().sub(1).sqrt());
    } };
  });
} }), dp = S({ asin_: function(e) {
  var n = k(e, "x", "asin");
  return D.runKernelFunc(function(t, r) {
    var a = t.asin(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.divStrict(X(1).sub(a.toFloat().square()).sqrt());
    } };
  });
} }), pp = S({ asinh_: function(e) {
  var n = k(e, "x", "asinh");
  return D.runKernelFunc(function(t, r) {
    var a = t.asinh(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.divStrict(X(1).add(a.toFloat().square()).sqrt());
    } };
  });
} }), fp = S({ atan_: function(e) {
  var n = k(e, "x", "atan");
  return D.runKernelFunc(function(t, r) {
    var a = t.atan(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.div(a.toFloat().square().add(1));
    } };
  });
} }), mp = S({ atanh_: function(e) {
  var n = k(e, "x", "atanh");
  return D.runKernelFunc(function(t, r) {
    var a = t.atanh(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.div(X(1).sub(a.toFloat().square()));
    } };
  });
} }), gp = S({ ceil_: function(e) {
  var n = k(e, "x", "ceil");
  return D.runKernelFunc(function(t) {
    return t.ceil(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), vp = S({ clipByValue_: function(e, n, t) {
  var r = k(e, "x", "clipByValue");
  A(n <= t, function() {
    return "Error in clip: min (" + n + ") must be less than or equal to max (" + t + ").";
  });
  var a = [r], o = { min: n, max: t };
  return D.runKernelFunc(function(i, s) {
    var u = i.clip(r, n, t);
    return s([r]), u;
  }, { x: r }, function(i, s) {
    var u = s[0];
    return { x: function() {
      return i.where(u.greaterEqual(n).logicalAnd(u.lessEqual(t)), ve(i));
    } };
  }, "ClipByValue", o, a);
} }), yp = S({ cos_: function(e) {
  var n = k(e, "x", "cos"), t = [n];
  return D.runKernelFunc(function(r, a) {
    var o = r.cos(n);
    return a([n]), o;
  }, { x: n }, function(r, a) {
    var o = a[0];
    return { x: function() {
      return o.toFloat().sin().neg().mul(r);
    } };
  }, "Cos", {}, t);
} }), bp = S({ cosh_: function(e) {
  var n = k(e, "x", "cosh");
  return D.runKernelFunc(function(t, r) {
    var a = t.cosh(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return a.toFloat().sinh().mulStrict(t);
    } };
  });
} }), xp = S({ erf_: function(e) {
  var n = k(e, "x", "erf");
  return A(n.dtype === "int32" || n.dtype === "float32", function() {
    return "Input dtype must be `int32` or `float32`.";
  }), n.dtype === "int32" && (n = n.toFloat()), D.runKernelFunc(function(t, r) {
    var a = t.erf(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.mul(a.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));
    } };
  });
} }), wp = S({ exp_: function(e) {
  var n = k(e, "x", "exp");
  return D.runKernelFunc(function(t, r) {
    var a = t.exp(n);
    return r([a]), a;
  }, { x: n }, function(t, r) {
    return { x: function() {
      return t.mulStrict(r[0]);
    } };
  }, "Exp", {}, [], [!0]);
} }), Cp = S({ expm1_: function(e) {
  var n = k(e, "x", "expm1");
  return D.runKernelFunc(function(t, r) {
    var a = t.expm1(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.mul(a.exp());
    } };
  });
} }), kp = S({ floor_: function(e) {
  var n = k(e, "x", "floor");
  return D.runKernelFunc(function(t) {
    return t.floor(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), Np = S({ log_: function(e) {
  var n = k(e, "x", "log"), t = [n];
  return D.runKernelFunc(function(r, a) {
    var o = r.log(n);
    return a([n]), o;
  }, { x: n }, function(r, a) {
    var o = a[0];
    return { x: function() {
      return r.div(o.toFloat());
    } };
  }, "Log", {}, t);
} }), Ap = S({ log1p_: function(e) {
  var n = k(e, "x", "log1p");
  return D.runKernelFunc(function(t, r) {
    var a = t.log1p(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.div(a.add(1));
    } };
  });
} }), xv = S({ logSigmoid_: function(e) {
  var n = k(e, "x", "logSigmoid");
  return D.runKernelFunc(function(t, r) {
    var a = t.softplus(n.neg()).neg();
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.mul(a.neg().sigmoid());
    } };
  });
} }), fi = S({ neg_: function(e) {
  var n = k(e, "x", "neg"), t = [n];
  return D.runKernelFunc(function(r) {
    return r.neg(n);
  }, { x: n }, function(r) {
    return { x: function() {
      return r.neg();
    } };
  }, "Neg", {}, t);
} }), Ip = S({ reciprocal_: function(e) {
  var n = k(e, "x", "reciprocal");
  return D.runKernelFunc(function(t, r) {
    var a = t.reciprocal(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.div(a.square().neg());
    } };
  });
} }), Ep = S({ round_: function(e) {
  var n = k(e, "x", "round");
  return D.runKernelFunc(function(t) {
    return t.round(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), Ru = S({ rsqrt_: function(e) {
  var n = k(e, "x", "rsqrt"), t = [n];
  return D.runKernelFunc(function(r, a) {
    var o = r.rsqrt(n);
    return a([n]), o;
  }, { x: n }, function(r, a) {
    var o = a[0];
    return { x: function() {
      return r.div(o.pow(1.5).mul(2)).neg();
    } };
  }, "Rsqrt", {}, t);
} }), Tp = S({ sigmoid_: function(e) {
  var n = k(e, "x", "sigmoid");
  return D.runKernelFunc(function(t, r) {
    var a = t.sigmoid(n);
    return r([a]), a;
  }, { x: n }, function(t, r) {
    var a = r[0];
    return { x: function() {
      return t.mul(a.mul(X(1).sub(a)));
    } };
  }, "Sigmoid");
} }), Pp = S({ sign_: function(e) {
  var n = k(e, "x", "sign");
  return D.runKernelFunc(function(t) {
    return t.sign(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), wv = S({ isNaN_: function(e) {
  var n = k(e, "x", "isNaN");
  return D.runKernelFunc(function(t) {
    return t.isNaN(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), Cv = S({ isInf_: function(e) {
  var n = k(e, "x", "isInf");
  return D.runKernelFunc(function(t) {
    return t.isInf(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), kv = S({ isFinite_: function(e) {
  var n = k(e, "x", "isFinite");
  return D.runKernelFunc(function(t) {
    return t.isFinite(n);
  }, { $x: n }, function(t) {
    return { $x: function() {
      return ve(t);
    } };
  });
} }), Sp = S({ sin_: function(e) {
  var n = k(e, "x", "sin"), t = [n];
  return D.runKernelFunc(function(r, a) {
    var o = r.sin(n);
    return a([n]), o;
  }, { x: n }, function(r, a) {
    var o = a[0];
    return { x: function() {
      return o.toFloat().cos().mul(r);
    } };
  }, "Sin", {}, t);
} }), Dp = S({ sinh_: function(e) {
  var n = k(e, "x", "sinh");
  return D.runKernelFunc(function(t, r) {
    var a = t.sinh(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return a.toFloat().cosh().mulStrict(t);
    } };
  });
} }), Op = S({ softplus_: function(e) {
  var n = k(e, "x", "softplus");
  return D.runKernelFunc(function(t, r) {
    var a = t.softplus(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.mul(a.sigmoid());
    } };
  });
} }), Rp = S({ sqrt_: function(e) {
  var n = k(e, "x", "sqrt");
  return D.runKernelFunc(function(t, r) {
    var a = t.sqrt(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.div(a.toFloat().sqrt().mul(2));
    } };
  });
} }), Nv = S({ step_: function(e, n) {
  n === void 0 && (n = 0);
  var t = k(e, "x", "step");
  return D.runKernelFunc(function(r) {
    return r.step(t, n);
  }, { $x: t }, function(r) {
    return { $x: function() {
      return ve(r);
    } };
  });
} }), Fp = S({ tan_: function(e) {
  var n = k(e, "x", "tan");
  return D.runKernelFunc(function(t, r) {
    var a = t.tan(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return t.div(a.cos().square());
    } };
  });
} }), Mp = S({ tanh_: function(e) {
  var n = k(e, "x", "tanh");
  return D.runKernelFunc(function(t, r) {
    var a = t.tanh(n);
    return r([a]), a;
  }, { x: n }, function(t, r) {
    var a = r[0];
    return { x: function() {
      return X(1).sub(a.square()).mulStrict(t);
    } };
  }, "Tanh", {}, null, [!0]);
} }), Av = S({ addStrict_: function(e, n) {
  var t = k(e, "a", "addStrict"), r = k(n, "b", "addStrict");
  return ke(t.shape, r.shape, "Error in addStrict: "), t.add(r);
} }), _p = S({ atan2_: function(e, n) {
  var t, r = k(e, "a", "atan2"), a = k(n, "b", "atan2");
  t = Le(r, a), r = t[0], a = t[1];
  var o = fe(r.shape, a.shape);
  return D.runKernelFunc(function(i, s) {
    var u = i.atan2(r, a);
    return s([r, a]), u;
  }, { $a: r, $b: a }, function(i, s) {
    var u = s[0], l = s[1];
    return { $a: function() {
      var c = _n(u.square(), l.square()), h = i.mul(l.div(c)), d = Qe(u.shape, o);
      return d.length > 0 && (h = h.sum(d)), h.reshape(u.shape);
    }, $b: function() {
      var c = _n(u.square(), l.square()), h = fi(i.mul(u.div(c))), d = Qe(l.shape, o);
      return d.length > 0 && (h = h.sum(d)), h.reshape(l.shape);
    } };
  });
} }), Iv = S({ divStrict_: function(e, n) {
  var t = k(e, "a", "div"), r = k(n, "b", "div");
  return ke(t.shape, r.shape, "Error in divideStrict: "), t.div(r);
} }), Fu = S({ floorDiv_: function(e, n) {
  var t, r = k(e, "a", "floorDiv"), a = k(n, "b", "floorDiv");
  t = Le(r, a), r = t[0], a = t[1];
  var o = fe(r.shape, a.shape);
  return D.runKernelFunc(function(i, s) {
    var u = i.floorDiv(r, a);
    return s([r, a]), u;
  }, { a: r, b: a }, function(i, s) {
    var u = s[0], l = s[1];
    return { a: function() {
      var c = i.div(l.toFloat()), h = Qe(u.shape, o);
      return h.length > 0 ? c.sum(h).reshape(u.shape) : c;
    }, b: function() {
      var c = i.mul(u.toFloat()), h = Qe(l.shape, o);
      h.length > 0 && (c = c.sum(h).reshape(l.shape));
      var d = l.square();
      return c.div(d.toFloat()).neg();
    } };
  }, "FloorDiv");
} }), mi = S({ maximum_: function(e, n) {
  var t, r = k(e, "a", "maximum"), a = k(n, "b", "maximum");
  return t = Le(r, a), r = t[0], a = t[1], r.dtype === "bool" && (r = r.toInt(), a = a.toInt()), fe(r.shape, a.shape), D.runKernelFunc(function(o, i) {
    var s = o.maximum(r, a);
    return i([r, a]), s;
  }, { a: r, b: a }, function(o, i) {
    var s = i[0], u = i[1];
    return { a: function() {
      return o.mul(s.greaterEqual(u).toFloat());
    }, b: function() {
      return o.mul(s.less(u).toFloat());
    } };
  }, "Maximum");
} }), Ev = S({ maximumStrict_: function(e, n) {
  var t = k(e, "a", "maximumStrict"), r = k(n, "b", "maximumStrict");
  return ke(t.shape, r.shape, "Error in maximumStrict: "), t.maximum(r);
} }), Mu = S({ minimum_: function(e, n) {
  var t, r = k(e, "a", "minimum"), a = k(n, "b", "minimum");
  return t = Le(r, a), r = t[0], a = t[1], r.dtype === "bool" && (r = r.toInt(), a = a.toInt()), fe(r.shape, a.shape), D.runKernelFunc(function(o, i) {
    var s = o.minimum(r, a);
    return i([r, a]), s;
  }, { a: r, b: a }, function(o, i) {
    var s = i[0], u = i[1];
    return { a: function() {
      return o.mul(s.lessEqual(u).toFloat());
    }, b: function() {
      return o.mul(s.greater(u).toFloat());
    } };
  }, "Minimum");
} }), Tv = S({ minimumStrict_: function(e, n) {
  var t = k(e, "a", "minimumStrict"), r = k(n, "b", "minimumStrict");
  return ke(t.shape, r.shape, "Error in minimumStrict: "), t.minimum(r);
} }), Bp = S({ mod_: function(e, n) {
  var t, r = k(e, "a", "mod"), a = k(n, "b", "mod");
  t = Le(r, a), r = t[0], a = t[1];
  var o = fe(r.shape, a.shape);
  return D.runKernelFunc(function(i, s) {
    var u = i.mod(r, a);
    return s([r, a]), u;
  }, { $a: r, $b: a }, function(i, s) {
    var u = s[0], l = s[1];
    return { $a: function() {
      var c = Qe(u.shape, o);
      return c.length > 0 ? i.sum(c).reshape(u.shape) : i;
    }, $b: function() {
      var c = i.mul(u.div(l).floor().neg()), h = Qe(l.shape, o);
      return h.length > 0 ? c.sum(h).reshape(l.shape) : c;
    } };
  });
} }), Pv = S({ modStrict_: function(e, n) {
  var t = k(e, "a", "modStrict"), r = k(n, "b", "modStrict");
  return ke(t.shape, r.shape, "Error in modStrict: "), t.mod(r);
} }), $e = S({ mul_: function(e, n) {
  var t, r = k(e, "a", "mul"), a = k(n, "b", "mul");
  t = Le(r, a), r = t[0], a = t[1];
  var o = fe(r.shape, a.shape);
  return D.runKernelFunc(function(i, s) {
    var u = i.multiply(r, a);
    return s([r, a]), u;
  }, { a: r, b: a }, function(i, s) {
    var u = s[0], l = s[1];
    return { a: function() {
      var c = i.mul(l.toFloat()), h = Qe(u.shape, o);
      return h.length > 0 ? c.sum(h).reshape(u.shape) : c;
    }, b: function() {
      var c = i.mul(u.toFloat()), h = Qe(l.shape, o);
      return h.length > 0 ? c.sum(h).reshape(l.shape) : c;
    } };
  }, "Mul");
} }), Sv = S({ mulStrict_: function(e, n) {
  var t = k(e, "a", "mul"), r = k(n, "b", "mul");
  return ke(t.shape, r.shape, "Error in multiplyStrict: "), t.mul(r);
} }), La = S({ pow_: function(e, n) {
  var t, r = k(e, "base", "pow"), a = k(n, "exp", "pow");
  t = Le(r, a), r = t[0], a = t[1];
  var o = fe(r.shape, a.shape), i = [r, a];
  return D.runKernelFunc(function(s, u) {
    var l = s.pow(r, a);
    return u([r, a, l]), l;
  }, { a: r, b: a }, function(s, u) {
    var l = u[0], c = u[1], h = u[2];
    return { a: function() {
      var d = c.toFloat(), p = s.mul(d.mul(l.pow(d.sub(X(1))))), f = Qe(l.shape, o);
      return f.length > 0 && (p = p.sum(f)), p.reshape(l.shape);
    }, b: function() {
      var d = l.greater(0), p = l.log().where(d, ve(l)), f = s.mul(h.mul(p)), m = Qe(c.shape, o);
      return m.length > 0 && (f = f.sum(m)), f.reshape(c.shape);
    } };
  }, "Pow", {}, i, [!0]);
} }), Dv = S({ powStrict_: function(e, n) {
  return ke(e.shape, n.shape, "Error in powStrict: "), e.pow(n);
} }), Ov = S({ squaredDifferenceStrict_: function(e, n) {
  var t = k(e, "a", "squaredDifferenceStrict"), r = k(n, "b", "squaredDifferenceStrict");
  return ke(t.shape, r.shape, "Error in squaredDifferenceStrict: "), t.squaredDifference(r);
} }), Rn = S({ sub_: function(e, n) {
  var t, r = k(e, "a", "sub"), a = k(n, "b", "sub");
  t = Le(r, a), r = t[0], a = t[1];
  var o = fe(r.shape, a.shape);
  return D.runKernelFunc(function(i) {
    return i.subtract(r, a);
  }, { a: r, b: a }, function(i) {
    return { a: function() {
      var s = i, u = Qe(r.shape, o);
      return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);
    }, b: function() {
      var s = i, u = Qe(a.shape, o);
      return u.length > 0 && (s = s.sum(u)), s.neg().reshape(a.shape);
    } };
  }, "Sub");
} }), Rv = S({ subStrict_: function(e, n) {
  var t = k(e, "a", "subStrict"), r = k(n, "b", "subStrict");
  return ke(t.shape, r.shape, "Error in subStrict: "), t.sub(r);
} }), Bn = S({ div_: function(e, n) {
  var t, r = k(e, "a", "div"), a = k(n, "b", "div");
  if (t = Le(r, a), r = t[0], a = t[1], r.dtype === "int32" && a.dtype === "int32") return Fu(r, a);
  var o = { a: r, b: a };
  return D.runKernelFunc(function(i, s) {
    var u = i.realDivide(r, a);
    return s([r, a]), u;
  }, o, null, di, {});
} });
function jp(e, n) {
  if (e.rank < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (n.rank < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + n.rank + ".");
  if (n.dtype !== "int32") throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + n.dtype + ".");
  if (n.shape[n.rank - 1] > e.rank) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + n.shape[n.rank - 1] + " vs. " + e.rank);
  if (e.size === 0) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + e.shape + ".");
  for (var t = n.shape, r = t[t.length - 1], a = 1, o = 0; o < t.length - 1; ++o) a *= t[o];
  var i = e.shape, s = t.slice();
  s.pop();
  var u = 1;
  for (o = r; o < e.rank; ++o) u *= i[o], s.push(i[o]);
  var l = bt(e.shape).map(function(c) {
    return c / u;
  }).concat([1]).slice(0, r);
  return [s, a, u, l];
}
var Vp = 30;
function Gi(e) {
  return e <= Vp ? e : Go(e, Math.floor(Math.sqrt(e)));
}
function Fv(e, n, t) {
  var r = n.rank > 1 ? n.shape[n.rank - 1] : 1, a = n.rank > 1 ? n.rank - 1 : 1, o = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + t.shape + ", indices.shape: " + n.shape + ", shape: " + e + ", sliceDim: " + r + ", and batchDim: " + a + ".";
  if (t.rank < a) throw new Error(o + " update.rank < " + a + ". ");
  if (e.length < r + (t.rank - a)) throw new Error(o + " Output shape length < " + (r + (t.rank - a)));
  if (t.rank !== a + e.length - r) throw new Error(o + " update.rank != " + (a + e.length - r));
  for (var i = 0; i < a; ++i) if (t.shape[i] !== n.shape[i]) throw new Error(o + " updates.shape[" + i + "] (" + t.shape[i] + ") != indices.shape[" + i + "] (" + n.shape[i] + ").");
  for (i = 0; i < t.rank - a; ++i) if (t.shape[i + a] !== e[i + r]) throw new Error(o + " updates.shape[" + (i + a) + "] (" + t.shape[i + a] + ") != shape[" + (i + a) + "] (" + e[i + a] + ")");
}
function Mv(e, n, t) {
  if (n.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + n.rank + ".");
  if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + e.rank + ".");
  if (n.dtype !== "int32") throw new Error("The dtype of 'indices' should be int32, but got dtype: " + n.dtype);
  if (t.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + t);
  if (t.length === 0) {
    if (n.size === 0) throw new Error("Indices specified for empty output. indices shape: " + n.shape);
    if (e.size === 0) throw new Error("Updates specified for empty output. updates shape: " + e.shape);
  }
  Fv(t, n, e);
}
function Yo(e, n, t) {
  for (var r = n.shape.length, a = r > 1 ? n.shape[r - 1] : 1, o = t.length, i = 1, s = a; s < o; ++s) i *= t[s];
  var u = a < 1 ? 1 : a;
  return { sliceRank: a, numUpdates: Q(n.shape) / u, sliceSize: i, strides: bt(t.slice(0, a)).concat([1]), outputSize: Q(t) };
}
function _v(e, n, t) {
  A(e.rank === n.length, function() {
    return "Error in slice" + e.rank + "D: Length of begin " + n + " must match the rank of the array (" + e.rank + ").";
  }), A(e.rank === t.length, function() {
    return "Error in slice" + e.rank + "D: Length of size " + t + " must match the rank of the array (" + e.rank + ").";
  });
  for (var r = function(o) {
    A(n[o] + t[o] <= e.shape[o], function() {
      return "Error in slice" + e.rank + "D: begin[" + o + "] + size[" + o + "] (" + (n[o] + t[o]) + ") would overflow input.shape[" + o + "] (" + e.shape[o] + ")";
    });
  }, a = 0; a < e.rank; ++a) r(a);
}
function Vl(e) {
  for (var n = [], t = 0; e > 0; ) 1 & e && n.push(t), e /= 2, t++;
  return n;
}
function _u(e, n, t) {
  for (var r = [], a = 0; a < e.length; a++) r[a] = Math.ceil((n[a] - e[a]) / t[a]);
  return r;
}
function Bv(e, n, t, r, a) {
  var o = n[a], i = t[a] || 1;
  (e & 1 << a || o == null) && (o = i > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
  var s = r[a];
  return o < 0 && (o += s), o = Vo(0, o, s - 1);
}
function jv(e, n, t, r, a) {
  var o = n[a], i = t[a] || 1;
  (e & 1 << a || o == null) && (o = i > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
  var s = r[a];
  return o < 0 && (o += s), o = i > 0 ? Vo(0, o, s) : Vo(-1, o, s - 1);
}
function Lp(e, n, t) {
  for (var r = t.length, a = 0; a < t.length; a++) if (t[a] > 1) {
    r = a;
    break;
  }
  for (a = r + 1; a < t.length; a++) if (n[a] > 0 || t[a] !== e[a]) return !1;
  return !0;
}
function zp(e, n) {
  for (var t = e.length > 0 ? e[e.length - 1] : 1, r = 0; r < e.length - 1; r++) t += e[r] * n[r];
  return t;
}
function Vv(e, n) {
  A(zo(e), function() {
    return "The f passed in variableGrads(f) must be a function";
  }), A(n == null || Array.isArray(n) && n.every(function(c) {
    return c instanceof Wo;
  }), function() {
    return "The varList passed in variableGrads(f, varList) must be an array of variables";
  });
  var t = n != null;
  if (!t) for (var r in n = [], D.registeredVariables) n.push(D.registeredVariables[r]);
  var a = t ? n.filter(function(c) {
    return !c.trainable;
  }) : null, o = n.length;
  A((n = n.filter(function(c) {
    return c.trainable;
  })).length > 0, function() {
    return "variableGrads() expects at least one of the input variables to be trainable, but none of the " + o + " variables is trainable.";
  });
  var i = D.gradients(e, n, null, !0), s = i.value, u = i.grads;
  A(u.some(function(c) {
    return c != null;
  }), function() {
    return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().";
  }), A(s.rank === 0, function() {
    return "The f passed in variableGrads(f) must return a scalar, but it returned a rank-" + s.rank + " tensor";
  });
  var l = {};
  return n.forEach(function(c, h) {
    u[h] != null && (l[c.name] = u[h]);
  }), a != null && a.forEach(function(c) {
    return l[c.name] = null;
  }), { value: s, grads: l };
}
function gi(e) {
  return D.customGrad(e);
}
var vi = S({ softmax_: function(e, n) {
  n === void 0 && (n = -1);
  var t = k(e, "logits", "softmax", "float32");
  if (n === -1 && (n = t.rank - 1), n !== t.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank " + t.rank + " and dim was " + n);
  return D.runKernelFunc(function(r, a) {
    var o = r.softmax(t, n);
    return a([o]), o;
  }, { logits: t }, function(r, a) {
    var o = a[0], i = r.mul(o);
    return { logits: function() {
      return i.sub(i.sum([n], !0).mul(o));
    } };
  }, "Softmax", { dim: n }, [], [!0]);
} }), Gp = S({ logSoftmax_: function(e, n) {
  n === void 0 && (n = -1);
  var t = k(e, "logits", "logSoftmax");
  if (n === -1 && (n = t.rank - 1), n !== t.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank " + t.rank + " and axis was " + n);
  return gi(function(r, a) {
    var o = r.max(n, !0), i = r.sub(o), s = i.toFloat().sub(i.exp().sum(n, !0).log());
    return a([s]), { value: s, gradFunc: function(u, l) {
      var c = l[0].exp();
      return u.sub(u.sum(n, !0).mul(c));
    } };
  })(t);
} }), Lt = S({ transpose_: function(e, n) {
  var t = k(e, "x", "transpose");
  if (n == null && (n = t.shape.map(function(a, o) {
    return o;
  }).reverse()), A(t.rank === n.length, function() {
    return "Error in transpose: rank of input " + t.rank + " must match length of perm " + n + ".";
  }), n.forEach(function(a) {
    A(a >= 0 && a < t.rank, function() {
      return "All entries in 'perm' must be between 0 and " + (t.rank - 1) + " but got " + n;
    });
  }), t.rank <= 1) return t.clone();
  var r = { perm: n };
  return D.runKernelFunc(function(a) {
    return a.transpose(t, n);
  }, { x: t }, null, "Transpose", r);
} }), Hp = function() {
  function e(n, t) {
    this.backend = n, this.dataMover = t, this.data = /* @__PURE__ */ new WeakMap(), this.dataIdsCount = 0;
  }
  return e.prototype.get = function(n) {
    return this.data.has(n) || this.dataMover.moveData(this.backend, n), this.data.get(n);
  }, e.prototype.set = function(n, t) {
    this.dataIdsCount++, this.data.set(n, t);
  }, e.prototype.has = function(n) {
    return this.data.has(n);
  }, e.prototype.delete = function(n) {
    return this.dataIdsCount--, this.data.delete(n);
  }, e.prototype.numDataIds = function() {
    return this.dataIdsCount;
  }, e;
}(), Wp = function() {
  function e() {
  }
  return e.prototype.time = function(n) {
    return F("time");
  }, e.prototype.read = function(n) {
    return F("read");
  }, e.prototype.readSync = function(n) {
    return F("readSync");
  }, e.prototype.numDataIds = function() {
    return F("numDataIds");
  }, e.prototype.disposeData = function(n) {
    return F("disposeData");
  }, e.prototype.write = function(n, t, r) {
    return F("write");
  }, e.prototype.move = function(n, t, r, a) {
    return F("move");
  }, e.prototype.memory = function() {
    return F("memory");
  }, e.prototype.floatPrecision = function() {
    return F("floatPrecision");
  }, e.prototype.epsilon = function() {
    return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
  }, e.prototype.batchMatMul = function(n, t, r, a) {
    return F("batchMatMul");
  }, e.prototype.fusedBatchMatMul = function(n) {
    return n.a, n.b, n.transposeA, n.transposeB, n.bias, n.activation, n.preluActivationWeights, F("fusedBatchMatMul");
  }, e.prototype.slice = function(n, t, r) {
    return F("slice");
  }, e.prototype.stridedSlice = function(n, t, r, a) {
    return F("stridedSlice");
  }, e.prototype.unstack = function(n, t) {
    return F("unstack");
  }, e.prototype.reverse = function(n, t) {
    return F("reverse");
  }, e.prototype.concat = function(n, t) {
    return F("concat");
  }, e.prototype.neg = function(n) {
    return F("neg");
  }, e.prototype.add = function(n, t) {
    return F("add");
  }, e.prototype.addN = function(n) {
    return F("addN");
  }, e.prototype.subtract = function(n, t) {
    return F("subtract");
  }, e.prototype.multiply = function(n, t) {
    return F("multiply");
  }, e.prototype.realDivide = function(n, t) {
    return F("realDivide");
  }, e.prototype.floorDiv = function(n, t) {
    return F("floorDiv");
  }, e.prototype.sum = function(n, t) {
    return F("sum");
  }, e.prototype.prod = function(n, t) {
    return F("prod");
  }, e.prototype.unsortedSegmentSum = function(n, t, r) {
    return F("unsortedSegmentSum");
  }, e.prototype.argMin = function(n, t) {
    return F("argMin");
  }, e.prototype.argMax = function(n, t) {
    return F("argMax");
  }, e.prototype.equal = function(n, t) {
    return F("equal");
  }, e.prototype.notEqual = function(n, t) {
    return F("notEqual");
  }, e.prototype.less = function(n, t) {
    return F("less");
  }, e.prototype.lessEqual = function(n, t) {
    return F("lessEqual");
  }, e.prototype.greater = function(n, t) {
    return F("greater");
  }, e.prototype.greaterEqual = function(n, t) {
    return F("greaterEqual");
  }, e.prototype.logicalNot = function(n) {
    return F("logicalNot");
  }, e.prototype.logicalAnd = function(n, t) {
    return F("logicalAnd");
  }, e.prototype.logicalOr = function(n, t) {
    return F("logicalOr");
  }, e.prototype.where = function(n) {
    return F("where");
  }, e.prototype.select = function(n, t, r) {
    return F("select");
  }, e.prototype.topk = function(n, t, r) {
    return F("topk");
  }, e.prototype.min = function(n, t) {
    return F("min");
  }, e.prototype.minimum = function(n, t) {
    return F("minimum");
  }, e.prototype.mod = function(n, t) {
    return F("mod");
  }, e.prototype.max = function(n, t) {
    return F("max");
  }, e.prototype.maximum = function(n, t) {
    return F("maximum");
  }, e.prototype.all = function(n, t) {
    return F("all");
  }, e.prototype.any = function(n, t) {
    return F("any");
  }, e.prototype.squaredDifference = function(n, t) {
    return F("squaredDifference");
  }, e.prototype.ceil = function(n) {
    return F("ceil");
  }, e.prototype.floor = function(n) {
    return F("floor");
  }, e.prototype.round = function(n) {
    return F("round");
  }, e.prototype.sign = function(n) {
    return F("sign");
  }, e.prototype.isNaN = function(n) {
    return F("isNaN");
  }, e.prototype.isInf = function(n) {
    return F("isInf");
  }, e.prototype.isFinite = function(n) {
    return F("isFinite");
  }, e.prototype.pow = function(n, t) {
    return F("pow");
  }, e.prototype.exp = function(n) {
    return F("exp");
  }, e.prototype.expm1 = function(n) {
    return F("expm1");
  }, e.prototype.softmax = function(n, t) {
    return F("softmax");
  }, e.prototype.log = function(n) {
    return F("log");
  }, e.prototype.log1p = function(n) {
    return F("log1p");
  }, e.prototype.sqrt = function(n) {
    return F("sqrt");
  }, e.prototype.rsqrt = function(n) {
    return F("rsqrt");
  }, e.prototype.square = function(n) {
    return F("square");
  }, e.prototype.reciprocal = function(n) {
    return F("reciprocal");
  }, e.prototype.relu = function(n) {
    return F("relu");
  }, e.prototype.relu6 = function(n) {
    return F("relu6");
  }, e.prototype.prelu = function(n, t) {
    return F("prelu");
  }, e.prototype.elu = function(n) {
    return F("elu");
  }, e.prototype.eluDer = function(n, t) {
    return F("eluDer");
  }, e.prototype.selu = function(n) {
    return F("selu");
  }, e.prototype.int = function(n) {
    return F("int");
  }, e.prototype.clip = function(n, t, r) {
    return F("clip");
  }, e.prototype.abs = function(n) {
    return F("abs");
  }, e.prototype.complexAbs = function(n) {
    return F("complexAbs");
  }, e.prototype.sigmoid = function(n) {
    return F("sigmoid");
  }, e.prototype.softplus = function(n) {
    return F("softplus");
  }, e.prototype.sin = function(n) {
    return F("sin");
  }, e.prototype.cos = function(n) {
    return F("cos");
  }, e.prototype.tan = function(n) {
    return F("tan");
  }, e.prototype.asin = function(n) {
    return F("asin");
  }, e.prototype.acos = function(n) {
    return F("acos");
  }, e.prototype.atan = function(n) {
    return F("atan");
  }, e.prototype.atan2 = function(n, t) {
    return F("atan2");
  }, e.prototype.sinh = function(n) {
    return F("sinh");
  }, e.prototype.cosh = function(n) {
    return F("cosh");
  }, e.prototype.tanh = function(n) {
    return F("tanh");
  }, e.prototype.asinh = function(n) {
    return F("asinh");
  }, e.prototype.acosh = function(n) {
    return F("acosh");
  }, e.prototype.atanh = function(n) {
    return F("atanh");
  }, e.prototype.erf = function(n) {
    return F("erf");
  }, e.prototype.step = function(n, t) {
    return F("step");
  }, e.prototype.fusedConv2d = function(n) {
    return n.input, n.filter, n.convInfo, n.bias, n.activation, n.preluActivationWeights, F("fusedConv2d");
  }, e.prototype.conv2d = function(n, t, r) {
    return F("conv2d");
  }, e.prototype.conv2dDerInput = function(n, t, r) {
    return F("conv2dDerInput");
  }, e.prototype.conv2dDerFilter = function(n, t, r) {
    return F("conv2dDerFilter");
  }, e.prototype.fusedDepthwiseConv2D = function(n) {
    return n.input, n.filter, n.convInfo, n.bias, n.activation, n.preluActivationWeights, F("fusedDepthwiseConv2D");
  }, e.prototype.depthwiseConv2D = function(n, t, r) {
    return F("depthwiseConv2D");
  }, e.prototype.depthwiseConv2DDerInput = function(n, t, r) {
    return F("depthwiseConv2DDerInput");
  }, e.prototype.depthwiseConv2DDerFilter = function(n, t, r) {
    return F("depthwiseConv2DDerFilter");
  }, e.prototype.conv3d = function(n, t, r) {
    return F("conv3d");
  }, e.prototype.conv3dDerInput = function(n, t, r) {
    return F("conv3dDerInput");
  }, e.prototype.conv3dDerFilter = function(n, t, r) {
    return F("conv3dDerFilter");
  }, e.prototype.maxPool = function(n, t) {
    return F("maxPool");
  }, e.prototype.maxPoolBackprop = function(n, t, r, a) {
    return F("maxPoolBackprop");
  }, e.prototype.avgPool = function(n, t) {
    return F("avgPool");
  }, e.prototype.avgPoolBackprop = function(n, t, r) {
    return F("avgPoolBackprop");
  }, e.prototype.avgPool3d = function(n, t) {
    return F("avgPool3d");
  }, e.prototype.avgPool3dBackprop = function(n, t, r) {
    return F("avgPool3dBackprop");
  }, e.prototype.maxPool3d = function(n, t) {
    return F("maxPool3d");
  }, e.prototype.maxPool3dBackprop = function(n, t, r, a) {
    return F("maxPool3dBackprop");
  }, e.prototype.reshape = function(n, t) {
    return F("reshape");
  }, e.prototype.cast = function(n, t) {
    return F("cast");
  }, e.prototype.tile = function(n, t) {
    return F("tile");
  }, e.prototype.pad = function(n, t, r) {
    return F("pad");
  }, e.prototype.transpose = function(n, t) {
    return F("transpose");
  }, e.prototype.gather = function(n, t, r) {
    return F("gather");
  }, e.prototype.gatherND = function(n, t) {
    return F("gatherND");
  }, e.prototype.scatterND = function(n, t, r) {
    return F("scatterND");
  }, e.prototype.batchToSpaceND = function(n, t, r) {
    return F("batchToSpaceND");
  }, e.prototype.spaceToBatchND = function(n, t, r) {
    return F("spaceToBatchND");
  }, e.prototype.resizeBilinear = function(n, t, r, a) {
    return F("resizeBilinear");
  }, e.prototype.resizeBilinearBackprop = function(n, t, r) {
    return F("resizeBilinearBackprop");
  }, e.prototype.resizeNearestNeighbor = function(n, t, r, a) {
    return F("resizeNearestNeighbor");
  }, e.prototype.resizeNearestNeighborBackprop = function(n, t, r) {
    return F("resizeNearestNeighborBackprop");
  }, e.prototype.batchNormalization = function(n, t, r, a, o, i) {
    return F("batchNormalization");
  }, e.prototype.localResponseNormalization4D = function(n, t, r, a, o) {
    return F("localResponseNormalization4D");
  }, e.prototype.LRNGrad = function(n, t, r, a, o, i, s) {
    return F("LRNGrad");
  }, e.prototype.multinomial = function(n, t, r, a) {
    return F("multinomial");
  }, e.prototype.oneHot = function(n, t, r, a) {
    return F("oneHot");
  }, e.prototype.cumsum = function(n, t, r, a) {
    return F("cumsum");
  }, e.prototype.nonMaxSuppression = function(n, t, r, a, o) {
    return F("nonMaxSuppression");
  }, e.prototype.fft = function(n) {
    return F("fft");
  }, e.prototype.ifft = function(n) {
    return F("ifft");
  }, e.prototype.complex = function(n, t) {
    return F("complex");
  }, e.prototype.real = function(n) {
    return F("real");
  }, e.prototype.imag = function(n) {
    return F("imag");
  }, e.prototype.cropAndResize = function(n, t, r, a, o, i) {
    return F("cropAndResize");
  }, e.prototype.depthToSpace = function(n, t, r) {
    return F("depthToSpace");
  }, e.prototype.split = function(n, t, r) {
    return F("split");
  }, e.prototype.sparseToDense = function(n, t, r, a) {
    return F("sparseToDense");
  }, e.prototype.diag = function(n) {
    return F("diag");
  }, e.prototype.fill = function(n, t, r) {
    return F("fill");
  }, e.prototype.onesLike = function(n) {
    return F("onesLike");
  }, e.prototype.zerosLike = function(n) {
    return F("zerosLike");
  }, e.prototype.linspace = function(n, t, r) {
    return F("linspace");
  }, e.prototype.dispose = function() {
    return F("dispose");
  }, e;
}();
function F(e) {
  throw new Error("'" + e + "' not yet implemented or not found in the registry. Did you forget to import the kernel?");
}
function Ir(e, n, t, r, a, o, i) {
  i === void 0 && (i = "channelsLast");
  var s, u = ti(n), l = u[0], c = u[1];
  if (i === "channelsLast") s = [l, c, e[3], e[3]];
  else {
    if (i !== "channelsFirst") throw new Error("Unknown dataFormat " + i);
    s = [l, c, e[1], e[1]];
  }
  return Sr(e, s, t, r, a, o, !1, i);
}
function Zo(e, n, t, r, a, o, i) {
  i === void 0 && (i = "NDHWC");
  var s, u, l = Os(n), c = l[0], h = l[1], d = l[2];
  if (i === "NDHWC") u = "channelsLast", s = [c, h, d, e[4], e[4]];
  else {
    if (i !== "NCDHW") throw new Error("Unknown dataFormat " + i);
    u = "channelsFirst", s = [c, h, d, e[1], e[1]];
  }
  return ei(e, s, t, r, a, !1, u, o);
}
function Sr(e, n, t, r, a, o, i, s) {
  i === void 0 && (i = !1), s === void 0 && (s = "channelsLast");
  var u = [-1, -1, -1, -1], l = u[0], c = u[1], h = u[2], d = u[3];
  if (s === "channelsLast") l = e[0], c = e[1], h = e[2], d = e[3];
  else {
    if (s !== "channelsFirst") throw new Error("Unknown dataFormat " + s);
    l = e[0], d = e[1], c = e[2], h = e[3];
  }
  var p, f = n[0], m = n[1], g = n[3], v = ti(t), y = v[0], b = v[1], x = ti(r), C = x[0], N = x[1], T = ra(f, C), I = ra(m, N), E = function(j, B, H, W, L, $, K, J) {
    var ee, ne, ce;
    if (typeof j == "number") {
      ee = { top: j, bottom: j, left: j, right: j, type: j === 0 ? "VALID" : "NUMBER" };
      var he = function(ge, Ie, Ce, ze, Me) {
        ze == null && (ze = $p(ge, Ie, Ce));
        var _e = ge[0], nn = ge[1], rn = Da((_e - Ie + 2 * ze) / Ce + 1, Me);
        A(He(rn), function() {
          return "The output # of rows (" + rn + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var Ct = Da((nn - Ie + 2 * ze) / Ce + 1, Me);
        return A(He(Ct), function() {
          return "The output # of columns (" + Ct + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [rn, Ct];
      }([B, H], $, W, j, J);
      ne = he[0], ce = he[1];
    } else if (j === "same") {
      ne = Math.ceil(B / W), ce = Math.ceil(H / L);
      var pe = Math.max(0, (ne - 1) * W + $ - B), ye = Math.max(0, (ce - 1) * L + K - H), me = Math.floor(pe / 2), be = pe - me, We = Math.floor(ye / 2);
      ee = { top: me, bottom: be, left: We, right: ye - We, type: "SAME" };
    } else {
      if (j !== "valid") throw Error("Unknown padding parameter: " + j);
      ee = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" }, ne = Math.ceil((B - $ + 1) / W), ce = Math.ceil((H - K + 1) / L);
    }
    return { padInfo: ee, outHeight: ne, outWidth: ce };
  }(a, c, h, y, b, T, I, o), P = E.padInfo, O = E.outHeight, R = E.outWidth, z = i ? g * d : g;
  return s === "channelsFirst" ? p = [l, z, O, R] : s === "channelsLast" && (p = [l, O, R, z]), { batchSize: l, dataFormat: s, inHeight: c, inWidth: h, inChannels: d, outHeight: O, outWidth: R, outChannels: z, padInfo: P, strideHeight: y, strideWidth: b, filterHeight: f, filterWidth: m, effectiveFilterHeight: T, effectiveFilterWidth: I, dilationHeight: C, dilationWidth: N, inShape: e, outShape: p, filterShape: n };
}
function ei(e, n, t, r, a, o, i, s) {
  o === void 0 && (o = !1), i === void 0 && (i = "channelsLast");
  var u = [-1, -1, -1, -1, -1], l = u[0], c = u[1], h = u[2], d = u[3], p = u[4];
  if (i === "channelsLast") l = e[0], c = e[1], h = e[2], d = e[3], p = e[4];
  else {
    if (i !== "channelsFirst") throw new Error("Unknown dataFormat " + i);
    l = e[0], p = e[1], c = e[2], h = e[3], d = e[4];
  }
  var f, m = n[0], g = n[1], v = n[2], y = n[4], b = Os(t), x = b[0], C = b[1], N = b[2], T = Os(r), I = T[0], E = T[1], P = T[2], O = ra(m, I), R = ra(g, E), z = ra(v, P), j = function(K, J, ee, ne, ce, he, pe, ye, me, be, We) {
    var ge, Ie, Ce, ze;
    if (typeof K == "number") {
      ge = { top: K, bottom: K, left: K, right: K, front: K, back: K, type: K === 0 ? "VALID" : "NUMBER" };
      var Me = function(Br, yn, Ti, jr, an, Pi) {
        an == null && (an = $p(Br, yn, jr));
        var Cg = Br[0], kg = Br[1], Ng = Br[2], Si = Da((Cg - yn + 2 * an) / jr + 1, Pi);
        A(He(Si), function() {
          return "The output # of depths (" + Si + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var Di = Da((kg - yn + 2 * an) / jr + 1, Pi);
        A(He(Di), function() {
          return "The output # of rows (" + Di + ") must be an integer. Change the stride and/or zero pad parameters";
        });
        var Oi = Da((Ng - yn + 2 * an) / jr + 1, Pi);
        return A(He(Oi), function() {
          return "The output # of columns (" + Oi + ") must be an integer. Change the stride and/or zero pad parameters";
        }), [Si, Di, Oi, Ti];
      }([J, ee, ne, 1], ye, 1, ce, K, We);
      Ie = Me[0], Ce = Me[1], ze = Me[2];
    } else if (K === "same") {
      Ie = Math.ceil(J / ce), Ce = Math.ceil(ee / he), ze = Math.ceil(ne / pe);
      var _e = (Ie - 1) * ce + ye - J, nn = (Ce - 1) * he + me - ee, rn = (ze - 1) * pe + be - ne, Ct = Math.floor(_e / 2), _r = _e - Ct, gn = Math.floor(nn / 2), zn = nn - gn, vn = Math.floor(rn / 2);
      ge = { top: gn, bottom: zn, left: vn, right: rn - vn, front: Ct, back: _r, type: "SAME" };
    } else {
      if (K !== "valid") throw Error("Unknown padding parameter: " + K);
      ge = { top: 0, bottom: 0, left: 0, right: 0, front: 0, back: 0, type: "VALID" }, Ie = Math.ceil((J - ye + 1) / ce), Ce = Math.ceil((ee - me + 1) / he), ze = Math.ceil((ne - be + 1) / pe);
    }
    return { padInfo: ge, outDepth: Ie, outHeight: Ce, outWidth: ze };
  }(a, c, h, d, x, C, N, O, R, z, s), B = j.padInfo, H = j.outDepth, W = j.outHeight, L = j.outWidth, $ = o ? y * p : y;
  return i === "channelsFirst" ? f = [l, $, H, W, L] : i === "channelsLast" && (f = [l, H, W, L, $]), { batchSize: l, dataFormat: i, inDepth: c, inHeight: h, inWidth: d, inChannels: p, outDepth: H, outHeight: W, outWidth: L, outChannels: $, padInfo: B, strideDepth: x, strideHeight: C, strideWidth: N, filterDepth: m, filterHeight: g, filterWidth: v, effectiveFilterDepth: O, effectiveFilterHeight: R, effectiveFilterWidth: z, dilationDepth: I, dilationHeight: E, dilationWidth: P, inShape: e, outShape: f, filterShape: n };
}
function $p(e, n, t, r) {
  r === void 0 && (r = 1);
  var a = ra(n, r);
  return Math.floor((e[0] * (t - 1) - t + a) / 2);
}
function ti(e) {
  return typeof e == "number" ? [e, e, e] : e.length === 2 ? [e[0], e[1], 1] : e;
}
function Os(e) {
  return typeof e == "number" ? [e, e, e] : e;
}
function ra(e, n) {
  return n <= 1 ? e : e + (e - 1) * (n - 1);
}
function Da(e, n) {
  if (!n) return e;
  switch (n) {
    case "round":
      return Math.round(e);
    case "ceil":
      return Math.ceil(e);
    case "floor":
      return Math.floor(e);
    default:
      throw new Error("Unknown roundingMode " + n);
  }
}
function ca(e) {
  var n = ti(e), t = n[0], r = n[1], a = n[2];
  return t === 1 && r === 1 && a === 1;
}
function vt(e, n) {
  return ca(e) || ca(n);
}
function Bu(e) {
  if (e === "NHWC") return "channelsLast";
  if (e === "NCHW") return "channelsFirst";
  throw new Error("Unknown dataFormat " + e);
}
function Up(e, n, t) {
  if (n === "complex64") {
    if (e.dtype === "complex64") return e.clone();
    var r = je(e.shape), a = e.toFloat(), o = t.complex(a, r);
    return r.dispose(), a.dispose(), o;
  }
  if (!Vd(e.dtype, n)) return D.makeTensorFromDataId(e.dataId, e.shape, n);
  if (e.dtype === "complex64") {
    var i = t.real(e);
    return o = i.cast(n), i.dispose(), o;
  }
  if (n === "int32") return t.int(e);
  if (n === "bool") {
    var s = X(0, e.dtype);
    return o = t.notEqual(e, s), s.dispose(), o;
  }
  throw new Error("Error in Cast: failed to cast " + e.dtype + " to " + n);
}
function Rs(e, n) {
  return D.makeTensorFromDataId(e.dataId, n, e.dtype);
}
function Kp(e, n, t) {
  var r = (n - e) / (t - 1), a = pa(t, "float32");
  a[0] = e;
  for (var o = 1; o < a.length; o++) a[o] = a[o - 1] + r;
  return Fn(a, "float32");
}
function Fs(e, n) {
  if (e.length !== n.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + e.length + ", imag: " + n.length + ".");
  for (var t = new Float32Array(2 * e.length), r = 0; r < t.length; r += 2) t[r] = e[r / 2], t[r + 1] = n[r / 2];
  return t;
}
function Ll(e, n) {
  return { real: e[2 * n], imag: e[2 * n + 1] };
}
function Lv(e, n, t, r) {
  e[2 * r] = n, e[2 * r + 1] = t;
}
function zv(e, n, t) {
  var r = (t ? 2 : -2) * Math.PI * (e / n);
  return { real: Math.cos(r), imag: Math.sin(r) };
}
function Gv(e, n, t) {
  var r = function(o, i, s) {
    return function(u, l, c) {
      for (var h = 0, d = u.length, p = 0, f = !1; h < d; ) {
        var m = c(l, u[p = h + (d - h >>> 1)]);
        m > 0 ? h = p + 1 : (d = p, f = !m);
      }
      return f ? h : -h - 1;
    }(o, i, s || Hv);
  }(e, n, t), a = r < 0 ? -(r + 1) : r;
  e.splice(a, 0, n);
}
function Hv(e, n) {
  return e > n ? 1 : e < n ? -1 : 0;
}
function ju(e, n, t, r, a) {
  return qp(e, n, t, r, a, 0).selectedIndices;
}
function Vu(e, n, t, r, a, o) {
  var i = qp(e, n, t, r, a, o);
  return i.numValidOutputs.dispose(), { selectedIndices: i.selectedIndices, selectedScores: i.selectedScores };
}
function qp(e, n, t, r, a, o, i, s) {
  s === void 0 && (s = !1);
  for (var u = Array.from(n).map(function(x, C) {
    return { score: x, boxIndex: C, suppressBeginIndex: 0 };
  }).filter(function(x) {
    return x.score > a;
  }).sort(zl), l = o > 0 ? -0.5 / o : 0, c = [], h = []; c.length < t && u.length > 0; ) {
    var d = u.pop(), p = d.score, f = d.boxIndex, m = d.suppressBeginIndex;
    if (p < a) break;
    for (var g = !1, v = c.length - 1; v >= m; --v) {
      var y = Wv(e, f, c[v]);
      if (y >= r) {
        g = !0;
        break;
      }
      if (d.score = d.score * $v(r, l, y), d.score <= a) break;
    }
    d.suppressBeginIndex = c.length, g || (d.score === p ? (c.push(f), h.push(d.score)) : d.score > a && Gv(u, d, zl));
  }
  var b = c.length;
  return s && (c.fill(0, b), h.fill(0, b)), { selectedIndices: Fn(c, "int32"), selectedScores: Fn(h, "float32"), numValidOutputs: X(b, "int32") };
}
function Wv(e, n, t) {
  var r = e.subarray(4 * n, 4 * n + 4), a = e.subarray(4 * t, 4 * t + 4), o = Math.min(r[0], r[2]), i = Math.min(r[1], r[3]), s = Math.max(r[0], r[2]), u = Math.max(r[1], r[3]), l = Math.min(a[0], a[2]), c = Math.min(a[1], a[3]), h = Math.max(a[0], a[2]), d = Math.max(a[1], a[3]), p = (s - o) * (u - i), f = (h - l) * (d - c);
  if (p <= 0 || f <= 0) return 0;
  var m = Math.max(o, l), g = Math.max(i, c), v = Math.min(s, h), y = Math.min(u, d), b = Math.max(v - m, 0) * Math.max(y - g, 0);
  return b / (p + f - b);
}
function $v(e, n, t) {
  var r = Math.exp(n * t * t);
  return t <= e ? r : 0;
}
function zl(e, n) {
  return e.score - n.score || e.score === n.score && n.boxIndex - e.boxIndex;
}
function Jp(e, n, t) {
  var r = new Array(e.rank).fill(0), a = e.shape.slice();
  return n.map(function(o) {
    a[t] = o;
    var i = e.slice(r, a);
    return r[t] += o, i;
  });
}
function Xp(e, n) {
  for (var t = new Array(e.rank), r = 0; r < t.length; r++) t[r] = e.shape[r] * n[r];
  var a = oe(t, e.dtype);
  for (r = 0; r < a.values.length; ++r) {
    for (var o = a.indexToLoc(r), i = new Array(e.rank), s = 0; s < i.length; s++) i[s] = o[s] % e.shape[s];
    var u = e.locToIndex(i);
    a.values[r] = e.values[u];
  }
  return a.toTensor();
}
function Qp(e, n, t, r, a) {
  for (var o = n[n.length - 1], i = [e.length / o, o], s = i[0], u = i[1], l = Ar(t, s * r), c = Ar("int32", s * r), h = 0; h < s; h++) {
    for (var d = h * u, p = e.subarray(d, d + u), f = [], m = 0; m < p.length; m++) f.push({ value: p[m], index: m });
    f.sort(function(x, C) {
      return C.value - x.value;
    });
    var g = h * r, v = l.subarray(g, g + r), y = c.subarray(g, g + r);
    for (m = 0; m < r; m++) v[m] = f[m].value, y[m] = f[m].index;
  }
  var b = n.slice();
  return b[b.length - 1] = r, [rt(l, b, t), rt(c, b, "int32")];
}
function Lu(e, n) {
  for (var t = [], r = 0; r < n.length; r++) n[r] && t.push(r);
  var a = oe(e, "int32"), o = oe([t.length, e.length], "int32");
  for (r = 0; r < t.length; r++) {
    var i = a.indexToLoc(t[r]), s = r * e.length;
    o.values.set(i, s);
  }
  return o.toTensor();
}
var Uv = function(e, n) {
  this.outputShape = [], this.outputShape = e, this.variableNames = n.map(function(a, o) {
    return "T" + o;
  });
  var t = [];
  this.variableNames.forEach(function(a) {
    t.push("float v" + a + " = get" + a + "AtOutCoords();");
  });
  var r = this.variableNames.map(function(a) {
    return "v" + a;
  }).join(" + ");
  this.userCode = `
      void main() {
        ` + t.join(`
        `) + `

        float result = ` + r + `;
        setOutput(result);
      }
    `;
}, Kv = function(e, n) {
  this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.variableNames = n.map(function(a, o) {
    return "T" + o;
  });
  var t = [];
  this.variableNames.forEach(function(a) {
    t.push("vec4 v" + a + " = get" + a + "AtOutCoords();");
  });
  var r = this.variableNames.map(function(a) {
    return "v" + a;
  }).join(" + ");
  this.userCode = `
      void main() {
        ` + t.join(`
        `) + `

        vec4 result = ` + r + `;
        setOutput(result);
      }
    `;
}, qv = function(e, n, t) {
  this.variableNames = ["A"];
  var r = e.windowSize, a = e.batchSize, o = e.inSize, i = Math.ceil(o / r);
  t || this.variableNames.push("bestIndicesA"), this.outputShape = [a, i];
  var s = n === "max" ? ">" : "<", u = t ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
  this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ` + r + `;

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ` + r + `; i++) {
          int inIdx = ` + u + `;
          float candidate = getA(batch, inIdx);
          if (candidate ` + s + ` bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
};
function Yp(e, n) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, n).map(function(t) {
    return e + "." + t;
  });
}
function yt(e, n) {
  return n === 1 ? [e] : Yp(e, n);
}
function ht() {
  var e, n, t, r, a, o, i, s, u, l;
  return _().getNumber("WEBGL_VERSION") === 2 ? (e = "#version 300 es", n = "in", t = "out", r = "in", a = "texture", o = "outputColor", i = "out vec4 outputColor;", s = `
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `, u = "", l = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (e = "", n = "attribute", t = "varying", r = "varying", a = "texture2D", o = "gl_FragColor", i = "", s = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, u = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, l = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), { version: e, attribute: n, varyingVs: t, varyingFs: r, texture2D: a, output: o, defineOutput: i, defineSpecialNaN: s, defineSpecialInf: u, defineRound: l };
}
function gr(e, n, t) {
  t === void 0 && (t = "index");
  var r = bt(n);
  return r.map(function(a, o) {
    return "int " + e[o] + " = " + t + " / " + a + "; " + (o === r.length - 1 ? "int " + e[o + 1] + " = " + t + " - " + e[o] + " * " + a : "index -= " + e[o] + " * " + a) + ";";
  }).join("");
}
function zu(e) {
  var n = bt(e).map(function(t) {
    return t.toString();
  });
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ` + n[0] + " + coords.y * " + n[1] + ` + coords.z;
  }
`;
}
var Zp = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
function Jv(e, n, t, r) {
  var a = [];
  e.forEach(function(p) {
    var f = Q(p.shapeInfo.logicalShape);
    p.shapeInfo.isUniform ? a.push("uniform float " + p.name + (f > 1 ? "[" + f + "]" : "") + ";") : (a.push("uniform sampler2D " + p.name + ";"), a.push("uniform int offset" + p.name + ";"));
  });
  var o, i, s = a.join(`
`), u = e.map(function(p) {
    return function(f, m, g) {
      g === void 0 && (g = !1);
      var v = "";
      v += g ? ef(f) : Jr(f);
      var y = f.shapeInfo.logicalShape, b = m.logicalShape;
      return y.length <= b.length && (v += g ? function(x, C) {
        var N, T = x.name, I = T.charAt(0).toUpperCase() + T.slice(1), E = "get" + I + "AtOutCoords", P = x.shapeInfo.logicalShape.length, O = C.logicalShape.length, R = Kn(x.shapeInfo.logicalShape, C.logicalShape), z = De(O), j = O - P, B = ["x", "y", "z", "w", "u", "v"];
        N = P === 0 ? "" : O < 2 && R.length >= 1 ? "coords = 0;" : R.map(function(ee) {
          return "coords." + B[ee + j] + " = 0;";
        }).join(`
`);
        var H = "";
        H = O < 2 && P > 0 ? "coords" : x.shapeInfo.logicalShape.map(function(ee, ne) {
          return "coords." + B[ne + j];
        }).join(", ");
        var W = "return outputValue;", L = Q(x.shapeInfo.logicalShape) === 1, $ = Q(C.logicalShape) === 1;
        if (P !== 1 || L || $) {
          if (L && !$) W = O === 1 ? `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : `
        return vec4(outputValue.x);
      `;
          else if (R.length) {
            var K = P - 2, J = P - 1;
            R.indexOf(K) > -1 && R.indexOf(J) > -1 ? W = "return vec4(outputValue.x);" : R.indexOf(K) > -1 ? W = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : R.indexOf(J) > -1 && (W = "return vec4(outputValue.xx, outputValue.zz);");
          }
        } else W = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
        return `
    vec4 ` + E + `() {
      ` + z + ` coords = getOutputCoords();
      ` + N + `
      vec4 outputValue = get` + I + "(" + H + `);
      ` + W + `
    }
  `;
      }(f, m) : function(x, C) {
        var N = x.name, T = N.charAt(0).toUpperCase() + N.slice(1), I = "get" + T + "AtOutCoords", E = C.texShape, P = x.shapeInfo.texShape, O = x.shapeInfo.logicalShape.length, R = C.logicalShape.length;
        if (!x.shapeInfo.isUniform && O === R && x.shapeInfo.flatOffset == null && Ye(P, E)) return `
      float ` + I + `() {
        return sampleTexture(` + N + `, resultUV);
      }
    `;
        var z, j = De(R), B = Kn(x.shapeInfo.logicalShape, C.logicalShape), H = R - O, W = ["x", "y", "z", "w", "u", "v"];
        z = O === 0 ? "" : R < 2 && B.length >= 1 ? "coords = 0;" : B.map(function($) {
          return "coords." + W[$ + H] + " = 0;";
        }).join(`
`);
        var L = "";
        return L = R < 2 && O > 0 ? "coords" : x.shapeInfo.logicalShape.map(function($, K) {
          return "coords." + W[K + H];
        }).join(", "), `
    float ` + I + `() {
      ` + j + ` coords = getOutputCoords();
      ` + z + `
      return get` + T + "(" + L + `);
    }
  `;
      }(f, m)), v;
    }(p, n, r);
  }).join(`
`), l = n.texShape, c = ht(), h = function(p) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ` + p.texture2D + `(textureSampler, uv).r;
    }
  `;
  }(c), d = function(p) {
    return p.version + `
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ` + p.varyingFs + ` vec2 resultUV;
    ` + p.defineOutput + `
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ` + p.defineSpecialNaN + `
    ` + p.defineSpecialInf + `
    ` + p.defineRound + `

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ` + Xv + `
    ` + Qv + `
    ` + Yv + `
  `;
  }(c);
  return n.isPacked ? (o = function(p, f) {
    switch (p.length) {
      case 0:
        return `
    int getOutputCoords() {
      return 0;
    }
  `;
      case 1:
        return function(x, C) {
          var N = [Math.ceil(C[0] / 2), Math.ceil(C[1] / 2)];
          return N[0] === 1 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ` + N[1] + `.0);
      }
    ` : N[1] === 1 ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ` + N[0] + `.0);
      }
    ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + N[0] + ", " + N[1] + `));
      return 2 * (resTexRC.x * ` + N[1] + ` + resTexRC.y);
    }
  `;
        }(0, f);
      case 2:
        return function(x, C) {
          var N = [Math.ceil(C[0] / 2), Math.ceil(C[1] / 2)];
          if (Ye(x, C)) return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(` + N[0] + ", " + N[1] + `));
      }
    `;
          var T = Math.ceil(x[1] / 2);
          return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + N[0] + ", " + N[1] + `));

      int index = resTexRC.x * ` + N[1] + ` + resTexRC.y;
      int r = 2 * (index / ` + T + `);
      int c = imod(index, ` + T + `) * 2;

      return ivec2(r, c);
    }
  `;
        }(p, f);
      case 3:
        return m = p, g = f, v = [Math.ceil(g[0] / 2), Math.ceil(g[1] / 2)], y = Math.ceil(m[2] / 2), b = y * Math.ceil(m[1] / 2), `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + v[0] + ", " + v[1] + `));
      int index = resTexRC.x * ` + v[1] + ` + resTexRC.y;

      int b = index / ` + b + `;
      index -= b * ` + b + `;

      int r = 2 * (index / ` + y + `);
      int c = imod(index, ` + y + `) * 2;

      return ivec3(b, r, c);
    }
  `;
      default:
        return function(x, C) {
          for (var N = [Math.ceil(C[0] / 2), Math.ceil(C[1] / 2)], T = Math.ceil(x[x.length - 1] / 2), I = T * Math.ceil(x[x.length - 2] / 2), E = I, P = "", O = "b, r, c", R = 2; R < x.length - 1; R++) E *= x[x.length - R - 1], P = `
      int b` + R + " = index / " + E + `;
      index -= b` + R + " * " + E + `;
    ` + P, O = "b" + R + ", " + O;
          return `
    ivec` + x.length + ` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + N[0] + ", " + N[1] + `));
      int index = resTexRC.x * ` + N[1] + ` + resTexRC.y;

      ` + P + `

      int b = index / ` + I + `;
      index -= b * ` + I + `;

      int r = 2 * (index / ` + T + `);
      int c = imod(index, ` + T + `) * 2;

      return ivec` + x.length + "(" + O + `);
    }
  `;
        }(p, f);
    }
    var m, g, v, y, b;
  }(n.logicalShape, l), i = function(p) {
    return `
    void setOutput(vec4 val) {
      ` + p.output + ` = val;
    }
  `;
  }(c)) : (o = function(p, f) {
    switch (p.length) {
      case 0:
        return `
    int getOutputCoords() {
      return 0;
    }
  `;
      case 1:
        return function(v, y) {
          return y[0] === 1 ? `
      int getOutputCoords() {
        return int(resultUV.x * ` + y[1] + `.0);
      }
    ` : y[1] === 1 ? `
      int getOutputCoords() {
        return int(resultUV.y * ` + y[0] + `.0);
      }
    ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + y[0] + ", " + y[1] + `));
      return resTexRC.x * ` + y[1] + ` + resTexRC.y;
    }
  `;
        }(0, f);
      case 2:
        return function(v, y) {
          return Ye(v, y) ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(` + y[0] + ", " + y[1] + `));
      }
    ` : v[1] === 1 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(` + y[0] + ", " + y[1] + `));
        int index = resTexRC.x * ` + y[1] + ` + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : v[0] === 1 ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(` + y[0] + ", " + y[1] + `));
        int index = resTexRC.x * ` + y[1] + ` + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + y[0] + ", " + y[1] + `));
      int index = resTexRC.x * ` + y[1] + ` + resTexRC.y;
      int r = index / ` + v[1] + `;
      int c = index - r * ` + v[1] + `;
      return ivec2(r, c);
    }
  `;
        }(p, f);
      case 3:
        return m = f, g = gr(["r", "c", "d"], p), `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(` + m[0] + ", " + m[1] + `));
      int index = resTexRC.x * ` + m[1] + ` + resTexRC.y;
      ` + g + `
      return ivec3(r, c, d);
    }
  `;
      case 4:
        return function(v, y) {
          var b = gr(["r", "c", "d", "d2"], v);
          return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(` + y[0] + ", " + y[1] + `));
      int index = resTexRC.x * ` + y[1] + ` + resTexRC.y;
      ` + b + `
      return ivec4(r, c, d, d2);
    }
  `;
        }(p, f);
      case 5:
        return function(v, y) {
          var b = gr(["r", "c", "d", "d2", "d3"], v);
          return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(` + y[0] + `,
                             ` + y[1] + `));

      int index = resTexRC.x * ` + y[1] + ` + resTexRC.y;

      ` + b + `

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
        }(p, f);
      case 6:
        return function(v, y) {
          var b = gr(["r", "c", "d", "d2", "d3", "d4"], v);
          return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(` + y[0] + ", " + y[1] + `));
      int index = resTexRC.x * ` + y[1] + ` + resTexRC.y;

      ` + b + `

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
        }(p, f);
      default:
        throw new Error(p.length + "-D output sampling is not yet supported");
    }
    var m, g;
  }(n.logicalShape, l), i = function(p) {
    return `
    void setOutput(float val) {
      ` + p.output + ` = vec4(val, 0, 0, 0);
    }
  `;
  }(c)), r && (d += Zv), [d, h, i, s, o, u, t].join(`
`);
}
function Jr(e) {
  var n = e.shapeInfo.logicalShape;
  switch (n.length) {
    case 0:
      return function(t) {
        var r = t.name, a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
        if (t.shapeInfo.isUniform) return "float " + a + "() {return " + r + ";}";
        var o = t.shapeInfo.texShape, i = o[0], s = o[1];
        if (i === 1 && s === 1) return `
      float ` + a + `() {
        return sampleTexture(` + r + `, halfCR);
      }
    `;
        var u = t.shapeInfo.texShape, l = u[0], c = u[1], h = sr(r);
        return `
    float ` + a + `() {
      vec2 uv = uvFromFlat(` + l + ", " + c + ", " + h + `);
      return sampleTexture(` + r + `, uv);
    }
  `;
      }(e);
    case 1:
      return function(t) {
        var r = t.name, a = "get" + r.charAt(0).toUpperCase() + r.slice(1);
        if (t.shapeInfo.isUniform) return `
      float ` + a + `(int index) {
        ` + Vr(t) + `
      }
    `;
        var o = t.shapeInfo.texShape, i = o[0], s = o[1];
        if (s === 1 && i === 1) return `
      float ` + a + `(int index) {
        return sampleTexture(` + r + `, halfCR);
      }
    `;
        var u = sr(r);
        return s === 1 ? `
      float ` + a + `(int index) {
        vec2 uv = vec2(0.5, (float(index + ` + u + ") + 0.5) / " + i + `.0);
        return sampleTexture(` + r + `, uv);
      }
    ` : i === 1 ? `
      float ` + a + `(int index) {
        vec2 uv = vec2((float(index + ` + u + ") + 0.5) / " + s + `.0, 0.5);
        return sampleTexture(` + r + `, uv);
      }
    ` : `
    float ` + a + `(int index) {
      vec2 uv = uvFromFlat(` + i + ", " + s + ", index + " + u + `);
      return sampleTexture(` + r + `, uv);
    }
  `;
      }(e);
    case 2:
      return function(t) {
        var r = t.shapeInfo.logicalShape, a = t.name, o = "get" + a.charAt(0).toUpperCase() + a.slice(1), i = t.shapeInfo.texShape;
        if (i != null && Ye(r, i)) {
          var s = i[0], u = i[1];
          return `
    float ` + o + `(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(` + u + ".0, " + s + `.0);
      return sampleTexture(` + a + `, uv);
    }
  `;
        }
        var l = Un(r), c = l.newShape, h = l.keptDims, d = c;
        if (d.length < r.length) {
          var p = Xr(t, d);
          return `
      ` + Jr(p) + `
      float ` + o + `(int row, int col) {
        return ` + o + "(" + Qr(["row", "col"], h) + `);
      }
    `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + o + `(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(` + r[1] + `, 1)));
        ` + Vr(t) + `
      }
    `;
        var f = i[0], m = i[1], g = sr(a);
        return m === 1 ? `
    float ` + o + `(int row, int col) {
      float index = dot(vec3(row, col, ` + g + "), vec3(" + r[1] + `, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ` + f + `.0);
      return sampleTexture(` + a + `, uv);
    }
  ` : f === 1 ? `
    float ` + o + `(int row, int col) {
      float index = dot(vec3(row, col, ` + g + "), vec3(" + r[1] + `, 1, 1));
      vec2 uv = vec2((index + 0.5) / ` + m + `.0, 0.5);
      return sampleTexture(` + a + `, uv);
    }
  ` : `
  float ` + o + `(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ` + r[1] + " + col + " + g + `;
    vec2 uv = uvFromFlat(` + f + ", " + m + `, index);
    return sampleTexture(` + a + `, uv);
  }
`;
      }(e);
    case 3:
      return function(t) {
        var r = t.shapeInfo.logicalShape, a = t.name, o = "get" + a.charAt(0).toUpperCase() + a.slice(1), i = r[1] * r[2], s = r[2], u = Un(r), l = u.newShape, c = u.keptDims, h = l;
        if (h.length < r.length) {
          var d = Xr(t, h);
          return `
        ` + Jr(d) + `
        float ` + o + `(int row, int col, int depth) {
          return ` + o + "(" + Qr(["row", "col", "depth"], c) + `);
        }
      `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + o + `(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(` + i + ", " + s + `, 1)));
        ` + Vr(t) + `
      }
    `;
        var p = t.shapeInfo.texShape, f = p[0], m = p[1], g = t.shapeInfo.flatOffset;
        if (m === i && g == null) return `
        float ` + o + `(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(` + s + `, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(` + m + ".0, " + f + `.0);
          return sampleTexture(` + a + `, uv);
        }
      `;
        if (m === s && g == null) return `
    float ` + o + `(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(` + r[1] + `, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(` + m + ".0, " + f + `.0);
      return sampleTexture(` + a + `, uv);
    }
  `;
        var v = sr(a);
        return `
      float ` + o + `(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ` + i + " + col * " + s + " + depth + " + v + `;
        vec2 uv = uvFromFlat(` + f + ", " + m + `, index);
        return sampleTexture(` + a + `, uv);
      }
  `;
      }(e);
    case 4:
      return function(t) {
        var r = t.shapeInfo.logicalShape, a = t.name, o = "get" + a.charAt(0).toUpperCase() + a.slice(1), i = r[3], s = r[2] * i, u = r[1] * s, l = Un(r), c = l.newShape, h = l.keptDims;
        if (c.length < r.length) {
          var d = Xr(t, c);
          return `
      ` + Jr(d) + `
      float ` + o + `(int row, int col, int depth, int depth2) {
        return ` + o + "(" + Qr(["row", "col", "depth", "depth2"], h) + `);
      }
    `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + o + `(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(` + u + ", " + s + ", " + i + `, 1)));
        ` + Vr(t) + `
      }
    `;
        var p = t.shapeInfo.flatOffset, f = t.shapeInfo.texShape, m = f[0], g = f[1];
        if (g === u && p == null) return `
      float ` + o + `(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(` + s + ", " + i + `, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(` + g + ".0, " + m + `.0);
        return sampleTexture(` + a + `, uv);
      }
    `;
        if (g === i && p == null) return `
      float ` + o + `(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(` + r[1] * r[2] + ", " + r[2] + `, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(` + g + ".0, " + m + `.0);
        return sampleTexture(` + a + `, uv);
      }
    `;
        var v = sr(a);
        return `
    float ` + o + `(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ` + u + " + col * " + s + ` +
          depth * ` + i + ` + depth2;
      vec2 uv = uvFromFlat(` + m + ", " + g + ", index + " + v + `);
      return sampleTexture(` + a + `, uv);
    }
  `;
      }(e);
    case 5:
      return function(t) {
        var r = t.shapeInfo.logicalShape, a = t.name, o = "get" + a.charAt(0).toUpperCase() + a.slice(1), i = r[4], s = r[3] * i, u = r[2] * s, l = r[1] * u, c = Un(r), h = c.newShape, d = c.keptDims;
        if (h.length < r.length) {
          var p = Xr(t, h);
          return `
      ` + Jr(p) + `
      float ` + o + `(int row, int col, int depth, int depth2, int depth3) {
        return ` + o + "(" + Qr(["row", "col", "depth", "depth2", "depth3"], d) + `);
      }
    `;
        }
        if (t.shapeInfo.isUniform) return `
      float ` + o + `(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(` + l + ", " + u + ", " + s + ", " + i + `)) +
          depth3;
        ` + Vr(t) + `
      }
    `;
        var f = t.shapeInfo.flatOffset, m = t.shapeInfo.texShape, g = m[0], v = m[1];
        if (v === l && f == null) return `
      float ` + o + `(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(` + u + ", " + s + ", " + i + `, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(` + v + ".0, " + g + `.0);
        return sampleTexture(` + a + `, uv);
      }
    `;
        if (v === i && f == null) return `
      float ` + o + `(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(` + r[1] * r[2] * r[3] + `,
               ` + r[2] * r[3] + ", " + r[3] + `, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(` + v + ".0, " + g + `.0);
        return sampleTexture(` + a + `, uv);
      }
    `;
        var y = sr(a);
        return `
    float ` + o + `(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ` + l + " + col * " + u + " + depth * " + s + ` +
          depth2 * ` + i + " + depth3 + " + y + `;
      vec2 uv = uvFromFlat(` + g + ", " + v + `, index);
      return sampleTexture(` + a + `, uv);
    }
  `;
      }(e);
    case 6:
      return function(t) {
        var r = t.shapeInfo.logicalShape, a = t.name, o = "get" + a.charAt(0).toUpperCase() + a.slice(1), i = Un(r), s = i.newShape, u = i.keptDims;
        if (s.length < r.length) {
          var l = Xr(t, s);
          return `
      ` + Jr(l) + `
      float ` + o + `(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ` + o + "(" + Qr(["row", "col", "depth", "depth2", "depth3", "depth4"], u) + `);
      }
    `;
        }
        var c = r[5], h = r[4] * c, d = r[3] * h, p = r[2] * d, f = r[1] * p;
        if (t.shapeInfo.isUniform) return `
      float ` + o + `(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(` + f + ", " + p + ", " + d + ", " + h + `)) +
          dot(
            vec2(depth3, depth4),
            vec2(` + c + `, 1)));
        ` + Vr(t) + `
      }
    `;
        var m = t.shapeInfo.flatOffset, g = t.shapeInfo.texShape, v = g[0], y = g[1];
        if (y === f && m == null) return `
      float ` + o + `(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(` + p + ", " + d + ", " + h + ", " + c + `)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(` + y + ".0, " + v + `.0);
        return sampleTexture(` + a + `, uv);
      }
    `;
        if (y === c && m == null) return `
      float ` + o + `(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(` + r[1] * r[2] * r[3] * r[4] + `,
               ` + r[2] * r[3] * r[4] + `,
               ` + r[3] * r[4] + `,
               ` + r[4] + `)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(` + y + ".0, " + v + `.0);
        return sampleTexture(` + a + `, uv);
      }
    `;
        var b = sr(a);
        return `
    float ` + o + `(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ` + f + " + col * " + p + " + depth * " + d + ` +
          depth2 * ` + h + " + depth3 * " + c + " + depth4 + " + b + `;
      vec2 uv = uvFromFlat(` + v + ", " + y + `, index);
      return sampleTexture(` + a + `, uv);
    }
  `;
      }(e);
    default:
      throw new Error(n.length + "-D input sampling is not yet supported");
  }
}
function ef(e) {
  var n, t, r;
  switch (e.shapeInfo.logicalShape.length) {
    case 0:
      return n = e.name, t = "get" + n.charAt(0).toUpperCase() + n.slice(1), r = ht(), `
    vec4 ` + t + `() {
      return ` + r.texture2D + "(" + n + `, halfCR);
    }
  `;
    case 1:
      return function(a) {
        var o = a.name, i = "get" + o.charAt(0).toUpperCase() + o.slice(1), s = a.shapeInfo.texShape, u = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)], l = ht();
        return `
    vec4 ` + i + `(int index) {
      vec2 uv = packedUVfrom1D(
        ` + u[0] + ", " + u[1] + `, index);
      return ` + l.texture2D + "(" + o + `, uv);
    }
  `;
      }(e);
    case 2:
      return function(a) {
        var o = a.shapeInfo.logicalShape, i = a.name, s = "get" + i.charAt(0).toUpperCase() + i.slice(1), u = a.shapeInfo.texShape, l = u[0], c = u[1], h = ht();
        if (u != null && Ye(o, u)) return `
      vec4 ` + s + `(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(` + c + ".0, " + l + `.0);

        return ` + h.texture2D + "(" + i + `, uv);
      }
    `;
        var d = [Math.ceil(u[0] / 2), Math.ceil(u[1] / 2)], p = Math.ceil(o[1] / 2);
        return `
    vec4 ` + s + `(int row, int col) {
      vec2 uv = packedUVfrom2D(` + p + ", " + d[0] + ", " + d[1] + `, row, col);
      return ` + h.texture2D + "(" + i + `, uv);
    }
  `;
      }(e);
    case 3:
      return function(a) {
        var o = a.shapeInfo.logicalShape, i = a.name, s = "get" + i.charAt(0).toUpperCase() + i.slice(1), u = a.shapeInfo.texShape, l = [Math.ceil(u[0] / 2), Math.ceil(u[1] / 2)];
        if (o[0] === 1) {
          var c = o.slice(1), h = Xr(a, c);
          return `
        ` + ef(h) + `
        vec4 ` + s + `(int b, int row, int col) {
          return ` + s + "(" + Qr(["b", "row", "col"], [1, 2]) + `);
        }
      `;
        }
        var d = l[0], p = l[1], f = Math.ceil(o[2] / 2), m = f * Math.ceil(o[1] / 2), g = ht();
        return `
    vec4 ` + s + `(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ` + d + ", " + p + ", " + m + ", " + f + `, b, row, col);
      return ` + g.texture2D + "(" + i + `, uv);
    }
  `;
      }(e);
    default:
      return function(a) {
        for (var o = a.shapeInfo.logicalShape, i = o.length, s = a.name, u = "get" + s.charAt(0).toUpperCase() + s.slice(1), l = a.shapeInfo.texShape, c = [Math.ceil(l[0] / 2), Math.ceil(l[1] / 2)], h = c[0], d = c[1], p = Math.ceil(o[i - 1] / 2), f = p * Math.ceil(o[i - 2] / 2), m = "int b, int row, int col", g = "b * " + f + " + (row / 2) * " + p + " + (col / 2)", v = 2; v < i - 1; v++) m = "int b" + v + ", " + m, f *= o[i - v - 1], g = "b" + v + " * " + f + " + " + g;
        var y = ht();
        return `
    vec4 ` + u + "(" + m + `) {
      int index = ` + g + `;
      int texR = index / ` + d + `;
      int texC = index - texR * ` + d + `;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(` + d + ", " + h + `);
      return ` + y.texture2D + "(" + s + `, uv);
    }
  `;
      }(e);
  }
}
var Xv = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Qv = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Yv = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, Zv = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
function sr(e) {
  return "offset" + e;
}
function Vr(e) {
  var n = e.name, t = Q(e.shapeInfo.logicalShape);
  return t < 2 ? "return " + n + ";" : `
    for (int i = 0; i < ` + t + `; i++) {
      if (i == index) {
        return ` + n + `[i];
      }
    }
  `;
}
function De(e) {
  if (e <= 1) return "int";
  if (e === 2) return "ivec2";
  if (e === 3) return "ivec3";
  if (e === 4) return "ivec4";
  if (e === 5) return "ivec5";
  if (e === 6) return "ivec6";
  throw Error("GPU for rank " + e + " is not yet supported");
}
function Xr(e, n) {
  var t = JSON.parse(JSON.stringify(e));
  return t.shapeInfo.logicalShape = n, t;
}
function Qr(e, n) {
  return n.map(function(t) {
    return e[t];
  }).join(", ");
}
var e0 = function(e, n, t, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, A(e.length > 2, function() {
    return "Packed arg" + (t.charAt(0).toUpperCase() + t.slice(1)) + " supports only inputs with rank above 2.";
  });
  var a = e[e.length - 1], o = Math.ceil(a / n);
  this.outputShape = e.slice(0, -1), o > 1 && this.outputShape.push(o), r || this.variableNames.push("bestIndicesA");
  var i, s, u = this.outputShape, l = u.length, c = De(l), h = yt("coords", l);
  if (o === 1) {
    var d = De(s = l + 1);
    i = `
        ` + d + " sourceLocR = " + d + "(" + h.join() + `, 0);
        ++` + h[l - 1] + `;
        ` + d + " sourceLocG = " + d + "(" + h.join() + `, 0);
        ++` + h[l - 2] + `;
        ` + d + " sourceLocA = " + d + "(" + h.join() + `, 0);
        --` + h[l - 1] + `;
        ` + d + " sourceLocB = " + d + "(" + h.join() + `, 0);
        --` + h[l - 2] + ";";
  } else s = l, i = `
        ` + c + ` sourceLocR = coords;
        ++` + h[l - 1] + `;
        ` + c + ` sourceLocG = coords;
        ++` + h[l - 2] + `;
        ` + c + ` sourceLocA = coords;
        --` + h[l - 1] + `;
        ` + c + ` sourceLocB = coords;
        --` + h[l - 2] + ";";
  var p = ["x", "y", "z", "w", "u", "v"].slice(0, s), f = "." + p[s - 1], m = p.map(function(I) {
    return "int " + I;
  }), g = yt("sourceLocR", s - 1).concat("inIdx.r"), v = yt("sourceLocG", s - 1).concat("inIdx.g"), y = yt("sourceLocB", s - 1).concat("inIdx.b"), b = yt("sourceLocA", s - 1).concat("inIdx.a"), x = t === "max" ? "greaterThan" : "lessThan", C = r ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(` + g.join() + `),
                             getBestIndicesAChannel(` + v.join() + `),
                             getBestIndicesAChannel(` + y.join() + `),
                             getBestIndicesAChannel(` + b.join() + ")));", N = `vec4(
            getAChannel(` + g.join() + `),
            hasNextCol ? getAChannel(` + v.join() + `) : 0.,
            hasNextRow ? getAChannel(` + y.join() + `) : 0.,
            hasNextRow && hasNextCol ? getAChannel(` + b.join() + ") : 0.)", T = r ? "" : `
      float getBestIndicesAChannel(` + m.join() + `) {
        return getChannel(getBestIndicesA(` + p.join() + `),
                                          vec2(` + p.slice(-2).join() + `));
      }`;
  this.userCode = `
      float getAChannel(` + m.join() + `) {
        return getChannel(getA(` + p.join() + `),
                               vec2(` + p.slice(-2).join() + `));
      }
      ` + T + `
      void main() {
        ` + c + ` coords = getOutputCoords();
        bool hasNextCol = ` + h[l - 1] + " < " + (u[l - 1] - 1) + `;
        bool hasNextRow = ` + h[l - 2] + " < " + (u[l - 2] - 1) + `;
        ` + i + `
        ivec4 srcIdx = ivec4(sourceLocR` + f + ", sourceLocG" + f + `,
          sourceLocB` + f + ", sourceLocA" + f + ") * " + n + `;
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ` + N + `;

        for (int i = 0; i < ` + n + `; i++) {
          inIdx = srcIdx;
          ` + C + `
          vec4 candidate = ` + N + `;
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(` + x + `(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
}, t0 = function(e) {
  this.variableNames = ["dy"], this.outputShape = e.inShape;
  var n = e.filterHeight, t = e.filterWidth, r = e.strideHeight, a = e.strideWidth, o = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, l = s - 1 - e.padInfo.top, c = u - 1 - e.padInfo.left, h = 1 / (n * t);
  this.userCode = `
      const ivec2 pads = ivec2(` + l + ", " + c + `);
      const float avgMultiplier = float(` + h + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + s + `;
            wR += ` + o + `) {
          float dyR = float(dyRCorner + wR) / ` + r + `.0;

          if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ` + u + `;
            wC+= ` + i + `) {
            float dyC = float(dyCCorner + wC) / ` + a + `.0;

            if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
}, n0 = function(e) {
  this.variableNames = ["dy"], this.outputShape = e.inShape;
  var n = e.filterDepth, t = e.filterHeight, r = e.filterWidth, a = e.strideDepth, o = e.strideHeight, i = e.strideWidth, s = e.dilationDepth, u = e.dilationHeight, l = e.dilationWidth, c = e.effectiveFilterDepth, h = e.effectiveFilterHeight, d = e.effectiveFilterWidth, p = c - 1 - e.padInfo.front, f = h - 1 - e.padInfo.top, m = d - 1 - e.padInfo.left, g = 1 / (n * t * r);
  this.userCode = `
      const ivec3 pads = ivec3(` + p + ", " + f + ", " + m + `);
      const float avgMultiplier = float(` + g + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ` + c + `;
            wD += ` + s + `) {
          float dyD = float(dyDCorner + wD) / ` + a + `.0;

          if (dyD < 0.0 || dyD >= ` + e.outDepth + `.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ` + h + `;
              wR += ` + u + `) {
            float dyR = float(dyRCorner + wR) / ` + o + `.0;

            if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ` + d + `;
                wC += ` + l + `) {
              float dyC = float(dyCCorner + wC) / ` + i + `.0;

              if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, r0 = function(e, n, t, r, a, o) {
  this.outputShape = [], this.variableNames = ["x", "mean", "variance"], fe(e, n), fe(e, t);
  var i = "0.0";
  r != null && (fe(e, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var s = "1.0";
  a != null && (fe(e, a), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ` + i + `;
        float scale = ` + s + `;
        float inv = scale * inversesqrt(variance + float(` + o + `));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
}, a0 = function(e, n, t, r, a, o) {
  this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], fe(e, n), fe(e, t);
  var i = "vec4(0.0)";
  r != null && (fe(e, r), this.variableNames.push("offset"), i = "getOffsetAtOutCoords()");
  var s = "vec4(1.0)";
  a != null && (fe(e, a), this.variableNames.push("scale"), s = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        vec4 offset = ` + i + `;
        vec4 scale = ` + s + `;

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(` + o + `));

        setOutput((x - mean) * inv + offset);
      }
    `;
}, o0 = "return areal * breal - aimag * bimag;", i0 = "return areal * bimag + aimag * breal;", Gl = function(e, n, t) {
  this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = fe(n, t), this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ` + e + `
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
}, Hi = "return a + b;", Wi = "return a - b;", Hl = "return a * b;", s0 = `
if (a == b) {
  return 1.0;
};
return a / b;`, tf = "return (a < 0.) ? b * a : a;", Ge = function(e, n, t) {
  this.variableNames = ["A", "B"], this.outputShape = fe(n, t), this.userCode = `
      float binaryOperation(float a, float b) {
        ` + e + `
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
}, u0 = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, nf = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`, sn = function(e, n, t, r) {
  r === void 0 && (r = !1), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = fe(n, t);
  var a = this.outputShape.length, o = "";
  if (r) if (a === 0 || Q(this.outputShape) === 1) o = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
  else if (o = `
          ` + De(a) + ` coords = getOutputCoords();
        `, a === 1) o += `
            result.y = (coords + 1) >= ` + this.outputShape[0] + ` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
  else {
    var i = yt("coords", a);
    o += `
            bool nextRowOutOfBounds =
              (` + i[a - 2] + " + 1) >= " + this.outputShape[a - 2] + `;
            bool nextColOutOfBounds =
              (` + i[a - 1] + " + 1) >= " + this.outputShape[a - 1] + `;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
  }
  this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ` + e + `
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ` + o + `

        setOutput(result);
      }
    `;
}, l0 = function() {
  function e(n) {
    this.variableNames = ["A"], this.outputShape = n, this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
  return e.prototype.getCustomSetupFunc = function(n, t) {
    var r = this;
    return function(a, o) {
      r.minLoc == null && (r.minLoc = a.getUniformLocationNoThrow(o, "minVal"), r.maxLoc = a.getUniformLocationNoThrow(o, "maxVal")), a.gl.uniform1f(r.minLoc, n), a.gl.uniform1f(r.maxLoc, t);
    };
  }, e;
}(), c0 = function() {
  function e(n) {
    this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n, this.userCode = `
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
  return e.prototype.getCustomSetupFunc = function(n, t) {
    var r = this;
    return function(a, o) {
      r.minLoc == null && (r.minLoc = a.getUniformLocationNoThrow(o, "minVal"), r.maxLoc = a.getUniformLocationNoThrow(o, "maxVal")), a.gl.uniform1f(r.minLoc, n), a.gl.uniform1f(r.maxLoc, t);
    };
  }, e;
}(), h0 = function(e) {
  this.variableNames = ["real", "imag"], this.outputShape = e, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
}, d0 = function(e) {
  this.outputShape = [], this.outputShape = la(e, 1), this.variableNames = e.map(function(s, u) {
    return "T" + u;
  });
  var n = new Array(e.length - 1);
  n[0] = e[0][1];
  for (var t = 1; t < n.length; t++) n[t] = n[t - 1] + e[t][1];
  var r = ["if (yC < " + n[0] + ") setOutput(getT0(yR, yC));"];
  for (t = 1; t < n.length; t++) {
    var a = n[t - 1];
    r.push("else if (yC < " + n[t] + ") setOutput(getT" + t + "(yR, yC-" + a + "));");
  }
  var o = n.length, i = n[n.length - 1];
  r.push("else setOutput(getT" + o + "(yR, yC-" + i + "));"), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ` + r.join(`
        `) + `
      }
    `;
}, p0 = function(e, n) {
  this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = la(e, n);
  var t = this.outputShape, r = t.length, a = De(r), o = yt("coords", r), i = ["x", "y", "z", "w", "u", "v"].slice(0, r);
  this.variableNames = e.map(function(g, v) {
    return "T" + v;
  });
  var s = new Array(e.length - 1);
  s[0] = e[0][n];
  for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + e[u][n];
  var l = i[n], c = i.slice(-2), h = i.join(), d = "if (" + l + " < " + s[0] + `) {
        return getChannel(
            getT0(` + h + "), vec2(" + c.join() + `));
        }`;
  for (u = 1; u < s.length; u++) {
    var p = s[u - 1];
    d += `
        if (` + l + " < " + s[u] + "  && " + l + " >= " + s[u - 1] + `) {
          return getChannel(
            getT` + u + "(" + so(i, l, p) + `),
            vec2(` + so(c, l, p) + `));
        }`;
  }
  var f = s.length, m = s[s.length - 1];
  d += `
        return getChannel(
          getT` + f + "(" + so(i, l, m) + `),
          vec2(` + so(c, l, m) + "));", this.userCode = `
      float getValue(` + i.map(function(g) {
    return "int " + g;
  }) + `) {
        ` + d + `
      }

      void main() {
        ` + a + ` coords = getOutputCoords();
        vec4 result = vec4(getValue(` + o + `), 0., 0., 0.);

        ` + o[r - 1] + " = " + o[r - 1] + ` + 1;
        if (` + o[r - 1] + " < " + t[r - 1] + `) {
          result.g = getValue(` + o + `);
        }

        ` + o[r - 2] + " = " + o[r - 2] + ` + 1;
        if (` + o[r - 2] + " < " + t[r - 2] + `) {
          result.a = getValue(` + o + `);
        }

        ` + o[r - 1] + " = " + o[r - 1] + ` - 1;
        if (` + o[r - 2] + " < " + t[r - 2] + ` &&
            ` + o[r - 1] + " < " + t[r - 1] + `) {
          result.b = getValue(` + o + `);
        }
        setOutput(result);
      }
    `;
};
function so(e, n, t) {
  var r = e.indexOf(n);
  return e.map(function(a, o) {
    return o === r ? a + " - " + t : a;
  }).join();
}
var f0 = function(e) {
  this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
  var n = e.strideHeight, t = e.strideWidth, r = e.padInfo.top, a = e.padInfo.left, o = e.dataFormat === "channelsLast";
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ` + e.batchSize + `; b++) {
          for (int yR = 0; yR < ` + e.outHeight + `; yR++) {
            int xR = wR + yR * ` + n + " - " + r + `;

            if (xR < 0 || xR >= ` + e.inHeight + `) {
              continue;
            }

            for (int yC = 0; yC < ` + e.outWidth + `; yC++) {
              int xC = wC + yC * ` + t + " - " + a + `;

              if (xC < 0 || xC >= ` + e.inWidth + `) {
                continue;
              }

              if (` + o + `) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, m0 = function(e) {
  this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
  var n = e.filterHeight, t = e.filterWidth, r = e.strideHeight, a = e.strideWidth, o = e.dataFormat === "channelsLast", i = n - 1 - e.padInfo.top, s = t - 1 - e.padInfo.left, u = o ? 1 : 2, l = o ? 2 : 3, c = o ? 3 : 1;
  this.userCode = `
      const ivec2 pads = ivec2(` + i + ", " + s + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[` + c + `];

        ivec2 dyCorner = ivec2(coords[` + u + "], coords[" + l + `]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + n + `; wR++) {
          float dyR = float(dyRCorner + wR) / ` + r + `.0;

          if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ` + n + ` - 1 - wR;

          for (int wC = 0; wC < ` + t + `; wC++) {
            float dyC = float(dyCCorner + wC) / ` + a + `.0;

            if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ` + t + ` - 1 - wC;

            for (int d2 = 0; d2 < ` + e.outChannels + `; d2++) {

              if (` + o + `) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, g0 = function(e) {
  this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
  var n = e.strideDepth, t = e.strideHeight, r = e.strideWidth, a = e.padInfo.front, o = e.padInfo.top, i = e.padInfo.left;
  this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ` + e.batchSize + `; b++) {
          for (int yF = 0; yF < ` + e.outDepth + `; yF++) {
            int xF = wF + yF * ` + n + " - " + a + `;

            if (xF < 0 || xF >= ` + e.inDepth + `) {
              continue;
            }

            for (int yR = 0; yR < ` + e.outHeight + `; yR++) {
              int xR = wR + yR * ` + t + " - " + o + `;

              if (xR < 0 || xR >= ` + e.inHeight + `) {
                continue;
              }

              for (int yC = 0; yC < ` + e.outWidth + `; yC++) {
                int xC = wC + yC * ` + r + " - " + i + `;

                if (xC < 0 || xC >= ` + e.inWidth + `) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, v0 = function(e) {
  this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
  var n = e.filterDepth, t = e.filterHeight, r = e.filterWidth, a = e.strideDepth, o = e.strideHeight, i = e.strideWidth, s = n - 1 - e.padInfo.front, u = t - 1 - e.padInfo.top, l = r - 1 - e.padInfo.left;
  this.userCode = `
      const ivec3 pads = ivec3(` + s + ", " + u + ", " + l + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ` + n + `; wF++) {
          float dyF = float(dyFCorner + wF) / ` + a + `.0;

          if (dyF < 0.0 || dyF >= ` + e.outDepth + `.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ` + n + ` - 1 - wF;

          for (int wR = 0; wR < ` + t + `; wR++) {
            float dyR = float(dyRCorner + wR) / ` + o + `.0;

            if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ` + t + ` - 1 - wR;

            for (int wC = 0; wC < ` + r + `; wC++) {
              float dyC = float(dyCCorner + wC) / ` + i + `.0;

              if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ` + r + ` - 1 - wC;

              for (int d2 = 0; d2 < ` + e.outChannels + `; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, y0 = function(e) {
  this.variableNames = ["x", "dy"], this.outputShape = e.filterShape;
  var n = e.strideHeight, t = e.strideWidth, r = e.padInfo.top, a = e.padInfo.left, o = e.outChannels / e.inChannels;
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ` + o + ` + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ` + e.batchSize + `; b++) {
          for (int yR = 0; yR < ` + e.outHeight + `; yR++) {
            int xR = wR + yR * ` + n + " - " + r + `;

            if (xR < 0 || xR >= ` + e.inHeight + `) {
              continue;
            }

            for (int yC = 0; yC < ` + e.outWidth + `; yC++) {
              int xC = wC + yC * ` + t + " - " + a + `;

              if (xC < 0 || xC >= ` + e.inWidth + `) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, b0 = function(e) {
  this.variableNames = ["dy", "W"], this.outputShape = e.inShape;
  var n = e.filterHeight, t = e.filterWidth, r = e.strideHeight, a = e.strideWidth, o = n - 1 - e.padInfo.top, i = t - 1 - e.padInfo.left, s = e.outChannels / e.inChannels;
  this.userCode = `
      const ivec2 pads = ivec2(` + o + ", " + i + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ` + n + `; wR++) {
          float dyR = float(dyRCorner + wR) / ` + r + `.0;

          if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ` + n + ` - 1 - wR;

          for (int wC = 0; wC < ` + t + `; wC++) {
            float dyC = float(dyCCorner + wC) / ` + a + `.0;

            if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ` + t + ` - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ` + s + `; dm++) {
              int d2 = d1 * ` + s + ` + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, Wl = function(e, n, t, r) {
  n === void 0 && (n = !1), t === void 0 && (t = null), r === void 0 && (r = !1), this.variableNames = ["x", "W"], this.outputShape = e.outShape;
  var a = e.padInfo.top, o = e.padInfo.left, i = e.strideHeight, s = e.strideWidth, u = e.dilationHeight, l = e.dilationWidth, c = e.filterHeight, h = e.filterWidth, d = 4 * Math.floor(e.inChannels / 4), p = e.inChannels % 4, f = e.dataFormat === "channelsLast", m = f ? 1 : 2, g = f ? 2 : 3, v = f ? 3 : 1, y = "", b = "";
  t && (y = r ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ` + t + `
        }` : `
          float activation(float x) {
            ` + t + `
          }
        `, b = "result = activation(result);");
  var x = n ? "result += getBiasAtOutCoords();" : "";
  n && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + y + `

      const ivec2 strides = ivec2(` + i + ", " + s + `);
      const ivec2 pads = ivec2(` + a + ", " + o + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[` + v + `];

        ivec2 xRCCorner =
            ivec2(coords[` + m + "], coords[" + g + `]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + c + `; wR++) {
          int xR = xRCorner + wR * ` + u + `;

          if (xR < 0 || xR >= ` + e.inHeight + `) {
            continue;
          }

          for (int wC = 0; wC < ` + h + `; wC++) {
            int xC = xCCorner + wC * ` + l + `;

            if (xC < 0 || xC >= ` + e.inWidth + `) {
              continue;
            }

            for (int d1 = 0; d1 < ` + d + `; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (` + f + `) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (` + (p === 1) + `) {

              if (` + f + `) {
                dotProd +=
                    getX(batch, xR, xC, ` + d + `) *
                    getW(wR, wC, ` + d + `, d2);
              } else {
                dotProd +=
                    getX(batch, ` + d + `, xR, xC) *
                    getW(wR, wC, ` + d + `, d2);
              }

            } else if (` + (p === 2) + `) {
              vec2 wValues = vec2(
                getW(wR, wC, ` + d + `, d2),
                getW(wR, wC, ` + d + ` + 1, d2)
              );

              if (` + f + `) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ` + d + `),
                  getX(batch, xR, xC, ` + d + ` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ` + d + `, xR, xC),
                  getX(batch, ` + d + ` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (` + (p === 3) + `) {
              vec3 wValues = vec3(
                getW(wR, wC, ` + d + `, d2),
                getW(wR, wC, ` + d + ` + 1, d2),
                getW(wR, wC, ` + d + ` + 2, d2)
              );

              if (` + f + `) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ` + d + `),
                  getX(batch, xR, xC, ` + d + ` + 1),
                  getX(batch, xR, xC, ` + d + ` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ` + d + `, xR, xC),
                  getX(batch, ` + d + ` + 1, xR, xC),
                  getX(batch, ` + d + ` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ` + x + `
        ` + b + `
        setOutput(result);
      }
    `;
}, x0 = function(e) {
  this.variableNames = ["x", "W"], this.outputShape = e.outShape;
  var n = e.padInfo.front, t = e.padInfo.top, r = e.padInfo.left, a = e.strideDepth, o = e.strideHeight, i = e.strideWidth, s = e.dilationDepth, u = e.dilationHeight, l = e.dilationWidth, c = e.filterDepth, h = e.filterHeight, d = e.filterWidth, p = 4 * Math.floor(e.inChannels / 4), f = e.inChannels % 4;
  this.userCode = `
      const ivec3 strides = ivec3(` + a + ", " + o + ", " + i + `);
      const ivec3 pads = ivec3(` + n + ", " + t + ", " + r + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ` + c + `; wF++) {
          int xF = xFCorner + wF * ` + s + `;

          if (xF < 0 || xF >= ` + e.inDepth + `) {
            continue;
          }

          for (int wR = 0; wR < ` + h + `; wR++) {
            int xR = xRCorner + wR * ` + u + `;

            if (xR < 0 || xR >= ` + e.inHeight + `) {
              continue;
            }

            for (int wC = 0; wC < ` + d + `; wC++) {
              int xC = xCCorner + wC * ` + l + `;

              if (xC < 0 || xC >= ` + e.inWidth + `) {
                continue;
              }

              for (int d1 = 0; d1 < ` + p + `; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (` + (f === 1) + `) {
                dotProd +=
                  getX(batch, xF, xR, xC, ` + p + `) *
                  getW(wF, wR, wC, ` + p + `, d2);
              } else if (` + (f === 2) + `) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ` + p + `),
                  getX(batch, xF, xR, xC, ` + p + ` + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ` + p + `, d2),
                  getW(wF, wR, wC, ` + p + ` + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (` + (f === 3) + `) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ` + p + `),
                  getX(batch, xF, xR, xC, ` + p + ` + 1),
                  getX(batch, xF, xR, xC, ` + p + ` + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ` + p + `, d2),
                  getW(wF, wR, wC, ` + p + ` + 1, d2),
                  getW(wF, wR, wC, ` + p + ` + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, $l = function(e, n, t, r) {
  n === void 0 && (n = !1), t === void 0 && (t = null), r === void 0 && (r = !1), this.variableNames = ["x", "W"], this.outputShape = e.outShape;
  var a = e.inHeight, o = e.inWidth, i = e.padInfo.top, s = e.padInfo.left, u = e.strideHeight, l = e.strideWidth, c = e.dilationHeight, h = e.dilationWidth, d = e.filterHeight, p = e.filterWidth, f = e.outChannels / e.inChannels, m = "", g = "";
  t && (m = r ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ` + t + `
        }` : `
          float activation(float x) {
            ` + t + `
          }
        `, g = "result = activation(result);");
  var v = n ? "result += getBiasAtOutCoords();" : "";
  n && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + m + `

      const ivec2 strides = ivec2(` + u + ", " + l + `);
      const ivec2 pads = ivec2(` + i + ", " + s + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ` + f + `;
        int q = d2 - d1 * ` + f + `;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ` + d + `; wR++) {
          int xR = xRCorner + wR * ` + c + `;

          if (xR < 0 || xR >= ` + a + `) {
            continue;
          }

          for (int wC = 0; wC < ` + p + `; wC++) {
            int xC = xCCorner + wC * ` + h + `;

            if (xC < 0 || xC >= ` + o + `) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ` + v + `
        ` + g + `
        setOutput(result);
      }
    `;
}, Ul = function(e, n, t, r) {
  n === void 0 && (n = !1), t === void 0 && (t = null), r === void 0 && (r = !1), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.outShape;
  for (var a = e.inHeight, o = e.inWidth, i = e.padInfo.top, s = e.padInfo.left, u = e.strideHeight, l = e.strideWidth, c = e.dilationHeight, h = e.dilationWidth, d = e.filterHeight, p = e.filterWidth, f = p, m = "int xR; int xC; int xCOffset;", g = 0; g < d; g++) for (var v = 0; v < p; v++) m += `
          vec4 xTexelR` + g + "C" + 2 * v + ` = vec4(0.);
          vec4 wR` + g + "C" + v + ` = vec4(0.);
          vec4 xR` + g + "C" + v + " = vec4(0.);";
  for (g = 0; g < d; g++) for (var y = 0; y < f; y++) {
    if (m += `
          xR = xRCorner + ` + g * c + `;
          xC = xCCorner + ` + (v = 2 * y) * h + `;
        `, l === 1) {
      if (v < p && (m += s % 2 == 1 ? `
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ` + a + " && xCOffset >= 0 && xCOffset < " + o + `) {
                  xTexelR` + g + "C" + v + ` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ` + o + `) {
                    xTexelR` + g + "C" + v + `.zw = vec2(0.);
                  }
                } else {
                  xTexelR` + g + "C" + v + ` = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ` + a + " && xCOffset >= 0 && xCOffset < " + o + `) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ` + o + `) {
                    previous.zw = vec2(0.);
                  }

                  xR` + g + "C" + v + " = vec4(previous.zw, xTexelR" + g + "C" + v + `.xy);
                } else {
                  xR` + g + "C" + v + " = vec4(0, 0, xTexelR" + g + "C" + v + `.xy);
                }
              ` : `
                if(xR >= 0 && xR < ` + a + " && xC >= 0 && xC < " + o + `) {
                  xTexelR` + g + "C" + v + ` = getX(batch, xR, xC, d1);
                } else {
                  xTexelR` + g + "C" + v + ` = vec4(0.);
                }

                xR` + g + "C" + v + " = xTexelR" + g + "C" + v + `;
              `, v + 1 < p)) {
        var b = s % 2 == 0 ? wu(h) : h;
        h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (m += `
                  xCOffset = xC + ` + s % 2 + " + " + b + `;

                  if(xR >= 0 && xR < ` + a + ` &&
                    xCOffset >= 0 && xCOffset < ` + o + `) {
                    xTexelR` + g + "C" + (v + 2) + ` = getX(batch, xR, xCOffset, d1);
                  }
                `, h > 1 && (m += `
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ` + a + ` &&
                      xCOffset >= 0 && xCOffset < ` + o + `) {
                      xTexelR` + g + "C" + v + ` = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR` + g + "C" + v + ` = vec4(0.);
                    }
                  `), m += `
                  xR` + g + "C" + (v + 1) + ` = vec4(
                    xTexelR` + g + "C" + v + ".zw, xTexelR" + g + "C" + (v + 2) + `.xy);
                `) : m += `
                  xCOffset = xC + ` + b + `;

                  if(xR >= 0 && xR < ` + a + ` &&
                    xCOffset >= 0 && xCOffset < ` + o + `) {
                    xTexelR` + g + "C" + (v + 2) + ` = getX(batch, xR, xCOffset, d1);
                  }

                  xR` + g + "C" + (v + 1) + " = xTexelR" + g + "C" + (v + 2) + `;
                `;
      }
    } else v < p && (m += `
              if(xR >= 0 && xR < ` + a + `) {
            `, s % 2 == 1 ? (m += `
                xCOffset = xC + 1 - ` + l + `;
                if(xCOffset >= 0 && xCOffset < ` + o + `) {
                  xTexelR` + g + "C" + v + ` = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR` + g + "C" + v + ` = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ` + o + `) {
                  xTexelR` + g + "C" + (v + 2) + ` = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR` + g + "C" + (v + 2) + ` = vec4(0.);
                }

                xR` + g + "C" + v + ` = vec4(
                  xTexelR` + g + "C" + v + ".zw, xTexelR" + g + "C" + (v + 2) + `.zw);
              `, v + 1 < p && (m += `
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ` + l + `;
                  if(xCOffset >= 0 && xCOffset < ` + o + `) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR` + g + "C" + (v + 1) + " = vec4(xTexelR" + g + "C" + (v + 2) + `.xy, final.xy);
                `)) : (m += `
                if(xC >= 0 && xC < ` + o + `) {
                  xTexelR` + g + "C" + v + ` = getX(batch, xR, xC, d1);
                } else {
                  xTexelR` + g + "C" + v + ` = vec4(0.);
                }

                xCOffset = xC + ` + l + `;
                if(xCOffset >= 0 && xCOffset < ` + o + `) {
                  xTexelR` + g + "C" + (v + 2) + ` = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR` + g + "C" + (v + 2) + ` = vec4(0.);
                }

                xR` + g + "C" + v + ` = vec4(
                  xTexelR` + g + "C" + v + ".xy, xTexelR" + g + "C" + (v + 2) + `.xy);
              `, v + 1 < p && (m += `
                  xR` + g + "C" + (v + 1) + ` = vec4(
                    xTexelR` + g + "C" + v + ".zw, xTexelR" + g + "C" + (v + 2) + `.zw);
                `)), m += "}");
    v < p && (m += `
            vec4 wTexelR` + g + "C" + v + " = getW(" + g + ", " + v + `, d1, q);
            wR` + g + "C" + v + " = vec4(wTexelR" + g + "C" + v + ".xz, wTexelR" + g + "C" + v + `.xz);
          `, v + 1 < p && (m += `
              vec4 wTexelR` + g + "C" + (v + 1) + " = getW(" + g + ", " + (v + 1) + `, d1, q);
              wR` + g + "C" + (v + 1) + ` =
                vec4(wTexelR` + g + "C" + (v + 1) + ".xz, wTexelR" + g + "C" + (v + 1) + ".xz);"));
  }
  for (g = 0; g < d; g++) for (v = 0; v < p; v++) m += "dotProd += xR" + g + "C" + v + " * wR" + g + "C" + v + ";";
  var x = "", C = "";
  t && (x = r ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ` + t + `
        }` : `vec4 activation(vec4 x) {
          ` + t + `
        }`, C = "result = activation(result);");
  var N = n ? "result += getBiasAtOutCoords();" : "";
  n && this.variableNames.push("bias"), r && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + x + `

      const ivec2 strides = ivec2(` + u + ", " + l + `);
      const ivec2 pads = ivec2(` + i + ", " + s + `);

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ` + m + `

        vec4 result = dotProd;
        ` + N + `
        ` + C + `
        setOutput(result);
      }
    `;
}, w0 = function(e, n, t, r, a) {
  this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
  var o = e[0], i = e[1], s = e[2], u = e[3], l = n[0], c = t[0], h = t[1];
  this.outputShape = [l, c, h, u];
  var d = r === "bilinear" ? 1 : 0, p = [i - 1 + ".0", s - 1 + ".0"], f = p[0], m = p[1], g = c > 1 ? ["" + (i - 1) / (c - 1), "(y2-y1) * height_ratio", "y1*" + f + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + f], v = g[0], y = g[1], b = g[2], x = h > 1 ? ["" + (s - 1) / (h - 1), "(x2-x1) * width_ratio", "x1*" + m + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + m], C = x[0], N = x[1], T = x[2];
  this.userCode = `
      const float height_ratio = float(` + v + `);
      const float width_ratio = float(` + C + `);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ` + o + `) {
          return;
        }

        float height_scale = ` + y + `;
        float width_scale = ` + N + `;

        float in_y = ` + b + `;
        if( in_y < 0.0 || in_y > ` + f + ` ) {
          setOutput(float(` + a + `));
          return;
        }
        float in_x = ` + T + `;
        if( in_x < 0.0 || in_x > ` + m + ` ) {
          setOutput(float(` + a + `));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(` + d + ` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
}, C0 = function(e, n, t) {
  this.variableNames = ["x"], this.outputShape = e;
  var r = e.length, a = e[e.length - 1], o = t ? "<" : ">";
  this.userCode = `
      int getIndex(int i) {
        ` + (t ? "return " + a + " -i - 1;" : "return i;") + `
      }

      void main() {
        ` + De(r) + ` coords = getOutputCoords();
        int end = ` + Kl(r, "coords") + `;
        float val = 0.0;
        for (int i = ` + a + ` - 1; i >= 0; i -= 1) {
          int idx = getIndex(i);
          if (idx ` + o + ` end) {
            continue;
          }
          if (idx == end && ` + n + `) {
            continue;
          }
          ` + Kl(r, "coords") + ` = idx;
          val += getX(` + function(i, s) {
    if (i === 1) return "" + s;
    if (i === 2) return s + ".x, " + s + ".y";
    if (i === 3) return s + ".x, " + s + ".y, " + s + ".z";
    if (i === 4) return s + ".x, " + s + ".y, " + s + ".z, " + s + ".w";
    throw Error("Cumulative sum for rank " + i + " is not yet supported");
  }(r, "coords") + `);
        }
        setOutput(val);
      }
    `;
};
function Kl(e, n) {
  if (e === 1) return "" + n;
  if (e === 2) return n + ".y";
  if (e === 3) return n + ".z";
  if (e === 4) return n + ".w";
  throw Error("Cumulative sum for rank " + e + " is not yet supported");
}
var k0 = function(e) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = ja.DENSE;
  var n = Sa(e), t = ht();
  this.outputShape = e, this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ` + gr(["r", "c", "d"], e) + `
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(` + n[0] + ", " + n[1] + `));
        int index = 4 * (resTexRC.x * ` + n[1] + ` + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ` + t.output + ` = result;
      }
    `;
}, N0 = function(e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = ja.DENSE;
  var n = Sa(e), t = ht();
  this.outputShape = e, this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ` + gr(["r", "c", "d"], e) + `
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(` + n[0] + ", " + n[1] + `));
        int index = 4 * (resTexRC.x * ` + n[1] + ` + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ` + t.output + ` = result;
      }
    `;
}, A0 = function() {
  function e(n, t, r) {
    this.variableNames = ["x"], this.outputShape = [], this.outputShape = n, this.blockSize = t, this.dataFormat = r, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ` + this.getHeightCoordString() + `;
      int w = ` + this.getWidthCoordString() + `;
      int d = ` + this.getDepthCoordString() + `;

      int in_h = h / ` + t + `;
      int offset_h = imod(h, ` + t + `);
      int in_w = w / ` + t + `;
      int offset_w = imod(w, ` + t + `);
      int offset_d = (offset_h * ` + t + ` + offset_w) *
        ` + this.getOutputDepthSize() + `;
      int in_d = d + offset_d;

      float result = ` + this.getInputSamplingString() + `;
      setOutput(result);
    }
  `;
  }
  return e.prototype.getHeightCoordString = function() {
    return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
  }, e.prototype.getWidthCoordString = function() {
    return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
  }, e.prototype.getDepthCoordString = function() {
    return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
  }, e.prototype.getOutputDepthSize = function() {
    return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
  }, e.prototype.getInputSamplingString = function() {
    return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }, e;
}(), I0 = function(e) {
  this.variableNames = ["X"], this.outputShape = [e, e], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
}, E0 = function(e) {
  this.variableNames = ["A"], this.outTexUsage = Ot.DOWNLOAD;
  var n = ht();
  this.outputShape = e, this.userCode = `
      ` + Zp + `

      void main() {
        float x = getAAtOutCoords();
        ` + n.output + ` = encode_float(x);
      }
    `;
}, T0 = function(e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = Ot.DOWNLOAD;
  var n = ht();
  this.outputShape = e, this.userCode = `
      ` + Zp + `

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ` + n.output + ` = encode_float(x);
      }
    `;
}, P0 = function(e, n, t) {
  t === void 0 && (t = !1), this.variableNames = ["A"];
  var r = ht(), a = n[0], o = n[1];
  this.outputShape = e;
  var i = "result";
  t && (i = "floor(result * 255. + 0.5)"), this.userCode = `
      ` + zu(e) + `

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);
        
        int r = flatIndex / ` + o + `;
        int c = imod(flatIndex, ` + o + `);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(` + o + ".0, " + a + `.0);
        vec4 values = ` + r.texture2D + `(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ` + r.output + " = vec4(" + i + `, 0., 0., 0.);
      }
    `;
}, S0 = function(e, n, t) {
  t === void 0 && (t = !1), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var r = ht(), a = n[0], o = n[1];
  this.outputShape = e;
  var i = "", s = "result";
  t && (s = "floor(result * 255. + 0.5)");
  for (var u = 0; u <= 1; u++) for (var l = 0; l <= 1; l++) {
    var c = 2 * u + l;
    i += `
          localCoords = coords;
          if(localCoords[2] + ` + l + " < " + e[2] + `) {
            localCoords[2] += ` + l + `;
            if(localCoords[1] + ` + u + " < " + e[1] + `) {
              localCoords[1] += ` + u + `;

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ` + o + `;
              c = imod(flatIndex, ` + o + `);
              uv = (vec2(c, r) + halfCR) / vec2(` + o + ".0, " + a + `.0);
              values = ` + r.texture2D + `(A, uv);

              if(offset == 0) {
                result[` + c + `] = values[0];
              } else if(offset == 1) {
                result[` + c + `] = values[1];
              } else if(offset == 2) {
                result[` + c + `] = values[2];
              } else {
                result[` + c + `] = values[3];
              }
            }
          }
        `;
  }
  this.userCode = `
      ` + zu(e) + `

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ` + i + `

        ` + r.output + " = " + s + `;
      }
    `;
}, D0 = "return real * expR - imag * expI;", O0 = "return real * expI + imag * expR;", ql = function(e, n, t) {
  this.variableNames = ["real", "imag"];
  var r = n[1];
  this.outputShape = n;
  var a = t ? "2.0 * " + Math.PI : "-2.0 * " + Math.PI, o = t ? r + ".0" : "1.0";
  this.userCode = `
      const float exponentMultiplier = ` + a + `;

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ` + e + `
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(` + r + `);
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ` + r + `; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ` + o + `;
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
}, R0 = function() {
  function e(n, t) {
    this.outputShape = [], this.variableNames = ["x"], this.outputShape = n, this.userCode = `
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
  return e.prototype.getCustomSetupFunc = function(n) {
    var t = this;
    return function(r, a) {
      t.valueLoc == null && (t.valueLoc = r.getUniformLocationNoThrow(a, "value")), r.gl.uniform1f(t.valueLoc, n);
    };
  }, e;
}(), F0 = function(e, n, t) {
  this.variableNames = ["A", "indices"];
  var r = e.slice();
  r[t] = n, this.outputShape = r, this.rank = r.length;
  var a = De(this.rank), o = function(i, s) {
    var u = i.length;
    if (u > 4) throw Error("Gather for rank " + u + " is not yet supported");
    if (u === 1) return "int(getIndices(resRC))";
    for (var l = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], c = [], h = 0; h < i.length; h++) h === s ? c.push("int(getIndices(" + l[h] + "))") : c.push("" + l[h]);
    return c.join();
  }(e, t);
  this.userCode = `
      void main() {
        ` + a + ` resRC = getOutputCoords();
        setOutput(getA(` + o + `));
      }
    `;
}, M0 = function(e, n, t) {
  this.sliceDim = e, this.strides = n, this.variableNames = ["x", "indices"], this.outputShape = t;
  var r = De(n.length), a = De(t.length), o = this.sliceDim > 1 ? "strides[j]" : "strides";
  this.userCode = `
        ` + r + " strides = " + r + "(" + this.strides + `);
         void main() {
          ` + a + ` coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ` + this.sliceDim + `; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ` + o + `;
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
};
function _0(e, n) {
  var t = ht();
  return Vg(e, n, t.version + `
    precision highp float;
    ` + t.attribute + ` vec3 clipSpacePos;
    ` + t.attribute + ` vec2 uv;
    ` + t.varyingVs + ` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`);
}
function B0(e, n) {
  return Wg(e, n, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));
}
function j0(e, n) {
  return $g(e, n, new Uint16Array([0, 1, 2, 2, 1, 3]));
}
function Ja(e, n, t, r, a, o, i) {
  Kg(t, r);
  var s = Ug(e, n), u = e.TEXTURE_2D;
  return te(e, n, function() {
    return e.bindTexture(u, s);
  }), te(e, n, function() {
    return e.texParameteri(u, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);
  }), te(e, n, function() {
    return e.texParameteri(u, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
  }), te(e, n, function() {
    return e.texParameteri(u, e.TEXTURE_MIN_FILTER, e.NEAREST);
  }), te(e, n, function() {
    return e.texParameteri(u, e.TEXTURE_MAG_FILTER, e.NEAREST);
  }), te(e, n, function() {
    return e.texImage2D(u, 0, a, t, r, 0, o, i, null);
  }), te(e, n, function() {
    return e.bindTexture(e.TEXTURE_2D, null);
  }), s;
}
function V0(e, n, t, r, a) {
  var o = li(t, r);
  return Ja(e, n, o[0], o[1], a.internalFormatFloat, a.textureFormatFloat, e.FLOAT);
}
function L0(e, n, t, r, a) {
  var o = li(t, r);
  return Ja(e, n, o[0], o[1], a.internalFormatHalfFloat, a.textureFormatFloat, a.textureTypeHalfFloat);
}
function z0(e, n, t, r, a) {
  var o = li(t, r);
  return Ja(e, n, o[0], o[1], e.RGBA, e.RGBA, e.UNSIGNED_BYTE);
}
function G0(e, n, t, r, a) {
  var o = Ka(t, r);
  return Ja(e, n, o[0], o[1], a.internalFormatPackedFloat, e.RGBA, e.FLOAT);
}
function H0(e, n, t, r, a) {
  var o = Ka(t, r);
  return Ja(e, n, o[0], o[1], a.internalFormatPackedHalfFloat, e.RGBA, a.textureTypeHalfFloat);
}
function W0(e, n, t, r) {
  return te(e, n, function() {
    return e.bindBuffer(e.ARRAY_BUFFER, r);
  }), Ml(e, n, t, "clipSpacePos", r, 3, 20, 0) && Ml(e, n, t, "uv", r, 2, 20, 12);
}
function $0(e, n, t, r, a, o, i) {
  var s, u, l;
  te(e, n, function() {
    return e.bindTexture(e.TEXTURE_2D, t);
  }), o instanceof Uint8Array ? (s = new Uint8Array(r * a * 4), u = e.UNSIGNED_BYTE, l = e.RGBA) : (s = new Float32Array(r * a * 4), u = e.FLOAT, l = i.internalFormatPackedFloat), s.set(o), te(e, n, function() {
    return e.texImage2D(e.TEXTURE_2D, 0, l, r, a, 0, e.RGBA, u, s);
  }), te(e, n, function() {
    return e.bindTexture(e.TEXTURE_2D, null);
  });
}
function U0(e, n, t, r) {
  te(e, n, function() {
    return e.bindTexture(e.TEXTURE_2D, t);
  }), r.data instanceof Uint8Array ? te(e, n, function() {
    return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, r.width, r.height, 0, e.RGBA, e.UNSIGNED_BYTE, r.data);
  }) : te(e, n, function() {
    return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, r);
  }), te(e, n, function() {
    return e.bindTexture(e.TEXTURE_2D, null);
  });
}
function K0(e, n, t, r, a) {
  var o = e.createBuffer();
  te(e, n, function() {
    return e.bindBuffer(e.PIXEL_PACK_BUFFER, o);
  });
  var i = 16 * t * r;
  return te(e, n, function() {
    return e.bufferData(e.PIXEL_PACK_BUFFER, i, e.STREAM_READ);
  }), te(e, n, function() {
    return e.readPixels(0, 0, r, t, e.RGBA, e.FLOAT, 0);
  }), te(e, n, function() {
    return e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
  }), o;
}
function q0(e, n, t) {
  var r = e, a = new Float32Array(t);
  return r.bindBuffer(r.PIXEL_PACK_BUFFER, n), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, a), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), a;
}
function J0(e, n, t, r, a) {
  var o = li(t, r), i = o[0], s = o[1], u = new Uint8Array(t * r * 4);
  return te(e, n, function() {
    return e.readPixels(0, 0, i, s, a.downloadTextureFormat, e.UNSIGNED_BYTE, u);
  }), new Float32Array(u.buffer);
}
function X0(e, n, t, r, a, o, i, s) {
  var u = e, l = new Float32Array(function(c, h) {
    var d = Ka(c, h);
    return d[0] * d[1] * 4;
  }(o, i));
  return u.bindBuffer(u.PIXEL_PACK_BUFFER, n), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, l), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), l;
}
function Q0(e, n, t, r) {
  var a = new Float32Array(t * r * 4);
  return te(e, n, function() {
    return e.readPixels(0, 0, r, t, e.RGBA, e.FLOAT, a);
  }), a;
}
var Y0 = function() {
  function e(n) {
    this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];
    var t = _().getNumber("WEBGL_VERSION");
    n != null ? (this.gl = n, Fg(t, n)) : this.gl = pn(t);
    var r = "WEBGL_color_buffer_float";
    if (_().getNumber("WEBGL_VERSION") === 1) {
      if (this.textureFloatExtension = ro(this.gl, this.debug, "OES_texture_float"), zt(this.gl, "OES_texture_half_float")) this.textureHalfFloatExtension = ro(this.gl, this.debug, "OES_texture_half_float");
      else if (_().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      if (this.colorBufferFloatExtension = this.gl.getExtension(r), zt(this.gl, "EXT_color_buffer_half_float")) this.colorBufferHalfFloatExtension = ro(this.gl, this.debug, "EXT_color_buffer_half_float");
      else if (_().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
    } else if (r = "EXT_color_buffer_float", zt(this.gl, r)) this.colorBufferFloatExtension = this.gl.getExtension(r);
    else {
      if (!zt(this.gl, "EXT_color_buffer_half_float")) throw new Error("GL context does not support color renderable floats");
      this.colorBufferHalfFloatExtension = this.gl.getExtension("EXT_color_buffer_half_float");
    }
    this.vertexBuffer = B0(this.gl, this.debug), this.indexBuffer = j0(this.gl, this.debug), this.framebuffer = qg(this.gl, this.debug), this.textureConfig = Eu(this.gl, this.textureHalfFloatExtension);
  }
  return Object.defineProperty(e.prototype, "debug", { get: function() {
    return _().getBool("DEBUG");
  }, enumerable: !0, configurable: !0 }), e.prototype.dispose = function() {
    var n = this;
    if (!this.disposed) {
      this.program != null && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this.outputTexture != null && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      var t = this.gl;
      te(t, this.debug, function() {
        return t.finish();
      }), te(t, this.debug, function() {
        return t.bindFramebuffer(t.FRAMEBUFFER, null);
      }), te(t, this.debug, function() {
        return t.deleteFramebuffer(n.framebuffer);
      }), te(t, this.debug, function() {
        return t.bindBuffer(t.ARRAY_BUFFER, null);
      }), te(t, this.debug, function() {
        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);
      }), te(t, this.debug, function() {
        return t.deleteBuffer(n.indexBuffer);
      }), this.disposed = !0;
    }
  }, e.prototype.createFloat32MatrixTexture = function(n, t) {
    return this.throwIfDisposed(), V0(this.gl, this.debug, n, t, this.textureConfig);
  }, e.prototype.createFloat16MatrixTexture = function(n, t) {
    return this.throwIfDisposed(), L0(this.gl, this.debug, n, t, this.textureConfig);
  }, e.prototype.createUnsignedBytesMatrixTexture = function(n, t) {
    return this.throwIfDisposed(), z0(this.gl, this.debug, n, t, this.textureConfig);
  }, e.prototype.uploadPixelDataToTexture = function(n, t) {
    this.throwIfDisposed(), U0(this.gl, this.debug, n, t);
  }, e.prototype.uploadDenseMatrixToTexture = function(n, t, r, a) {
    this.throwIfDisposed(), $0(this.gl, this.debug, n, t, r, a, this.textureConfig);
  }, e.prototype.createFloat16PackedMatrixTexture = function(n, t) {
    return this.throwIfDisposed(), H0(this.gl, this.debug, n, t, this.textureConfig);
  }, e.prototype.createPackedMatrixTexture = function(n, t) {
    return this.throwIfDisposed(), G0(this.gl, this.debug, n, t, this.textureConfig);
  }, e.prototype.deleteMatrixTexture = function(n) {
    var t = this;
    this.throwIfDisposed(), this.outputTexture === n && (_l(this.gl, this.debug, this.framebuffer), this.outputTexture = null), te(this.gl, this.debug, function() {
      return t.gl.deleteTexture(n);
    });
  }, e.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(n, t, r) {
    var a = this;
    return this.downloadMatrixDriver(n, function() {
      return J0(a.gl, a.debug, t, r, a.textureConfig);
    });
  }, e.prototype.downloadPackedMatrixFromBuffer = function(n, t, r, a, o, i) {
    return X0(this.gl, n, 0, 0, 0, o, i, this.textureConfig);
  }, e.prototype.downloadFloat32MatrixFromBuffer = function(n, t) {
    return q0(this.gl, n, t);
  }, e.prototype.createBufferFromTexture = function(n, t, r) {
    this.bindTextureToFrameBuffer(n);
    var a = K0(this.gl, this.debug, t, r, this.textureConfig);
    return this.unbindTextureToFrameBuffer(), a;
  }, e.prototype.createAndWaitForFence = function() {
    var n = this.createFence(this.gl);
    return this.pollFence(n);
  }, e.prototype.createFence = function(n) {
    var t, r, a = this;
    if (_().getBool("WEBGL_FENCE_API_ENABLED")) {
      var o = n, i = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
      n.flush(), r = function() {
        var s = o.clientWaitSync(i, 0, 0);
        return s === o.ALREADY_SIGNALED || s === o.CONDITION_SATISFIED;
      }, t = i;
    } else _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), r = function() {
      return a.isQueryAvailable(t, _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }) : r = function() {
      return !0;
    };
    return { query: t, isFencePassed: r };
  }, e.prototype.downloadMatrixFromPackedTexture = function(n, t, r) {
    var a = this;
    return this.downloadMatrixDriver(n, function() {
      return Q0(a.gl, a.debug, t, r);
    });
  }, e.prototype.createProgram = function(n) {
    this.throwIfDisposed();
    var t = this.gl, r = Lg(t, this.debug, n), a = _0(t, this.debug), o = Gg(t, this.debug);
    return te(t, this.debug, function() {
      return t.attachShader(o, a);
    }), te(t, this.debug, function() {
      return t.attachShader(o, r);
    }), Hg(t, this.debug, o), this.debug && Vi(t, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = W0(t, this.debug, this.program, this.vertexBuffer)), o;
  }, e.prototype.deleteProgram = function(n) {
    var t = this;
    this.throwIfDisposed(), n === this.program && (this.program = null), n != null && te(this.gl, this.debug, function() {
      return t.gl.deleteProgram(n);
    });
  }, e.prototype.setProgram = function(n) {
    var t = this;
    this.throwIfDisposed(), this.program = n, this.program != null && this.debug && Vi(this.gl, this.debug, this.program), te(this.gl, this.debug, function() {
      return t.gl.useProgram(n);
    });
  }, e.prototype.getUniformLocation = function(n, t, r) {
    return r === void 0 && (r = !0), this.throwIfDisposed(), r ? Xg(this.gl, this.debug, n, t) : Qg(this.gl, n, t);
  }, e.prototype.getAttributeLocation = function(n, t) {
    var r = this;
    return this.throwIfDisposed(), te(this.gl, this.debug, function() {
      return r.gl.getAttribLocation(n, t);
    });
  }, e.prototype.getUniformLocationNoThrow = function(n, t) {
    return this.throwIfDisposed(), this.gl.getUniformLocation(n, t);
  }, e.prototype.setInputMatrixTexture = function(n, t, r) {
    this.throwIfDisposed(), this.throwIfNoProgram(), Yg(this.gl, this.debug, this.program, n, t, r);
  }, e.prototype.setOutputMatrixTexture = function(n, t, r) {
    this.setOutputMatrixTextureDriver(n, r, t);
  }, e.prototype.setOutputPackedMatrixTexture = function(n, t, r) {
    this.throwIfDisposed();
    var a = Ka(t, r), o = a[0], i = a[1];
    this.setOutputMatrixTextureDriver(n, o, i);
  }, e.prototype.setOutputMatrixWriteRegion = function(n, t, r, a) {
    this.setOutputMatrixWriteRegionDriver(r, n, a, t);
  }, e.prototype.setOutputPackedMatrixWriteRegion = function(n, t, r, a) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }, e.prototype.debugValidate = function() {
    this.program != null && Vi(this.gl, this.debug, this.program), ao(this.gl);
  }, e.prototype.executeProgram = function() {
    this.throwIfDisposed(), this.throwIfNoProgram();
    var n = this.gl;
    this.debug && this.debugValidate(), te(n, this.debug, function() {
      return n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);
    });
  }, e.prototype.blockUntilAllProgramsCompleted = function() {
    var n = this;
    this.throwIfDisposed(), te(this.gl, this.debug, function() {
      return n.gl.finish();
    });
  }, e.prototype.getQueryTimerExtension = function() {
    return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = ro(this.gl, this.debug, _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension;
  }, e.prototype.getQueryTimerExtensionWebGL2 = function() {
    return this.getQueryTimerExtension();
  }, e.prototype.getQueryTimerExtensionWebGL1 = function() {
    return this.getQueryTimerExtension();
  }, e.prototype.beginQuery = function() {
    if (_().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      var n = this.gl, t = this.getQueryTimerExtensionWebGL2(), r = n.createQuery();
      return n.beginQuery(t.TIME_ELAPSED_EXT, r), r;
    }
    var a = this.getQueryTimerExtensionWebGL1(), o = a.createQueryEXT();
    return a.beginQueryEXT(a.TIME_ELAPSED_EXT, o), o;
  }, e.prototype.endQuery = function() {
    if (_().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") !== 2) {
      var n = this.getQueryTimerExtensionWebGL1();
      n.endQueryEXT(n.TIME_ELAPSED_EXT);
    } else {
      var t = this.gl, r = this.getQueryTimerExtensionWebGL2();
      t.endQuery(r.TIME_ELAPSED_EXT);
    }
  }, e.prototype.waitForQueryAndGetTime = function(n) {
    return Y(this, void 0, void 0, function() {
      var t = this;
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, As(function() {
              return t.disposed || t.isQueryAvailable(n, _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
            })];
          case 1:
            return r.sent(), [2, this.getQueryTime(n, _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))];
        }
      });
    });
  }, e.prototype.getQueryTime = function(n, t) {
    if (t === 0) return null;
    if (t === 2) {
      var r = this.gl;
      return r.getQueryParameter(n, r.QUERY_RESULT) / 1e6;
    }
    var a = this.getQueryTimerExtensionWebGL1();
    return a.getQueryObjectEXT(n, a.QUERY_RESULT_EXT) / 1e6;
  }, e.prototype.isQueryAvailable = function(n, t) {
    if (t === 0) return !0;
    if (t === 2) {
      var r = this.gl, a = this.getQueryTimerExtensionWebGL2(), o = r.getQueryParameter(n, r.QUERY_RESULT_AVAILABLE);
      return this.disjoint == null && (this.disjoint = this.gl.getParameter(a.GPU_DISJOINT_EXT)), o && !this.disjoint;
    }
    return o = (a = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(n, a.QUERY_RESULT_AVAILABLE_EXT), this.disjoint == null && (this.disjoint = this.gl.getParameter(a.GPU_DISJOINT_EXT)), o && !this.disjoint;
  }, e.prototype.pollFence = function(n) {
    var t = this;
    return new Promise(function(r) {
      t.addItemToPoll(function() {
        return n.isFencePassed();
      }, function() {
        return r();
      });
    });
  }, e.prototype.pollItems = function() {
    for (var n = function(r) {
      for (var a = 0; a < r.length && r[a](); ++a)
        ;
      return a - 1;
    }(this.itemsToPoll.map(function(r) {
      return r.isDoneFn;
    })), t = 0; t <= n; ++t)
      (0, this.itemsToPoll[t].resolveFn)();
    this.itemsToPoll = this.itemsToPoll.slice(n + 1);
  }, e.prototype.addItemToPoll = function(n, t) {
    var r = this;
    this.itemsToPoll.push({ isDoneFn: n, resolveFn: t }), this.itemsToPoll.length > 1 || As(function() {
      return r.pollItems(), r.itemsToPoll.length === 0;
    });
  }, e.prototype.bindTextureToFrameBuffer = function(n) {
    this.throwIfDisposed(), Li(this.gl, this.debug, n, this.framebuffer), this.debug && ao(this.gl);
  }, e.prototype.unbindTextureToFrameBuffer = function() {
    this.outputTexture != null ? (Li(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && ao(this.gl)) : _l(this.gl, this.debug, this.framebuffer);
  }, e.prototype.downloadMatrixDriver = function(n, t) {
    this.bindTextureToFrameBuffer(n);
    var r = t();
    return this.unbindTextureToFrameBuffer(), r;
  }, e.prototype.setOutputMatrixTextureDriver = function(n, t, r) {
    this.throwIfDisposed();
    var a = this.gl;
    Li(a, this.debug, n, this.framebuffer), this.debug && ao(a), this.outputTexture = n, te(a, this.debug, function() {
      return a.viewport(0, 0, t, r);
    }), te(a, this.debug, function() {
      return a.scissor(0, 0, t, r);
    });
  }, e.prototype.setOutputMatrixWriteRegionDriver = function(n, t, r, a) {
    var o = this;
    this.throwIfDisposed(), te(this.gl, this.debug, function() {
      return o.gl.scissor(n, t, r, a);
    });
  }, e.prototype.throwIfDisposed = function() {
    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
  }, e.prototype.throwIfNoProgram = function() {
    if (this.program == null) throw new Error("No GPU program is currently set.");
  }, e;
}();
function Jl(e, n) {
  if (e.length !== n.length) throw Error("Binary was compiled with " + e.length + " inputs, but was executed with " + n.length + " inputs");
  e.forEach(function(t, r) {
    var a = t.logicalShape, o = n[r], i = o.shape;
    if (!Ye(a, i)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + a + " and " + i + " must match");
    if (!t.isUniform || !o.isUniform) {
      var s = t.texShape, u = o.isUniform ? null : o.texData.texShape;
      if (!Ye(s, u)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + s + " and " + u + " must match");
    }
  });
}
var Z0 = function(e, n, t) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  for (var r = t.filterWidth, a = t.inChannels, o = t.strideWidth, i = t.strideHeight, s = t.padInfo, u = t.outWidth, l = t.dilationWidth, c = t.dilationHeight, h = t.dataFormat, d = s.left, p = s.top, f = a * r, m = ht(), g = h === "channelsLast", v = g ? 0 : 1, y = g ? 1 : 2, b = "", x = 0; x <= 1; x++) for (var C = 0; C <= 1; C++) b += `
          blockIndex = rc.y + ` + C + `;
          pos = rc.x + ` + x + `;

          if(blockIndex < ` + e[1] + " && pos < " + e[0] + `) {
            offsetY = int(blockIndex / (` + u + ")) * " + i + " - " + p + `;
            d0 = offsetY + ` + c + " * (pos / " + f + `);

            if(d0 < ` + n[v] + ` && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ` + u + ".) * " + o + ". - " + d + `.);
              d1 = offsetX + ` + l + " * (int(mod(float(pos), " + f + ".) / " + a + `.));

              if(d1 < ` + n[y] + ` && d1 >= 0) {

                ch = int(mod(float(pos), ` + a + `.));

                if (` + g + `) {
                  innerDims = vec2(d1, ch);
                  result[` + (2 * x + C) + `] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[` + (2 * x + C) + `] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
  this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ` + b + `

        ` + m.output + ` = result;
      }
    `;
}, ey = function(e, n, t, r, a) {
  this.variableNames = ["x"], this.outputShape = [];
  var o, i = n, s = e[3] - 1;
  this.outputShape = e;
  var u = "float(" + t + ") + float(" + r + ") * sum";
  o = a === 0.5 ? "inversesqrt(" + u + ")" : a === 1 ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + a + "));", this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -` + i + "; j <= " + i + `; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ` + s + `) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ` + o + `;
        setOutput(val);
      }
    `;
}, ty = function(e, n, t, r, a) {
  this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = n, this.bias = t, this.alpha = r, this.beta = a, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ` + this.depth + `; ++d) {
          int depthBegin = int(max(0.0, float(d - ` + n + `)));
          int depthEnd = int(min(float(` + this.depth + `),
              float(d + ` + n + ` + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ` + this.depth + `;

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(` + r + ") * norm + float(" + t + `);

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(` + r + `)
                * float(` + a + `)
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ` + a + `);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
}, ny = function(e, n, t, r, a) {
  this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
  var o, i = n, s = e[3] - 1;
  this.outputShape = e;
  var u = "float(" + t + ") + float(" + r + ") * sum";
  o = a === 0.5 ? "inversesqrt(" + u + ")" : a === 1 ? "1.0/(" + u + ")" : "exp(log(" + u + ") * float(-" + a + "));", this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ` + this.outputShape[3] + `;
        bool hasNextRow = c < ` + this.outputShape[2] + `;

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ` + i + `;
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ` + i + "; j <= " + i + `; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(` + s + `));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ` + o + `;
        setOutput(result);
      }
    `;
}, ry = function(e) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
  var n = e.strideHeight, t = e.strideWidth, r = e.dilationHeight, a = e.effectiveFilterHeight, o = e.effectiveFilterWidth, i = a - 1 - e.padInfo.top, s = o - 1 - e.padInfo.left, u = a * o - 1;
  this.userCode = `
      const ivec2 pads = ivec2(` + i + ", " + s + `);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ` + a + `;
          wR += ` + r + `) {
          float dyR = float(dyRCorner + wR) / ` + n + `.0;

          if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ` + o + `; wC++) {
            float dyC = float(dyCCorner + wC) / ` + t + `.0;

            if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ` + u + ` - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ` + o + ` + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
}, ay = function(e) {
  this.variableNames = ["dy", "maxPos"], this.outputShape = e.inShape;
  var n = e.strideDepth, t = e.strideHeight, r = e.strideWidth, a = e.dilationDepth, o = e.dilationHeight, i = e.dilationWidth, s = e.effectiveFilterDepth, u = e.effectiveFilterHeight, l = e.effectiveFilterWidth, c = s - 1 - e.padInfo.front, h = u - 1 - e.padInfo.top, d = l - 1 - e.padInfo.left, p = s * u * l - 1;
  this.userCode = `
      const ivec3 pads = ivec3(` + c + ", " + h + ", " + d + `);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ` + s + `;
           wD += ` + a + `) {
          float dyD = float(dyDCorner + wD) / ` + n + `.0;

          if (dyD < 0.0 || dyD >= ` + e.outDepth + `.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ` + u + `;
              wR += ` + o + `) {
            float dyR = float(dyRCorner + wR) / ` + t + `.0;

            if (dyR < 0.0 || dyR >= ` + e.outHeight + `.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ` + l + `;
                wC += ` + i + `) {
              float dyC = float(dyCCorner + wC) / ` + r + `.0;

              if (dyC < 0.0 || dyC >= ` + e.outWidth + `.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ` + p + ` -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ` + u + " * " + l + ` +
                  wR * ` + l + ` + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
}, $i = function(e, n, t, r, a, o, i) {
  t === void 0 && (t = !1), r === void 0 && (r = !1), a === void 0 && (a = !1), o === void 0 && (o = null), i === void 0 && (i = !1), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n;
  var s = t ? e[1] : e[2], u = Math.ceil(s / 2), l = t ? "i * 2, rc.y" : "rc.y, i * 2", c = r ? "rc.z, i * 2" : "i * 2, rc.z", h = t ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], d = r ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"], p = "", f = "";
  o && (p = i ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ` + o + `
        }` : `vec4 activation(vec4 x) {
          ` + o + `
        }`, f = "result = activation(result);");
  var m = a ? "result += getBiasAtOutCoords();" : "";
  a && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights"), this.userCode = `
      ` + p + `

      const float sharedDimension = ` + u + `.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ` + u + `; i++) {
          vec4 a = getMatrixA(rc.x, ` + l + `);
          vec4 b = getMatrixB(rc.x, ` + c + `);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (` + h[0] + " * " + d[0] + `);
          result += (` + h[1] + " * " + d[1] + `);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ` + m + `

        ` + f + `

        setOutput(result);
      }
    `;
}, oy = function() {
  function e(n, t, r) {
    this.variableNames = ["probs"], this.outputShape = [n, r], this.userCode = `
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ` + (t - 1) + `; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(` + (t - 1) + `));
      }
    `;
  }
  return e.prototype.getCustomSetupFunc = function(n) {
    var t = this;
    return function(r, a) {
      t.seedLoc == null && (t.seedLoc = r.getUniformLocation(a, "seed")), r.gl.uniform1f(t.seedLoc, n);
    };
  }, e;
}(), iy = function(e, n, t, r) {
  this.variableNames = ["indices"], this.outputShape = [e, n], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(` + r + "), float(" + t + `),
                      float(index == coords.y)));
      }
    `;
}, sy = function(e) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = e;
  var n = e.length;
  if (n === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
  else {
    var t = yt("rc", n), r = De(n), a = function(s, u, l) {
      if (s === 1) return "rc > " + u[0];
      for (var c = "", h = s - 2; h < s; h++) c += l[h] + " >= " + u[h], h < s - 1 && (c += "||");
      return c;
    }(n, e, t), o = function(s, u, l, c) {
      if (s === 1) return "";
      var h = c.slice(-2);
      return `
    int r = ` + h[0] + `;
    int c = ` + h[1] + `;
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ` + u + `;
    bool rEdge = rp1 >= ` + l + `;
  `;
    }(n, e[e.length - 1], e[e.length - 2], t), i = function(s, u) {
      var l = s.length, c = function(h, d) {
        for (var p = [], f = 0; f <= 1; f++) for (var m = 0; m <= 1; m++) {
          for (var g = (f === 0 ? "r" : "rp1") + ", " + (m === 0 ? "c" : "cp1"), v = 2; v < h; v++) g = d[d.length - 1 - v] + "," + g;
          p.push(g);
        }
        return p;
      }(l, u);
      return l === 1 ? `getA(rc),
            rc + 1 >= ` + s[0] + ` ? 0. : getA(rc + 1),
            0, 0` : "getA(" + c[0] + `),
          cEdge ? 0. : getA(` + c[1] + `),
          rEdge ? 0. : getA(` + c[2] + `),
          rEdge || cEdge ? 0. : getA(` + c[3] + ")";
    }(e, t);
    this.userCode = `
        void main() {
          ` + r + ` rc = getOutputCoords();

          if(` + a + `) {
            setOutput(vec4(0));
          } else {
            ` + o + `

            setOutput(vec4(` + i + `));
          }
        }
      `;
  }
}, uy = function(e, n, t) {
  this.variableNames = ["x"], this.outputShape = n.map(function(u, l) {
    return u[0] + e[l] + u[1];
  });
  var r = e.length, a = De(r), o = n.map(function(u) {
    return u[0];
  }).join(","), i = n.map(function(u, l) {
    return u[0] + e[l];
  }).join(","), s = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, r);
  this.userCode = r !== 1 ? `
      ` + a + " start = " + a + "(" + o + `);
      ` + a + " end = " + a + "(" + i + `);

      void main() {
        ` + a + ` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(` + t + `));
        } else {
          ` + a + ` coords = outC - start;
          setOutput(getX(` + s + `));
        }
      }
    ` : `
        int start = ` + o + `;
        int end = ` + i + `;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(` + t + `));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
}, ly = function(e, n, t) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n.map(function(g, v) {
    return g[0] + e[v] + g[1];
  });
  for (var r = e.length, a = De(r), o = n.map(function(g) {
    return g[0];
  }).join(","), i = n.map(function(g, v) {
    return g[0] + e[v];
  }).join(","), s = yt("rc", r), u = yt("source", r), l = s[r - 1] + " < " + this.outputShape[r - 1], c = r === 1 ? "source" : "vec2(" + u.slice(-2).join() + ")", h = [a + " rc = outputLoc;", s[r - 1] + ` += 1;
       if(` + l + `) {
      `, r === 1 ? "" : `}
       rc = outputLoc;
       ` + s[r - 2] + ` += 1;
       if(` + s[r - 2] + " < " + this.outputShape[r - 2] + ") {", r === 1 ? "" : "  " + s[r - 1] + ` += 1;
         if(` + l + ") {"], d = r === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", p = "", f = 0, m = r === 1 ? 2 : 4; f < m; f++) p += `
        ` + h[f] + `
        if (` + d + `) {
          result[` + f + "] = float(" + t + `);
        } else {
          ` + a + ` source = rc - start;
          result[` + f + "] = getChannel(getX(" + u.join() + "), " + c + `);
        }
      `;
  p += r === 1 ? "} " : "}}", this.userCode = `
      const ` + a + " start = " + a + "(" + o + `);
      const ` + a + " end = " + a + "(" + i + `);

      void main() {
        ` + a + ` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ` + p + `
        setOutput(result);
      }
    `;
}, Oa = function(e, n, t, r, a) {
  if (r === void 0 && (r = !1), a === void 0 && (a = !1), this.variableNames = ["x"], n === "avg" && t) throw new Error("Cannot compute positions for average pool.");
  var o = e.filterWidth, i = e.strideHeight, s = e.strideWidth, u = e.dilationHeight, l = e.dilationWidth, c = e.effectiveFilterHeight, h = e.effectiveFilterWidth, d = e.padInfo.top, p = e.padInfo.left;
  this.outputShape = e.outShape;
  var f = n === "avg", m = "((batch  * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + d", g = "(xR * " + e.inWidth + " + xC) * " + e.inChannels + " + d", v = "0.0";
  if (f || (v = "-1.0 / 1e-20"), t) this.userCode = `
        const ivec2 strides = ivec2(` + i + ", " + s + `);
        const ivec2 pads = ivec2(` + d + ", " + p + `);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ` + c + `;
              wR += ` + u + `) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ` + e.inHeight + `) {
              continue;
            }

            for (int wC = 0; wC < ` + h + `;
                wC += ` + l + `) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ` + e.inWidth + `) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ` + (r ? a ? m : g : "wR * " + h + " + wC") + `;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
  else {
    var y = n + "(" + n + "(" + n + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    n === "avg" && (y = "avgValue / count");
    var b = 4 * Math.floor(o / 4), x = o % 4, C = `
      if (` + f + `) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(` + i + ", " + s + `);
      const ivec2 pads = ivec2(` + d + ", " + p + `);
      const float initializationValue = ` + v + `;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ` + e.inWidth + `) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(` + v + `);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ` + c + `;
            wR += ` + u + `) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ` + e.inHeight + `) {
            continue;
          }

          for (int wC = 0; wC < ` + b + `; wC += 4) {
            int xC = xCCorner + wC * ` + l + `;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ` + l + `, d),
              getValue(batch, xR, xC + 2 * ` + l + `, d),
              getValue(batch, xR, xC + 3 * ` + l + `, d)
            );

            ` + C + `
          }

          int xC = xCCorner + ` + b + `;
          if (` + (x === 1) + `) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ` + C + `
          } else if (` + (x === 2) + `) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ` + l + `, d),
              initializationValue,
              initializationValue
            );

            ` + C + `
          } else if (` + (x === 3) + `) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ` + l + `, d),
              getValue(batch, xR, xC + 2 * ` + l + `, d),
              initializationValue
            );

            ` + C + `
          }
        }
        setOutput(` + y + `);
      }
    `;
  }
}, Ui = function(e, n, t, r, a) {
  if (r === void 0 && (r = !1), a === void 0 && (a = !1), this.variableNames = ["x"], n === "avg" && t) throw new Error("Cannot compute positions for average pool.");
  var o = e.filterWidth, i = e.strideDepth, s = e.strideHeight, u = e.strideWidth, l = e.dilationDepth, c = e.dilationHeight, h = e.dilationWidth, d = e.effectiveFilterDepth, p = e.effectiveFilterHeight, f = e.effectiveFilterWidth, m = e.padInfo.front, g = e.padInfo.top, v = e.padInfo.left;
  this.outputShape = e.outShape;
  var y = n === "avg", b = "0.0";
  if (y || (b = "-1.0 / 1e-20"), t) this.userCode = `
        const ivec3 strides =
            ivec3(` + i + ", " + s + ", " + u + `);
        const ivec3 pads = ivec3(` + m + ", " + g + ", " + v + `);

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ` + d + `;
              wD += ` + l + `) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ` + e.inDepth + `) {
              continue;
            }

            for (int wR = 0; wR < ` + p + `;
                wR += ` + c + `) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ` + e.inHeight + `) {
                continue;
              }

              for (int wC = 0; wC < ` + f + `;
                  wC += ` + h + `) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ` + e.inWidth + `) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ` + (r ? a ? "(((batch * " + e.inDepth + " + xD) * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + ch" : "((xD * " + e.inHeight + " + xR) * " + e.inWidth + " + xC) * " + e.inChannels + " + ch" : "wD * " + p + " * " + f + ` +
                      wR * ` + f + " + wC") + `;
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
  else {
    var x = n + "(" + n + "(" + n + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    n === "avg" && (x = "avgValue / count");
    var C = 4 * Math.floor(o / 4), N = o % 4, T = `
      if (` + y + `) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(` + i + ", " + s + ", " + u + `);
      const ivec3 pads = ivec3(` + m + ", " + g + ", " + v + `);
      const float initializationValue = ` + b + `;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ` + e.inWidth + `) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(` + b + `);
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ` + d + `;
            wD += ` + l + `) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ` + e.inDepth + `) {
            continue;
          }

          for (int wR = 0; wR < ` + p + `;
            wR += ` + c + `) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ` + e.inHeight + `) {
              continue;
            }

            for (int wC = 0; wC < ` + C + `; wC += 4) {
              int xC = xCCorner + wC * ` + h + `;

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ` + h + `, ch),
                getValue(batch, xD, xR, xC + 2 * ` + h + `, ch),
                getValue(batch, xD, xR, xC + 3 * ` + h + `, ch)
              );

              ` + T + `
            }

            int xC = xCCorner + ` + C + `;
            if (` + (N === 1) + `) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ` + T + `
            } else if (` + (N === 2) + `) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ` + h + `, ch),
                initializationValue,
                initializationValue
              );

              ` + T + `
            } else if (` + (N === 3) + `) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ` + h + `, ch),
                getValue(batch, xD, xR, xC + 2 * ` + h + `, ch),
                initializationValue
              );

              ` + T + `
            }
          }
          setOutput(` + x + `);
        }
      }
    `;
  }
}, cy = function(e, n) {
  this.variableNames = ["x"];
  var t = e.windowSize, r = e.batchSize, a = e.inSize, o = Math.ceil(a / t);
  this.outputShape = [r, o];
  var i = "0.0", s = "";
  n === "prod" ? i = "1.0" : n === "min" ? (i = "1.0 / 1e-20", s = "min") : n === "max" && (i = "-1.0 / 1e-20", s = "max");
  var u = n + "(" + n + "(" + n + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
  n === "sum" ? u = "sumValue" : n === "prod" ? u = "prodValue" : n === "all" ? u = "allValue" : n === "any" && (u = "anyValue");
  var l = 4 * Math.floor(t / 4), c = t % 4, h = `
      if (` + (n === "sum") + `) {
        sumValue += dot(values, ones);
      } else if (` + (n === "prod") + `) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ` + s + `(values, minMaxValue);
      }
    `, d = "vec4";
  n === "all" ? (i = "1.0", h = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, d = "bvec4") : n === "any" && (i = "0.0", h = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, d = "bvec4");
  var p = "";
  a % t > 0 && (p = `
        if (inIdx < 0 || inIdx >= ` + a + `) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ` + i + `;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ` + p + `
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ` + t + `;

        vec4 minMaxValue = vec4(` + i + `);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ` + l + `; i += 4) {
          int inIdx = inOffset + i;
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ` + h + `
        }

        int inIdx = inOffset + ` + l + `;
        if (` + (c === 1) + `) {
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ` + h + `
        } else if (` + (c === 2) + `) {
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ` + h + `
        } else if (` + (c === 3) + `) {
          ` + d + " values = " + d + `(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ` + h + `
        }
        setOutput(` + u + `);
      }
    `;
}, hy = function(e, n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;
  for (var t = "", r = 0; r < 4; r++) {
    var a = "thisRC = rc;";
    r % 2 == 1 && (a += "thisRC.z += 1;"), r > 1 && (a += "thisRC.y += 1;"), t += `
        ` + a + `
        ` + (r > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + `
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[` + r + `] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ` + (r > 0 ? "}" : "") + `
      `;
  }
  this.userCode = `
      
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ` + gr(["r", "c", "d"], n) + `
      return ivec3(r, c, d);
    }
  
      ` + zu(e) + `

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ` + e[1] + `;
        int cols = ` + e[2] + `;

        ` + t + `

        setOutput(result);
      }
    `;
}, dy = function(e, n, t) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n.shape;
  var r = n.shape, a = r[1], o = r[2], i = e.shape, s = i[1], u = i[2], l = [t && s > 1 ? a - 1 : a, t && u > 1 ? o - 1 : o], c = [t && s > 1 ? s - 1 : s, t && u > 1 ? u - 1 : u], h = l[0] / c[0], d = l[1] / c[1], p = 1 / h, f = 1 / d, m = 2 * Math.ceil(p) + 2, g = 2 * Math.ceil(f) + 2;
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(` + h + `);
        const float widthScale = float(` + d + `);

        const float invHeightScale = float(` + p + `);
        const float invWidthScale = float(` + f + `);

        const int winHeight = int(` + m + `);
        const int winWidth = int(` + g + `);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ` + s + `) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ` + u + `) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ` + (a - 1) + `.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ` + (o - 1) + `.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
}, py = function(e, n, t, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var a = e[0], o = e[1], i = e[2], s = e[3];
  this.outputShape = [a, n, t, s];
  var u = [r && n > 1 ? o - 1 : o, r && t > 1 ? i - 1 : i], l = [r && n > 1 ? n - 1 : n, r && t > 1 ? t - 1 : t];
  this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ` + u[0] / l[0] + `,
          ` + u[1] / l[1] + `);
      const vec2 inputShapeRC = vec2(` + o + ".0, " + i + `.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
}, fy = function(e, n, t, r) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
  var a = e[0], o = e[1], i = e[2], s = e[3];
  this.outputShape = [a, n, t, s];
  var u = [r && n > 1 ? o - 1 : o, r && t > 1 ? i - 1 : i], l = [r && n > 1 ? n - 1 : n, r && t > 1 ? t - 1 : t];
  this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ` + u[0] / l[0] + `,
          ` + u[1] / l[1] + `,
          ` + u[1] / l[1] + `);
      const vec3 inputShapeRC = vec3(` + o + ".0, " + i + `.0,
                                     ` + i + `.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ` + (s - 1) + `;
        bool hasNextRow = coords.z < ` + (t - 1) + `;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
}, my = function(e, n, t) {
  this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n.shape;
  var r = n.shape, a = r[1], o = r[2], i = e.shape, s = i[1], u = i[2], l = [t && s > 1 ? a - 1 : a, t && u > 1 ? o - 1 : o], c = [t && s > 1 ? s - 1 : s, t && u > 1 ? u - 1 : u], h = l[0] / c[0], d = l[1] / c[1], p = 1 / h, f = 1 / d, m = 2 * Math.ceil(p) + 2, g = 2 * Math.ceil(f) + 2;
  this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(` + h + `);
        const float widthScale = float(` + d + `);

        const float invHeightScale = float(` + p + `);
        const float invWidthScale = float(` + f + `);

        const int winHeight = int(` + m + `);
        const int winWidth = int(` + g + `);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ` + s + `) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ` + u + `) {
              continue;
            }

            float sourceFracRow =
              float(` + l[0] + `) *
                (float(dyR) / float(` + c[0] + `));

            float sourceFracCol =
                float(` + l[1] + `) *
                  (float(dyC) / float(` + c[1] + `));

            int sourceNearestRow = int(min(
                float(int(` + a + `) - 1),
                ` + t + ` ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(` + o + `) - 1),
                ` + t + ` ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
}, gy = function(e, n, t, r) {
  this.variableNames = ["A"], this.outputShape = [];
  var a = e[0], o = e[1], i = e[2], s = e[3];
  this.outputShape = [a, n, t, s];
  var u = [r && n > 1 ? o - 1 : o, r && t > 1 ? i - 1 : i], l = [r && n > 1 ? n - 1 : n, r && t > 1 ? t - 1 : t], c = r ? "0.5" : "0.0";
  this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ` + u[0] / l[0] + `,
          ` + u[1] / l[1] + `);
      const vec2 inputShapeRC = vec2(` + o + ".0, " + i + `.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ` + c + `)));

        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
}, vy = function(e, n) {
  this.variableNames = ["x"];
  var t = e.length;
  if (t > 4) throw new Error("WebGL backend: Reverse of rank-" + t + " tensor is not yet supported");
  if (this.outputShape = e, t !== 1) {
    var r = e.map(function(o, i) {
      return function(s) {
        return n.indexOf(s) !== -1 && e[s] !== 1 ? e[s] + " - coords[" + s + "] - 1" : "coords[" + s + "]";
      }(i);
    }).join(","), a = De(t);
    this.userCode = `
      void main() {
        ` + a + ` coords = getOutputCoords();
        setOutput(getX(` + r + `));
      }
    `;
  } else this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(` + e[0] + ` - coord - 1));
        }
      `;
}, yy = function(e, n) {
  this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
  var t = e.length;
  if (t > 4) throw new Error("WebGL backend: Reverse of rank-" + t + " tensor is not yet supported");
  this.outputShape = e;
  var r = yt("rc", t), a = r[t - 1] + " + 1 < " + this.outputShape[t - 1], o = r[t - 2] + " + 1 < " + this.outputShape[t - 2], i = De(t);
  function s(u) {
    var l = e.map(function(c, h) {
      return function(d, p) {
        return n.indexOf(d) !== -1 && e[d] !== 1 ? e[d] + " - " + p[d] + " - 1" : "" + p[d];
      }(h, u);
    });
    return "getChannel(getX(" + l.join(",") + "), vec2(" + l.slice(-2).join(",") + "))";
  }
  this.userCode = t === 1 ? `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(` + e[0] + ` - rc - 1),
            ` + e[0] + ` - rc - 1);
          if(` + a + `){
              result.g = getChannel(getX(` + e[0] + ` - (rc  + 1) - 1),
                ` + e[0] + ` - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : `
        void main() {
          ` + i + ` rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ` + function(u) {
    return s(u);
  }(r.slice()) + `;
          if(` + a + `){
            result.g = ` + function(u) {
    return u[t - 1] = "(" + u[t - 1] + " + 1)", s(u);
  }(r.slice()) + `;
          }
          if(` + o + `) {
            result.b = ` + function(u) {
    return u[t - 2] = "(" + u[t - 2] + " + 1)", s(u);
  }(r.slice()) + `;
            if(` + a + `) {
              result.a = ` + function(u) {
    return u[t - 1] = "(" + u[t - 1] + " + 1)", u[t - 2] = "(" + u[t - 2] + " + 1)", s(u);
  }(r.slice()) + `;
            }
          }
          setOutput(result);
        }
    `;
}, Xl = function(e, n, t, r, a, o, i) {
  this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = o;
  var s = De(a.length), u = De(o.length), l = "";
  t === 1 ? l = "i" : t === 2 && (l = "i, j");
  var c = "getIndices(" + l + ")", h = "";
  r === 1 ? h = "i" : r === 2 && (h = "i, coords[1]");
  var d = "getUpdates(" + h + ")", p = n > 1 ? "strides[j]" : "strides";
  this.userCode = `
        ` + s + " strides = " + s + "(" + a + `);

        void main() {
          ` + u + ` coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ` + e + `; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ` + n + `; j++) {
              int index = round(` + c + `);
              flattenedIndex += index * ` + p + `;
            }
            if (flattenedIndex == coords[0]) {
              sum += ` + d + `;
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
}, by = function(e, n) {
  this.variableNames = ["x", "segmentIds"];
  var t = e.windowSize, r = e.batchSize, a = e.inSize, o = e.numSegments, i = o * Math.ceil(a / t);
  this.outputShape = [r, i];
  var s = 4 * Math.floor(t / 4), u = t % 4, l = `
        sumValue += dot(values, segFilter);
    `, c = "";
  a % t > 0 && (c = `
        if (inIdx < 0 || inIdx >= ` + a + `) {
          return initializationValue;
        }
      `);
  var h = "";
  a % t > 0 && (h = `
        if (inIdx < 0 || inIdx >= ` + a + `) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ` + c + `
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ` + h + `
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ` + o + ")) * float(" + t + `));
        int currentSeg = int(mod(float(outIdx), float(` + o + `)));

        float sumValue = 0.0;

        for (int i = 0; i < ` + s + `; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ` + l + `
        }

        int inIdx = inOffset + ` + s + `;
        if (` + (u === 1) + `) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ` + l + `
        } else if (` + (u === 2) + `) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ` + l + `
        } else if (` + (u === 3) + `) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ` + l + `
        }
        setOutput(sumValue);
      }
    `;
}, xy = function(e, n, t) {
  var r, a;
  if (this.variableNames = ["c", "a", "b"], this.outputShape = n, t > 4) throw Error("Where for rank " + t + " is not yet supported");
  if (t === 1) a = "resRC", r = "resRC";
  else {
    for (var o = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], i = [], s = [], u = 0; u < n.length; u++) s.push("" + o[u]), u < e && i.push("" + o[u]);
    r = i.join(), a = s.join();
  }
  var l = De(t);
  this.userCode = `
      void main() {
        ` + l + ` resRC = getOutputCoords();
        float cVal = getC(` + r + `);
        if (cVal >= 1.0) {
          setOutput(getA(` + a + `));
        } else {
          setOutput(getB(` + a + `));
        }
      }
    `;
}, wy = function() {
  function e(n) {
    this.variableNames = ["source"], this.outputShape = n, this.rank = n.length;
    var t, r = De(this.rank), a = "uniform int start[" + this.rank + "];", o = function(i) {
      if (i === 1) return "sourceLoc";
      if (i <= 6) return Ki.slice(0, i).map(function(s) {
        return "sourceLoc." + s;
      }).join(",");
      throw Error("Slicing for rank " + i + " is not yet supported");
    }(this.rank);
    t = `
        ` + r + ` sourceLoc;
        ` + r + ` coords = getOutputCoords();
        ` + n.map(function(i, s) {
      return "sourceLoc." + Ki[s] + " = start[" + s + "] + coords." + Ki[s] + ";";
    }).join(`
`) + `
      `, this.userCode = `
      ` + a + `
      void main() {
        ` + t + `
        setOutput(getSource(` + o + `));
      }
    `;
  }
  return e.prototype.getCustomSetupFunc = function(n) {
    var t = this;
    if (n.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + n.length + ")");
    return function(r, a) {
      t.startLoc == null && (t.startLoc = r.getUniformLocationNoThrow(a, "start"), t.startLoc == null) || r.gl.uniform1iv(t.startLoc, n);
    };
  }, e;
}(), Ki = ["x", "y", "z", "w", "u", "v"], Cy = function() {
  function e(n) {
    this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n, this.rank = n.length;
    var t = De(this.rank), r = yt("coords", this.rank), a = yt("sourceLoc", this.rank), o = this.rank === 1 ? "sourceLoc" : "vec2(" + a.slice(-2).join() + ")", i = "getChannel(getSource(" + a.join() + "), " + o + ")", s = `
      result.x = ` + i + `;
      if (++` + r[this.rank - 1] + " < " + n[this.rank - 1] + `) {
        ++` + a[this.rank - 1] + `;
        result.y = ` + i + `;
        --` + a[this.rank - 1] + `;
      }
    `, u = this.rank === 1 ? "" : `
      --` + r[this.rank - 1] + `;
      if (++` + r[this.rank - 2] + " < " + n[this.rank - 2] + `) {
        ++` + a[this.rank - 2] + `;
        result.z = ` + i + `;
        if (++` + r[this.rank - 1] + " < " + n[this.rank - 1] + `) {
          ++` + a[this.rank - 1] + `;
          result.w = ` + i + `;
        }
      }
    `, l = this.rank <= 4 ? `sourceLoc = coords +
            ` + t + "(" + n.map(function(c, h) {
      return "start[" + h + "]";
    }).join() + ");" : n.map(function(c, h) {
      return a[h] + " = " + r[h] + " + start[" + h + "];";
    }).join(`
`);
    this.userCode = `
      uniform int start[` + this.rank + `];
      void main() {
        ` + t + ` coords = getOutputCoords();
        ` + t + ` sourceLoc;
        ` + l + `
        vec4 result = vec4(0.);
        ` + s + `
        ` + u + `
        setOutput(result);
      }
    `;
  }
  return e.prototype.getCustomSetupFunc = function(n) {
    var t = this;
    if (n.length !== this.rank) throw Error("The rank (" + this.rank + ") of the program must match the length of start (" + n.length + ")");
    return function(r, a) {
      t.startLoc == null && (t.startLoc = r.getUniformLocationNoThrow(a, "start"), t.startLoc == null) || r.gl.uniform1iv(t.startLoc, n);
    };
  }, e;
}(), ky = function(e, n, t) {
  this.variableNames = ["x"], this.outputShape = t;
  var r = t.length, a = De(t.length), o = De(t.length), i = "";
  if (r === 1) i = "coords * strides + begin";
  else {
    var s = 0;
    i = t.map(function(u, l) {
      return s++, t.length === 1 ? "coords * strides[" + l + "] + begin[" + l + "]" : "coords[" + (s - 1) + "] * strides[" + l + "] + begin[" + l + "]";
    }).join(",");
  }
  this.userCode = `
      ` + a + " begin = " + a + "(" + e + `);
      ` + a + " strides = " + a + "(" + n + `);

      void main() {
        ` + o + ` coords = getOutputCoords();
        setOutput(getX(` + i + `));
      }
    `;
}, Ny = function() {
  function e(n) {
    this.gpgpu = n, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};
  }
  return e.prototype.acquireTexture = function(n, t, r) {
    var a, o = Ql(t, r), i = Yl(n, o, r);
    if (i in this.freeTextures || (this.freeTextures[i] = []), i in this.usedTextures || (this.usedTextures[i] = []), this.freeTextures[i].length > 0) {
      this.numFreeTextures--, this.numUsedTextures++, this.log();
      var s = this.freeTextures[i].shift();
      return this.usedTextures[i].push(s), s;
    }
    return this.numUsedTextures++, this.log(), o === St.PACKED_2X2_FLOAT32 ? a = this.gpgpu.createPackedMatrixTexture(n[0], n[1]) : o === St.PACKED_2X2_FLOAT16 ? a = this.gpgpu.createFloat16PackedMatrixTexture(n[0], n[1]) : o === St.UNPACKED_FLOAT32 ? a = this.gpgpu.createFloat32MatrixTexture(n[0], n[1]) : o === St.UNPACKED_FLOAT16 ? a = this.gpgpu.createFloat16MatrixTexture(n[0], n[1]) : o === St.PACKED_4X1_UNSIGNED_BYTE && (a = this.gpgpu.createUnsignedBytesMatrixTexture(n[0], n[1])), this.usedTextures[i].push(a), a;
  }, e.prototype.releaseTexture = function(n, t, r, a) {
    if (this.freeTextures != null) {
      var o = Yl(t, Ql(r, a), a);
      o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(n), this.numFreeTextures++, this.numUsedTextures--;
      var i = this.usedTextures[o], s = i.indexOf(n);
      if (s < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
      i.splice(s, 1), this.log();
    }
  }, e.prototype.log = function() {
    if (this.logEnabled) {
      var n = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", this.numFreeTextures + " / " + this.numUsedTextures, "(" + n + ")");
    }
  }, e.prototype.getNumUsedTextures = function() {
    return this.numUsedTextures;
  }, e.prototype.getNumFreeTextures = function() {
    return this.numFreeTextures;
  }, e.prototype.dispose = function() {
    var n = this;
    if (this.freeTextures != null) {
      for (var t in this.freeTextures) this.freeTextures[t].forEach(function(r) {
        n.gpgpu.deleteMatrixTexture(r);
      });
      for (var t in this.usedTextures) this.usedTextures[t].forEach(function(a) {
        n.gpgpu.deleteMatrixTexture(a);
      });
      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;
    }
  }, e;
}();
function Ql(e, n) {
  if (e === Ot.UPLOAD) return St.PACKED_2X2_FLOAT32;
  if (e === Ot.RENDER || e == null) return function(t) {
    return _().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? t ? St.PACKED_2X2_FLOAT32 : St.UNPACKED_FLOAT32 : t ? St.PACKED_2X2_FLOAT16 : St.UNPACKED_FLOAT16;
  }(n);
  if (e === Ot.DOWNLOAD || e === Ot.PIXELS) return St.PACKED_4X1_UNSIGNED_BYTE;
  throw new Error("Unknown logical texture type " + e);
}
function Yl(e, n, t) {
  return e[0] + "_" + e[1] + "_" + n + "_" + t;
}
var Ay = function(e, n) {
  this.variableNames = ["A"];
  for (var t = new Array(e.length), r = 0; r < t.length; r++) t[r] = e[r] * n[r];
  this.outputShape = t, this.rank = t.length;
  var a = De(this.rank), o = function(i) {
    var s = i.length;
    if (s > 5) throw Error("Tile for rank " + s + " is not yet supported");
    if (s === 1) return "imod(resRC, " + i[0] + ")";
    for (var u = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], l = [], c = 0; c < i.length; c++) l.push("imod(" + u[c] + ", " + i[c] + ")");
    return l.join();
  }(e);
  this.userCode = `
      void main() {
        ` + a + ` resRC = getOutputCoords();
        setOutput(getA(` + o + `));
      }
    `;
}, Gu = 1.7580993408473768, Hu = 1.0507009873554805, le = function(e, n) {
  this.variableNames = ["A"], this.outputShape = e, this.userCode = `
      float unaryOperation(float x) {
        ` + n + `
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
}, tn = "if (isnan(x)) return x;", Iy = "return x;", Zl = "return abs(x);", rf = tn + `
  return (x < 0.0) ? 0.0 : x;
`, af = tn + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, of = "return (x >= 0.0) ? x : (exp(x) - 1.0);", Ey = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ` + Gu + `;
  float scale = ` + Hu + `;
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`, ec = "return -x;", tc = "return ceil(x);", nc = "return floor(x);", rc = "return exp(x);", ac = "return exp(x) - 1.0;", Ty = tn + `
  return sin(x);
`, Py = tn + `
  return cos(x);
`, Sy = tn + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`, Dy = tn + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`, Oy = tn + `
  return atan(x);
`, Ry = tn + "return log(x + sqrt(x * x + 1.0));", Fy = tn + `
  if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`, My = tn + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`, uo = "return x;", _y = "return x;", sf = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, uf = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, lf = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, Ca = function(e, n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ` + n + `
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
}, By = function(e) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = e;
  var n = e.length, t = yt("rc", n), r = De(n), a = function(s, u) {
    if (s === 1) return "rc";
    for (var l = "", c = 0; c < s; c++) l += u[c], c < s - 1 && (l += ",");
    return l;
  }(n, t), o = t.slice(-2), i = n <= 1 ? "rc" : "vec2(" + o.join(",") + ")";
  this.userCode = `
      void main() {
        ` + r + ` rc = getOutputCoords();
        vec4 packedInput = getA(` + a + `);

        setOutput(getChannel(packedInput, ` + i + `));
      }
    `;
}, lo = {};
function co(e, n) {
  if (n === void 0 && (n = !1), e === "linear") return n ? _y : Iy;
  if (e === "relu") return n ? sf : rf;
  if (e === "elu") return n ? lf : of;
  if (e === "relu6") return n ? uf : af;
  if (e === "prelu") return n ? nf : tf;
  throw new Error("Activation " + e + " has not been implemented for the WebGL backend.");
}
var jy = 600, Vy = function(e) {
  function n(t) {
    var r, a = e.call(this) || this;
    if (a.pendingRead = /* @__PURE__ */ new WeakMap(), a.pendingDisposal = /* @__PURE__ */ new WeakSet(), a.dataRefCount = /* @__PURE__ */ new WeakMap(), a.numBytesInGPU = 0, a.uploadWaitMs = 0, a.downloadWaitMs = 0, a.warnedAboutMemory = !1, a.pendingDeletes = 0, a.disposed = !1, !_().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
    if (t == null) {
      var o = pn(_().getNumber("WEBGL_VERSION"));
      a.binaryCache = ((r = _().getNumber("WEBGL_VERSION")) in lo || (lo[r] = {}), lo[r]), a.gpgpu = new Y0(o), a.canvas = o.canvas, a.gpgpuCreatedLocally = !0;
    } else a.gpgpu = t, a.binaryCache = {}, a.gpgpuCreatedLocally = !1, a.canvas = t.gl.canvas;
    return a.textureManager = new Ny(a.gpgpu), a.numMBBeforeWarning = _().global.screen == null ? 1024 : _().global.screen.height * _().global.screen.width * window.devicePixelRatio * jy / 1024 / 1024, a.texData = new Hp(a, D), a;
  }
  return en(n, e), n.prototype.numDataIds = function() {
    return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;
  }, n.prototype.write = function(t, r, a) {
    if (_().getBool("DEBUG") && this.checkNumericalProblems(t), a === "complex64" && t != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    var o = {};
    return this.texData.set(o, { shape: r, dtype: a, values: t, usage: Ot.UPLOAD }), o;
  }, n.prototype.move = function(t, r, a, o) {
    if (_().getBool("DEBUG") && this.checkNumericalProblems(r), o === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this.texData.set(t, { shape: a, dtype: o, values: r, usage: Ot.UPLOAD });
  }, n.prototype.readSync = function(t) {
    var r = this.texData.get(t), a = r.values, o = r.dtype, i = r.complexTensors, s = r.slice, u = r.shape, l = r.isPacked;
    if (s != null) {
      var c = void 0;
      c = l ? new Ca(u, uo) : new le(u, uo);
      var h = this.runWebGLProgram(c, [{ dataId: t, shape: u, dtype: o }], o), d = this.readSync(h.dataId);
      return this.disposeData(h.dataId), d;
    }
    if (a != null) return this.convertAndCacheOnCPU(t);
    if (o === "string") return a;
    var p, f, m = this.activeTimers != null;
    return m && (p = Jt()), o === "complex64" ? f = Fs(i.real.dataSync(), i.imag.dataSync()) : f = this.getValuesFromTexture(t), m && (this.downloadWaitMs += Jt() - p), this.convertAndCacheOnCPU(t, f);
  }, n.prototype.read = function(t) {
    return Y(this, void 0, void 0, function() {
      var r, a, o, i, s, u, l, c, h, d, p, f, m, g, v, y, b, x, C, N, T, I;
      return Z(this, function(E) {
        switch (E.label) {
          case 0:
            if (this.pendingRead.has(t)) return r = this.pendingRead.get(t), [2, new Promise(function(P) {
              return r.push(P);
            })];
            if (a = this.texData.get(t), o = a.values, i = a.shape, s = a.slice, u = a.dtype, l = a.complexTensors, c = a.isPacked, s != null) return h = void 0, h = c ? new Ca(i, uo) : new le(i, uo), d = this.runWebGLProgram(h, [{ dataId: t, shape: i, dtype: u }], u), p = this.read(d.dataId), this.disposeData(d.dataId), [2, p];
            if (o != null) return [2, this.convertAndCacheOnCPU(t)];
            if (!_().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && _().getNumber("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
            return f = null, u !== "complex64" && _().get("WEBGL_BUFFER_SUPPORTED") && (m = this.decode(t), g = this.texData.get(m.dataId), f = (I = this.gpgpu).createBufferFromTexture.apply(I, [g.texture].concat(Sa(i)))), this.pendingRead.set(t, []), u === "complex64" ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];
          case 1:
            E.sent(), E.label = 2;
          case 2:
            return u !== "complex64" ? [3, 4] : [4, Promise.all([l.real.data(), l.imag.data()])];
          case 3:
            return y = E.sent(), b = y[0], x = y[1], v = Fs(b, x), [3, 5];
          case 4:
            f == null ? v = this.getValuesFromTexture(t) : (C = Q(i), v = this.gpgpu.downloadFloat32MatrixFromBuffer(f, C)), E.label = 5;
          case 5:
            return m != null && this.disposeData(m.dataId), N = this.convertAndCacheOnCPU(t, v), T = this.pendingRead.get(t), this.pendingRead.delete(t), T.forEach(function(P) {
              return P(N);
            }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, N];
        }
      });
    });
  }, n.prototype.checkNumericalProblems = function(t) {
    if (t != null) for (var r = 0; r < t.length; r++) {
      var a = t[r];
      if (!Bg(a))
        throw _().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error("The value " + a + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'") : Error("The value " + a + " cannot be represented on this device.");
    }
  }, n.prototype.getValuesFromTexture = function(t) {
    var r, a = this.texData.get(t), o = a.shape, i = a.dtype, s = a.isPacked, u = Q(o);
    if (_().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      var l = this.decode(t), c = this.texData.get(l.dataId), h = (r = this.gpgpu).downloadMatrixFromPackedTexture.apply(r, [c.texture].concat(Sa(o))).subarray(0, u);
      return this.disposeData(l.dataId), h;
    }
    var d = _().getBool("WEBGL_PACK") && s === !0, p = d ? zi(o) : o, f = d ? new T0(p) : new E0(p), m = this.runWebGLProgram(f, [{ shape: p, dtype: i, dataId: t }], "float32"), g = this.texData.get(m.dataId), v = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(g.texture, g.texShape[0], g.texShape[1]).subarray(0, u);
    return this.disposeData(m.dataId), v;
  }, n.prototype.time = function(t) {
    return Y(this, void 0, void 0, function() {
      var r, a, o, i, s, u, l;
      return Z(this, function(c) {
        switch (c.label) {
          case 0:
            return r = this.activeTimers, a = [], o = !1, this.programTimersStack == null ? (this.programTimersStack = a, o = !0) : this.activeTimers.push(a), this.activeTimers = a, t(), i = Nr(this.activeTimers.map(function(h) {
              return h.query;
            })).filter(function(h) {
              return h != null;
            }), s = Nr(this.activeTimers.map(function(h) {
              return h.name;
            })).filter(function(h) {
              return h != null;
            }), this.activeTimers = r, o && (this.programTimersStack = null), u = { uploadWaitMs: this.uploadWaitMs, downloadWaitMs: this.downloadWaitMs, kernelMs: null, wallMs: null }, _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [4, Promise.all(i)] : [3, 2];
          case 1:
            return l = c.sent(), u.kernelMs = Fd(l), u.getExtraProfileInfo = function() {
              return l.map(function(h, d) {
                return { name: s[d], ms: h };
              }).map(function(h) {
                return h.name + ": " + h.ms;
              }).join(", ");
            }, [3, 3];
          case 2:
            u.kernelMs = { error: "WebGL query timers are not supported in this environment." }, c.label = 3;
          case 3:
            return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, u];
        }
      });
    });
  }, n.prototype.memory = function() {
    return { unreliable: !1, numBytesInGPU: this.numBytesInGPU };
  }, n.prototype.startTimer = function() {
    return _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : { startMs: Jt(), endMs: null };
  }, n.prototype.endTimer = function(t) {
    return _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = Jt(), t);
  }, n.prototype.getQueryTime = function(t) {
    return Y(this, void 0, void 0, function() {
      var r;
      return Z(this, function(a) {
        return _().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (r = t).endMs - r.startMs];
      });
    });
  }, n.prototype.disposeData = function(t) {
    if (!this.pendingDisposal.has(t)) {
      if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;
      if (this.texData.has(t)) {
        this.releaseGPUData(t);
        var r = this.texData.get(t).complexTensors;
        r != null && (r.real.dispose(), r.imag.dispose()), this.texData.delete(t);
      }
    }
  }, n.prototype.releaseGPUData = function(t) {
    var r = this.texData.get(t), a = r.texture, o = r.dtype, i = r.texShape, s = r.usage, u = r.isPacked, l = r.slice, c = l && l.origDataId || t, h = this.dataRefCount.get(c);
    h > 1 ? this.dataRefCount.set(c, h - 1) : (this.dataRefCount.delete(c), a != null && (this.numBytesInGPU -= this.computeBytes(i, o), this.textureManager.releaseTexture(a, i, s, u)));
    var d = this.texData.get(t);
    d.texture = null, d.texShape = null, d.isPacked = !1, d.slice = null;
  }, n.prototype.getTexture = function(t) {
    return this.uploadToGPU(t), this.texData.get(t).texture;
  }, n.prototype.getDataInfo = function(t) {
    return this.texData.get(t);
  }, n.prototype.getCPUBackend = function() {
    return _().getBool("WEBGL_CPU_FORWARD") ? (this.cpuBackend == null && (this.cpuBackend = D.findBackend("cpu")), this.cpuBackend) : null;
  }, n.prototype.shouldExecuteOnCPU = function(t, r) {
    var a = this;
    return r === void 0 && (r = 128), this.getCPUBackend() != null && t.every(function(o) {
      return a.texData.get(o.dataId).texture == null && Q(o.shape) < r;
    });
  }, n.prototype.getGPGPUContext = function() {
    return this.gpgpu;
  }, n.prototype.complex = function(t, r) {
    var a = this.makeOutput(t.shape, "complex64");
    return this.texData.get(a.dataId).complexTensors = { real: D.keep(t.clone()), imag: D.keep(r.clone()) }, a;
  }, n.prototype.real = function(t) {
    return this.texData.get(t.dataId).complexTensors.real.clone();
  }, n.prototype.imag = function(t) {
    return this.texData.get(t.dataId).complexTensors.imag.clone();
  }, n.prototype.slice = function(t, r, a) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, r, a);
    if (Q(a) === 0) return rt([], a, t.dtype);
    var o = this.texData.get(t.dataId).isPacked, i = Lp(t.shape, r, a);
    if (o || !i) {
      var s = _().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Cy(a) : new wy(a), u = s.getCustomSetupFunc(r);
      return this.compileAndRun(s, [t], null, u);
    }
    return this.uploadToGPU(t.dataId), this.shallowSlice(t, r, a);
  }, n.prototype.shallowSlice = function(t, r, a) {
    var o = this.texData.get(t.dataId), i = this.makeOutput(a, t.dtype), s = this.texData.get(i.dataId);
    Object.assign(s, o), s.shape = a, s.dtype = t.dtype;
    var u = zp(r, t.strides);
    o.slice && (u += o.slice.flatOffset), s.slice = { flatOffset: u, origDataId: o.slice && o.slice.origDataId || t.dataId };
    var l = this.dataRefCount.get(s.slice.origDataId) || 1;
    return this.dataRefCount.set(s.slice.origDataId, l + 1), i;
  }, n.prototype.stridedSlice = function(t, r, a, o) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, r, a, o);
    var i = _u(r, a, o);
    if (i.some(function(u) {
      return u === 0;
    })) return rt([], i);
    var s = new ky(r, o, i);
    return this.compileAndRun(s, [t]);
  }, n.prototype.reverse = function(t, r) {
    var a = _().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new yy(t.shape, r) : new vy(t.shape, r);
    return this.compileAndRun(a, [t]);
  }, n.prototype.concat = function(t, r) {
    if (t[0].dtype === "complex64") {
      var a = t.map(function(p) {
        return Dt(p);
      }), o = t.map(function(p) {
        return Xt(p);
      });
      return nt(this.concat(a, r), this.concat(o, r));
    }
    if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, r);
    if (t.length === 1) return t[0];
    if (t.length > _().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var i = Math.floor(t.length / 2), s = this.concat(t.slice(0, i), r), u = this.concat(t.slice(i), r);
      return this.concat([s, u], r);
    }
    if (_().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && t[0].rank > 1) {
      var l = new p0(t.map(function(p) {
        return p.shape;
      }), r);
      return this.compileAndRun(l, t);
    }
    var c = la(t.map(function(p) {
      return p.shape;
    }), r), h = t.map(function(p) {
      return p.as2D(-1, Q(p.shape.slice(r)));
    }), d = new d0(h.map(function(p) {
      return p.shape;
    }));
    return this.compileAndRun(d, h).reshape(c);
  }, n.prototype.neg = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, ec, t.dtype);
    var r = new le(t.shape, ec);
    return this.compileAndRun(r, [t]);
  }, n.prototype.batchMatMul = function(t, r, a, o) {
    var i = a ? t.shape[2] : t.shape[1], s = o ? r.shape[1] : r.shape[2], u = a ? t.shape[1] : t.shape[2], l = t.shape[0];
    if ((i === 1 || s === 1) && u > 1e3) {
      a && (t = Lt(t, [0, 2, 1])), o && (r = Lt(r, [0, 2, 1]));
      var c = s === 1 ? t : t.as3D(l, u, 1), h = s === 1 ? 2 : 1, d = s === 1 ? r.as3D(l, 1, u) : r;
      return this.multiply(c, d).sum(h, !0);
    }
    var p = st(t.dtype, r.dtype), f = new $i(t.shape, [l, i, s], a, o);
    return this.compileAndRun(f, [t, r], p);
  }, n.prototype.fusedBatchMatMul = function(t) {
    var r = t.a, a = t.b, o = t.transposeA, i = t.transposeB, s = t.bias, u = t.activation, l = t.preluActivationWeights, c = o ? r.shape[2] : r.shape[1], h = i ? a.shape[1] : a.shape[2], d = r.shape[0], p = st(r.dtype, a.dtype), f = s != null, m = l != null, g = u ? co(u, !0) : null, v = new $i(r.shape, [d, c, h], o, i, f, g, m), y = [r, a];
    return s && y.push(s), l && y.push(l), this.compileAndRun(v, y, p);
  }, n.prototype.multiply = function(t, r) {
    if (t.dtype === "complex64") {
      var a = this.texData.get(t.dataId), o = this.texData.get(r.dataId), i = new Gl(o0, t.shape, r.shape), s = new Gl(i0, t.shape, r.shape), u = [this.makeComplexComponentTensorInfo(t, a.complexTensors.real), this.makeComplexComponentTensorInfo(t, a.complexTensors.imag), this.makeComplexComponentTensorInfo(r, o.complexTensors.real), this.makeComplexComponentTensorInfo(r, o.complexTensors.imag)], l = this.compileAndRun(i, u), c = this.compileAndRun(s, u), h = this.complex(l, c);
      return l.dispose(), c.dispose(), h;
    }
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.multiply(t, r);
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, Hl, t.dtype);
    var d = new Ge(Hl, t.shape, r.shape);
    return this.compileAndRun(d, [t, r], t.dtype);
  }, n.prototype.batchNormalization = function(t, r, a, o, i, s) {
    var u = [t, r, a], l = null;
    s != null && (l = s.shape, u.push(s));
    var c = null;
    if (i != null && (c = i.shape, u.push(i)), _().getBool("WEBGL_PACK_NORMALIZATION")) {
      var h = new a0(t.shape, r.shape, a.shape, l, c, o);
      return this.compileAndRun(h, u);
    }
    var d = new r0(t.shape, r.shape, a.shape, l, c, o);
    return this.compileAndRun(d, u);
  }, n.prototype.localResponseNormalization4D = function(t, r, a, o, i) {
    var s = _().getBool("WEBGL_PACK_NORMALIZATION") ? new ny(t.shape, r, a, o, i) : new ey(t.shape, r, a, o, i);
    return this.compileAndRun(s, [t]);
  }, n.prototype.LRNGrad = function(t, r, a, o, i, s, u) {
    var l = new ty(r.shape, o, i, s, u);
    return this.compileAndRun(l, [r, a, t]);
  }, n.prototype.tile = function(t, r) {
    if (t.dtype === "string") {
      var a = this.readSync(t.dataId).map(function(i) {
        return _a(i);
      });
      return Xp(oe(t.shape, t.dtype, a), r);
    }
    var o = new Ay(t.shape, r);
    return this.compileAndRun(o, [t]);
  }, n.prototype.pad = function(t, r, a) {
    var o = _().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ly(t.shape, r, a) : new uy(t.shape, r, a);
    return this.compileAndRun(o, [t]);
  }, n.prototype.gather = function(t, r, a) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.gather(t, r, a);
    var o = new F0(t.shape, r.size, a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.batchToSpaceND = function(t, r, a) {
    A(t.rank <= 4, function() {
      return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet";
    });
    var o = r.reduce(function(h, d) {
      return h * d;
    }), i = Jo(t.shape, r, o), s = Xo(i.length, r.length), u = Qo(t.shape, r, o), l = tp(a, r.length), c = np(u, a, r.length);
    return Lt(t.reshape(i), s).reshape(u).slice(l, c);
  }, n.prototype.spaceToBatchND = function(t, r, a) {
    A(t.rank <= 4, function() {
      return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet";
    });
    var o = r.reduce(function(d, p) {
      return d * p;
    }), i = [[0, 0]];
    i.push.apply(i, a);
    for (var s = 1 + r.length; s < t.shape.length; ++s) i.push([0, 0]);
    var u = t.pad(i), l = Jo(u.shape, r, o, !1), c = Xo(l.length, r.length, !1), h = Qo(u.shape, r, o, !1);
    return Lt(u.reshape(l), c).reshape(h);
  }, n.prototype.reduce = function(t, r, a) {
    var o = t.shape[0], i = t.shape[1], s = Gi(i), u = new cy({ windowSize: s, inSize: i, batchSize: o }, r), l = this.compileAndRun(u, [t], a);
    return l.shape[1] === 1 ? l : this.reduce(l, r, a);
  }, n.prototype.argReduce = function(t, r, a) {
    a === void 0 && (a = null);
    var o = t.shape[0], i = t.shape[1];
    a != null && (o = a.shape[0], i = a.shape[1]);
    var s = Gi(i), u = new qv({ windowSize: s, inSize: i, batchSize: o }, r, a == null), l = [t];
    a != null && l.push(a);
    var c = this.compileAndRun(u, l, "int32");
    return c.shape[1] === 1 ? c : this.argReduce(t, r, c);
  }, n.prototype.argReducePacked = function(t, r, a) {
    a === void 0 && (a = null);
    var o = a != null ? a.shape : t.shape, i = Gi(o[o.length - 1]), s = new e0(o, i, r, a == null), u = a == null ? [t] : [t, a], l = this.compileAndRun(s, u, "int32");
    return l.rank === t.rank ? this.argReducePacked(t, r, l) : l;
  }, n.prototype.sum = function(t, r) {
    Tt("sum", r, t.rank);
    var a = ct(t.shape, r), o = a[0], i = Q(a[1]), s = t.as2D(-1, i), u = Fi(t.dtype);
    return this.reduce(s, "sum", u).reshape(o);
  }, n.prototype.prod = function(t, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, r);
    var a = ct(t.shape, r), o = a[0], i = Q(a[1]), s = t.as2D(-1, i), u = Fi(t.dtype);
    return this.reduce(s, "prod", u).reshape(o);
  }, n.prototype.unsortedSegmentSum = function(t, r, a) {
    var o = 0, i = fn([o], t.rank), s = t;
    i != null && (s = Lt(t, i), o = mn(1, t.rank)[0]);
    var u = function(p, f, m) {
      for (var g = [], v = p.length, y = 0; y < v; y++) y !== f ? g.push(p[y]) : g.push(m);
      return g;
    }(s.shape, o, a), l = Q([s.shape[o]]), c = s.as2D(-1, l), h = Fi(t.dtype), d = this.segOpCompute(c, "unsortedSegmentSum", r, h, a).reshape(u);
    return i != null && (d = Lt(d, Tu(i))), d;
  }, n.prototype.segOpCompute = function(t, r, a, o, i) {
    var s = t.shape[0], u = t.shape[1], l = function(d, p) {
      var f, m = !1;
      for (d <= Vp ? (f = d, m = !0) : f = Go(d, Math.floor(Math.sqrt(d))); !m; ) f > p || f === d ? m = !0 : f = Go(d, f + 1);
      return f;
    }(u, i), c = new by({ windowSize: l, inSize: u, batchSize: s, numSegments: i }), h = this.compileAndRun(c, [t, a], o);
    return h.shape[1] === i ? h : (a = Va(0, i).tile([u / l]), this.segOpCompute(h, r, a, o, i));
  }, n.prototype.argMinMaxReduce = function(t, r, a) {
    var o = [r];
    if (Tt("arg" + a.charAt(0).toUpperCase() + a.slice(1), o, t.rank), !_().getBool("WEBGL_PACK_REDUCE") || t.rank <= 2) {
      var i = ct(t.shape, o), s = i[0], u = Q(i[1]), l = t.as2D(-1, u);
      return this.argReduce(l, a).reshape(s);
    }
    return this.argReducePacked(t, a);
  }, n.prototype.argMin = function(t, r) {
    return this.argMinMaxReduce(t, r, "min");
  }, n.prototype.argMax = function(t, r) {
    return this.argMinMaxReduce(t, r, "max");
  }, n.prototype.cumsum = function(t, r, a, o) {
    if (r !== t.rank - 1) throw new Error("WebGL cumsum shader expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + r);
    var i = new C0(t.shape, a, o);
    return this.compileAndRun(i, [t]);
  }, n.prototype.equal = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(equal(a, b));
`, "bool");
    var a = new Ge("return float(a == b);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.notEqual = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(notEqual(a, b));
`, "bool");
    var a = new Ge("return float(a != b);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.less = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.less(t, r);
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(lessThan(a, b));
`, "bool");
    var a = new Ge("return float(a < b);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.lessEqual = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(lessThanEqual(a, b));
`, "bool");
    var a = new Ge("return float(a <= b);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.greater = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.greater(t, r);
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(greaterThan(a, b));
`, "bool");
    var a = new Ge("return float(a > b);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.greaterEqual = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(greaterThanEqual(a, b));
`, "bool");
    var a = new Ge("return float(a >= b);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.logicalNot = function(t) {
    var r = new le(t.shape, "return float(!(x >= 1.0));");
    return this.compileAndRun(r, [t]);
  }, n.prototype.logicalAnd = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, "bool");
    var a = new Ge("return float(a >= 1.0 && b >= 1.0);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.logicalOr = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, "bool");
    var a = new Ge("return float(a >= 1.0 || b >= 1.0);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "bool");
  }, n.prototype.select = function(t, r, a) {
    var o = new xy(t.rank, r.shape, r.rank);
    return this.compileAndRun(o, [t, r, a], st(r.dtype, a.dtype));
  }, n.prototype.where = function(t) {
    Ko("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    var r = t.dataSync();
    return Lu(t.shape, r);
  }, n.prototype.topk = function(t, r, a) {
    return Qp(t.dataSync(), t.shape, t.dtype, r);
  }, n.prototype.min = function(t, r) {
    Tt("min", r, t.rank);
    var a = ct(t.shape, r), o = a[0], i = Q(a[1]), s = t.as2D(-1, i);
    return this.reduce(s, "min", s.dtype).reshape(o);
  }, n.prototype.minimum = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.minimum(t, r);
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new Ge(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return min(a, b);
`, t.shape, r.shape);
    return this.compileAndRun(a, [t, r]);
  }, n.prototype.mod = function(t, r) {
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new Ge(`if (b == 0.0) return NAN;
  return mod(a, b);`, t.shape, r.shape);
    return this.compileAndRun(a, [t, r]);
  }, n.prototype.max = function(t, r) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, r);
    Tt("max", r, t.rank);
    var a = ct(t.shape, r), o = a[0], i = Q(a[1]), s = t.as2D(-1, i);
    return this.reduce(s, "max", s.dtype).reshape(o);
  }, n.prototype.maximum = function(t, r) {
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.maximum(t, r);
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new Ge(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return max(a, b);
`, t.shape, r.shape);
    return this.compileAndRun(a, [t, r]);
  }, n.prototype.all = function(t, r) {
    Tt("all", r, t.rank);
    var a = ct(t.shape, r), o = a[0], i = Q(a[1]), s = t.as2D(-1, i);
    return this.reduce(s, "all", s.dtype).reshape(o);
  }, n.prototype.any = function(t, r) {
    Tt("any", r, t.rank);
    var a = ct(t.shape, r), o = a[0], i = Q(a[1]), s = t.as2D(-1, i);
    return this.reduce(s, "any", s.dtype).reshape(o);
  }, n.prototype.floorDiv = function(t, r) {
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, "int32");
    var a = new Ge(`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, t.shape, r.shape);
    return this.compileAndRun(a, [t, r], "int32");
  }, n.prototype.add = function(t, r) {
    if (t.dtype === "complex64" && r.dtype === "complex64") return this.complexSeparableBinaryOp(t, r, Hi);
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.add(t, r);
    var a = st(t.dtype, r.dtype);
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, Hi, a);
    var o = new Ge(Hi, t.shape, r.shape);
    return this.compileAndRun(o, [t, r], a);
  }, n.prototype.packedUnaryOp = function(t, r, a) {
    var o = new Ca(t.shape, r);
    return this.compileAndRun(o, [t], a);
  }, n.prototype.packedBinaryOp = function(t, r, a, o, i) {
    i === void 0 && (i = !1);
    var s = new sn(a, t.shape, r.shape, i);
    return this.compileAndRun(s, [t, r], o);
  }, n.prototype.complexSeparableBinaryOp = function(t, r, a) {
    var o = this, i = this.texData.get(t.dataId), s = this.texData.get(r.dataId), u = [[i.complexTensors.real, s.complexTensors.real], [i.complexTensors.imag, s.complexTensors.imag]].map(function(d) {
      var p = d[0], f = d[1], m = o.makeComplexComponentTensorInfo(t, p), g = o.makeComplexComponentTensorInfo(r, f), v = new Ge(a, t.shape, r.shape);
      return o.compileAndRun(v, [m, g], st(p.dtype, f.dtype));
    }), l = u[0], c = u[1], h = this.complex(l, c);
    return l.dispose(), c.dispose(), h;
  }, n.prototype.makeComplexComponentTensorInfo = function(t, r) {
    return { dataId: r.dataId, dtype: r.dtype, shape: t.shape };
  }, n.prototype.addN = function(t) {
    if (t.length === 1) return t[0];
    if (t.length > _().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      var r = Math.floor(t.length / 2), a = this.addN(t.slice(0, r)), o = this.addN(t.slice(r));
      return this.addN([a, o]);
    }
    var i = t.map(function(l) {
      return l.dtype;
    }).reduce(function(l, c) {
      return st(l, c);
    }), s = t.map(function(l) {
      return l.shape;
    }), u = _().getBool("WEBGL_PACK") ? new Kv(t[0].shape, s) : new Uv(t[0].shape, s);
    return this.compileAndRun(u, t, i);
  }, n.prototype.subtract = function(t, r) {
    if (t.dtype === "complex64" && r.dtype === "complex64") return this.complexSeparableBinaryOp(t, r, Wi);
    if (this.shouldExecuteOnCPU([t, r])) return this.cpuBackend.subtract(t, r);
    var a = st(t.dtype, r.dtype);
    if (_().getBool("WEBGL_PACK_BINARY_OPERATIONS")) return this.packedBinaryOp(t, r, Wi, t.dtype);
    var o = new Ge(Wi, t.shape, r.shape);
    return this.compileAndRun(o, [t, r], a);
  }, n.prototype.pow = function(t, r) {
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new Ge(`
if(a < 0.0 && floor(b) < b){
  return NAN;
}
if (b == 0.0) {
  return 1.0;
}
return (round(mod(b, 2.0)) != 1) ?
    pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, t.shape, r.shape), o = st(t.dtype, r.dtype);
    return this.compileAndRun(a, [t, r], o);
  }, n.prototype.ceil = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, tc, t.dtype);
    var r = new le(t.shape, tc);
    return this.compileAndRun(r, [t]);
  }, n.prototype.floor = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, nc, t.dtype);
    var r = new le(t.shape, nc);
    return this.compileAndRun(r, [t]);
  }, n.prototype.sign = function(t) {
    var r = new le(t.shape, `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.isNaN = function(t) {
    var r = new le(t.shape, "return float(isnan(x));");
    return this.compileAndRun(r, [t], "bool");
  }, n.prototype.isInf = function(t) {
    var r = new le(t.shape, "return float(isinf(x));");
    return this.compileAndRun(r, [t], "bool");
  }, n.prototype.isFinite = function(t) {
    var r = new le(t.shape, "return float(!isnan(x) && !isinf(x));");
    return this.compileAndRun(r, [t], "bool");
  }, n.prototype.round = function(t) {
    var r = new le(t.shape, `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.exp = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, rc, t.dtype);
    var r = new le(t.shape, rc);
    return this.compileAndRun(r, [t]);
  }, n.prototype.expm1 = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, ac, t.dtype);
    var r = new le(t.shape, ac);
    return this.compileAndRun(r, [t]);
  }, n.prototype.softmax = function(t, r) {
    var a = Xe([r], t.shape), o = this.max(t, a), i = wt(o.shape, a), s = this.subtract(t, o.reshape(i)), u = this.exp(s), l = this.sum(u, a).reshape(i);
    return Bn(u, l);
  }, n.prototype.log = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, `
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`, t.dtype);
    var r = new le(t.shape, `if (x < 0.0) return NAN;
  return log(x);`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.log1p = function(t) {
    var r = new le(t.shape, "return log(1.0 + x);");
    return this.compileAndRun(r, [t]);
  }, n.prototype.sqrt = function(t) {
    var r = new le(t.shape, "return sqrt(x);");
    return this.compileAndRun(r, [t]);
  }, n.prototype.rsqrt = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);
    var r = new le(t.shape, "return inversesqrt(x);");
    return this.compileAndRun(r, [t]);
  }, n.prototype.reciprocal = function(t) {
    var r = new le(t.shape, "return 1.0 / x;");
    return this.compileAndRun(r, [t]);
  }, n.prototype.relu = function(t) {
    var r;
    return r = _().getBool("WEBGL_PACK") ? new Ca(t.shape, sf) : new le(t.shape, rf), this.compileAndRun(r, [t]);
  }, n.prototype.relu6 = function(t) {
    var r;
    return r = _().getBool("WEBGL_PACK") ? new Ca(t.shape, uf) : new le(t.shape, af), this.compileAndRun(r, [t]);
  }, n.prototype.prelu = function(t, r) {
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(nf, t.shape, r.shape) : new Ge(tf, t.shape, r.shape);
    return this.compileAndRun(a, [t, r]);
  }, n.prototype.elu = function(t) {
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, lf, t.dtype);
    var r = new le(t.shape, of);
    return this.compileAndRun(r, [t]);
  }, n.prototype.eluDer = function(t, r) {
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, t.shape, r.shape) : new Ge("return (b >= 1.0) ? a : a * (b + 1.0);", t.shape, r.shape);
    return this.compileAndRun(a, [t, r]);
  }, n.prototype.selu = function(t) {
    var r = new le(t.shape, Ey);
    return this.compileAndRun(r, [t]);
  }, n.prototype.int = function(t) {
    var r = new le(t.shape, "return float(int(x));");
    return this.compileAndRun(r, [t], "int32");
  }, n.prototype.clip = function(t, r, a) {
    var o, i = (o = _().getBool("WEBGL_PACK_CLIP") ? new c0(t.shape) : new l0(t.shape)).getCustomSetupFunc(r, a);
    return this.compileAndRun(o, [t], null, i);
  }, n.prototype.abs = function(t) {
    if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);
    if (_().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Zl, t.dtype);
    var r = new le(t.shape, Zl);
    return this.compileAndRun(r, [t]);
  }, n.prototype.complexAbs = function(t) {
    var r = this.texData.get(t.dataId), a = new h0(t.shape), o = [this.makeComplexComponentTensorInfo(t, r.complexTensors.real), this.makeComplexComponentTensorInfo(t, r.complexTensors.imag)];
    return this.compileAndRun(a, o);
  }, n.prototype.sigmoid = function(t) {
    var r = new le(t.shape, "return 1.0 / (1.0 + exp(-1.0 * x));");
    return this.compileAndRun(r, [t]);
  }, n.prototype.softplus = function(t) {
    var r = new le(t.shape, `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.sin = function(t) {
    var r = new le(t.shape, Ty);
    return this.compileAndRun(r, [t]);
  }, n.prototype.cos = function(t) {
    var r = new le(t.shape, Py);
    return this.compileAndRun(r, [t]);
  }, n.prototype.tan = function(t) {
    var r = new le(t.shape, "return tan(x);");
    return this.compileAndRun(r, [t]);
  }, n.prototype.asin = function(t) {
    var r = new le(t.shape, Sy);
    return this.compileAndRun(r, [t]);
  }, n.prototype.acos = function(t) {
    var r = new le(t.shape, Dy);
    return this.compileAndRun(r, [t]);
  }, n.prototype.atan = function(t) {
    var r = new le(t.shape, Oy);
    return this.compileAndRun(r, [t]);
  }, n.prototype.atan2 = function(t, r) {
    var a = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn(`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`, t.shape, r.shape) : new Ge(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return atan(a, b);
`, t.shape, r.shape);
    return this.compileAndRun(a, [t, r]);
  }, n.prototype.sinh = function(t) {
    var r = new le(t.shape, `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.cosh = function(t) {
    var r = new le(t.shape, `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.tanh = function(t) {
    var r = new le(t.shape, `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.asinh = function(t) {
    var r = new le(t.shape, Ry);
    return this.compileAndRun(r, [t]);
  }, n.prototype.acosh = function(t) {
    var r = new le(t.shape, Fy);
    return this.compileAndRun(r, [t]);
  }, n.prototype.atanh = function(t) {
    var r = new le(t.shape, My);
    return this.compileAndRun(r, [t]);
  }, n.prototype.erf = function(t) {
    var r = new le(t.shape, `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = 0.3275911;
  float a1 = 0.254829592;
  float a2 = -0.284496736;
  float a3 = 1.421413741;
  float a4 = -1.453152027;
  float a5 = 1.061405429;

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`);
    return this.compileAndRun(r, [t]);
  }, n.prototype.step = function(t, r) {
    var a = new le(t.shape, function(o) {
      return o === void 0 && (o = 0), tn + `
    return x > 0.0 ? 1.0 : float(` + o + `);
  `;
    }(r));
    return this.compileAndRun(a, [t]);
  }, n.prototype.conv2dByMatMul = function(t, r, a, o, i, s) {
    var u = t.shape, l = this.texData.get(t.dataId), c = a.inChannels, h = u[0] * u[1] * u[2], d = a.outChannels, p = a.dataFormat === "channelsLast", f = (h === 1 || d === 1) && c > 1e3, m = u[2] % 2 != 0 && !!l.isPacked;
    if (f || !_().getBool("WEBGL_LAZILY_UNPACK") || !_().getBool("WEBGL_PACK_BINARY_OPERATIONS") || !m) {
      var g = p ? u[0] * u[1] * u[2] : u[0] * u[2] * u[3], v = this.reshape(t, [1, g, a.inChannels]), y = this.reshape(r, [1, a.inChannels, a.outChannels]);
      return this.reshape(this.fusedBatchMatMul({ a: v, b: y, transposeA: !1, transposeB: !1, bias: o, activation: i, preluActivationWeights: s }), a.outShape);
    }
    var b = p ? u[0] * u[1] * (u[2] + 1) : u[0] * u[2] * (u[3] + 1), x = { dataId: t.dataId, shape: [1, b, a.inChannels], dtype: t.dtype }, C = l.shape;
    l.shape = l.shape.slice(), l.shape[l.shape.length - 2]++, A(io(l.shape, x.shape), function() {
      return "packed reshape " + l.shape + " to " + x.shape + " isn't free";
    });
    var N = this.reshape(r, [1, a.inChannels, a.outChannels]), T = this.fusedBatchMatMul({ a: x, b: N, transposeA: !1, transposeB: !1, bias: o, activation: i, preluActivationWeights: s }), I = this.texData.get(T.dataId);
    return A(I.isPacked, function() {
      return "batchMatMul result is expected to be packed";
    }), l.shape = C, I.shape = a.outShape, D.makeTensorFromDataId(T.dataId, a.outShape, T.dtype);
  }, n.prototype.conv2dWithIm2Row = function(t, r, a, o, i, s) {
    var u = a.filterWidth, l = a.filterHeight, c = a.inChannels, h = a.outWidth, d = a.outHeight, p = a.dataFormat === "channelsLast", f = u * l * c, m = d * h, g = [f, m], v = t.squeeze([0]), y = r.reshape([1, f, -1]), b = new Z0(g, v.shape, a), x = this.compileAndRun(b, [v]).reshape([1, g[0], g[1]]), C = o != null, N = s != null, T = i ? co(i, !0) : null, I = new $i(x.shape, [1, m, a.outChannels], !0, !1, C, T, N), E = [x, y];
    o && E.push(o), N && E.push(s);
    var P = this.compileAndRun(I, E);
    return p ? P.reshape([1, d, h, a.outChannels]) : P.reshape([1, a.outChannels, d, h]);
  }, n.prototype.fusedConv2d = function(t) {
    var r = t.input, a = t.filter, o = t.convInfo, i = t.bias, s = t.activation, u = t.preluActivationWeights;
    if (o.filterHeight === 1 && o.filterWidth === 1 && o.dilationHeight === 1 && o.dilationWidth === 1 && o.strideHeight === 1 && o.strideWidth === 1 && (o.padInfo.type === "SAME" || o.padInfo.type === "VALID")) return this.conv2dByMatMul(r, a, o, i, s, u);
    if (_().getBool("WEBGL_CONV_IM2COL") && r.shape[0] === 1) return this.conv2dWithIm2Row(r, a, o, i, s, u);
    var l = i != null, c = u != null, h = s ? co(s, !1) : null, d = new Wl(o, l, h, c), p = [r, a];
    return i && p.push(i), u && p.push(u), this.compileAndRun(d, p);
  }, n.prototype.conv2d = function(t, r, a) {
    if (a.filterHeight === 1 && a.filterWidth === 1 && a.dilationHeight === 1 && a.dilationWidth === 1 && a.strideHeight === 1 && a.strideWidth === 1 && (a.padInfo.type === "SAME" || a.padInfo.type === "VALID")) return this.conv2dByMatMul(t, r, a);
    if (_().getBool("WEBGL_CONV_IM2COL") && t.shape[0] === 1) return this.conv2dWithIm2Row(t, r, a);
    var o = new Wl(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.conv2dDerInput = function(t, r, a) {
    var o = new m0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.conv2dDerFilter = function(t, r, a) {
    var o = new f0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.fusedDepthwiseConv2D = function(t) {
    var r, a = t.input, o = t.filter, i = t.convInfo, s = t.bias, u = t.activation, l = t.preluActivationWeights, c = _().getBool("WEBGL_PACK_DEPTHWISECONV") && i.strideWidth <= 2 && i.outChannels / i.inChannels == 1, h = u ? co(u, c) : null, d = [a, o], p = s != null, f = l != null;
    return p && d.push(s), f && d.push(l), c ? (r = new Ul(i, p, h, f), this.compileAndRun(r, d)) : (r = new $l(i, p, h, f), this.compileAndRun(r, d));
  }, n.prototype.depthwiseConv2D = function(t, r, a) {
    var o;
    return _().getBool("WEBGL_PACK_DEPTHWISECONV") && a.strideWidth <= 2 && a.outChannels / a.inChannels == 1 ? (o = new Ul(a), this.compileAndRun(o, [t, r])) : (o = new $l(a), this.compileAndRun(o, [t, r]));
  }, n.prototype.depthwiseConv2DDerInput = function(t, r, a) {
    var o = new b0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.depthwiseConv2DDerFilter = function(t, r, a) {
    var o = new y0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.conv3d = function(t, r, a) {
    var o = new x0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.conv3dDerInput = function(t, r, a) {
    var o = new v0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.conv3dDerFilter = function(t, r, a) {
    var o = new g0(a);
    return this.compileAndRun(o, [t, r]);
  }, n.prototype.maxPool = function(t, r) {
    var a = new Oa(r, "max", !1);
    return this.compileAndRun(a, [t]);
  }, n.prototype.avgPool = function(t, r) {
    var a = new Oa(r, "avg", !1);
    return this.compileAndRun(a, [t], "float32");
  }, n.prototype.maxPoolBackprop = function(t, r, a, o) {
    var i = new Oa(o, "max", !0), s = this.compileAndRun(i, [r]), u = new ry(o), l = this.compileAndRun(u, [t, s], r.dtype);
    return s.dispose(), l;
  }, n.prototype.avgPoolBackprop = function(t, r, a) {
    var o = new t0(a);
    return this.compileAndRun(o, [t], r.dtype);
  }, n.prototype.cast = function(t, r) {
    return Up(t, r, this);
  }, n.prototype.unstack = function(t, r) {
    for (var a = t.shape[r], o = new Array(t.rank - 1), i = 0, s = 0; s < t.rank; s++) s !== r && (o[i++] = t.shape[s]);
    var u = new Array(t.rank).fill(0), l = t.shape.slice();
    l[r] = 1;
    var c = new Array(a);
    for (s = 0; s < c.length; s++) u[r] = s, c[s] = this.slice(t, u, l).reshape(o);
    return c;
  }, n.prototype.avgPool3d = function(t, r) {
    var a = new Ui(r, "avg", !1);
    return this.compileAndRun(a, [t], "float32");
  }, n.prototype.avgPool3dBackprop = function(t, r, a) {
    var o = new n0(a);
    return this.compileAndRun(o, [t], r.dtype);
  }, n.prototype.maxPool3d = function(t, r) {
    var a = new Ui(r, "max", !1);
    return this.compileAndRun(a, [t], "float32");
  }, n.prototype.maxPool3dBackprop = function(t, r, a, o) {
    var i = new Ui(o, "max", !0), s = this.compileAndRun(i, [r]), u = new ay(o), l = this.compileAndRun(u, [t, s], r.dtype);
    return s.dispose(), l;
  }, n.prototype.reshape = function(t, r) {
    var a = this.texData.get(t.dataId);
    if (a.isPacked && !io(t.shape, r) && (a.texture === null || !io(a.shape, r))) {
      var o = this.packedReshape(t, r);
      return D.makeTensorFromDataId(o.dataId, o.shape, o.dtype);
    }
    return Rs(t, r);
  }, n.prototype.resizeBilinear = function(t, r, a, o) {
    var i = _().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new fy(t.shape, r, a, o) : new py(t.shape, r, a, o);
    return this.compileAndRun(i, [t], "float32");
  }, n.prototype.resizeBilinearBackprop = function(t, r, a) {
    var o = new dy(t, r, a);
    return this.compileAndRun(o, [t]);
  }, n.prototype.resizeNearestNeighbor = function(t, r, a, o) {
    var i = new gy(t.shape, r, a, o);
    return this.compileAndRun(i, [t]);
  }, n.prototype.resizeNearestNeighborBackprop = function(t, r, a) {
    var o = new my(t, r, a);
    return this.compileAndRun(o, [t]);
  }, n.prototype.multinomial = function(t, r, a, o) {
    var i = r ? t : vi(t), s = i.shape[0], u = i.shape[1], l = new oy(s, u, a), c = l.getCustomSetupFunc(o);
    return this.compileAndRun(l, [i], "int32", c);
  }, n.prototype.oneHot = function(t, r, a, o) {
    var i = new iy(t.size, r, a, o);
    return this.compileAndRun(i, [t]);
  }, n.prototype.diag = function(t) {
    var r = new I0(t.size);
    return this.compileAndRun(r, [t]);
  }, n.prototype.nonMaxSuppression = function(t, r, a, o, i) {
    return Ko("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"), ju(t.dataSync(), r.dataSync(), a, o, i);
  }, n.prototype.cropAndResize = function(t, r, a, o, i, s) {
    var u = new w0(t.shape, r.shape, o, i, s);
    return this.compileAndRun(u, [t, r, a], "float32");
  }, n.prototype.depthToSpace = function(t, r, a) {
    A(r > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + r;
    });
    var o = t.shape[0], i = a === "NHWC" ? t.shape[1] : t.shape[2], s = a === "NHWC" ? t.shape[2] : t.shape[3], u = a === "NHWC" ? t.shape[3] : t.shape[1], l = i * r, c = s * r, h = u / (r * r), d = new A0(a === "NHWC" ? [o, l, c, h] : [o, h, l, c], r, a);
    return this.compileAndRun(d, [t]);
  }, n.prototype.split = function(t, r, a) {
    return Jp(t, r, a);
  }, n.prototype.scatterND = function(t, r, a) {
    var o = Yo(0, t, a), i = o.sliceRank, s = o.numUpdates, u = o.sliceSize, l = o.strides, c = o.outputSize, h = [c / u, u], d = t.reshape([s, i]), p = r.reshape([s, u]);
    if (c === 0) return Rs(rt([]), a);
    var f = X(0), m = new Xl(s, i, d.rank, p.rank, l, h);
    return this.compileAndRun(m, [p, d, f]).reshape(a);
  }, n.prototype.sparseToDense = function(t, r, a, o) {
    var i = Yo(0, t, a), s = i.sliceRank, u = i.numUpdates, l = i.strides, c = i.outputSize, h = new Xl(u, s, t.rank, r.rank, l, [c, 1]);
    return this.compileAndRun(h, [r, t, o]).reshape(a);
  }, n.prototype.fft = function(t) {
    return this.fftImpl(t, !1);
  }, n.prototype.ifft = function(t) {
    return this.fftImpl(t, !0);
  }, n.prototype.fftImpl = function(t, r) {
    var a = this.texData.get(t.dataId), o = new ql(D0, t.shape, r), i = new ql(O0, t.shape, r), s = [this.makeComplexComponentTensorInfo(t, a.complexTensors.real), this.makeComplexComponentTensorInfo(t, a.complexTensors.imag)], u = this.compileAndRun(o, s), l = this.compileAndRun(i, s), c = this.complex(u, l).as2D(t.shape[0], t.shape[1]);
    return u.dispose(), l.dispose(), c;
  }, n.prototype.gatherND = function(t, r) {
    var a = r.shape, o = a[a.length - 1], i = jp(t, r), s = i[0], u = i[1], l = i[2], c = i[3], h = r.reshape([u, o]), d = t.reshape([t.size / l, l]), p = new M0(o, c, [u, l]);
    return this.compileAndRun(p, [d, h]).reshape(s);
  }, n.prototype.fill = function(t, r, a) {
    if ((a = a || da(r)) === "string") {
      var o = Ma(a, Q(t));
      return o.fill(r), D.makeTensor(o, t, a, this);
    }
    var i = new R0(t, r), s = i.getCustomSetupFunc(r);
    return this.compileAndRun(i, [], a, s);
  }, n.prototype.onesLike = function(t) {
    if (t.dtype === "string") throw new Error("onesLike is not supported under string dtype");
    return this.fill(t.shape, 1, t.dtype);
  }, n.prototype.zerosLike = function(t) {
    return this.fill(t.shape, t.dtype === "string" ? "" : 0, t.dtype);
  }, n.prototype.linspace = function(t, r, a) {
    return Kp(t, r, a);
  }, n.prototype.makeTensorInfo = function(t, r) {
    var a = this.write(null, t, r);
    return this.texData.get(a).usage = null, { dataId: a, shape: t, dtype: r };
  }, n.prototype.makeOutput = function(t, r) {
    var a = this.makeTensorInfo(t, r).dataId;
    return D.makeTensorFromDataId(a, t, r, this);
  }, n.prototype.unpackTensor = function(t) {
    var r = new By(t.shape);
    return this.runWebGLProgram(r, [t], t.dtype);
  }, n.prototype.packTensor = function(t) {
    var r = new sy(t.shape);
    return this.runWebGLProgram(r, [t], t.dtype, null, !0);
  }, n.prototype.packedReshape = function(t, r) {
    var a = [$o(t.shape)].concat(Uo(t.shape)), o = { dtype: t.dtype, shape: a, dataId: t.dataId }, i = [$o(r)].concat(Uo(r)), s = new hy(i, a), u = this.runWebGLProgram(s, [o], t.dtype, null, !0);
    return { dataId: u.dataId, shape: r, dtype: u.dtype };
  }, n.prototype.decode = function(t) {
    var r, a = this.texData.get(t), o = a.isPacked, i = a.shape, s = a.dtype, u = zi(i);
    return r = o ? new N0(u) : new k0(u), { dtype: s, shape: i, dataId: this.runWebGLProgram(r, [{ shape: u, dtype: s, dataId: t }], s, null, !0).dataId };
  }, n.prototype.runWebGLProgram = function(t, r, a, o, i) {
    var s = this;
    i === void 0 && (i = !1);
    var u = this.makeTensorInfo(t.outputShape, a), l = this.texData.get(u.dataId);
    if (t.packedOutput && (l.isPacked = !0), t.outPackingScheme === ja.DENSE) {
      var c = Sa(t.outputShape);
      l.texShape = c.map(function(b) {
        return 2 * b;
      });
    }
    if (t.outTexUsage != null && (l.usage = t.outTexUsage), Q(u.shape) === 0) return l.values = Ar(u.dtype, 0), u;
    var h = [], d = r.map(function(b) {
      if (b.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      var x = s.texData.get(b.dataId);
      if (x.texture == null) {
        if (!t.packedInputs && Q(b.shape) <= _().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return { shape: b.shape, texData: null, isUniform: !0, uniformValues: x.values };
        t.packedInputs && (x.isPacked = !0, x.shape = b.shape);
      } else if (!!x.isPacked != !!t.packedInputs) b = x.isPacked ? s.unpackTensor(b) : s.packTensor(b), h.push(b), x = s.texData.get(b.dataId);
      else if (x.isPacked && !io(x.shape, b.shape)) {
        var C = b, N = b.shape;
        b.shape = x.shape, b = s.packedReshape(b, N), h.push(b), x = s.texData.get(b.dataId), C.shape = N;
      }
      return s.uploadToGPU(b.dataId), { shape: b.shape, texData: x, isUniform: !1 };
    });
    this.uploadToGPU(u.dataId);
    var p, f = { shape: u.shape, texData: l, isUniform: !1 }, m = function(b, x, C) {
      var N = "";
      x.concat(C).forEach(function(E) {
        var P = E.texData != null && E.texData.slice != null && E.texData.slice.flatOffset > 0, O = E.isUniform ? "uniform" : E.texData.texShape;
        N += E.shape + "_" + O + "_" + P;
      });
      var T = b.userCode, I = b.constructor.name;
      return I += "_" + N + "_" + T;
    }(t, d, f), g = this.getAndSaveBinary(m, function() {
      return function(b, x, C, N) {
        var T = x.userCode, I = C.map(function(L, $) {
          var K = { logicalShape: L.shape, texShape: L.isUniform ? null : L.texData.texShape, isUniform: L.isUniform, isPacked: !L.isUniform && L.texData.isPacked, flatOffset: null };
          return L.texData != null && L.texData.slice != null && L.texData.slice.flatOffset > 0 && (K.flatOffset = L.texData.slice.flatOffset), { name: x.variableNames[$], shapeInfo: K };
        }), E = I.map(function(L) {
          return L.shapeInfo;
        }), P = { logicalShape: N.shape, texShape: N.texData.texShape, isUniform: !1, isPacked: N.texData.isPacked, flatOffset: null }, O = Jv(I, P, T, x.packedInputs), R = b.createProgram(O), z = null, j = b.getUniformLocation(R, "NAN", !1);
        _().getNumber("WEBGL_VERSION") === 1 && (z = b.getUniformLocation(R, "INFINITY", !1));
        for (var B = {}, H = 0; H < x.variableNames.length; H++) {
          var W = x.variableNames[H];
          B[W] = b.getUniformLocation(R, W, !1), B["offset" + W] = b.getUniformLocation(R, "offset" + W, !1);
        }
        return { program: x, source: O, webGLProgram: R, uniformLocations: B, inShapeInfos: E, outShapeInfo: P, infLoc: z, nanLoc: j };
      }(s.gpgpu, t, d, f);
    }), v = this.activeTimers != null;
    if (v && (p = this.startTimer()), function(b, x, C, N, T) {
      Jl(x.inShapeInfos, C), Jl([x.outShapeInfo], [N]);
      var I = N.texData.texture, E = N.texData.texShape;
      N.texData.isPacked ? b.setOutputPackedMatrixTexture(I, E[0], E[1]) : b.setOutputMatrixTexture(I, E[0], E[1]), b.setProgram(x.webGLProgram), _().getNumber("WEBGL_VERSION") === 1 && x.infLoc !== null && b.gl.uniform1f(x.infLoc, 1 / 0), x.nanLoc !== null && b.gl.uniform1f(x.nanLoc, NaN), C.forEach(function(P, O) {
        var R = x.program.variableNames[O], z = x.uniformLocations[R], j = x.uniformLocations["offset" + R];
        if (z != null) if (P.isUniform) if (Q(P.shape) < 2) b.gl.uniform1f(z, P.uniformValues[0]);
        else {
          var B = P.uniformValues;
          B instanceof Float32Array || (B = new Float32Array(B)), b.gl.uniform1fv(z, B);
        }
        else P.texData.slice != null && j != null && b.gl.uniform1i(j, P.texData.slice.flatOffset), b.setInputMatrixTexture(P.texData.texture, z, O);
      }), T != null && T(b, x.webGLProgram), b.executeProgram();
    }(this.gpgpu, g, d, f, o), h.forEach(function(b) {
      return s.disposeData(b.dataId);
    }), v && (p = this.endTimer(p), this.activeTimers.push({ name: t.constructor.name, query: this.getQueryTime(p) })), !_().getBool("WEBGL_LAZILY_UNPACK") && l.isPacked && i === !1) {
      var y = this.unpackTensor(u);
      return this.disposeData(u.dataId), y;
    }
    return u;
  }, n.prototype.compileAndRun = function(t, r, a, o, i) {
    i === void 0 && (i = !1), a = a || r[0].dtype;
    var s = this.runWebGLProgram(t, r, a, o, i);
    return D.makeTensorFromDataId(s.dataId, s.shape, s.dtype);
  }, n.prototype.getAndSaveBinary = function(t, r) {
    return t in this.binaryCache || (this.binaryCache[t] = r()), this.binaryCache[t];
  }, n.prototype.getTextureManager = function() {
    return this.textureManager;
  }, n.prototype.dispose = function() {
    var t = this;
    this.disposed || (_().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(function(r) {
      t.gpgpu.deleteProgram(t.binaryCache[r].webGLProgram), delete t.binaryCache[r];
    }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);
  }, n.prototype.floatPrecision = function() {
    var t = this;
    return this.floatPrecisionValue == null && (this.floatPrecisionValue = de(function() {
      if (!_().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
        var r = _().getBool("DEBUG");
        _().set("DEBUG", !1);
        var a = t.abs(X(1e-8)).dataSync()[0];
        if (_().set("DEBUG", r), a > 0) return 32;
      }
      return 16;
    })), this.floatPrecisionValue;
  }, n.prototype.epsilon = function() {
    return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
  }, n.prototype.uploadToGPU = function(t) {
    var r, a = this.texData.get(t), o = a.shape, i = a.dtype, s = a.values, u = a.texture, l = a.usage, c = a.isPacked;
    if (u == null) {
      var h, d = this.activeTimers != null;
      d && (h = Jt());
      var p = a.texShape;
      if (p == null && (p = tv(o, c), a.texShape = p), s != null) {
        var f = zi(o), m = void 0, g = p[1], v = p[0], y = s instanceof Uint8Array;
        c ? (g = (r = Ka(p[0], p[1]))[0], v = r[1], m = new S0(f, [v, g], y)) : m = new P0(f, [v, g], y);
        var b = this.makeTensorInfo([v, g], i);
        this.texData.get(b.dataId).usage = y ? Ot.PIXELS : Ot.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId), g, v, s);
        var x = this.runWebGLProgram(m, [b], i, null, !0), C = this.texData.get(x.dataId);
        a.texture = C.texture, a.texShape = C.texShape, a.isPacked = C.isPacked, a.usage = C.usage, this.disposeData(b.dataId), this.texData.delete(x.dataId), a.values = null, d && (this.uploadWaitMs += Jt() - h);
      } else {
        var N = this.acquireTexture(p, l, i, c);
        a.texture = N;
      }
    }
  }, n.prototype.convertAndCacheOnCPU = function(t, r) {
    var a = this.texData.get(t), o = a.dtype;
    return this.releaseGPUData(t), r != null && (a.values = function(i, s) {
      if (s === "float32" || s === "complex64") return i;
      if (s === "int32" || s === "bool") {
        for (var u = s === "int32" ? new Int32Array(i.length) : new Uint8Array(i.length), l = 0; l < u.length; ++l) u[l] = Math.round(i[l]);
        return u;
      }
      throw new Error("Unknown dtype " + s);
    }(r, o)), a.values;
  }, n.prototype.acquireTexture = function(t, r, a, o) {
    if (this.numBytesInGPU += this.computeBytes(t, a), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
      var i = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
      this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: " + i + " MB, most likely due to a memory leak");
    }
    return this.textureManager.acquireTexture(t, r, o);
  }, n.prototype.computeBytes = function(t, r) {
    return t[0] * t[1] * Cu(r);
  }, n;
}(Wp);
Kd() && D.registerBackend("webgl", function() {
  return new Vy();
}, 2);
function Dr(e, n) {
  return e(n = { exports: {} }, n.exports), n.exports;
}
var Ly = Dr(function(e) {
  (function(n, t, r) {
    function a(s) {
      var u, l = this, c = (u = 4022871197, function(h) {
        h = h.toString();
        for (var d = 0; d < h.length; d++) {
          var p = 0.02519603282416938 * (u += h.charCodeAt(d));
          p -= u = p >>> 0, u = (p *= u) >>> 0, u += 4294967296 * (p -= u);
        }
        return 23283064365386963e-26 * (u >>> 0);
      });
      l.next = function() {
        var h = 2091639 * l.s0 + 23283064365386963e-26 * l.c;
        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = h - (l.c = 0 | h);
      }, l.c = 1, l.s0 = c(" "), l.s1 = c(" "), l.s2 = c(" "), l.s0 -= c(s), l.s0 < 0 && (l.s0 += 1), l.s1 -= c(s), l.s1 < 0 && (l.s1 += 1), l.s2 -= c(s), l.s2 < 0 && (l.s2 += 1), c = null;
    }
    function o(s, u) {
      return u.c = s.c, u.s0 = s.s0, u.s1 = s.s1, u.s2 = s.s2, u;
    }
    function i(s, u) {
      var l = new a(s), c = u && u.state, h = l.next;
      return h.int32 = function() {
        return 4294967296 * l.next() | 0;
      }, h.double = function() {
        return h() + 11102230246251565e-32 * (2097152 * h() | 0);
      }, h.quick = h, c && (typeof c == "object" && o(c, l), h.state = function() {
        return o(l, {});
      }), h;
    }
    t && t.exports ? t.exports = i : this.alea = i;
  })(0, e);
}), zy = Dr(function(e) {
  (function(n, t, r) {
    function a(s) {
      var u = this, l = "";
      u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.next = function() {
        var h = u.x ^ u.x << 11;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w ^= u.w >>> 19 ^ h ^ h >>> 8;
      }, s === (0 | s) ? u.x = s : l += s;
      for (var c = 0; c < l.length + 64; c++) u.x ^= 0 | l.charCodeAt(c), u.next();
    }
    function o(s, u) {
      return u.x = s.x, u.y = s.y, u.z = s.z, u.w = s.w, u;
    }
    function i(s, u) {
      var l = new a(s), c = u && u.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, h.int32 = l.next, h.quick = h, c && (typeof c == "object" && o(c, l), h.state = function() {
        return o(l, {});
      }), h;
    }
    t && t.exports ? t.exports = i : this.xor128 = i;
  })(0, e);
}), Gy = Dr(function(e) {
  (function(n, t, r) {
    function a(s) {
      var u = this, l = "";
      u.next = function() {
        var h = u.x ^ u.x >>> 2;
        return u.x = u.y, u.y = u.z, u.z = u.w, u.w = u.v, (u.d = u.d + 362437 | 0) + (u.v = u.v ^ u.v << 4 ^ h ^ h << 1) | 0;
      }, u.x = 0, u.y = 0, u.z = 0, u.w = 0, u.v = 0, s === (0 | s) ? u.x = s : l += s;
      for (var c = 0; c < l.length + 64; c++) u.x ^= 0 | l.charCodeAt(c), c == l.length && (u.d = u.x << 10 ^ u.x >>> 4), u.next();
    }
    function o(s, u) {
      return u.x = s.x, u.y = s.y, u.z = s.z, u.w = s.w, u.v = s.v, u.d = s.d, u;
    }
    function i(s, u) {
      var l = new a(s), c = u && u.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, h.int32 = l.next, h.quick = h, c && (typeof c == "object" && o(c, l), h.state = function() {
        return o(l, {});
      }), h;
    }
    t && t.exports ? t.exports = i : this.xorwow = i;
  })(0, e);
}), Hy = Dr(function(e) {
  (function(n, t, r) {
    function a(s) {
      var u = this;
      u.next = function() {
        var l, c, h = u.x, d = u.i;
        return l = h[d], c = (l ^= l >>> 7) ^ l << 24, c ^= (l = h[d + 1 & 7]) ^ l >>> 10, c ^= (l = h[d + 3 & 7]) ^ l >>> 3, c ^= (l = h[d + 4 & 7]) ^ l << 7, l = h[d + 7 & 7], c ^= (l ^= l << 13) ^ l << 9, h[d] = c, u.i = d + 1 & 7, c;
      }, function(l, c) {
        var h, d = [];
        if (c === (0 | c)) d[0] = c;
        else for (c = "" + c, h = 0; h < c.length; ++h) d[7 & h] = d[7 & h] << 15 ^ c.charCodeAt(h) + d[h + 1 & 7] << 13;
        for (; d.length < 8; ) d.push(0);
        for (h = 0; h < 8 && d[h] === 0; ++h) ;
        for (h == 8 ? d[7] = -1 : d[h], l.x = d, l.i = 0, h = 256; h > 0; --h) l.next();
      }(u, s);
    }
    function o(s, u) {
      return u.x = s.x.slice(), u.i = s.i, u;
    }
    function i(s, u) {
      s == null && (s = +/* @__PURE__ */ new Date());
      var l = new a(s), c = u && u.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, h.int32 = l.next, h.quick = h, c && (c.x && o(c, l), h.state = function() {
        return o(l, {});
      }), h;
    }
    t && t.exports ? t.exports = i : this.xorshift7 = i;
  })(0, e);
}), Wy = Dr(function(e) {
  (function(n, t, r) {
    function a(s) {
      var u = this;
      u.next = function() {
        var l, c, h = u.w, d = u.X, p = u.i;
        return u.w = h = h + 1640531527 | 0, c = d[p + 34 & 127], l = d[p = p + 1 & 127], c ^= c << 13, l ^= l << 17, c ^= c >>> 15, l ^= l >>> 12, c = d[p] = c ^ l, u.i = p, c + (h ^ h >>> 16) | 0;
      }, function(l, c) {
        var h, d, p, f, m, g = [], v = 128;
        for (c === (0 | c) ? (d = c, c = null) : (c += "\0", d = 0, v = Math.max(v, c.length)), p = 0, f = -32; f < v; ++f) c && (d ^= c.charCodeAt((f + 32) % c.length)), f === 0 && (m = d), d ^= d << 10, d ^= d >>> 15, d ^= d << 4, d ^= d >>> 13, f >= 0 && (m = m + 1640531527 | 0, p = (h = g[127 & f] ^= d + m) == 0 ? p + 1 : 0);
        for (p >= 128 && (g[127 & (c && c.length || 0)] = -1), p = 127, f = 512; f > 0; --f) d = g[p + 34 & 127], h = g[p = p + 1 & 127], d ^= d << 13, h ^= h << 17, d ^= d >>> 15, h ^= h >>> 12, g[p] = d ^ h;
        l.w = m, l.X = g, l.i = p;
      }(u, s);
    }
    function o(s, u) {
      return u.i = s.i, u.w = s.w, u.X = s.X.slice(), u;
    }
    function i(s, u) {
      s == null && (s = +/* @__PURE__ */ new Date());
      var l = new a(s), c = u && u.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, h.int32 = l.next, h.quick = h, c && (c.X && o(c, l), h.state = function() {
        return o(l, {});
      }), h;
    }
    t && t.exports ? t.exports = i : this.xor4096 = i;
  })(0, e);
}), $y = Dr(function(e) {
  (function(n, t, r) {
    function a(s) {
      var u = this, l = "";
      u.next = function() {
        var h = u.b, d = u.c, p = u.d, f = u.a;
        return h = h << 25 ^ h >>> 7 ^ d, d = d - p | 0, p = p << 24 ^ p >>> 8 ^ f, f = f - h | 0, u.b = h = h << 20 ^ h >>> 12 ^ d, u.c = d = d - p | 0, u.d = p << 16 ^ d >>> 16 ^ f, u.a = f - h | 0;
      }, u.a = 0, u.b = 0, u.c = -1640531527, u.d = 1367130551, s === Math.floor(s) ? (u.a = s / 4294967296 | 0, u.b = 0 | s) : l += s;
      for (var c = 0; c < l.length + 20; c++) u.b ^= 0 | l.charCodeAt(c), u.next();
    }
    function o(s, u) {
      return u.a = s.a, u.b = s.b, u.c = s.c, u.d = s.d, u;
    }
    function i(s, u) {
      var l = new a(s), c = u && u.state, h = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return h.double = function() {
        do
          var d = ((l.next() >>> 11) + (l.next() >>> 0) / 4294967296) / 2097152;
        while (d === 0);
        return d;
      }, h.int32 = l.next, h.quick = h, c && (typeof c == "object" && o(c, l), h.state = function() {
        return o(l, {});
      }), h;
    }
    t && t.exports ? t.exports = i : this.tychei = i;
  })(0, e);
}), fr = Dr(function(e) {
  (function(n, t) {
    var r, a = this, o = 256, i = 6, s = "random", u = t.pow(o, i), l = t.pow(2, 52), c = 2 * l, h = o - 1;
    function d(v, y, b) {
      var x = [], C = m(function I(E, P) {
        var O, R = [], z = typeof E;
        if (P && z == "object") for (O in E) try {
          R.push(I(E[O], P - 1));
        } catch {
        }
        return R.length ? R : z == "string" ? E : E + "\0";
      }((y = y == 1 ? { entropy: !0 } : y || {}).entropy ? [v, g(n)] : v ?? function() {
        try {
          var I;
          return r && (I = r.randomBytes) ? I = I(o) : (I = new Uint8Array(o), (a.crypto || a.msCrypto).getRandomValues(I)), g(I);
        } catch {
          var E = a.navigator, P = E && E.plugins;
          return [+/* @__PURE__ */ new Date(), a, P, a.screen, g(n)];
        }
      }(), 3), x), N = new p(x), T = function() {
        for (var I = N.g(i), E = u, P = 0; I < l; ) I = (I + P) * o, E *= o, P = N.g(1);
        for (; I >= c; ) I /= 2, E /= 2, P >>>= 1;
        return (I + P) / E;
      };
      return T.int32 = function() {
        return 0 | N.g(4);
      }, T.quick = function() {
        return N.g(4) / 4294967296;
      }, T.double = T, m(g(N.S), n), (y.pass || b || function(I, E, P, O) {
        return O && (O.S && f(O, N), I.state = function() {
          return f(N, {});
        }), P ? (t[s] = I, E) : I;
      })(T, C, "global" in y ? y.global : this == t, y.state);
    }
    function p(v) {
      var y, b = v.length, x = this, C = 0, N = x.i = x.j = 0, T = x.S = [];
      for (b || (v = [b++]); C < o; ) T[C] = C++;
      for (C = 0; C < o; C++) T[C] = T[N = h & N + v[C % b] + (y = T[C])], T[N] = y;
      (x.g = function(I) {
        for (var E, P = 0, O = x.i, R = x.j, z = x.S; I--; ) E = z[O = h & O + 1], P = P * o + z[h & (z[O] = z[R = h & R + E]) + (z[R] = E)];
        return x.i = O, x.j = R, P;
      })(o);
    }
    function f(v, y) {
      return y.i = v.i, y.j = v.j, y.S = v.S.slice(), y;
    }
    function m(v, y) {
      for (var b, x = v + "", C = 0; C < x.length; ) y[h & C] = h & (b ^= 19 * y[h & C]) + x.charCodeAt(C++);
      return g(y);
    }
    function g(v) {
      return String.fromCharCode.apply(0, v);
    }
    if (t["seed" + s] = d, m(t.random(), n), e.exports) {
      e.exports = d;
      try {
        r = require("crypto");
      } catch {
      }
    }
  })([], Math);
});
fr.alea = Ly, fr.xor128 = zy, fr.xorwow = Gy, fr.xorshift7 = Hy, fr.xor4096 = Wy, fr.tychei = $y;
var yi = fr.alea, cf = S({ addN_: function(e) {
  A(Array.isArray(e), function() {
    return "The argument passed to tf.addN() must be a list of tensors";
  }), A(e.length >= 1, function() {
    return "Must pass at least one tensor to tf.addN(), but got " + e.length;
  });
  var n = e.map(function(a, o) {
    return k(a, "tensors" + o, "addN");
  }), t = n[0];
  n.forEach(function(a) {
    if (a.dtype !== t.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), n.forEach(function(a) {
    if (!Ye(a.shape, t.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  var r = n;
  return D.runKernelFunc(function(a, o) {
    return a.addN(n);
  }, r, null, "AddN");
} });
function bi() {
  qd("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon");
}
function hf(e) {
  return e.rank === 0 || e.rank === 1 ? e.as4D(1, 1, 1, e.size) : e.rank === 2 ? e.as4D(1, 1, e.shape[0], e.shape[1]) : e.rank === 3 ? e.as4D(1, e.shape[0], e.shape[1], e.shape[2]) : e;
}
function df(e, n, t, r, a, o) {
  o == null && (o = 1e-3);
  var i, s, u = k(e, "x", "batchNorm"), l = k(n, "mean", "batchNorm"), c = k(t, "variance", "batchNorm");
  a != null && (i = k(a, "scale", "batchNorm")), r != null && (s = k(r, "offset", "batchNorm")), A(l.rank === c.rank, function() {
    return "Batch normalization gradient requires mean and variance to have equal ranks.";
  }), A(s == null || l.rank === s.rank, function() {
    return "Batch normalization gradient requires mean and offset to have equal ranks.";
  }), A(i == null || l.rank === i.rank, function() {
    return "Batch normalization gradient requires mean and scale to have equal ranks.";
  });
  var h = { x: u, scale: i, offset: s, mean: l, variance: c }, d = { varianceEpsilon: o };
  return D.runKernelFunc(function(p, f) {
    var m = hf(u), g = p.batchNormalization(m, ho(l), ho(c), o, ho(i), ho(s));
    return f([u, l, c, i]), g;
  }, h, null, "FusedBatchNorm", d).reshape(u.shape);
}
function ho(e) {
  return e == null ? null : e.rank === 0 ? e.as1D() : e.rank === 1 ? e : e.rank === 2 ? e.as4D(1, 1, e.shape[0], e.shape[1]) : e.rank === 3 ? e.as4D(1, e.shape[0], e.shape[1], e.shape[2]) : e;
}
var Uy = S({ batchNormalization_: function(e, n, t, r, a, o) {
  return r === void 0 && (r = 1e-3), bi(), df(e, n, t, o, a, r);
} }), fa = S({ batchNorm_: df });
function pf(e, n, t, r, a, o) {
  var i, s, u = k(e, "x", "batchNorm"), l = k(n, "mean", "batchNorm"), c = k(t, "variance", "batchNorm");
  return a != null && (i = k(a, "scale", "batchNorm")), r != null && (s = k(r, "offset", "batchNorm")), A(u.rank === 2, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), A(l.rank === 2 || l.rank === 1, function() {
    return "Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank " + l.rank + ".";
  }), A(c.rank === 2 || c.rank === 1, function() {
    return "Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank " + c.rank + ".";
  }), i != null && A(i.rank === 2 || i.rank === 1, function() {
    return "Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank " + i.rank + ".";
  }), s != null && A(s.rank === 2 || s.rank === 1, function() {
    return "Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank " + s.rank + ".";
  }), fa(u, l, c, s, i, o);
}
var Ky = S({ batchNormalization2d_: function(e, n, t, r, a, o) {
  return r === void 0 && (r = 1e-3), bi(), pf(e, n, t, o, a, r);
} }), qy = S({ batchNorm2d_: pf });
function ff(e, n, t, r, a, o) {
  var i, s, u = k(e, "x", "batchNorm"), l = k(n, "mean", "batchNorm"), c = k(t, "variance", "batchNorm");
  return a != null && (i = k(a, "scale", "batchNorm")), r != null && (s = k(r, "offset", "batchNorm")), A(u.rank === 3, function() {
    return "Error in batchNorm3D: x must be rank 3 but got rank " + u.rank + ".";
  }), A(l.rank === 3 || l.rank === 1, function() {
    return "Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank " + l.rank + ".";
  }), A(c.rank === 3 || c.rank === 1, function() {
    return "Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank " + c.rank + ".";
  }), i != null && A(i.rank === 3 || i.rank === 1, function() {
    return "Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank " + i.rank + ".";
  }), s != null && A(s.rank === 3 || s.rank === 1, function() {
    return "Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank " + s.rank + ".";
  }), fa(u, l, c, s, i, o);
}
var Jy = S({ batchNormalization3d_: function(e, n, t, r, a, o) {
  return r === void 0 && (r = 1e-3), bi(), ff(e, n, t, o, a, r);
} }), Xy = S({ batchNorm3d_: ff });
function mf(e, n, t, r, a, o) {
  var i, s, u = k(e, "x", "batchNorm"), l = k(n, "mean", "batchNorm"), c = k(t, "variance", "batchNorm");
  return a != null && (i = k(a, "scale", "batchNorm")), r != null && (s = k(r, "offset", "batchNorm")), A(u.rank === 4, function() {
    return "Error in batchNorm4D: x must be rank 4 but got rank " + u.rank + ".";
  }), A(l.rank === 4 || l.rank === 1, function() {
    return "Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank " + l.rank + ".";
  }), A(c.rank === 4 || c.rank === 1, function() {
    return "Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank " + c.rank + ".";
  }), i != null && A(i.rank === 4 || i.rank === 1, function() {
    return "Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank " + i.rank + ".";
  }), s != null && A(s.rank === 4 || s.rank === 1, function() {
    return "Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank " + s.rank + ".";
  }), fa(u, l, c, s, i, o);
}
var Qy = S({ batchNormalization4d_: function(e, n, t, r, a, o) {
  return r === void 0 && (r = 1e-3), bi(), mf(e, n, t, o, a, r);
} }), Yy = S({ batchNorm4d_: mf }), gf = S({ broadcastTo_: function(e, n) {
  var t = k(e, "broadcastTo", "x"), r = t.shape;
  if (n.some(function(h) {
    return !(h > 0) || h % 1 != 0;
  })) throw new Error("broadcastTo(): Invalid broadcast shape [" + n + "].");
  if (n.length < t.rank) throw new Error("broadcastTo(): shape.length=" + n.length + " < input.rank=" + t.rank + ".");
  if (n.length > t.rank) {
    for (var a = t.shape.slice(); a.length < n.length; ) a.unshift(1);
    t = t.reshape(a);
  }
  for (var o = t.shape, i = Array.from(n), s = n.length - 1; s >= 0; s--) if (o[s] === n[s]) i[s] = 1;
  else if (t.shape[s] !== 1) throw new Error("broadcastTo(): [" + r + "] cannot be broadcast to [" + n + "].");
  var u = i.map(function(h, d) {
    return h > 1 ? d : -1;
  }).filter(function(h) {
    return h >= 0;
  });
  if (u.length === 0) return t.clone();
  var l = { x: t }, c = { shape: n, inputShape: o };
  return D.runKernelFunc(function(h) {
    return h.tile(t, i);
  }, l, function(h) {
    return { x: function() {
      return h.sum(u, !0);
    } };
  }, ap, c);
} }), Zy = S({ clone_: function(e) {
  var n = k(e, "x", "clone", null);
  return D.runKernelFunc(function() {
    return D.makeTensorFromDataId(n.dataId, n.shape, n.dtype);
  }, { x: n }, null, ip);
} }), Xa = S({ logicalAnd_: function(e, n) {
  var t = k(e, "a", "logicalAnd", "bool"), r = k(n, "b", "logicalAnd", "bool");
  return fe(t.shape, r.shape), D.runKernelFunc(function(a) {
    return a.logicalAnd(t, r);
  }, { a: t, b: r }, null, "LogicalAnd");
} }), vf = S({ logicalNot_: function(e) {
  var n = k(e, "x", "logicalNot", "bool");
  return D.runKernelFunc(function(t) {
    return t.logicalNot(n);
  }, { $x: n });
} }), Wu = S({ logicalOr_: function(e, n) {
  var t = k(e, "a", "logicalOr", "bool"), r = k(n, "b", "logicalOr", "bool");
  return fe(t.shape, r.shape), D.runKernelFunc(function(a) {
    return a.logicalOr(t, r);
  }, { $a: t, $b: r });
} }), eb = S({ logicalXor_: function(e, n) {
  var t = k(e, "a", "logicalXor", "bool"), r = k(n, "b", "logicalXor", "bool");
  return fe(t.shape, r.shape), Wu(e, n).logicalAnd(Xa(e, n).logicalNot());
} }), nr = S({ where_: function(e, n, t) {
  var r = k(n, "a", "where"), a = k(t, "b", "where"), o = k(e, "condition", "where", "bool");
  return ke(r.shape, a.shape, "Error in where: "), o.rank === 1 ? A(o.shape[0] === r.shape[0], function() {
    return "The first dimension of `a` must match the size of `condition`.";
  }) : ke(o.shape, a.shape, "Error in where: "), D.runKernelFunc(function(i, s) {
    var u = i.select(o, r, a);
    return s([o]), u;
  }, { $condition: o, $a: r, $b: a }, function(i, s) {
    var u = s[0];
    return { $condition: function() {
      return ve(u).toFloat();
    }, $a: function() {
      return i.mul(u.cast(i.dtype));
    }, $b: function() {
      return i.mul(u.logicalNot().cast(i.dtype));
    } };
  });
} }), $u = function(e) {
  return Y(this, void 0, void 0, function() {
    var n, t, r;
    return Z(this, function(a) {
      switch (a.label) {
        case 0:
          return [4, (n = k(e, "condition", "whereAsync", "bool")).data()];
        case 1:
          return t = a.sent(), r = Lu(n.shape, t), e !== n && n.dispose(), [2, r];
      }
    });
  });
}, Uu = S({ divNoNan_: function(e, n) {
  var t, r = k(e, "a", "div"), a = k(n, "b", "div");
  r = (t = Le(r, a))[0], a = t[1];
  var o = Bn(r, a), i = ve(o), s = a.equal(i);
  return nr(s, i, o);
} }), kr = S({ tile_: function(e, n) {
  var t = k(e, "x", "tile", null);
  A(t.rank === n.length, function() {
    return "Error in transpose: rank of input " + t.rank + " must match length of reps " + n + ".";
  });
  var r = [t], a = { x: t }, o = { reps: n };
  return D.runKernelFunc(function(i, s) {
    var u = i.tile(t, n);
    return s([t]), u;
  }, a, null, sp, o, r);
} }), yf = S({ eye_: function(e, n, t, r) {
  r === void 0 && (r = "float32"), n == null && (n = e);
  for (var a = oe([e, n], r), o = e <= n ? e : n, i = 0; i < o; ++i) a.set(1, i, i);
  var s = a.toTensor().as2D(e, n);
  if (t == null) return s;
  if (t.length === 1) return kr(Tn(s, 0), [t[0], 1, 1]);
  if (t.length === 2) return kr(Tn(Tn(s, 0), 0), [t[0], t[1], 1, 1]);
  if (t.length === 3) return kr(Tn(Tn(Tn(s, 0), 0), 0), [t[0], t[1], t[2], 1, 1]);
  throw new Error("eye() currently supports only 1D and 2D batchShapes, but received " + t.length + "D.");
} }), bf = S({ multinomial_: function(e, n, t, r) {
  r === void 0 && (r = !1);
  var a = k(e, "logits", "multinomial"), o = a.size, i = a.rank;
  if (o < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + o + ".");
  if (i > 2) throw new Error("Rank of probabilities must be 1 or 2, but is " + i);
  t = t || Math.random();
  var s = i === 1 ? a.as2D(1, -1) : a, u = D.runKernelFunc(function(l) {
    return l.multinomial(s, r, n, t);
  }, { logits2D: s });
  return i === 1 ? u.as1D() : u;
} }), za = S({ oneHot_: function(e, n, t, r) {
  if (t === void 0 && (t = 1), r === void 0 && (r = 0), n < 2) throw new Error("Error in oneHot: depth must be >=2, but it is " + n);
  var a = k(e, "indices", "oneHot", "int32"), o = a.shape.concat([n]), i = { indices: a = a.flatten() }, s = { depth: n, onValue: t, offValue: r };
  return D.runKernelFunc(function(u, l) {
    return l([a]), u.oneHot(a, n, t, r);
  }, i, null, op, s).reshape(o);
} }), ir = S({ pad_: function(e, n, t) {
  t === void 0 && (t = 0);
  var r = k(e, "x", "pad");
  if (r.rank === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  var a = { paddings: n, constantValue: t }, o = { x: r };
  return D.runKernelFunc(function(i, s) {
    return s([r]), i.pad(r, n, t);
  }, o, null, up, a);
} }), tb = S({ pad1d_: function(e, n, t) {
  return t === void 0 && (t = 0), A(n.length === 2, function() {
    return "Invalid number of paddings. Must be length of 2.";
  }), ir(e, [n], t);
} }), nb = S({ pad2d_: function(e, n, t) {
  return t === void 0 && (t = 0), A(n.length === 2 && n[0].length === 2 && n[1].length === 2, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), ir(e, n, t);
} }), rb = S({ pad3d_: function(e, n, t) {
  return t === void 0 && (t = 0), A(n.length === 3 && n[0].length === 2 && n[1].length === 2 && n[2].length === 2, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), ir(e, n, t);
} }), ab = S({ pad4d_: function(e, n, t) {
  return t === void 0 && (t = 0), A(n.length === 4 && n[0].length === 2 && n[1].length === 2 && n[2].length === 2 && n[3].length === 2, function() {
    return "Invalid number of paddings. Must be length of 2 each.";
  }), ir(e, n, t);
} }), ob = S({ rand_: function(e, n, t) {
  var r = Q(e), a = null;
  if (t == null || t === "float32") a = new Float32Array(r);
  else if (t === "int32") a = new Int32Array(r);
  else {
    if (t !== "bool") throw new Error("Unknown data type " + t);
    a = new Uint8Array(r);
  }
  for (var o = 0; o < r; o++) a[o] = n();
  return D.makeTensor(a, e, t);
} }), Ku = function() {
  function e(n, t, r, a, o) {
    this.mean = n, this.stdDev = t, this.dtype = r, this.nextVal = NaN, this.truncated = a, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
    var i = o || Math.random();
    this.random = yi(i.toString());
  }
  return e.prototype.nextValue = function() {
    if (!isNaN(this.nextVal)) {
      var n = this.nextVal;
      return this.nextVal = NaN, n;
    }
    for (var t, r, a = !1; !a; ) {
      var o = void 0, i = void 0, s = void 0;
      do
        s = (o = 2 * this.random() - 1) * o + (i = 2 * this.random() - 1) * i;
      while (s >= 1 || s === 0);
      var u = Math.sqrt(-2 * Math.log(s) / s);
      t = this.mean + this.stdDev * o * u, r = this.mean + this.stdDev * i * u, this.truncated && !this.isValidTruncated(t) || (a = !0);
    }
    return this.truncated && !this.isValidTruncated(r) || (this.nextVal = this.convertValue(r)), this.convertValue(t);
  }, e.prototype.convertValue = function(n) {
    return this.dtype == null || this.dtype === "float32" ? n : Math.round(n);
  }, e.prototype.isValidTruncated = function(n) {
    return n <= this.upper && n >= this.lower;
  }, e;
}(), ib = function() {
  function e(n, t, r, a) {
    this.alpha = n, this.beta = 1 / t, this.dtype = r;
    var o = a || Math.random();
    this.randu = yi(o.toString()), this.randn = new Ku(0, 1, r, !1, this.randu()), this.d = n < 1 ? n + 2 / 3 : n - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
  }
  return e.prototype.nextValue = function() {
    for (var n, t, r, a, o, i; ; ) {
      do
        a = this.randn.nextValue(), i = 1 + this.c * a;
      while (i <= 0);
      if (i *= i * i, t = 1 - 0.331 * (n = a * a) * n, r = 0.5 * n + this.d * (1 - i + Math.log(i)), (o = this.randu()) < t || Math.log(o) < r) break;
    }
    return i = 1 / this.beta * this.d * i, this.alpha < 1 && (i *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i);
  }, e.prototype.convertValue = function(n) {
    return this.dtype === "float32" ? n : Math.round(n);
  }, e;
}(), sb = function() {
  function e(n, t, r, a) {
    var o = this;
    if (n === void 0 && (n = 0), t === void 0 && (t = 1), this.canReturnFloat = function() {
      return o.dtype == null || o.dtype === "float32";
    }, this.min = n, this.range = t - n, this.dtype = r, a == null && (a = Math.random()), typeof a == "number" && (a = a.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between " + n + " - " + t + " <= 1 and dtype is not float");
    this.random = yi(a);
  }
  return e.prototype.convertValue = function(n) {
    return this.canReturnFloat() ? n : Math.round(n);
  }, e.prototype.nextValue = function() {
    return this.convertValue(this.min + this.range * this.random());
  }, e;
}(), ub = S({ randomGamma_: function(e, n, t, r, a) {
  if (t === void 0 && (t = 1), r === void 0 && (r = "float32"), t == null && (t = 1), r == null && (r = "float32"), r !== "float32" && r !== "int32") throw new Error("Unsupported data type " + r);
  for (var o = new ib(n, t, r, a), i = oe(e, r), s = 0; s < i.values.length; s++) i.values[s] = o.nextValue();
  return i.toTensor();
} }), lb = S({ randomNormal_: function(e, n, t, r, a) {
  if (n === void 0 && (n = 0), t === void 0 && (t = 1), r != null && r === "bool") throw new Error("Unsupported data type " + r);
  for (var o = new Ku(n, t, r, !1, a), i = oe(e, r), s = 0; s < i.values.length; s++) i.values[s] = o.nextValue();
  return i.toTensor();
} }), qu = S({ randomUniform_: function(e, n, t, r, a) {
  n === void 0 && (n = 0), t === void 0 && (t = 1), r === void 0 && (r = "float32");
  for (var o = oe(e, r), i = new sb(n, t, null, a), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
  return o.toTensor();
} }), Ju = S({ square_: function(e) {
  var n = k(e, "x", "square"), t = [n];
  return D.runKernelFunc(function(r, a) {
    return a([n]), r.square(n);
  }, { x: n }, null, "Square", {}, t, []);
} }), Xu = S({ squaredDifference_: function(e, n) {
  var t, r = k(e, "a", "squaredDifference"), a = k(n, "b", "squaredDifference");
  t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape);
  var o = { a: r, b: a }, i = [r, a];
  return D.runKernelFunc(function(s, u) {
    var l = s.squaredDifference(r, a);
    return u([r, a]), l;
  }, o, function(s, u) {
    var l = u[0], c = u[1], h = X(2);
    return { a: function() {
      return s.mul(l.sub(c).mul(h));
    }, b: function() {
      return s.mul(c.sub(l).mul(h));
    } };
  }, pi, {}, i, []);
} }), xf = S({ truncatedNormal_: function(e, n, t, r, a) {
  if (n === void 0 && (n = 0), t === void 0 && (t = 1), r != null && r === "bool") throw new Error("Unsupported data type $ { dtype }");
  for (var o = new Ku(n, t, r, !0, a), i = oe(e, r), s = 0; s < i.values.length; s++) i.values[s] = o.nextValue();
  return i.toTensor();
} }), Qu = S({ equal_: function(e, n) {
  var t, r = k(e, "a", "equal"), a = k(n, "b", "equal");
  return t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape), D.runKernelFunc(function(o) {
    return o.equal(r, a);
  }, { $a: r, $b: a });
} }), cb = S({ equalStrict_: function(e, n) {
  var t = k(e, "a", "equalStrict"), r = k(n, "b", "equalStrict");
  return ke(t.shape, r.shape, "Error in equalStrict: "), t.equal(r);
} }), wf = S({ greater_: function(e, n) {
  var t, r = k(e, "a", "greater"), a = k(n, "b", "greater");
  return t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape), D.runKernelFunc(function(o) {
    return o.greater(r, a);
  }, { a: r, b: a }, null, "Greater");
} }), Yu = S({ greaterEqual_: function(e, n) {
  var t, r = k(e, "a", "greaterEqual"), a = k(n, "b", "greaterEqual");
  return t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape), D.runKernelFunc(function(o, i) {
    var s = o.greaterEqual(r, a);
    return i([r, a]), s;
  }, { a: r, b: a }, function(o, i) {
    var s = i[0], u = i[1];
    return { a: function() {
      return ve(s);
    }, b: function() {
      return ve(u);
    } };
  }, "GreaterEqual");
} }), hb = S({ greaterEqualStrict_: function(e, n) {
  var t = k(e, "a", "greaterEqualStrict"), r = k(n, "b", "greaterEqualStrict");
  return ke(t.shape, r.shape, "Error in greaterEqualStrict: "), t.greaterEqual(r);
} }), db = S({ greaterStrict_: function(e, n) {
  var t = k(e, "a", "greaterStrict"), r = k(n, "b", "greaterStrict");
  return ke(t.shape, r.shape, "Error in greaterStrict: "), t.greater(r);
} }), Cf = S({ less_: function(e, n) {
  var t, r = k(e, "a", "less"), a = k(n, "b", "less");
  return t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape), D.runKernelFunc(function(o) {
    return o.less(r, a);
  }, { a: r, b: a }, null, "Less");
} }), kf = S({ lessEqual_: function(e, n) {
  var t, r = k(e, "a", "lessEqual"), a = k(n, "b", "lessEqual");
  return t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape), D.runKernelFunc(function(o, i) {
    var s = o.lessEqual(r, a);
    return i([r, a]), s;
  }, { a: r, b: a }, null, "LessEqual");
} }), pb = S({ lessEqualStrict_: function(e, n) {
  var t = k(e, "a", "lessEqualStrict"), r = k(n, "b", "lessEqualStrict");
  return ke(t.shape, r.shape, "Error in lessEqualStrict: "), t.lessEqual(r);
} }), fb = S({ lessStrict_: function(e, n) {
  var t = k(e, "a", "lessStrict"), r = k(n, "b", "lessStrict");
  return ke(t.shape, r.shape, "Error in lessStrict: "), t.less(r);
} }), Nf = S({ notEqual_: function(e, n) {
  var t, r = k(e, "a", "notEqual"), a = k(n, "b", "notEqual");
  return t = Le(r, a), r = t[0], a = t[1], fe(r.shape, a.shape), D.runKernelFunc(function(o) {
    return o.notEqual(r, a);
  }, { a: r, b: a }, null, "NotEqual");
} }), mb = S({ notEqualStrict_: function(e, n) {
  var t = k(e, "a", "notEqualStrict"), r = k(n, "b", "notEqualStrict");
  return ke(t.shape, r.shape, "Error in notEqualStrict: "), t.notEqual(r);
} });
function oc(e, n) {
  for (var t = [], r = e; r < n; ++r) t.push(r);
  return t;
}
function ic(e) {
  for (var n = [], t = 0; t < e.length; ++t) for (var r = 0; r < e[t].length; ++r) n.push(e[t][r]);
  return n;
}
var xi = S({ gather_: function(e, n, t) {
  t === void 0 && (t = 0);
  var r = k(e, "x", "gather"), a = k(n, "indices", "gather", "int32");
  t = Xe(t, r.shape)[0];
  var o = function(i, s, u) {
    for (var l = i.shape[u], c = [], h = 1, d = 1, p = 0; p < u; p++) c.push(i.shape[p]), h *= i.shape[p];
    for (p = 0; p < s.rank; p++) c.push(s.shape[p]);
    for (p = u + 1; p < i.rank; p++) c.push(i.shape[p]), d *= i.shape[p];
    return { batchSize: h, sliceSize: d, dimSize: l, outputShape: c };
  }(r, a, t);
  return D.runKernelFunc(function(i, s) {
    var u = i.gather(r, a.flatten(), t);
    return s([a]), u;
  }, { x: r, indices: a }, function(i, s) {
    var u = s[0];
    return { x: function() {
      var l = r.shape, c = u.size, h = l.slice(0, t), d = h.length, p = l.slice(t, l.length).slice(1), f = p.length, m = oc(0, d), g = oc(d + 1, d + 1 + f), v = ic([h, [c], p]), y = i.reshape(v), b = u.reshape([c]), x = ic([[d], m, g]), C = y.transpose(x), N = Af(C, b, r.shape[t]), T = Tu(x);
      return N = N.transpose(T);
    }, indices: function() {
      return u;
    } };
  }, "Gather", { axis: t }).reshape(o.outputShape);
} }), Af = S({ unsortedSegmentSum_: function(e, n, t) {
  var r = k(e, "x", "unsortedSegmentSum"), a = k(n, "segmentIds", "unsortedSegmentSum", "int32");
  return A(He(t), function() {
    return "numSegments must be of dtype int";
  }), D.runKernelFunc(function(o, i) {
    var s = o.unsortedSegmentSum(r, a, t);
    return i([a]), s;
  }, { $x: r }, function(o, i) {
    var s = i[0];
    return { $x: function() {
      return function(u, l) {
        for (var c = mi(l, ve(l)), h = xi(u, c), d = Yu(l, X(0, "int32")), p = h.rank - d.rank, f = 0; f < p; ++f) d = Tn(d, f + 1);
        d = Xa(d, Pr(h.shape, "bool"));
        var m = ve(h);
        return nr(d, h, m);
      }(o, s);
    } };
  });
} }), gb = function(e, n, t) {
  return Y(this, void 0, void 0, function() {
    var r, a, o, i, s, u, l, c, h, d, p, f, m;
    return Z(this, function(g) {
      switch (g.label) {
        case 0:
          for (r = k(e, "tensor", "boolMask"), a = k(n, "mask", "boolMask", "bool"), o = t ?? 0, i = a.rank, s = r.shape, A(i > 0, function() {
            return "mask cannot be scalar";
          }), ke(s.slice(o, o + i), a.shape, "mask's shape must match the first K dimensions of tensor's shape,"), u = 1, l = o; l < o + i; l++) u *= s[l];
          return c = s.slice(0, o).concat([u], s.slice(o + i)), h = r.reshape(c), d = a.reshape([-1]), [4, $u(d)];
        case 1:
          return p = g.sent(), f = p.squeeze([1]), m = xi(h, f, o), e !== r && r.dispose(), n !== a && a.dispose(), f.dispose(), h.dispose(), d.dispose(), p.dispose(), [2, m];
      }
    });
  });
};
function If(e, n, t, r, a, o, i) {
  o === void 0 && (o = "NHWC"), A(e.length === n.rank, function() {
    return "Length of inShape (" + e.length + ") and rank of dy (" + n.rank + ") must match";
  });
  var s = e, u = n, l = !1;
  n.rank === 3 && (l = !0, u = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]), s = [1, e[0], e[1], e[2]]), A(s.length === 4, function() {
    return "Error in conv2dDerInput: inShape must be length 4, but got length " + s.length + ".";
  }), A(u.rank === 4, function() {
    return "Error in conv2dDerInput: dy must be rank 4, but got rank " + u.rank;
  }), A(t.rank === 4, function() {
    return "Error in conv2dDerInput: filter must be rank 4, but got rank " + t.rank;
  });
  var c = o === "NHWC" ? s[3] : s[1], h = o === "NHWC" ? u.shape[3] : u.shape[1];
  A(c === t.shape[2], function() {
    return "Error in conv2dDerInput: depth of input (" + c + ") must match input depth for filter " + t.shape[2] + ".";
  }), A(h === t.shape[3], function() {
    return "Error in conv2dDerInput: depth of output (" + h + ") must match output depth for filter " + t.shape[3] + ".";
  }), i != null && A(He(a), function() {
    return "Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + ".";
  });
  var d = Bu(o), p = Sr(s, t.shape, r, 1, a, i, !1, d), f = D.runKernelFunc(function(m, g) {
    var v = m.conv2dDerInput(u, t, p);
    return g([t, u]), v;
  }, { dy4D: u, filter: t }, function(m, g) {
    var v = g[0], y = g[1];
    return { dy4D: function() {
      return ma(m, v, r, a, o, 1, i);
    }, filter: function() {
      return Zu(m, y, v.shape, r, a, o, i);
    } };
  });
  return l ? f.as3D(f.shape[1], f.shape[2], f.shape[3]) : f;
}
function qi(e) {
  var n = function(o) {
    return typeof o == "number" ? [o, o, o] : o.length === 2 ? [o[0], o[1], 1] : o;
  }(e), t = n[0], r = n[1], a = n[2];
  return t === 1 && r === 1 && a === 1;
}
function Ef(e, n, t, r, a) {
  A(e.length === n.rank, function() {
    return "Length of inShape (" + e.length + ") and rank of dy (" + n.rank + ") must match";
  });
  var o = e, i = n, s = !1;
  n.rank === 4 && (s = !0, i = n.as5D(1, n.shape[0], n.shape[1], n.shape[2], n.shape[3]), o = [1, e[0], e[1], e[2], e[3]]);
  var u = o[4], l = i.shape[4];
  A(o.length === 5, function() {
    return "Error in conv3dDerInput: inShape must be length 5, but got length " + o.length + ".";
  }), A(i.rank === 5, function() {
    return "Error in conv3dDerInput: dy must be rank 5, but got rank " + i.rank;
  }), A(t.rank === 5, function() {
    return "Error in conv3dDerInput: filter must be rank 5, but got rank " + t.rank;
  }), A(u === t.shape[3], function() {
    return "Error in conv3dDerInput: depth of input (" + u + ") must match input depth for filter " + t.shape[3] + ".";
  }), A(l === t.shape[4], function() {
    return "Error in conv3dDerInput: depth of output (" + l + ") must match output depth for filter " + t.shape[4] + ".";
  });
  var c = ei(o, t.shape, r, 1, a), h = D.runKernelFunc(function(d) {
    return d.conv3dDerInput(i, t, c);
  }, { dy5D: i });
  return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
}
var Tf = S({ conv1d_: function(e, n, t, r, a, o, i) {
  a === void 0 && (a = "NWC"), o === void 0 && (o = 1);
  var s = k(e, "x", "conv1d"), u = k(n, "filter", "conv1d"), l = s, c = !1;
  s.rank === 2 && (c = !0, l = s.as3D(1, s.shape[0], s.shape[1])), A(l.rank === 3, function() {
    return "Error in conv1d: input must be rank 3, but got rank " + l.rank + ".";
  }), A(u.rank === 3, function() {
    return "Error in conv1d: filter must be rank 3, but got rank " + u.rank + ".";
  }), i != null && A(He(r), function() {
    return "Error in conv1d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
  }), A(l.shape[2] === u.shape[1], function() {
    return "Error in conv1d: depth of input (" + l.shape[2] + ") must match input depth for filter " + u.shape[1] + ".";
  }), A(vt(t, o), function() {
    return "Error in conv1D: Either stride or dilation must be 1. Got stride " + t + " and dilation '" + o + "'";
  }), A(a === "NWC", function() {
    return "Error in conv1d: got dataFormat of " + a + " but only NWC is currently supported.";
  });
  var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]), d = l.as4D(l.shape[0], 1, l.shape[1], l.shape[2]), p = ma(d, h, [1, t], r, "NHWC", [1, o], i);
  return c ? p.as2D(p.shape[2], p.shape[3]) : p.as3D(p.shape[0], p.shape[2], p.shape[3]);
} }), ma = S({ conv2d_: function(e, n, t, r, a, o, i) {
  a === void 0 && (a = "NHWC"), o === void 0 && (o = [1, 1]);
  var s = k(e, "x", "conv2d"), u = k(n, "filter", "conv2d"), l = s, c = !1;
  s.rank === 3 && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), A(l.rank === 4, function() {
    return "Error in conv2d: input must be rank 4, but got rank " + l.rank + ".";
  }), A(u.rank === 4, function() {
    return "Error in conv2d: filter must be rank 4, but got rank " + u.rank + ".";
  }), i != null && A(He(r), function() {
    return "Error in conv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
  });
  var h = a === "NHWC" ? l.shape[3] : l.shape[1];
  A(h === u.shape[2], function() {
    return "Error in conv2d: depth of input (" + h + ") must match input depth for filter " + u.shape[2] + ".";
  }), A(vt(t, o), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + o + "'";
  });
  var d = Bu(a), p = Sr(l.shape, u.shape, t, o, r, i, !1, d), f = [u, l], m = D.runKernelFunc(function(g, v) {
    var y = g.conv2d(l, u, p);
    return v([u, l]), y;
  }, { x: l, filter: u }, function(g, v) {
    var y = v, b = y[0], x = y[1];
    return A(ca(o), function() {
      return "Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + o + "'";
    }), { x: function() {
      return Sf(x.shape, g, b, t, r, a);
    }, filter: function() {
      return Zu(x, g, b.shape, t, r, a);
    } };
  }, "Conv2D", p, f);
  return c ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;
} }), Pf = S({ conv3d_: function(e, n, t, r, a, o) {
  a === void 0 && (a = "NDHWC"), o === void 0 && (o = [1, 1, 1]);
  var i = k(e, "x", "conv3d"), s = k(n, "filter", "conv3d"), u = i, l = !1;
  i.rank === 4 && (l = !0, u = i.as5D(1, i.shape[0], i.shape[1], i.shape[2], i.shape[3])), A(u.rank === 5, function() {
    return "Error in conv3d: input must be rank 5, but got rank " + u.rank + ".";
  }), A(s.rank === 5, function() {
    return "Error in conv3d: filter must be rank 5, but got rank " + s.rank + ".";
  }), A(u.shape[4] === s.shape[3], function() {
    return "Error in conv3d: depth of input (" + u.shape[4] + ") must match input depth for filter " + s.shape[3] + ".";
  }), A(function(d, p) {
    return qi(d) || qi(p);
  }(t, o), function() {
    return "Error in conv3D: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + o + "'";
  }), A(a === "NDHWC", function() {
    return "Error in conv3d: got dataFormat of " + a + " but only NDHWC is currently supported.";
  });
  var c = ei(u.shape, s.shape, t, o, r), h = D.runKernelFunc(function(d, p) {
    var f = d.conv3d(u, s, c);
    return p([u, s]), f;
  }, { x: u, $filter: s }, function(d, p) {
    A(qi(o), function() {
      return "Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + o + "'";
    });
    var f = p[0], m = p[1];
    return { x: function() {
      return Ef(f.shape, d, m, t, r);
    }, $filter: function() {
      return function(g, v, y, b, x) {
        var C = g;
        g.rank === 4 && (C = g.as5D(1, g.shape[0], g.shape[1], g.shape[2], g.shape[3]));
        var N = v;
        N.rank === 4 && (N = v.as5D(1, v.shape[0], v.shape[1], v.shape[2], v.shape[3])), A(C.rank === 5, function() {
          return "Error in conv3dDerFilter: input must be rank 5, but got shape " + C.shape + ".";
        }), A(N.rank === 5, function() {
          return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + N.shape + ".";
        }), A(y.length === 5, function() {
          return "Error in conv3dDerFilter: filterShape must be length 5, but got " + y + ".";
        }), A(C.shape[4] === y[3], function() {
          return "Error in conv3dDerFilter: depth of input " + C.shape[4] + ") must match input depth in filter (" + y[3] + ".";
        }), A(N.shape[4] === y[4], function() {
          return "Error in conv3dDerFilter: depth of dy (" + N.shape[4] + ") must match output depth for filter (" + y[4] + ").";
        });
        var T = ei(C.shape, y, b, 1, x);
        return D.runKernelFunc(function(I) {
          return I.conv3dDerFilter(C, N, T);
        }, { x5D: C, dy5D: N });
      }(f, d, m.shape, t, r);
    } };
  });
  return l ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
} }), Zu = S({ conv2dDerFilter_: function(e, n, t, r, a, o, i) {
  o === void 0 && (o = "NHWC");
  var s = e;
  e.rank === 3 && (s = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
  var u = n;
  u.rank === 3 && (u = n.as4D(1, n.shape[0], n.shape[1], n.shape[2])), A(s.rank === 4, function() {
    return "Error in conv2dDerFilter: input must be rank 4, but got shape " + s.shape + ".";
  }), A(u.rank === 4, function() {
    return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + u.shape + ".";
  }), A(t.length === 4, function() {
    return "Error in conv2dDerFilter: filterShape must be length 4, but got " + t + ".";
  });
  var l = o === "NHWC" ? s.shape[3] : s.shape[1], c = o === "NHWC" ? u.shape[3] : u.shape[1];
  A(l === t[2], function() {
    return "Error in conv2dDerFilter: depth of input " + l + ") must match input depth in filter (" + t[2] + ".";
  }), A(c === t[3], function() {
    return "Error in conv2dDerFilter: depth of dy (" + c + ") must match output depth for filter (" + t[3] + ").";
  }), i != null && A(He(a), function() {
    return "Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + a + ".";
  });
  var h = Bu(o), d = Sr(s.shape, t, r, 1, a, i, !1, h);
  return D.runKernelFunc(function(p) {
    return p.conv2dDerFilter(s, u, d);
  }, { x4D: s, dy4D: u });
} }), Sf = S({ conv2dDerInput_: If }), wi = S({ depthwiseConv2d_: function(e, n, t, r, a, o, i) {
  o === void 0 && (o = [1, 1]);
  var s = k(e, "x", "depthwiseConv2d"), u = k(n, "filter", "depthwiseConv2d"), l = s, c = !1;
  s.rank === 3 && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), A(l.rank === 4, function() {
    return "Error in depthwiseConv2d: input must be rank 4, but got rank " + l.rank + ".";
  }), A(u.rank === 4, function() {
    return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + u.rank + ".";
  }), A(l.shape[3] === u.shape[2], function() {
    return "Error in depthwiseConv2d: number of input channels (" + l.shape[3] + ") must match the inChannels dimension in filter " + u.shape[2] + ".";
  }), o == null && (o = [1, 1]), A(vt(t, o), function() {
    return "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + o + "'";
  }), i != null && A(He(r), function() {
    return "Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode " + i + " but got pad " + r + ".";
  });
  var h = Sr(l.shape, u.shape, t, o, r, i, !0), d = [l, u], p = D.runKernelFunc(function(f, m) {
    var g = f.depthwiseConv2D(l, u, h);
    return m([l, u]), g;
  }, { x: l, filter: u }, function(f, m) {
    A(ca(o), function() {
      return "Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + o + "'";
    });
    var g = m[0], v = m[1];
    return { x: function() {
      return Df(g.shape, f, v, h);
    }, filter: function() {
      return Of(g, f, v.shape, h);
    } };
  }, "DepthwiseConv2dNative", h, d);
  return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;
} }), Df = S({ depthwiseConv2dDerInput_: function(e, n, t, r) {
  var a = n, o = !1;
  n.rank === 3 && (o = !0, a = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]));
  var i = D.runKernelFunc(function(s) {
    return s.depthwiseConv2DDerInput(a, t, r);
  }, { dy4D: a });
  return o ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;
} }), Of = S({ depthwiseConv2dDerFilter_: function(e, n, t, r) {
  var a = e;
  e.rank === 3 && (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));
  var o = n;
  return o.rank === 3 && (o = n.as4D(1, n.shape[0], n.shape[1], n.shape[2])), D.runKernelFunc(function(i) {
    return i.depthwiseConv2DDerFilter(a, o, r);
  }, { x4D: a, dy4D: o });
} }), vb = S({ separableConv2d_: function(e, n, t, r, a, o, i) {
  o === void 0 && (o = [1, 1]), i === void 0 && (i = "NHWC");
  var s = k(e, "x", "separableConv2d"), u = k(n, "depthwiseFilter", "separableConv2d"), l = k(t, "pointwiseFilter", "separableConv2d"), c = s, h = !1;
  if (s.rank === 3 && (h = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), i === "NCHW") throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  A(c.rank === 4, function() {
    return "Error in separableConv2d: input must be rank 4, but got rank " + c.rank + ".";
  }), A(u.rank === 4, function() {
    return "Error in separableConv2d: depthwise filter must be rank 4, but got rank " + u.rank + ".";
  }), A(l.rank === 4, function() {
    return "Error in separableConv2d: pointwise filter must be rank 4, but got rank " + u.rank + ".";
  }), A(l.shape[0] === 1, function() {
    return "Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got " + l.shape[0] + ".";
  }), A(l.shape[1] === 1, function() {
    return "Error in separableConv2d: the second dimension of pointwise filter must be 1, but got " + l.shape[1] + ".";
  });
  var d = u.shape[2], p = u.shape[3];
  A(l.shape[2] === d * p, function() {
    return "Error in separableConv2d: the third dimension of pointwise filter must be " + d * p + ", but got " + l.shape[2] + ".";
  });
  var f = wi(c, u, r, a, i, o), m = ma(f, l, 1, "valid", i);
  return h ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;
} }), Rf = S({ conv2dTranspose_: function(e, n, t, r, a, o) {
  return If(t, k(e, "x", "conv2dTranspose"), k(n, "filter", "conv2dTranspose"), r, a, "NHWC", o);
} }), yb = S({ conv3dTranspose_: function(e, n, t, r, a) {
  return Ef(t, k(e, "x", "conv3dTranspose"), k(n, "filter", "conv3dTranspose"), r, a);
} }), el = S({ matMul_: function(e, n, t, r) {
  var a;
  t === void 0 && (t = !1), r === void 0 && (r = !1);
  var o = k(e, "a", "matMul"), i = k(n, "b", "matMul");
  a = Le(o, i), o = a[0], i = a[1];
  var s = t ? o.shape[o.rank - 2] : o.shape[o.rank - 1], u = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2], l = t ? o.shape[o.rank - 1] : o.shape[o.rank - 2], c = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1], h = o.shape.slice(0, -2), d = i.shape.slice(0, -2), p = Q(h), f = Q(d);
  A(o.rank >= 2 && i.rank >= 2 && o.rank === i.rank, function() {
    return "Error in matMul: inputs must have the same rank of at least 2, got ranks " + o.rank + " and " + i.rank + ".";
  }), A(Ye(h, d), function() {
    return "Error in matMul: outer dimensions (" + h + ") and (" + d + ") of Tensors with shapes " + o.shape + " and " + i.shape + " must match.";
  }), A(s === u, function() {
    return "Error in matMul: inner shapes (" + s + ") and (" + u + ") of Tensors with shapes " + o.shape + " and " + i.shape + " and transposeA=" + t + " and transposeB=" + r + " must match.";
  });
  var m = o.shape.slice(0, -2).concat([l, c]), g = t ? o.as3D(p, s, l) : o.as3D(p, l, s), v = r ? i.as3D(f, c, u) : i.as3D(f, u, c), y = { transposeA: t, transposeB: r };
  return D.runKernelFunc(function(b, x) {
    var C = b.batchMatMul(g, v, t, r);
    return x([g, v]), C;
  }, { a: g, b: v }, function(b, x) {
    var C = x, N = C[0], T = C[1];
    return t || r ? !t && r ? { a: function() {
      return b.matMul(T, !1, !1);
    }, b: function() {
      return b.matMul(N, !0, !1);
    } } : t && !r ? { a: function() {
      return T.matMul(b, !1, !0);
    }, b: function() {
      return N.matMul(b, !1, !1);
    } } : { a: function() {
      return T.matMul(b, !0, !0);
    }, b: function() {
      return b.matMul(N, !0, !0);
    } } : { a: function() {
      return b.matMul(T, !1, !0);
    }, b: function() {
      return N.matMul(b, !0, !1);
    } };
  }, "BatchMatMul", y).reshape(m);
} }), bb = S({ dot_: function(e, n) {
  var t = k(e, "t1", "dot"), r = k(n, "t2", "dot");
  A(!(t.rank !== 1 && t.rank !== 2 || r.rank !== 1 && r.rank !== 2), function() {
    return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + t.rank + " and " + r.rank + ".";
  });
  var a = t.rank === 1 ? t.size : t.shape[1], o = r.rank === 1 ? r.size : r.shape[0];
  return A(a === o, function() {
    return "Error in dot: inner dimensions of inputs must match, but got " + a + " and " + o + ".";
  }), t.rank === 1 && r.rank === 1 ? t.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : t.rank === 1 && r.rank === 2 ? t.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : t.rank === 2 && r.rank === 1 ? t.matMul(r.as2D(-1, 1)).as1D() : t.matMul(r.as2D(r.shape[0], r.shape[1]));
} }), xb = S({ outerProduct_: function(e, n) {
  var t = k(e, "v1", "outerProduct"), r = k(n, "v2", "outerProduct");
  return A(t.rank === 1 && r.rank === 1, function() {
    return "Error in outerProduct: inputs must be rank 1, but got ranks " + t.rank + " and " + r.rank + ".";
  }), t.as2D(-1, 1).matMul(r.as2D(1, -1));
} }), ga = S({ reverse_: function(e, n) {
  var t = k(e, "x", "reverse");
  if (t.rank === 0) return t.clone();
  var r = Xe(n, t.shape);
  return D.runKernelFunc(function(a) {
    return a.reverse(t, r);
  }, { $x: t }, function(a) {
    return { $x: function() {
      return a.reverse(r);
    } };
  }).reshapeAs(t);
} }), wb = S({ reverse1d_: function(e) {
  var n = k(e, "x", "reverse");
  return A(n.rank === 1, function() {
    return "Error in reverse1D: x must be rank 1 but got rank " + n.rank + ".";
  }), ga(n, 0);
} }), Cb = S({ reverse2d_: function(e, n) {
  var t = k(e, "x", "reverse");
  return A(t.rank === 2, function() {
    return "Error in reverse2D: x must be rank 2 but got rank " + t.rank + ".";
  }), ga(t, n);
} }), kb = S({ reverse3d_: function(e, n) {
  var t = k(e, "x", "reverse");
  return A(t.rank === 3, function() {
    return "Error in reverse3D: x must be rank 3 but got rank " + t.rank + ".";
  }), ga(t, n);
} }), Nb = S({ reverse4d_: function(e, n) {
  var t = k(e, "x", "reverse");
  return A(t.rank === 4, function() {
    return "Error in reverse4D: x must be rank 4 but got rank " + t.rank + ".";
  }), ga(t, n);
} });
function Ff(e, n, t, r, a, o) {
  var i = k(e, "x", "maxPool"), s = i, u = !1;
  i.rank === 3 && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), A(s.rank === 4, function() {
    return "Error in maxPool: input must be rank 4 but got rank " + s.rank + ".";
  }), A(vt(t, r), function() {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + r + "'";
  }), o != null && A(He(a), function() {
    return "Error in maxPool: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + a + ".";
  });
  var l = Ir(s.shape, n, t, r, a, o);
  if (l.filterWidth === 1 && l.filterHeight === 1 && Ye(l.inShape, l.outShape)) return i.clone();
  var c = [s], h = D.runKernelFunc(function(d, p) {
    var f = d.maxPool(s, l);
    return p([s, f]), f;
  }, { x: s }, function(d, p) {
    var f = p[0], m = p[1];
    return { x: function() {
      return function(g, v, y, b, x, C, N, T) {
        var I = k(g, "dy", "maxPoolBackprop"), E = k(v, "input", "maxPoolBackprop"), P = k(y, "output", "maxPoolBackprop");
        A(E.rank === I.rank, function() {
          return "Rank of input (" + E.rank + ") does not match rank of dy (" + I.rank + ")";
        }), A(vt(x, C), function() {
          return "Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides " + x + " and dilations '" + C + "'";
        }), A(I.rank === 4, function() {
          return "Error in maxPoolBackprop: dy must be rank 4 but got rank " + I.rank + ".";
        }), A(E.rank === 4, function() {
          return "Error in maxPoolBackprop: input must be rank 4 but got rank " + E.rank + ".";
        });
        var O = Ir(E.shape, b, x, C, N, T);
        return D.runKernelFunc(function(R) {
          return R.maxPoolBackprop(I, E, P, O);
        }, { $dy: I, $input: E });
      }(d, f, m, n, t, r, a);
    } };
  }, "MaxPool", l, c);
  return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;
}
function Mf(e, n, t, r, a, o) {
  var i = k(e, "x", "avgPool", "float32");
  A(vt(t, r), function() {
    return "Error in avgPool: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + r + "'";
  });
  var s = i, u = !1;
  i.rank === 3 && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), A(s.rank === 4, function() {
    return "Error in avgPool: x must be rank 4 but got rank " + s.rank + ".";
  }), o != null && A(He(a), function() {
    return "Error in avgPool: pad must be an integer when using, dimRoundingMode " + o + " but got pad " + a + ".";
  });
  var l = Ir(s.shape, n, t, r, a, o);
  if (l.filterWidth === 1 && l.filterHeight === 1 && Ye(l.inShape, l.outShape)) return i.clone();
  var c = D.runKernelFunc(function(h) {
    return h.avgPool(s, l);
  }, { x: s }, function(h) {
    return { x: function() {
      return function(d, p, f, m, g, v) {
        var y = k(d, "dy", "avgPoolBackprop"), b = k(p, "input", "avgPoolBackprop");
        A(b.rank === y.rank, function() {
          return "Rank of input (" + b.rank + ") does not match rank of dy (" + y.rank + ")";
        }), A(vt(m, g), function() {
          return "Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides " + m + " and dilations '" + g + "'";
        });
        var x = b, C = y, N = !1;
        b.rank === 3 && (N = !0, x = b.as4D(1, b.shape[0], b.shape[1], b.shape[2]), C = y.as4D(1, y.shape[0], y.shape[1], y.shape[2])), A(C.rank === 4, function() {
          return "Error in avgPoolBackprop: dy must be rank 4 but got rank " + C.rank + ".";
        }), A(x.rank === 4, function() {
          return "Error in avgPoolBackprop: input must be rank 4 but got rank " + x.rank + ".";
        });
        var T = Ir(x.shape, f, m, g, v), I = D.runKernelFunc(function(E) {
          return E.avgPoolBackprop(C, x, T);
        }, { dy4D: C, input4D: x });
        return N ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
      }(h, s, n, t, r, a);
    } };
  }, "AvgPool", l);
  return c = c.cast(i.dtype), u ? c.as3D(c.shape[1], c.shape[2], c.shape[3]) : c;
}
var _f = S({ maxPool_: function(e, n, t, r, a) {
  return Ff(e, n, t, 1, r, a);
} }), Bf = S({ avgPool_: function(e, n, t, r, a) {
  return Mf(e, n, t, 1, r, a);
} }), Ab = S({ pool_: function(e, n, t, r, a, o) {
  a == null && (a = [1, 1]), o == null && (o = 1), r === 0 && (r = "valid");
  var i = k(e, "x", "maxPool"), s = i, u = !1;
  i.rank === 3 && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), A(vt(o, a), function() {
    return "Error in pool: Either strides or dilations must be 1. Got strides " + o + " and dilations '" + a + "'";
  });
  var l, c = Ir(s.shape, n, o, a, r), h = [c.dilationHeight, c.dilationWidth];
  l = r === "same" ? function(x, C) {
    var N = x.map(function(E, P) {
      return E + (E - 1) * (C[P] - 1);
    }).map(function(E) {
      return E - 1;
    }), T = N.map(function(E) {
      return Math.floor(E / 2);
    }), I = N.map(function(E, P) {
      return E - T[P];
    });
    return N.map(function(E, P) {
      return [T[P], I[P]];
    });
  }([c.filterHeight, c.filterWidth], h) : [[0, 0], [0, 0]];
  var d = h[0] === 1 && h[1] === 1, p = function(x, C, N) {
    var T = N.map(function(j) {
      return j[0];
    }), I = N.map(function(j) {
      return j[1];
    }), E = x.concat(T, I), P = C.map(function(j, B) {
      return (j - E[B] % j) % j;
    }), O = I.map(function(j, B) {
      return j + P[B];
    }), R = C.map(function(j, B) {
      return [T[B], O[B]];
    }), z = C.map(function(j, B) {
      return [0, P[B]];
    });
    return [R, z];
  }([c.inHeight, c.inWidth], h, l), f = p[0], m = p[1], g = d ? r : "valid", v = d ? s : Du(s, h, f), y = (t === "avg" ? function() {
    return Mf(v, n, o, 1, g);
  } : function() {
    return Ff(v, n, o, 1, g);
  })(), b = d ? y : Su(y, h, m);
  return u ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b;
} }), jf = S({ maxPool3d_: function(e, n, t, r, a, o, i) {
  o === void 0 && (o = "NDHWC");
  var s = k(e, "x", "maxPool3d"), u = s, l = !1;
  s.rank === 4 && (l = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), i == null && (i = [1, 1, 1]), A(u.rank === 5, function() {
    return "Error in maxPool3d: x must be rank 5 but got rank " + u.rank + ".";
  }), A(o === "NDHWC", function() {
    return "Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of " + o;
  }), A(vt(t, i), function() {
    return "Error in maxPool3d: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + i + "'";
  }), a != null && A(He(r), function() {
    return "Error in maxPool3d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + ".";
  });
  var c = Zo(u.shape, n, t, i, r, a, o), h = D.runKernelFunc(function(d, p) {
    var f = d.maxPool3d(u, c);
    return p([u, f]), f;
  }, { x: u }, function(d, p) {
    var f = p[0], m = p[1];
    return { x: function() {
      return function(g, v, y, b, x, C, N, T) {
        var I = k(g, "dy", "maxPool3dBackprop"), E = k(v, "input", "maxPool3dBackprop"), P = k(y, "output", "maxPool3dBackprop"), O = I, R = E, z = P, j = !1;
        E.rank === 4 && (j = !0, O = I.as5D(1, I.shape[0], I.shape[1], I.shape[2], I.shape[3]), R = E.as5D(1, E.shape[0], E.shape[1], E.shape[2], E.shape[3]), z = P.as5D(1, P.shape[0], P.shape[1], P.shape[2], P.shape[3])), A(O.rank === 5, function() {
          return "Error in maxPool3dBackprop: dy must be rank 5 but got rank " + O.rank + ".";
        }), A(R.rank === 5, function() {
          return "Error in maxPool3dBackprop: input must be rank 5 but got rank " + R.rank + ".";
        }), A(z.rank === 5, function() {
          return "Error in maxPool3dBackprop: output must be rank 5 but got rank " + z.rank + ".";
        }), C == null && (C = [1, 1, 1]), A(vt(x, C), function() {
          return "Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides " + x + " and dilations '" + C + "'";
        }), T != null && A(He(N), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + T + " but got pad " + N + ".";
        });
        var B = Zo(R.shape, b, x, C, N, T), H = D.runKernelFunc(function(W) {
          return W.maxPool3dBackprop(O, R, z, B);
        }, { dy5D: O, input5D: R });
        return j ? H.as4D(H.shape[1], H.shape[2], H.shape[3], H.shape[4]) : H;
      }(d, f, m, n, t, i, r, a);
    } };
  });
  return l ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
} }), Vf = S({ avgPool3d_: function(e, n, t, r, a, o, i) {
  o === void 0 && (o = "NDHWC");
  var s = k(e, "x", "avgPool3d", "float32"), u = s, l = !1;
  s.rank === 4 && (l = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), i == null && (i = [1, 1, 1]), A(u.rank === 5, function() {
    return "Error in avgPool3d: x must be rank 5 but got rank " + u.rank + ".";
  }), A(o === "NDHWC", function() {
    return "Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of " + o;
  }), A(vt(t, i), function() {
    return "Error in avgPool3d: Either strides or dilations must be 1. Got strides " + t + " and dilations '" + i + "'";
  }), a != null && A(He(r), function() {
    return "Error in avgPool3d: pad must be an integer when using, dimRoundingMode " + a + " but got pad " + r + ".";
  });
  var c = Zo(u.shape, n, t, i, r, a, o), h = D.runKernelFunc(function(d) {
    return d.avgPool3d(u, c);
  }, { x: u }, function(d) {
    return { x: function() {
      return function(p, f, m, g, v, y, b) {
        var x = k(p, "dy", "avgPool3dBackprop"), C = k(f, "input", "avgPool3dBackprop"), N = x, T = C, I = !1;
        C.rank === 4 && (I = !0, N = x.as5D(1, x.shape[0], x.shape[1], x.shape[2], x.shape[3]), T = C.as5D(1, C.shape[0], C.shape[1], C.shape[2], C.shape[3])), A(N.rank === 5, function() {
          return "Error in avgPool3dBackprop: dy must be rank 5 but got rank " + N.rank + ".";
        }), A(T.rank === 5, function() {
          return "Error in avgPool3dBackprop: input must be rank 5 but got rank " + T.rank + ".";
        }), v == null && (v = [1, 1, 1]), A(vt(g, v), function() {
          return "Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides " + g + " and dilations '" + v + "'";
        }), b != null && A(He(y), function() {
          return "Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode " + b + " but got pad " + y + ".";
        });
        var E = Zo(T.shape, m, g, v, y, b), P = D.runKernelFunc(function(O) {
          return O.avgPool3dBackprop(N, T, E);
        }, { dy5D: N, input5D: T });
        return I ? P.as4D(P.shape[1], P.shape[2], P.shape[3], P.shape[4]) : P;
      }(d, u, n, t, i, r, a);
    } };
  });
  return h = h.cast(u.dtype), l ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;
} }), Lf = S({ maxPoolWithArgmax_: function(e, n, t, r, a) {
  a === void 0 && (a = !1);
  var o = k(e, "x", "maxPoolWithArgmax"), i = { filterSize: n, strides: t, pad: r, includeBatchInIndex: a }, s = D.runKernel("MaxPoolWithArgmax", { x: o }, i);
  return { result: s[0], indexes: s[1] };
} }), hn = S({ slice_: function(e, n, t) {
  var r, a, o = k(e, "x", "slice");
  if (o.rank === 0) throw new Error("Slicing scalar is not possible");
  (r = typeof n == "number" ? [n].concat(new Array(o.rank - 1).fill(0)) : n.length < o.rank ? n.concat(new Array(o.rank - n.length).fill(0)) : n.slice()).forEach(function(u) {
    A(u !== -1, function() {
      return "slice() does not support negative begin indexing.";
    });
  }), a = (a = t == null ? new Array(o.rank).fill(-1) : typeof t == "number" ? [t].concat(new Array(o.rank - 1).fill(-1)) : t.length < o.rank ? t.concat(new Array(o.rank - t.length).fill(-1)) : t).map(function(u, l) {
    return u >= 0 ? u : (A(u === -1, function() {
      return "Negative size values should be exactly -1 but got " + u + " for the slice() size at index " + l + ".";
    }), o.shape[l] - r[l]);
  }), _v(o, r, a);
  var i = o.shape, s = { begin: r, size: a };
  return D.runKernelFunc(function(u) {
    return u.slice(o, r, a);
  }, { x: o }, function(u) {
    for (var l = [], c = 0; c < u.rank; c++) l.push([r[c], i[c] - r[c] - a[c]]);
    return { x: function() {
      return ir(u, l);
    } };
  }, "Slice", s);
} }), Ib = S({ slice1d_: function(e, n, t) {
  var r = k(e, "x", "slice1d");
  return A(r.rank === 1, function() {
    return "slice1d expects a rank-1 tensor, but got a rank-" + r.rank + " tensor";
  }), hn(r, [n], [t]);
} }), Eb = S({ slice2d_: function(e, n, t) {
  var r = k(e, "x", "slice2d");
  return A(r.rank === 2, function() {
    return "slice2d expects a rank-2 tensor, but got a rank-" + r.rank + " tensor";
  }), hn(r, n, t);
} }), Tb = S({ slice3d_: function(e, n, t) {
  var r = k(e, "x", "slice3d");
  return A(r.rank === 3, function() {
    return "slice3d expects a rank-3 tensor, but got a rank-" + r.rank + " tensor";
  }), hn(r, n, t);
} }), Pb = S({ slice4d_: function(e, n, t) {
  var r = k(e, "x", "slice4d");
  return A(r.rank === 4, function() {
    return "slice4d expects a rank-4 tensor, but got a rank-" + r.rank + " tensor";
  }), hn(r, n, t);
} });
function zf(e, n, t, r, a) {
  return n.rank < t.rank && (n = n.reshape(wt(n.shape, r))), e.rank < t.rank && (e = e.reshape(wt(e.shape, r))), { x: function() {
    var o = e.mul(t.equal(n).cast(e.dtype));
    return a == null ? o : o.transpose(a);
  } };
}
var Gf = S({ all_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "all", "bool"), a = Xe(n, r.shape), o = a, i = fn(o, r.rank);
  i != null && (r = r.transpose(i), o = mn(o.length, r.rank));
  var s = D.runKernelFunc(function(l) {
    return l.all(r, o);
  }, { $x: r });
  if (t) {
    var u = wt(s.shape, a);
    return s.reshape(u);
  }
  return s;
} }), Hf = S({ any_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "any", "bool"), a = Xe(n, r.shape), o = a, i = fn(o, r.rank);
  i != null && (r = r.transpose(i), o = mn(o.length, r.rank));
  var s = D.runKernelFunc(function(l) {
    return l.any(r, o);
  }, { $x: r });
  if (t) {
    var u = wt(s.shape, a);
    return s.reshape(u);
  }
  return s;
} }), Wf = S({ argMax_: function(e, n) {
  n === void 0 && (n = 0);
  var t = k(e, "x", "argMax");
  n == null && (n = 0);
  var r = Xe(n, t.shape), a = fn(r, t.rank);
  a != null && (t = t.transpose(a), r = mn(r.length, t.rank));
  var o = { axis: r[0] }, i = [t];
  return D.runKernelFunc(function(s, u) {
    var l = s.argMax(t, r[0]);
    return u([t]), l;
  }, { x: t }, function(s, u) {
    var l = u[0];
    return { x: function() {
      return ve(l);
    } };
  }, "ArgMax", o, i);
} }), $f = S({ argMin_: function(e, n) {
  n === void 0 && (n = 0);
  var t = k(e, "x", "argMin");
  n == null && (n = 0);
  var r = Xe(n, t.shape), a = fn(r, t.rank);
  return a != null && (t = t.transpose(a), r = mn(r.length, t.rank)), D.runKernelFunc(function(o, i) {
    var s = o.argMin(t, r[0]);
    return i([t]), s;
  }, { $x: t }, function(o, i) {
    var s = i[0];
    return { $x: function() {
      return ve(s);
    } };
  });
} }), Sb = S({ logSumExp_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "logSumExp"), a = Xe(n, r.shape), o = r.max(a, !0), i = r.sub(o).exp().sum(a).log(), s = o.reshape(i.shape).add(i);
  if (t) {
    var u = wt(s.shape, a);
    return s.reshape(u);
  }
  return s;
} }), Uf = S({ max_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "max"), a = r, o = Xe(n, r.shape), i = o, s = fn(i, r.rank);
  s != null && (r = r.transpose(s), i = mn(i.length, r.rank));
  var u = [r], l = D.runKernelFunc(function(h, d) {
    var p = h.max(r, i);
    return d([a, p]), p;
  }, { x: r }, function(h, d) {
    return zf(h, d[1], d[0], o, s);
  }, "Max", { axes: i }, u, [!0]);
  if (t) {
    var c = wt(l.shape, o);
    l = l.reshape(c);
  }
  return l;
} }), Kf = S({ mean_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "mean"), a = Xe(n, r.shape), o = Q(ct(r.shape, a)[1]);
  return gi(function(i) {
    var s = X(o);
    return { value: (s.dtype === i.dtype ? i : i.cast(s.dtype)).div(s).sum(n, t), gradFunc: function(u) {
      var l = i.shape.slice();
      return a.forEach(function(c) {
        l[c] = 1;
      }), u.reshape(l).mul(Pr(i.shape, "float32")).div(o);
    } };
  })(r);
} }), qf = S({ min_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "min"), a = r, o = Xe(n, r.shape), i = o, s = fn(i, r.rank);
  s != null && (r = r.transpose(s), i = mn(i.length, r.rank));
  var u = [r], l = D.runKernelFunc(function(h, d) {
    var p = h.min(r, i);
    return d([a, p]), p;
  }, { x: r }, function(h, d) {
    return zf(h, d[1], d[0], o, s);
  }, "Min", { axes: i }, u, [!0]);
  if (t) {
    var c = wt(l.shape, o);
    l = l.reshape(c);
  }
  return l;
} }), Db = S({ moments_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = Xe(n, (e = k(e, "x", "moments")).shape), a = e.mean(r, t), o = a.shape;
  t || (o = wt(a.shape, r));
  var i = e.toFloat().sub(a.reshape(o)).square();
  return { mean: a, variance: i.mean(r, t) };
} }), Pn = S({ sum_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "sum");
  r.dtype === "bool" && (r = r.toInt());
  var a = Xe(n, r.shape);
  return gi(function(o) {
    var i = fn(a, o.rank), s = a, u = o;
    i != null && (u = o.transpose(i), s = mn(s.length, o.rank));
    var l = function(p) {
      var f = o.shape.slice();
      return a.forEach(function(m) {
        f[m] = 1;
      }), p.reshape(f).mul(Pr(o.shape, "float32"));
    }, c = { axes: s }, h = D.runKernelFunc(function(p) {
      return p.sum(u, s);
    }, { x: u }, function(p) {
      return { x: function() {
        return l(p);
      } };
    }, "Sum", c);
    if (t) {
      var d = wt(h.shape, a);
      h = h.reshape(d);
    }
    return { value: h, gradFunc: l };
  })(r);
} }), tl = S({ prod_: function(e, n, t) {
  n === void 0 && (n = null), t === void 0 && (t = !1);
  var r = k(e, "x", "prod");
  r.dtype === "bool" && (r = r.toInt());
  var a = Xe(n, r.shape), o = fn(a, r.rank), i = a, s = r;
  o != null && (s = r.transpose(o), i = mn(i.length, r.rank));
  var u = D.runKernelFunc(function(c) {
    return c.prod(s, i);
  }, { permutedX: s });
  if (t) {
    var l = wt(u.shape, a);
    u = u.reshape(l);
  }
  return u;
} }), nl = S({ elu_: function(e) {
  var n = k(e, "x", "elu");
  return D.runKernelFunc(function(t, r) {
    var a = t.elu(n);
    return r([a]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      return D.runKernelFunc(function(o) {
        return o.eluDer(t, a);
      }, { dy: t, y: a });
    } };
  });
} }), Jf = S({ leakyRelu_: function(e, n) {
  n === void 0 && (n = 0.2);
  var t = k(e, "x", "leakyRelu");
  return mi(X(n).mul(t), t);
} }), rl = S({ prelu_: function(e, n) {
  var t = k(e, "x", "prelu"), r = k(n, "alpha", "prelu");
  return D.runKernelFunc(function(a, o) {
    var i = a.prelu(t, r);
    return o([t, r]), i;
  }, { x: t, alpha: r }, function(a, o) {
    var i = o[0], s = o[1], u = i.greater(0);
    return { x: function() {
      return nr(u, a, a.mul(s));
    }, alpha: function() {
      var l = nr(u, ve(a), a.mul(i)), c = Qe(s.shape, a.shape);
      return c.length > 0 && (l = l.sum(c)), l.reshape(s.shape);
    } };
  }, "Prelu");
} }), al = S({ relu_: function(e) {
  var n = k(e, "x", "relu");
  return n.dtype === "bool" ? n.toInt() : D.runKernelFunc(function(t, r) {
    var a = t.relu(n);
    return r([n]), a;
  }, { x: n }, function(t, r) {
    var a = r[0];
    return { x: function() {
      return t.mulStrict(a.step().toFloat());
    } };
  }, "Relu");
} }), Xf = S({ relu6_: function(e) {
  var n = k(e, "x", "relu6");
  return n.dtype === "bool" ? n.toInt() : D.runKernelFunc(function(t, r) {
    var a = t.relu6(n);
    return r([n]), a;
  }, { x: n }, function(t, r) {
    var a = r[0], o = a.lessEqual(6).mul(a.step());
    return { x: function() {
      return t.mulStrict(o.toFloat());
    } };
  }, "Relu6");
} }), Qf = S({ selu_: function(e) {
  var n = k(e, "x", "selu");
  return D.runKernelFunc(function(t, r) {
    var a = t.selu(n);
    return r([n]), a;
  }, { $x: n }, function(t, r) {
    var a = r[0];
    return { $x: function() {
      var o = a.greater(X(0)), i = X(Gu), s = X(Hu), u = t.mul(s), l = t.mul(i).mul(a.toFloat().exp());
      return nr(o, u, l);
    } };
  });
} }), Yf = S({ localResponseNormalization_: function(e, n, t, r, a) {
  n === void 0 && (n = 5), t === void 0 && (t = 1), r === void 0 && (r = 1), a === void 0 && (a = 0.5);
  var o = k(e, "x", "localResponseNormalization");
  A(o.rank === 4 || o.rank === 3, function() {
    return `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ` + o.rank + ".";
  }), A(He(n), function() {
    return "Error in localResponseNormalization: depthRadius must be an integer but got depthRadius " + n + ".";
  });
  var i = o, s = !1;
  o.rank === 3 && (s = !0, i = o.as4D(1, o.shape[0], o.shape[1], o.shape[2]));
  var u = D.runKernelFunc(function(l, c) {
    var h = l.localResponseNormalization4D(i, n, t, r, a);
    return c([i, h]), h;
  }, { x4D: i }, function(l, c) {
    var h = c[0], d = c[1];
    return { x4D: function() {
      return D.runKernelFunc(function(p) {
        return p.LRNGrad(l, h, d, n, t, r, a);
      }, {});
    } };
  });
  return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
} }), Zf = S({ norm_: function(e, n, t, r) {
  n === void 0 && (n = "euclidean"), t === void 0 && (t = null), r === void 0 && (r = !1);
  var a = function s(u, l, c) {
    if (c === void 0 && (c = null), u.rank === 0) return u.abs();
    if (u.rank !== 1 && c === null) return s(u.reshape([-1]), l, c);
    if (u.rank === 1 || typeof c == "number" || Array.isArray(c) && c.length === 1) {
      if (l === 1) return u.abs().sum(c);
      if (l === 1 / 0) return u.abs().max(c);
      if (l === -1 / 0) return u.abs().min(c);
      if (l === "euclidean" || l === 2) return u.abs().pow(X(2, "int32")).sum(c).sqrt();
      throw new Error("Error in norm: invalid ord value: " + l);
    }
    if (Array.isArray(c) && c.length === 2) {
      if (l === 1) return u.abs().sum(c[0]).max(c[1] - 1);
      if (l === 1 / 0) return u.abs().sum(c[1]).max(c[0]);
      if (l === -1 / 0) return u.abs().sum(c[1]).min(c[0]);
      if (l === "fro" || l === "euclidean") return u.square().sum(c).sqrt();
      throw new Error("Error in norm: invalid ord value: " + l);
    }
    throw new Error("Error in norm: invalid axis: " + c);
  }(e = k(e, "x", "norm"), n, t), o = a.shape;
  if (r) {
    var i = Xe(t, e.shape);
    o = wt(a.shape, i);
  }
  return a.reshape(o);
} }), Ob = S({ basicLSTMCell_: function(e, n, t, r, a, o) {
  var i = k(e, "forgetBias", "basicLSTMCell"), s = k(n, "lstmKernel", "basicLSTMCell"), u = k(t, "lstmBias", "basicLSTMCell"), l = k(r, "data", "basicLSTMCell"), c = k(a, "c", "basicLSTMCell"), h = k(o, "h", "basicLSTMCell"), d = l.concat(h, 1).matMul(s).add(u), p = d.shape[0], f = d.shape[1] / 4, m = [p, f], g = d.slice([0, 0], m), v = d.slice([0, f], m), y = d.slice([0, 2 * f], m), b = d.slice([0, 3 * f], m), x = g.sigmoid().mulStrict(v.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid())), C = x.tanh().mulStrict(b.sigmoid());
  return [x, C];
} }), Rb = S({ multiRNNCell_: function(e, n, t, r) {
  for (var a = k(n, "data", "multiRNNCell"), o = qo(t, "c", "multiRNNCell"), i = qo(r, "h", "multiRNNCell"), s = a, u = [], l = 0; l < e.length; l++) {
    var c = e[l](s, o[l], i[l]);
    u.push(c[0]), u.push(c[1]), s = c[1];
  }
  var h = [], d = [];
  for (l = 0; l < u.length; l += 2) h.push(u[l]), d.push(u[l + 1]);
  return [h, d];
} }), Fb = S({ movingAverage_: function(e, n, t, r, a) {
  a === void 0 && (a = !0);
  var o = k(e, "v", "movingAverage"), i = k(n, "x", "movingAverage"), s = k(t, "decay", "movingAverage");
  Og(o, i), A(Ye(o.shape, i.shape), function() {
    return "Shape mismatch in v and x";
  });
  var u = X(1), l = u.sub(s), c = i.sub(o).mul(l);
  if (a) {
    A(r != null, function() {
      return "When using zeroDebias: true, step is required.";
    });
    var h = k(r, "step", "movingAverage");
    c = c.div(u.sub(La(s, h)));
  }
  return o.add(c);
} }), em = S({ stridedSlice_: function(e, n, t, r, a, o, i, s, u) {
  if (a === void 0 && (a = 0), o === void 0 && (o = 0), i === void 0 && (i = 0), s === void 0 && (s = 0), u === void 0 && (u = 0), r == null && (r = new Array(n.length)), i !== 0) throw new Error("ellipsis mask is not yet supported");
  var l = k(e, "x", "stridedSlice"), c = Vl(s), h = l.shape.slice();
  c.forEach(function(g) {
    n[g] = 0, t[g] = 1, h.splice(g, 0, 1);
  }), l = l.reshape(h);
  for (var d = 0; d < l.rank; d++) n[d] = Bv(a, n, r, l.shape, d), t[d] = jv(o, t, r, l.shape, d), r[d] = r[d] || 1;
  var p = Vl(u);
  p.forEach(function(g) {
    t[g] = n[g] + 1, r[g] = 1;
  });
  var f = _u(n, t, r), m = f.filter(function(g, v) {
    return p.indexOf(v) === -1;
  });
  return r.every(function(g) {
    return g === 1;
  }) ? hn(l, n, f).reshape(m) : D.runKernelFunc(function(g) {
    return g.stridedSlice(l, n, t, r);
  }, { $x: l }).reshape(m);
} }), tm = S({ topk_: function(e, n, t) {
  n === void 0 && (n = 1), t === void 0 && (t = !0);
  var r = k(e, "x", "topk");
  if (r.rank === 0) throw new Error("topk() expects the input to be of rank 1 or higher");
  var a = r.shape[r.shape.length - 1];
  if (n > a) throw new Error("'k' passed to topk() must be <= the last dimension (" + a + ") but got " + n);
  var o = D.runKernelFunc(function(i) {
    return i.topk(r, n, t);
  }, { $x: r });
  return { values: o[0], indices: o[1] };
} }), nm = S({ scatterND_: function(e, n, t) {
  var r = k(e, "indices", "scatterND", "int32"), a = k(n, "updates", "scatterND");
  return Mv(a, r, t), D.runKernelFunc(function(o) {
    return o.scatterND(r, a, t);
  }, { indices: r, updates: a }, null, "ScatterNd", { shape: t });
} }), Ci = S({ fft_: function(e) {
  A(e.dtype === "complex64", function() {
    return "The dtype for tf.spectral.fft() must be complex64 but got " + e.dtype + ".";
  });
  var n = e.shape[e.shape.length - 1], t = e.size / n, r = e.as2D(t, n);
  return D.runKernelFunc(function(a) {
    return a.fft(r);
  }, { input: e }).reshape(e.shape);
} }), Ga = S({ ifft_: function(e) {
  A(e.dtype === "complex64", function() {
    return "The dtype for tf.spectral.ifft() must be complex64 but got " + e.dtype + ".";
  });
  var n = e.shape[e.shape.length - 1], t = e.size / n, r = e.as2D(t, n);
  return D.runKernelFunc(function(a) {
    return a.ifft(r);
  }, { input: e }).reshape(e.shape);
} }), ki = S({ rfft_: function(e, n) {
  A(e.dtype === "float32", function() {
    return "The dtype for rfft() must be real value but got " + e.dtype;
  });
  var t, r = e.shape[e.shape.length - 1], a = e.size / r;
  if (n != null && n < r) {
    var o = e.shape.map(function(v) {
      return 0;
    }), i = e.shape.map(function(v) {
      return v;
    });
    i[e.shape.length - 1] = n, t = e.slice(o, i), r = n;
  } else if (n != null && n > r) {
    var s = e.shape.map(function(v) {
      return v;
    });
    s[e.shape.length - 1] = n - r, t = e.concat(je(s), e.shape.length - 1), r = n;
  } else t = e;
  var u = t.zerosLike(), l = nt(t, u).as2D(a, r), c = Ci(l), h = Math.floor(r / 2) + 1, d = Dt(c), p = Xt(c), f = d.split([h, r - h], d.shape.length - 1), m = p.split([h, r - h], p.shape.length - 1), g = t.shape.slice();
  return g[t.shape.length - 1] = h, nt(f[0], m[0]).reshape(g);
} }), ol = S({ irfft_: function(e) {
  var n = e.shape[e.shape.length - 1], t = e.size / n;
  if (n <= 2) {
    var r = e.as2D(t, n), a = Ga(r);
    return Dt(a);
  }
  var o = [t, 2 * (n - 1)], i = Dt(e).as2D(t, n), s = Xt(e).as2D(t, n), u = i.slice([0, 1], [t, n - 2]).reverse(1), l = s.slice([0, 1], [t, n - 2]).reverse(1).mul(X(-1)), c = i.concat(u, 1), h = s.concat(l, 1);
  return r = nt(c, h).as2D(o[0], o[1]), a = Ga(r), Dt(a);
} }), Mb = Object.freeze({ fft: Ci, ifft: Ga, rfft: ki, irfft: ol }), il = S({ sparseToDense_: function(e, n, t, r) {
  r === void 0 && (r = 0);
  var a = k(e, "sparseIndices", "sparseToDense", "int32"), o = k(n, "sparseValues", "sparseToDense"), i = k(r, "defaultValue", "sparseToDense", o.dtype);
  return function(s, u, l, c) {
    if (s.dtype !== "int32") throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was " + s.dtype + ".");
    if (s.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape " + s.shape + ".");
    var h = s.rank > 0 ? s.shape[0] : 1, d = s.rank > 1 ? s.shape[1] : 1;
    if (l.length !== d) throw new Error("outputShape has incorrect number of elements:, " + l.length + ", should be: " + d + ".");
    var p = u.size;
    if (u.rank !== 0 && (u.rank !== 1 || p !== h)) throw new Error("sparseValues has incorrect shape " + u.shape + ", should be [] or [" + h + "]");
    if (u.dtype !== c.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }(a, o, t, i), D.runKernelFunc(function(s) {
    return s.sparseToDense(a, o, t, i);
  }, { $sparseIndices: a, $sparseValues: o, $defaultValue: i });
} }), rm = S({ gatherND_: function(e, n) {
  var t = k(n, "indices", "gatherND", "int32"), r = k(e, "x", "gatherND");
  return D.runKernelFunc(function(a) {
    return a.gatherND(r, t);
  }, { x: r, indices: t }, null, "GatherNd");
} }), _b = S({ diag_: function(e) {
  var n = k(e, "x", "diag").flatten(), t = e.shape.concat(e.shape);
  return D.runKernelFunc(function(r) {
    return r.diag(n);
  }, { $x: n }).reshape(t);
} }), Bb = S({ dropout_: function(e, n, t, r) {
  var a = k(e, "x", "dropout");
  if (A(a.dtype === "float32", function() {
    return "x has to be a floating point tensor since it's going to be scaled, but got a " + a.dtype + " tensor instead.";
  }), A(n >= 0 && n < 1, function() {
    return "rate must be a float in the range [0, 1), but got " + n + ".";
  }), n === 0) return e instanceof Ve ? a.clone() : a;
  var o = function(u, l) {
    if (l == null) return u.shape.slice();
    if (Ye(u.shape, l)) return l;
    if (u.shape.length === l.length) {
      for (var c = [], h = 0; h < u.shape.length; h++) l[h] == null && u.shape[h] != null ? c.push(u.shape[h]) : c.push(l[h]);
      return c;
    }
    return l;
  }(a, t), i = 1 - n, s = qu(o, 0, 1, "float32", r).add(i).floor().div(i);
  return a.mul(s);
} });
function am(e, n, t) {
  for (var r = 1 - e % 2, a = new Float32Array(e), o = 0; o < e; ++o) {
    var i = 2 * Math.PI * o / (e + r - 1);
    a[o] = n - t * Math.cos(i);
  }
  return Fn(a, "float32");
}
var sl = S({ hannWindow_: function(e) {
  return am(e, 0.5, 0.5);
} }), om = S({ hammingWindow_: function(e) {
  return am(e, 0.54, 0.46);
} }), ul = S({ frame_: function(e, n, t, r, a) {
  r === void 0 && (r = !1), a === void 0 && (a = 0);
  for (var o = 0, i = []; o + n <= e.size; ) i.push(hn(e, o, n)), o += t;
  if (r) for (; o < e.size; ) {
    var s = o + n - e.size, u = Gt([hn(e, o, n - s), ci([s], a)]);
    i.push(u), o += t;
  }
  return i.length === 0 ? Cr([], [0, n]) : Gt(i).as2D(i.length, n);
} }), im = S({ stft_: function(e, n, t, r, a) {
  var o;
  a === void 0 && (a = sl), r == null && (o = n, r = Math.floor(Math.pow(2, Math.ceil(Math.log(o) / Math.log(2)))));
  for (var i = ul(e, n, t), s = $e(i, a(n)), u = [], l = 0; l < i.shape[0]; l++) u.push(ki(s.slice([l, 0], [1, n]), r));
  return Gt(u);
} }), jb = Object.freeze({ hannWindow: sl, hammingWindow: om, frame: ul, stft: im }), dt, Vb = function(e, n, t) {
  return t === void 0 && (t = 1), Y(this, void 0, void 0, function() {
    var r, a, o, i, s, u, l, c, h, d, p, f, m, g;
    return Z(this, function(v) {
      switch (v.label) {
        case 0:
          return r = k(e, "predictions", "inTopK"), a = k(n, "targets", "inTopK"), A(r.rank > 1, function() {
            return "inTopK() expects the predictions to be of rank 2 or higher, but got " + r.rank;
          }), A(r.rank - 1 === a.rank, function() {
            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + r.rank + " and targets rank " + a.rank;
          }), ke(r.shape.slice(0, r.shape.length - 1), a.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), o = r.shape[r.shape.length - 1], A(t > 0 && t <= o, function() {
            return "'k' passed to inTopK() must be > 0 && <= the predictions last dimension (" + o + "), but got " + t;
          }), [4, r.data()];
        case 1:
          return i = v.sent(), [4, a.data()];
        case 2:
          for (s = v.sent(), u = [i.length / o, o], c = u[1], h = Ar("bool", l = u[0]), d = 0; d < l; d++) {
            for (p = d * c, f = i.subarray(p, p + c), m = [], g = 0; g < f.length; g++) m.push({ value: f[g], index: g });
            for (m.sort(function(y, b) {
              return b.value - y.value;
            }), h[d] = 0, g = 0; g < t; g++) if (m[g].index === s[d]) {
              h[d] = 1;
              break;
            }
          }
          return e !== r && r.dispose(), n !== a && a.dispose(), [2, rt(h, a.shape, "bool")];
      }
    });
  });
};
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(dt || (dt = {}));
var Lb = S({ absoluteDifference_: function(e, n, t, r) {
  r === void 0 && (r = dt.SUM_BY_NONZERO_WEIGHTS);
  var a = k(e, "labels", "absoluteDifference"), o = k(n, "predictions", "absoluteDifference"), i = null;
  t != null && (i = k(t, "weights", "absoluteDifference")), ke(a.shape, o.shape, "Error in absoluteDifference: ");
  var s = a.sub(o).abs();
  return Ln(s, i, r);
} }), Ln = S({ computeWeightedLoss_: function(e, n, t) {
  t === void 0 && (t = dt.SUM_BY_NONZERO_WEIGHTS);
  var r = k(e, "losses", "computeWeightedLoss"), a = null;
  n != null && (a = k(n, "weights", "computeWeightedLoss"));
  var o = a == null ? r : r.mul(a);
  if (t === dt.NONE) return o;
  if (t === dt.SUM) return o.sum();
  if (t === dt.MEAN) {
    if (a == null) return o.mean();
    var i = r.size / a.size, s = o.sum().div(a.sum());
    return i > 1 ? s.div(X(i)) : s;
  }
  if (t === dt.SUM_BY_NONZERO_WEIGHTS) {
    if (a == null) return o.sum().div(X(r.size));
    var u = a.mul(Pr(r.shape)).notEqual(X(0)).sum().toFloat();
    return o.sum().div(u);
  }
  throw Error("Unknown reduction: " + t);
} }), zb = S({ cosineDistance_: function(e, n, t, r, a) {
  a === void 0 && (a = dt.SUM_BY_NONZERO_WEIGHTS);
  var o = k(e, "labels", "cosineDistance"), i = k(n, "predictions", "cosineDistance"), s = null;
  r != null && (s = k(r, "weights", "cosineDistance")), ke(o.shape, i.shape, "Error in cosineDistance: ");
  var u = X(1).sub(o.mul(i).sum(t, !0));
  return Ln(u, s, a);
} }), Gb = S({ hingeLoss_: function(e, n, t, r) {
  r === void 0 && (r = dt.SUM_BY_NONZERO_WEIGHTS);
  var a = k(e, "labels", "hingeLoss"), o = k(n, "predictions", "hingeLoss"), i = null;
  t != null && (i = k(t, "weights", "hingeLoss")), ke(a.shape, o.shape, "Error in hingeLoss: ");
  var s = X(1);
  a = X(2).mul(a).sub(s);
  var u = s.sub(a.mul(o)).relu();
  return Ln(u, i, r);
} }), Hb = S({ huberLoss_: function(e, n, t, r, a) {
  r === void 0 && (r = 1), a === void 0 && (a = dt.SUM_BY_NONZERO_WEIGHTS);
  var o = k(e, "labels", "huberLoss"), i = k(n, "predictions", "huberLoss"), s = null;
  t != null && (s = k(t, "weights", "huberLoss")), ke(o.shape, i.shape, "Error in huberLoss: ");
  var u = X(r), l = i.sub(o).abs(), c = Mu(l, u), h = l.sub(c), d = X(0.5).mul(c.square()).add(u.mul(h));
  return Ln(d, s, a);
} }), Wb = S({ logLoss_: function(e, n, t, r, a) {
  r === void 0 && (r = 1e-7), a === void 0 && (a = dt.SUM_BY_NONZERO_WEIGHTS);
  var o = k(e, "labels", "logLoss"), i = k(n, "predictions", "logLoss"), s = null;
  t != null && (s = k(t, "weights", "logLoss")), ke(o.shape, i.shape, "Error in logLoss: ");
  var u = X(1), l = X(r), c = o.mul(i.add(l).log()).neg().sub(u.sub(o).mul(u.sub(i).add(l).log()));
  return Ln(c, s, a);
} }), $b = S({ meanSquaredError_: function(e, n, t, r) {
  r === void 0 && (r = dt.SUM_BY_NONZERO_WEIGHTS);
  var a = k(e, "labels", "meanSquaredError"), o = k(n, "predictions", "meanSquaredError"), i = null;
  t != null && (i = k(t, "weights", "meanSquaredError")), ke(a.shape, o.shape, "Error in meanSquaredError: ");
  var s = a.squaredDifference(o);
  return Ln(s, i, r);
} }), Ub = S({ sigmoidCrossEntropy_: function(e, n, t, r, a) {
  r === void 0 && (r = 0), a === void 0 && (a = dt.SUM_BY_NONZERO_WEIGHTS);
  var o = k(e, "multiClassLabels", "sigmoidCrossEntropy"), i = k(n, "logits", "sigmoidCrossEntropy"), s = null;
  if (t != null && (s = k(t, "weights", "sigmoidCrossEntropy")), ke(o.shape, i.shape, "Error in sigmoidCrossEntropy: "), r > 0) {
    var u = X(r), l = X(1), c = X(0.5);
    o = o.mul(l.sub(u)).add(c.mul(u));
  }
  var h = function(d, p) {
    var f = k(d, "labels", "sigmoidCrossEntropyWithLogits"), m = k(p, "logits", "sigmoidCrossEntropyWithLogits");
    ke(f.shape, m.shape, "Error in sigmoidCrossEntropyWithLogits: ");
    var g = m.relu(), v = m.mul(f), y = m.abs().neg().exp().log1p();
    return g.sub(v).add(y);
  }(o, i);
  return Ln(h, s, a);
} }), Kb = S({ softmaxCrossEntropy_: function(e, n, t, r, a) {
  r === void 0 && (r = 0), a === void 0 && (a = dt.SUM_BY_NONZERO_WEIGHTS);
  var o = k(e, "onehotLabels", "softmaxCrossEntropy"), i = k(n, "logits", "softmaxCrossEntropy"), s = null;
  if (t != null && (s = k(t, "weights", "softmaxCrossEntropy")), ke(o.shape, i.shape, "Error in softmaxCrossEntropy: "), r > 0) {
    var u = X(r), l = X(1), c = X(o.shape[1]);
    o = o.mul(l.sub(u)).add(u.div(c));
  }
  var h = function(d, p, f) {
    if (f === void 0 && (f = -1), f === -1 && (f = p.rank - 1), f !== p.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank " + p.rank + " and dim was " + f);
    return gi(function(m, g, v) {
      var y = g.logSumExp([f], !0), b = g.toFloat().sub(y);
      return v([m, b]), { value: b.mul(m).neg().sum([f]), gradFunc: function(x, C) {
        var N = C[0], T = C[1], I = wt(x.shape, [f]);
        return [x.reshape(I).mul(N.toFloat().sub(T.exp())), x.reshape(I).mul(T.exp().sub(N.toFloat()))];
      } };
    })(d, p);
  }(o, i);
  return Ln(h, s, a);
} }), qb = Object.freeze({ get Reduction() {
  return dt;
}, absoluteDifference: Lb, computeWeightedLoss: Ln, cosineDistance: zb, hingeLoss: Gb, huberLoss: Hb, logLoss: Wb, meanSquaredError: $b, sigmoidCrossEntropy: Ub, softmaxCrossEntropy: Kb });
function sc(e, n) {
  return n === void 0 && (n = !1), D.tidy(function() {
    if (e.shape.length !== 2) throw new Error("qr2d() requires a 2D Tensor, but got a " + e.shape.length + "D Tensor.");
    for (var t = e.shape[0], r = e.shape[1], a = yf(t), o = e.clone(), i = Cr([[1]], [1, 1]), s = i.clone(), u = t >= r ? r : t, l = function(h) {
      var d, p = o, f = s, m = a;
      d = D.tidy(function() {
        var g = o.slice([h, h], [t - h, 1]), v = g.norm(), y = o.slice([h, h], [1, 1]), b = Cr([[-1]]).where(y.greater(0), Cr([[1]])), x = y.sub(b.mul(v)), C = g.div(x);
        s = C.shape[0] === 1 ? i.clone() : i.concat(C.slice([1, 0], [C.shape[0] - 1, C.shape[1]]), 0);
        var N = b.matMul(x).div(v).neg(), T = o.slice([h, 0], [t - h, r]), I = N.mul(s), E = s.transpose();
        if (h === 0) o = T.sub(I.matMul(E.matMul(T)));
        else {
          var P = T.sub(I.matMul(E.matMul(T)));
          o = o.slice([0, 0], [h, r]).concat(P, 0);
        }
        var O = I.transpose(), R = a.slice([0, h], [t, a.shape[1] - h]);
        if (h === 0) a = R.sub(R.matMul(s).matMul(O));
        else {
          var z = R.sub(R.matMul(s).matMul(O));
          a = a.slice([0, 0], [t, h]).concat(z, 1);
        }
        return [s, o, a];
      }), s = d[0], o = d[1], a = d[2], xt([p, f, m]);
    }, c = 0; c < u; ++c) l(c);
    return !n && t > r && (a = a.slice([0, 0], [t, r]), o = o.slice([0, 0], [r, r])), [a, o];
  });
}
var Jb = S({ bandPart_: function(e, n, t) {
  if (n % 1 != 0) throw new Error("bandPart(): numLower must be an integer, got " + n + ".");
  if (t % 1 != 0) throw new Error("bandPart(): numUpper must be an integer, got " + t + ".");
  var r = k(e, "a", "bandPart");
  if (r.rank < 2) throw new Error("bandPart(): Rank must be at least 2, got " + r.rank + ".");
  var a = r.shape, o = r.shape.slice(-2), i = o[0], s = o[1];
  if (!(n <= i)) throw new Error("bandPart(): numLower (" + n + ") must not be greater than the number of rows (" + i + ").");
  if (!(t <= s)) throw new Error("bandPart(): numUpper (" + t + ") must not be greater than the number of columns (" + s + ").");
  n < 0 && (n = i), t < 0 && (t = s);
  var u = Va(0, i, 1, "int32").reshape([-1, 1]), l = Va(0, s, 1, "int32"), c = Rn(u, l), h = Xa(c.lessEqual(X(+n, "int32")), c.greaterEqual(X(-t, "int32"))), d = je([i, s], r.dtype);
  return Mn(qa(r.reshape([-1, i, s])).map(function(p) {
    return nr(h, p, d);
  })).reshape(a);
} }), Xb = S({ gramSchmidt_: function(e) {
  var n;
  if (Array.isArray(e)) {
    n = !1, A(e != null && e.length > 0, function() {
      return "Gram-Schmidt process: input must not be null, undefined, or empty";
    });
    for (var t = e[0].shape[0], r = function(u) {
      A(e[u].shape[0] === t, function() {
        return "Gram-Schmidt: Non-unique lengths found in the input vectors: (" + e[u].shape[0] + " vs. " + t + ")";
      });
    }, a = 1; a < e.length; ++a) r(a);
  } else n = !0, e = hi(e, e.shape[0], 0).map(function(u) {
    return Ou(u, [0]);
  });
  A(e.length <= e[0].shape[0], function() {
    return "Gram-Schmidt: Number of vectors (" + e.length + ") exceeds number of dimensions (" + e[0].shape[0] + ").";
  });
  var o = [], i = e, s = function(u) {
    o.push(D.tidy(function() {
      var l = i[u];
      if (u > 0) for (var c = 0; c < u; ++c) {
        var h = Pn(o[c].mulStrict(l)).mul(o[c]);
        l = l.sub(h);
      }
      return l.div(Zf(l, "euclidean"));
    }));
  };
  for (a = 0; a < e.length; ++a) s(a);
  return n ? Mn(o, 0) : o;
} }), Qb = S({ qr_: function(e, n) {
  if (n === void 0 && (n = !1), e.rank < 2) throw new Error("qr() requires input tensor to have a rank >= 2, but got rank " + e.rank);
  if (e.rank === 2) return sc(e, n);
  var t = e.shape.slice(0, e.shape.length - 2).reduce(function(i, s) {
    return i * s;
  }), r = qa(e.reshape([t, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0), a = [], o = [];
  return r.forEach(function(i) {
    var s = sc(i, n), u = s[0], l = s[1];
    a.push(u), o.push(l);
  }), [Mn(a, 0).reshape(e.shape), Mn(o, 0).reshape(e.shape)];
} }), Yb = Object.freeze({ bandPart: Jb, gramSchmidt: Xb, qr: Qb });
function Ni(e, n, t, r, a, o) {
  r == null && (r = 0.5), a == null && (a = Number.NEGATIVE_INFINITY), o == null && (o = 0);
  var i = e.shape[0];
  return t = Math.min(t, i), A(0 <= r && r <= 1, function() {
    return "iouThreshold must be in [0, 1], but was '" + r + "'";
  }), A(e.rank === 2, function() {
    return "boxes must be a 2D tensor, but was of rank '" + e.rank + "'";
  }), A(e.shape[1] === 4, function() {
    return "boxes must have 4 columns, but 2nd dimension was " + e.shape[1];
  }), A(n.rank === 1, function() {
    return "scores must be a 1D tensor";
  }), A(n.shape[0] === i, function() {
    return "scores has incompatible shape with boxes. Expected " + i + ", but was " + n.shape[0];
  }), A(0 <= o && o <= 1, function() {
    return "softNmsSigma must be in [0, 1], but was '" + o + "'";
  }), { maxOutputSize: t, iouThreshold: r, scoreThreshold: a, softNmsSigma: o };
}
var Zb = S({ resizeBilinear_: function(e, n, t) {
  t === void 0 && (t = !1);
  var r = k(e, "images", "resizeBilinear");
  A(r.rank === 3 || r.rank === 4, function() {
    return "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + r.rank + ".";
  }), A(n.length === 2, function() {
    return "Error in resizeBilinear: new shape must 2D, but got shape " + n + ".";
  });
  var a = r, o = !1;
  r.rank === 3 && (o = !0, a = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
  var i = n[0], s = n[1], u = D.runKernelFunc(function(l, c) {
    return c([a]), l.resizeBilinear(a, i, s, t);
  }, { x: a }, function(l, c) {
    return { x: function() {
      return D.runKernelFunc(function(h) {
        return h.resizeBilinearBackprop(l, c[0], t);
      }, {});
    } };
  }, "ResizeBilinear", { alignCorners: t, newHeight: i, newWidth: s });
  return o ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
} }), e1 = S({ resizeNearestNeighbor_: function(e, n, t) {
  t === void 0 && (t = !1);
  var r = k(e, "images", "resizeNearestNeighbor");
  A(r.rank === 3 || r.rank === 4, function() {
    return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + r.rank + ".";
  }), A(n.length === 2, function() {
    return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + n + ".";
  }), A(r.dtype === "float32" || r.dtype === "int32", function() {
    return "`images` must have `int32` or `float32` as dtype";
  });
  var a = r, o = !1;
  r.rank === 3 && (o = !0, a = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));
  var i = n[0], s = n[1], u = D.runKernelFunc(function(l, c) {
    return c([a]), l.resizeNearestNeighbor(a, i, s, t);
  }, { batchImages: a }, function(l, c) {
    return { batchImages: function() {
      return D.runKernelFunc(function(h) {
        return h.resizeNearestNeighborBackprop(l, c[0], t);
      }, {});
    } };
  });
  return o ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;
} }), t1 = S({ nonMaxSuppression_: function(e, n, t, r, a) {
  r === void 0 && (r = 0.5), a === void 0 && (a = Number.NEGATIVE_INFINITY);
  var o = k(e, "boxes", "nonMaxSuppression"), i = k(n, "scores", "nonMaxSuppression"), s = Ni(o, i, t, r, a);
  t = s.maxOutputSize, r = s.iouThreshold, a = s.scoreThreshold;
  var u = { maxOutputSize: t, iouThreshold: r, scoreThreshold: a };
  return D.runKernelFunc(function(l) {
    return l.nonMaxSuppression(o, i, t, r, a);
  }, { boxes: o, scores: i }, null, "NonMaxSuppressionV3", u);
} }), n1 = function(e, n, t, r, a) {
  return r === void 0 && (r = 0.5), a === void 0 && (a = Number.NEGATIVE_INFINITY), Y(this, void 0, void 0, function() {
    var o, i, s, u, l, c, h;
    return Z(this, function(d) {
      switch (d.label) {
        case 0:
          return o = k(e, "boxes", "nonMaxSuppressionAsync"), i = k(n, "scores", "nonMaxSuppressionAsync"), s = Ni(o, i, t, r, a), t = s.maxOutputSize, r = s.iouThreshold, a = s.scoreThreshold, [4, Promise.all([o.data(), i.data()])];
        case 1:
          return u = d.sent(), l = u[0], c = u[1], h = ju(l, c, t, r, a), o !== e && o.dispose(), i !== n && i.dispose(), [2, h];
      }
    });
  });
}, r1 = S({ nonMaxSuppressionWithScore_: function(e, n, t, r, a, o) {
  r === void 0 && (r = 0.5), a === void 0 && (a = Number.NEGATIVE_INFINITY), o === void 0 && (o = 0);
  var i = k(e, "boxes", "nonMaxSuppression"), s = k(n, "scores", "nonMaxSuppression"), u = Ni(i, s, t, r, a, o), l = { maxOutputSize: t = u.maxOutputSize, iouThreshold: r = u.iouThreshold, scoreThreshold: a = u.scoreThreshold, softNmsSigma: o = u.softNmsSigma }, c = D.runKernel("NonMaxSuppressionV5", { boxes: i, scores: s }, l);
  return { selectedIndices: c[0], selectedScores: c[1] };
} }), a1 = function(e, n, t, r, a, o) {
  return r === void 0 && (r = 0.5), a === void 0 && (a = Number.NEGATIVE_INFINITY), o === void 0 && (o = 0), Y(this, void 0, void 0, function() {
    var i, s, u, l, c, h, d;
    return Z(this, function(p) {
      switch (p.label) {
        case 0:
          return i = k(e, "boxes", "nonMaxSuppressionAsync"), s = k(n, "scores", "nonMaxSuppressionAsync"), u = Ni(i, s, t, r, a, o), t = u.maxOutputSize, r = u.iouThreshold, a = u.scoreThreshold, o = u.softNmsSigma, [4, Promise.all([i.data(), s.data()])];
        case 1:
          return l = p.sent(), c = l[0], h = l[1], d = Vu(c, h, t, r, a, o), i !== e && i.dispose(), s !== n && s.dispose(), [2, d];
      }
    });
  });
}, o1 = S({ cropAndResize_: function(e, n, t, r, a, o) {
  var i = k(e, "image", "cropAndResize"), s = k(n, "boxes", "cropAndResize", "float32"), u = k(t, "boxInd", "cropAndResize", "int32");
  a = a || "bilinear", o = o || 0;
  var l = s.shape[0];
  return A(i.rank === 4, function() {
    return "Error in cropAndResize: image must be rank 4,but got rank " + i.rank + ".";
  }), A(s.rank === 2 && s.shape[1] === 4, function() {
    return "Error in cropAndResize: boxes must be have size [" + l + ",4] but had shape " + s.shape + ".";
  }), A(u.rank === 1 && u.shape[0] === l, function() {
    return "Error in cropAndResize: boxInd must be have size [" + l + "] but had shape " + s.shape + ".";
  }), A(r.length === 2, function() {
    return "Error in cropAndResize: cropSize must be of length 2, but got length " + r.length + ".";
  }), A(r[0] >= 1 && r[1] >= 1, function() {
    return "cropSize must be atleast [1,1], but was " + r;
  }), A(a === "bilinear" || a === "nearest", function() {
    return "method must be bilinear or nearest, but was " + a;
  }), D.runKernelFunc(function(c, h) {
    return c.cropAndResize(i, s, u, r, a, o);
  }, { images: i, boxes: s, boxInd: u }, null, "CropAndResize", { method: a, extrapolationValue: o, cropSize: r });
} }), aa = Object.freeze({ resizeBilinear: Zb, resizeNearestNeighbor: e1, nonMaxSuppression: t1, nonMaxSuppressionAsync: n1, nonMaxSuppressionWithScore: r1, nonMaxSuppressionWithScoreAsync: a1, cropAndResize: o1 }), ll = function(e, n) {
  return !(e > 0) || n === "linear";
}, cl = function(e, n, t) {
  if (t == null || t === "linear") return e;
  if (t === "relu") return e.mul(n.step());
  throw new Error("Gradient for activation " + t + " has not been implemented yet.");
}, hl = function(e, n) {
  var t = n, r = Qe(e.shape, n.shape);
  return r.length > 0 && (t = t.sum(r)), t.reshape(e.shape);
}, dl = function(e, n, t) {
  if (n === "linear") return e;
  if (n === "relu") return al(e);
  if (n === "elu") return nl(e);
  if (n === "relu6") return Xf(e);
  if (n === "prelu") return rl(e, t);
  throw new Error("Unknown fused activation " + n + ".");
}, i1 = S({ fusedMatMul_: function(e) {
  var n, t = e.a, r = e.b, a = e.transposeA, o = a !== void 0 && a, i = e.transposeB, s = i !== void 0 && i, u = e.bias, l = e.activation, c = l === void 0 ? "linear" : l, h = e.preluActivationWeights;
  if (ll(D.state.gradientDepth, c) === !1) {
    var d = el(t, r, o, s);
    return u != null && (d = _n(d, u)), dl(d, c, h);
  }
  var p = k(t, "a", "fused matMul"), f = k(r, "b", "fused matMul");
  n = Le(p, f), p = n[0], f = n[1];
  var m = o ? p.shape[p.rank - 2] : p.shape[p.rank - 1], g = s ? f.shape[f.rank - 1] : f.shape[f.rank - 2], v = o ? p.shape[p.rank - 1] : p.shape[p.rank - 2], y = s ? f.shape[f.rank - 2] : f.shape[f.rank - 1], b = p.shape.slice(0, -2), x = f.shape.slice(0, -2), C = Q(b), N = Q(x);
  A(p.rank >= 2 && f.rank >= 2 && p.rank === f.rank, function() {
    return "Error in fused matMul: inputs must have the same rank of at least 2, got ranks " + p.rank + " and " + f.rank + ".";
  }), A(Ye(b, x), function() {
    return "Error in fused matMul: outer dimensions (" + b + ") and (" + x + ") of Tensors with shapes " + p.shape + " and " + f.shape + " must match.";
  }), A(m === g, function() {
    return "Error in fused matMul: inner shapes (" + m + ") and (" + g + ") of Tensors with shapes " + p.shape + " and " + f.shape + " and transposeA=" + o + " and transposeB=" + s + " must match.";
  });
  var T, I, E = p.shape.slice(0, -2).concat([v, y]), P = o ? p.as3D(C, m, v) : p.as3D(C, v, m), O = s ? f.as3D(N, y, g) : f.as3D(N, g, y);
  u != null && fe(E, (T = Le(T = k(u, "bias", "fused matMul"), p)[0]).shape), h != null && (I = k(h, "prelu weights", "fused matMul"));
  var R = { a: P, b: O };
  u != null && (R.bias = T), h != null && (R.preluActivationWeights = I);
  var z = [P, O];
  return D.runKernelFunc(function(j, B) {
    var H = j.fusedBatchMatMul({ a: P, b: O, transposeA: o, transposeB: s, bias: T, activation: c, preluActivationWeights: I });
    return B([P, O, H]), H;
  }, R, function(j, B) {
    var H = B[0], W = B[1], L = B[2], $ = cl(j, L, c), K = {};
    return u != null && (K = { bias: function() {
      return hl(T, $);
    } }), Object.assign(o || s ? !o && s ? { a: function() {
      return $.matMul(W, !1, !1);
    }, b: function() {
      return $.matMul(H, !0, !1);
    } } : o && !s ? { a: function() {
      return W.matMul($, !1, !0);
    }, b: function() {
      return H.matMul($, !1, !1);
    } } : { a: function() {
      return W.matMul($, !0, !0);
    }, b: function() {
      return $.matMul(H, !0, !0);
    } } : { a: function() {
      return $.matMul(W, !1, !0);
    }, b: function() {
      return H.matMul($, !0, !1);
    } }, K);
  }, "_FusedMatMul", { transposeA: o, transposeB: s, activation: c }, z, [!0]).reshape(E);
} }), s1 = S({ fusedConv2d_: function(e) {
  var n = e.x, t = e.filter, r = e.strides, a = e.pad, o = e.dataFormat, i = o === void 0 ? "NHWC" : o, s = e.dilations, u = s === void 0 ? [1, 1] : s, l = e.dimRoundingMode, c = e.bias, h = e.activation, d = h === void 0 ? "linear" : h, p = e.preluActivationWeights;
  if (d = d || "linear", ll(D.state.gradientDepth, d) === !1) {
    var f = ma(n, t, r, a, i, u, l);
    return c != null && (f = _n(f, c)), dl(f, d, p);
  }
  var m = k(n, "x", "conv2d"), g = k(t, "filter", "conv2d"), v = m, y = !1;
  m.rank === 3 && (y = !0, v = m.as4D(1, m.shape[0], m.shape[1], m.shape[2])), A(v.rank === 4, function() {
    return "Error in fused conv2d: input must be rank 4, but got rank " + v.rank + ".";
  }), A(g.rank === 4, function() {
    return "Error in fused conv2d: filter must be rank 4, but got rank " + g.rank + ".";
  }), l != null && A(He(a), function() {
    return "Error in fused conv2d: pad must be an integer when using, dimRoundingMode " + l + " but got pad " + a + ".";
  }), A(v.shape[3] === g.shape[2], function() {
    return "Error in conv2d: depth of input (" + v.shape[3] + ") must match input depth for filter " + g.shape[2] + ".";
  }), A(vt(r, u), function() {
    return "Error in conv2D: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
  }), A(i === "NHWC", function() {
    return "Error in conv2d: got dataFormat of " + i + " but only NHWC is currently supported.";
  });
  var b, x, C = Sr(v.shape, g.shape, r, u, a, l);
  c != null && (b = Le(b = k(c, "bias", "fused conv2d"), m)[0], fe(C.outShape, b.shape)), p != null && (x = k(p, "prelu weights", "fused conv2d"));
  var N = { x: v, filter: g };
  c != null && (N.bias = b), p != null && (N.preluActivationWeights = x);
  var T = [g, v], I = D.runKernelFunc(function(E, P) {
    var O = E.fusedConv2d({ input: v, filter: g, convInfo: C, bias: b, activation: d, preluActivationWeights: x });
    return P([g, v, O]), O;
  }, N, function(E, P) {
    var O = P, R = O[0], z = O[1], j = O[2], B = cl(E, j, d);
    A(ca(u), function() {
      return "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + u + "'";
    });
    var H = {};
    return c != null && (H = { bias: function() {
      return hl(b, B);
    } }), Object.assign({ x: function() {
      return Sf(z.shape, B, R, r, a);
    }, filter: function() {
      return Zu(z, B, R.shape, r, a);
    } }, H);
  }, "FusedConv2D", { convInfo: C, activation: d }, T, [!0]);
  return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
} }), u1 = S({ fusedDepthwiseConv2d_: function(e) {
  var n = e.x, t = e.filter, r = e.strides, a = e.pad, o = e.dataFormat, i = o === void 0 ? "NHWC" : o, s = e.dilations, u = s === void 0 ? [1, 1] : s, l = e.dimRoundingMode, c = e.bias, h = e.activation, d = h === void 0 ? "linear" : h, p = e.preluActivationWeights;
  if (ll(D.state.gradientDepth, d) === !1) {
    var f = wi(n, t, r, a, i, u, l);
    return c != null && (f = _n(f, c)), dl(f, d, p);
  }
  var m = k(n, "x", "depthwiseConv2d"), g = k(t, "filter", "depthwiseConv2d"), v = m, y = !1;
  m.rank === 3 && (y = !0, v = m.as4D(1, m.shape[0], m.shape[1], m.shape[2])), A(v.rank === 4, function() {
    return "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + v.rank + ".";
  }), A(g.rank === 4, function() {
    return "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + g.rank + ".";
  }), A(v.shape[3] === g.shape[2], function() {
    return "Error in fused depthwiseConv2d: number of input channels (" + v.shape[3] + ") must match the inChannels dimension in filter " + g.shape[2] + ".";
  }), u == null && (u = [1, 1]), A(vt(r, u), function() {
    return "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + r + " and dilations '" + u + "'";
  }), l != null && A(He(a), function() {
    return "Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode " + l + " but got pad " + a + ".";
  });
  var b, x, C = Sr(v.shape, g.shape, r, u, a, l, !0);
  c != null && (b = Le(b = k(c, "bias", "fused conv2d"), m)[0], fe(C.outShape, b.shape)), p != null && (x = k(p, "prelu weights", "fused depthwiseConv2d"));
  var N = { x: v, filter: g };
  c != null && (N.bias = b), p != null && (N.preluActivationWeights = x);
  var T = [g, v], I = D.runKernelFunc(function(E, P) {
    var O = E.fusedDepthwiseConv2D({ input: v, filter: g, convInfo: C, bias: b, activation: d, preluActivationWeights: x });
    return P([g, v, O]), O;
  }, N, function(E, P) {
    A(ca(u), function() {
      return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + u + "'";
    });
    var O = P[0], R = P[1], z = P[2], j = cl(E, z, d), B = {};
    return c != null && (B = { bias: function() {
      return hl(b, j);
    } }), Object.assign({ x: function() {
      return Df(R.shape, j, O, C);
    }, filter: function() {
      return Of(R, j, O.shape, C);
    } }, B);
  }, "FusedDepthwiseConv2D", { convInfo: C, activation: d }, T, [!0]);
  return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;
} }), ni = Object.freeze({ matMul: i1, conv2d: s1, depthwiseConv2d: u1 }), l1 = Object.freeze({ image: aa, linalg: Yb, losses: qb, spectral: Mb, fused: ni, signal: jb, add: _n, addN: cf, batchNorm: fa, batchNormalization: Uy, batchNorm2d: qy, batchNormalization2d: Ky, batchNorm3d: Xy, batchNormalization3d: Jy, batchNorm4d: Yy, batchNormalization4d: Qy, broadcastTo: gf, clone: Zy, div: Bn, divNoNan: Uu, eye: yf, multinomial: bf, oneHot: za, pad: ir, pad1d: tb, pad2d: nb, pad3d: rb, pad4d: ab, rand: ob, randomGamma: ub, randomNormal: lb, randomUniform: qu, square: Ju, squaredDifference: Xu, tile: kr, truncatedNormal: xf, conv1d: Tf, conv2d: ma, conv3d: Pf, depthwiseConv2d: wi, separableConv2d: vb, conv2dTranspose: Rf, conv3dTranspose: yb, op: S, booleanMaskAsync: gb, complex: nt, real: Dt, imag: Xt, concat: Gt, concat1d: fv, concat2d: mv, concat3d: gv, concat4d: vv, split: hi, matMul: el, dot: bb, outerProduct: xb, reverse: ga, reverse1d: wb, reverse2d: Cb, reverse3d: kb, reverse4d: Nb, maxPool: _f, avgPool: Bf, pool: Ab, maxPool3d: jf, avgPool3d: Vf, maxPoolWithArgmax: Lf, slice: hn, slice1d: Ib, slice2d: Eb, slice3d: Tb, slice4d: Pb, abs: lp, acos: cp, acosh: hp, asin: dp, asinh: pp, atan: fp, atanh: mp, ceil: gp, clipByValue: vp, cos: yp, cosh: bp, erf: xp, exp: wp, expm1: Cp, floor: kp, log: Np, log1p: Ap, logSigmoid: xv, neg: fi, reciprocal: Ip, round: Ep, rsqrt: Ru, sigmoid: Tp, sign: Pp, isNaN: wv, isInf: Cv, isFinite: kv, sin: Sp, sinh: Dp, softplus: Op, sqrt: Rp, step: Nv, tan: Fp, tanh: Mp, all: Gf, any: Hf, argMax: Wf, argMin: $f, logSumExp: Sb, max: Uf, mean: Kf, min: qf, moments: Db, sum: Pn, prod: tl, equal: Qu, equalStrict: cb, greater: wf, greaterEqual: Yu, greaterEqualStrict: hb, greaterStrict: db, less: Cf, lessEqual: kf, lessEqualStrict: pb, lessStrict: fb, notEqual: Nf, notEqualStrict: mb, addStrict: Av, atan2: _p, divStrict: Iv, floorDiv: Fu, maximum: mi, maximumStrict: Ev, minimum: Mu, minimumStrict: Tv, mod: Bp, modStrict: Pv, mul: $e, mulStrict: Sv, pow: La, powStrict: Dv, squaredDifferenceStrict: Ov, sub: Rn, subStrict: Rv, elu: nl, leakyRelu: Jf, prelu: rl, relu: al, relu6: Xf, selu: Qf, logicalAnd: Xa, logicalNot: vf, logicalOr: Wu, logicalXor: eb, where: nr, whereAsync: $u, buffer: oe, print: yv, batchToSpaceND: Su, cast: Yd, cumsum: bv, depthToSpace: Zd, expandDims: Tn, reshape: un, spaceToBatchND: Du, squeeze: Ou, stack: Mn, unstack: qa, setdiff1dAsync: ep, fill: ci, linspace: Qd, ones: Pr, range: Va, scalar: X, tensor: rt, tensor1d: Fn, tensor2d: Cr, tensor3d: Xd, tensor4d: pr, tensor5d: hv, tensor6d: dv, variable: pv, zeros: je, onesLike: Pu, zerosLike: ve, transpose: Lt, softmax: vi, logSoftmax: Gp, localResponseNormalization: Yf, norm: Zf, gather: xi, unsortedSegmentSum: Af, basicLSTMCell: Ob, multiRNNCell: Rb, movingAverage: Fb, stridedSlice: em, topk: tm, scatterND: nm, fft: Ci, ifft: Ga, rfft: ki, irfft: ol, sparseToDense: il, gatherND: rm, diag: _b, dropout: Bb, hannWindow: sl, hammingWindow: om, frame: ul, stft: im, inTopKAsync: Vb });
function G(e, n) {
  Array.isArray(e) || (e = [e]), e.forEach(function(t) {
    t != null && A(t.dtype !== "complex64", function() {
      return n + " does not support complex64 tensors.";
    });
  });
}
function Ms(e, n, t, r, a, o) {
  for (var i = a.strideHeight, s = a.strideWidth, u = a.dilationHeight, l = a.dilationWidth, c = a.effectiveFilterHeight, h = a.effectiveFilterWidth, d = a.padInfo.top, p = a.padInfo.left, f = o === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = oe(a.outShape, t), g = m.values, v = a.outShape[1] * a.outShape[2] * a.outShape[3], y = a.outShape[2] * a.outShape[3], b = a.outShape[3], x = 0; x < a.batchSize; ++x) for (var C = x * v, N = x * r[0], T = 0; T < a.inChannels; ++T) for (var I = 0; I < a.outHeight; ++I) for (var E = I * i - d, P = Math.max(0, E), O = Math.min(a.inHeight, c + E), R = C + I * y, z = 0; z < a.outWidth; ++z) {
    for (var j = z * s - p, B = Math.max(0, j), H = Math.min(a.inWidth, h + j), W = f, L = 0, $ = 0, K = P; K < O; K += u) {
      for (var J = N + K * r[1], ee = B; ee < H; ee += l) {
        var ne = e[J + ee * r[2] + T];
        o === "max" && ne > W ? W = ne : o === "avg" && (L += ne, $++);
      }
      if (isNaN(W)) break;
    }
    g[R + z * b + T] = o === "avg" ? L / $ : W;
  }
  return m;
}
function sm(e, n, t, r, a, o) {
  a === void 0 && (a = !1), o === void 0 && (o = !1);
  for (var i = oe(r.outShape, "int32"), s = r.strideHeight, u = r.strideWidth, l = r.dilationHeight, c = r.dilationWidth, h = r.effectiveFilterHeight, d = r.effectiveFilterWidth, p = r.padInfo.top, f = r.padInfo.left, m = oe(n, t, e), g = 0; g < r.batchSize; ++g) for (var v = 0; v < r.inChannels; ++v) for (var y = 0; y < r.outHeight; ++y) {
    for (var b = y * s - p, x = b; x < 0; ) x += l;
    for (var C = Math.min(r.inHeight, h + b), N = 0; N < r.outWidth; ++N) {
      for (var T = N * u - f, I = T; I < 0; ) I += c;
      for (var E = Math.min(r.inWidth, d + T), P = Number.NEGATIVE_INFINITY, O = -1, R = x; R < C; R += l) for (var z = R - b, j = I; j < E; j += c) {
        var B = j - T, H = m.get(g, R, j, v);
        H > P && (P = H, O = a ? o ? ((g * r.inHeight + R) * r.inWidth + j) * r.inChannels + v : (R * r.inWidth + j) * r.inChannels + v : z * d + B);
      }
      i.set(O, g, y, N, v);
    }
  }
  return i;
}
function Ji(e, n, t, r) {
  if (t === "linear") return e.linear(n);
  if (t === "relu") return e.relu(n);
  if (t === "elu") return e.elu(n);
  if (t === "relu6") return e.relu6(n);
  if (t === "prelu") return e.prelu(n, r);
  throw new Error("Activation " + t + " has not been implemented for the CPU backend.");
}
var c1 = function(e) {
  function n() {
    var t = e.call(this) || this;
    return t.blockSize = 48, t.firstUse = !0, t.data = new Hp(t, D), t;
  }
  return en(n, e), n.prototype.write = function(t, r, a) {
    this.firstUse && (this.firstUse = !1, _().get("IS_NODE") && Ko(`
============================
Hi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));
    var o = {};
    return this.data.set(o, { values: t, dtype: a }), o;
  }, n.prototype.move = function(t, r, a, o) {
    this.data.set(t, { values: r, dtype: o });
  }, n.prototype.numDataIds = function() {
    return this.data.numDataIds();
  }, n.prototype.read = function(t) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(r) {
        return [2, this.readSync(t)];
      });
    });
  }, n.prototype.readSync = function(t) {
    var r = this.data.get(t), a = r.dtype, o = r.complexTensors;
    return a === "complex64" ? Fs(this.readSync(o.real.dataId), this.readSync(o.imag.dataId)) : this.data.get(t).values;
  }, n.prototype.bufferSync = function(t) {
    var r = this.readSync(t.dataId), a = r;
    if (t.dtype === "string") try {
      a = r.map(function(o) {
        return _a(o);
      });
    } catch {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return oe(t.shape, t.dtype, a);
  }, n.prototype.makeOutput = function(t, r, a) {
    var o = this.write(t, r, a);
    return D.makeTensorFromDataId(o, r, a, this);
  }, n.prototype.disposeData = function(t) {
    if (this.data.has(t)) {
      var r = this.data.get(t).complexTensors;
      r != null && (r.real.dispose(), r.imag.dispose()), this.data.delete(t);
    }
  }, n.prototype.time = function(t) {
    return Y(this, void 0, void 0, function() {
      var r;
      return Z(this, function(a) {
        return r = Jt(), t(), [2, { kernelMs: Jt() - r }];
      });
    });
  }, n.prototype.memory = function() {
    return { unreliable: !0, reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
  }, n.prototype.complex = function(t, r) {
    var a = this.makeOutput(null, t.shape, "complex64");
    return this.data.get(a.dataId).complexTensors = { real: D.keep(t.clone()), imag: D.keep(r.clone()) }, a;
  }, n.prototype.real = function(t) {
    return this.data.get(t.dataId).complexTensors.real.clone();
  }, n.prototype.imag = function(t) {
    return this.data.get(t.dataId).complexTensors.imag.clone();
  }, n.prototype.slice = function(t, r, a) {
    if (G(t, "slice"), Lp(t.shape, r, a)) {
      var o = zp(r, t.strides), i = Q(a);
      return rt(this.readSync(t.dataId).subarray(o, o + i), a, t.dtype);
    }
    for (var s = oe(a, t.dtype), u = this.bufferSync(t), l = 0; l < s.size; ++l) {
      var c = s.indexToLoc(l).map(function(h, d) {
        return h + r[d];
      });
      s.values[l] = u.get.apply(u, c);
    }
    return s.toTensor();
  }, n.prototype.stridedSlice = function(t, r, a, o) {
    G(t, "stridedSlice");
    var i = _u(r, a, o);
    if (i.some(function(p) {
      return p === 0;
    })) return rt([], i);
    for (var s = oe(i, t.dtype), u = this.bufferSync(t), l = 0; l < s.size; l++) {
      for (var c = s.indexToLoc(l), h = new Array(c.length), d = 0; d < h.length; d++) h[d] = c[d] * o[d] + r[d];
      s.set.apply(s, [u.get.apply(u, h)].concat(c));
    }
    return s.toTensor();
  }, n.prototype.diag = function(t) {
    for (var r = this.readSync(t.dataId), a = oe([t.size, t.size], t.dtype), o = a.values, i = 0; i < r.length; i++) o[i * t.size + i] = r[i];
    return a.toTensor();
  }, n.prototype.unstack = function(t, r) {
    for (var a = t.shape[r], o = new Array(t.rank - 1), i = 0, s = 0; s < t.rank; s++) s !== r && (o[i++] = t.shape[s]);
    var u = new Array(t.rank).fill(0), l = t.shape.slice();
    l[r] = 1;
    var c = new Array(a);
    for (s = 0; s < c.length; s++) u[r] = s, c[s] = this.slice(t, u, l).reshape(o);
    return c;
  }, n.prototype.reverse = function(t, r) {
    G(t, "reverse");
    for (var a = oe(t.shape, t.dtype), o = this.bufferSync(t), i = function(u) {
      var l = a.indexToLoc(u), c = l.slice();
      r.forEach(function(h) {
        return c[h] = t.shape[h] - 1 - c[h];
      }), a.set.apply(a, [o.get.apply(o, c)].concat(l));
    }, s = 0; s < a.size; s++) i(s);
    return a.toTensor();
  }, n.prototype.concat = function(t, r) {
    var a = this;
    if (t[0].dtype === "complex64") {
      var o = t.map(function(p) {
        return Dt(p);
      }), i = t.map(function(p) {
        return Xt(p);
      });
      return nt(this.concat(o, r), this.concat(i, r));
    }
    var s = t.map(function(p) {
      var f = Q(p.shape.slice(r));
      return p.as2D(-1, f);
    }), u = la(s.map(function(p) {
      return p.shape;
    }), 1), l = oe(u, t[0].dtype).values;
    if (s[0].shape[0] === 1) {
      var c = 0;
      s.forEach(function(p) {
        l.set(a.readSync(p.dataId), c), c += p.size;
      });
    } else {
      var h = 0;
      s.forEach(function(p) {
        for (var f = a.readSync(p.dataId), m = 0, g = 0; g < p.shape[0]; ++g) for (var v = g * u[1] + h, y = 0; y < p.shape[1]; ++y) l[v + y] = f[m++];
        h += p.shape[1];
      });
    }
    var d = la(t.map(function(p) {
      return p.shape;
    }), r);
    return rt(l, d, t[0].dtype);
  }, n.prototype.neg = function(t) {
    return G(t, "neg"), this.multiply(X(-1), t);
  }, n.prototype.add = function(t, r) {
    return t.dtype === "complex64" || r.dtype === "complex64" ? this.broadcastedBinaryComplexOp(t.cast("complex64"), r.cast("complex64"), function(a, o, i, s) {
      return { real: a + i, imag: o + s };
    }) : this.broadcastedBinaryOp(t, r, st(t.dtype, r.dtype), function(a, o) {
      return a + o;
    });
  }, n.prototype.addN = function(t) {
    var r = this;
    G(t, "addN");
    for (var a = t.map(function(c) {
      return r.readSync(c.dataId);
    }), o = oe(t[0].shape, t[0].dtype), i = o.values, s = 0; s < t.length; s++) for (var u = a[s], l = 0; l < i.length; l++) i[l] += u[l];
    return o.toTensor();
  }, n.prototype.softmax = function(t, r) {
    var a = Xe([r], t.shape), o = this.max(t, a), i = wt(o.shape, a), s = this.subtract(t, o.reshape(i)), u = this.exp(s), l = this.sum(u, a).reshape(i);
    return Bn(u, l);
  }, n.prototype.subtract = function(t, r) {
    return t.dtype === "complex64" || r.dtype === "complex64" ? this.broadcastedBinaryComplexOp(t.cast("complex64"), r.cast("complex64"), function(a, o, i, s) {
      return { real: a - i, imag: o - s };
    }) : this.broadcastedBinaryOp(t, r, st(t.dtype, r.dtype), function(a, o) {
      return a - o;
    });
  }, n.prototype.pow = function(t, r) {
    return G([t, r], "pow"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      return Math.pow(a, o);
    });
  }, n.prototype.batchMatMul = function(t, r, a, o) {
    G([t, r], "matMul");
    for (var i = a ? t.shape[1] : t.shape[2], s = a ? t.shape[2] : t.shape[1], u = o ? r.shape[1] : r.shape[2], l = t.shape[0], c = this.readSync(t.dataId), h = this.readSync(r.dataId), d = a ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], p = d[0], f = d[1], m = d[2], g = o ? [1, r.strides[1], r.strides[0]] : [r.strides[1], 1, r.strides[0]], v = g[0], y = g[1], b = g[2], x = s * u, C = oe([l, s, u], t.dtype), N = C.values, T = this.blockSize, I = 0; I < l; I++) for (var E = 0; E < s; E += T) for (var P = 0; P < u; P += T) for (var O = 0; O < i; O += T) for (var R = Math.min(E + T, s), z = Math.min(P + T, u), j = Math.min(O + T, i), B = E; B < R; B++) for (var H = P; H < z; H++) {
      for (var W = 0, L = O; L < j; L++) W += c[I * p + B * f + L * m] * h[L * v + H * y + I * b];
      N[I * x + (B * u + H)] += W;
    }
    return C.toTensor();
  }, n.prototype.fusedBatchMatMul = function(t) {
    var r = t.a, a = t.b, o = t.transposeA, i = t.transposeB, s = t.bias, u = t.activation, l = t.preluActivationWeights, c = this.batchMatMul(r, a, o, i);
    return s && (c = this.add(c, s)), u && (c = Ji(this, c, u, l)), c;
  }, n.prototype.multiply = function(t, r) {
    return t.dtype === "complex64" || r.dtype === "complex64" ? this.broadcastedBinaryComplexOp(t.cast("complex64"), r.cast("complex64"), function(a, o, i, s) {
      return { real: a * i - o * s, imag: a * s + o * i };
    }) : this.broadcastedBinaryOp(t, r, st(t.dtype, r.dtype), function(a, o) {
      return a * o;
    });
  }, n.prototype.floorDiv = function(t, r) {
    return G([t, r], "floorDiv"), this.broadcastedBinaryOp(t, r, "int32", function(a, o) {
      return Math.floor(a / o);
    });
  }, n.prototype.sum = function(t, r) {
    G(t, "sum"), Tt("sum", r, t.rank);
    for (var a = ct(t.shape, r), o = a[0], i = a[1], s = je(o, st(t.dtype, "int32")), u = Q(i), l = this.readSync(s.dataId), c = this.readSync(t.dataId), h = 0; h < l.length; ++h) {
      for (var d = h * u, p = 0, f = 0; f < u; ++f) p += c[d + f];
      l[h] = p;
    }
    return s;
  }, n.prototype.prod = function(t, r) {
    G(t, "sum");
    for (var a = ct(t.shape, r), o = a[0], i = a[1], s = je(o, st(t.dtype, "int32")), u = Q(i), l = this.readSync(s.dataId), c = this.readSync(t.dataId), h = 0; h < l.length; ++h) {
      for (var d = h * u, p = 1, f = 0; f < u; ++f) p *= c[d + f];
      l[h] = p;
    }
    return s;
  }, n.prototype.unsortedSegmentSum = function(t, r, a) {
    G(t, "unsortedSegmentSum");
    for (var o = [], i = t.rank - r.rank, s = 0; s < i; ++s) r = r.expandDims(s + 1);
    for (s = 0; s < a; ++s) {
      var u = X(s, "int32"), l = Qu(u, r).asType("float32").mul(t).sum(0);
      o.push(l);
    }
    return Mn(o);
  }, n.prototype.argMin = function(t, r) {
    G(t, "argMin");
    var a = [r];
    Tt("argMin", a, t.rank);
    for (var o = ct(t.shape, a), i = o[0], s = o[1], u = je(i, "int32"), l = Q(s), c = this.readSync(u.dataId), h = this.readSync(t.dataId), d = 0; d < c.length; ++d) {
      for (var p = d * l, f = h[p], m = 0, g = 0; g < l; ++g) {
        var v = h[p + g];
        v < f && (f = v, m = g);
      }
      c[d] = m;
    }
    return u;
  }, n.prototype.argMax = function(t, r) {
    G(t, "argMax");
    var a = [r];
    Tt("argMax", a, t.rank);
    for (var o = ct(t.shape, a), i = o[0], s = o[1], u = je(i, "int32"), l = Q(s), c = this.readSync(u.dataId), h = this.readSync(t.dataId), d = 0; d < c.length; ++d) {
      for (var p = d * l, f = h[p], m = 0, g = 0; g < l; ++g) {
        var v = h[p + g];
        v > f && (f = v, m = g);
      }
      c[d] = m;
    }
    return u;
  }, n.prototype.cumsum = function(t, r, a, o) {
    if (G(t, "cumsum"), r !== t.rank - 1) throw new Error("backend.cumsum in CPU expects an inner-most axis=" + (t.rank - 1) + " but got axis=" + r);
    for (var i = st(t.dtype, "int32"), s = je(t.shape, i), u = this.readSync(s.dataId), l = this.readSync(t.dataId), c = t.shape[t.rank - 1], h = o ? function(g, v) {
      return g + c - v - 1;
    } : function(g, v) {
      return g + v;
    }, d = 0; d < l.length; d += c) for (var p = 0; p < c; p++) {
      var f = h(d, p);
      if (p === 0) u[f] = a ? 0 : l[f];
      else {
        var m = h(d, p - 1);
        u[f] = a ? l[m] + u[m] : l[f] + u[m];
      }
    }
    return s;
  }, n.prototype.equal = function(t, r) {
    return G([t, r], "equal"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a === o ? 1 : 0;
    });
  }, n.prototype.notEqual = function(t, r) {
    return G([t, r], "notEqual"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a !== o ? 1 : 0;
    });
  }, n.prototype.less = function(t, r) {
    return G([t, r], "less"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a < o ? 1 : 0;
    });
  }, n.prototype.lessEqual = function(t, r) {
    return G([t, r], "lessEqual"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a <= o ? 1 : 0;
    });
  }, n.prototype.greater = function(t, r) {
    return G([t, r], "greater"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a > o ? 1 : 0;
    });
  }, n.prototype.greaterEqual = function(t, r) {
    return G([t, r], "greaterEqual"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a >= o ? 1 : 0;
    });
  }, n.prototype.logicalNot = function(t) {
    G(t, "logicalNot");
    for (var r = this.readSync(t.dataId), a = new Uint8Array(r.length), o = 0; o < r.length; ++o) a[o] = r[o] ? 0 : 1;
    return this.makeOutput(a, t.shape, "bool");
  }, n.prototype.logicalAnd = function(t, r) {
    return G([t, r], "logicalAnd"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a && o;
    });
  }, n.prototype.logicalOr = function(t, r) {
    return G([t, r], "logicalOr"), this.broadcastedBinaryOp(t, r, "bool", function(a, o) {
      return a || o;
    });
  }, n.prototype.select = function(t, r, a) {
    G([t, r, a], "select");
    for (var o = this.readSync(t.dataId), i = this.readSync(r.dataId), s = this.readSync(a.dataId), u = je(r.shape, st(r.dtype, a.dtype)), l = this.readSync(u.dataId), c = 0, h = t.rank === 0 || t.rank > 1 || r.rank === 1 ? 1 : Q(r.shape.slice(1)), d = 0; d < o.length; d++) for (var p = 0; p < h; p++) o[d] === 1 ? l[c++] = i[d] : l[c++] = s[d];
    return u;
  }, n.prototype.where = function(t) {
    G([t], "where");
    var r = this.readSync(t.dataId);
    return Lu(t.shape, r);
  }, n.prototype.topk = function(t, r, a) {
    return G(t, "topk"), Qp(this.readSync(t.dataId), t.shape, t.dtype, r);
  }, n.prototype.min = function(t, r) {
    G(t, "min"), Tt("min", r, t.rank);
    for (var a = ct(t.shape, r), o = a[0], i = a[1], s = je(o, t.dtype), u = Q(i), l = this.readSync(s.dataId), c = this.readSync(t.dataId), h = 0; h < l.length; ++h) {
      for (var d = h * u, p = c[d], f = 0; f < u; ++f) {
        var m = c[d + f];
        m < p && (p = m);
      }
      l[h] = p;
    }
    return s;
  }, n.prototype.minimum = function(t, r) {
    return G([t, r], "minimum"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      return Math.min(a, o);
    });
  }, n.prototype.mod = function(t, r) {
    return G([t, r], "mod"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      var i = a % o;
      return a < 0 && o < 0 || a >= 0 && o >= 0 ? i : (i + o) % o;
    });
  }, n.prototype.max = function(t, r) {
    G(t, "max"), Tt("max", r, t.rank);
    for (var a = ct(t.shape, r), o = a[0], i = a[1], s = je(o, t.dtype), u = Q(i), l = this.readSync(s.dataId), c = this.readSync(t.dataId), h = 0; h < l.length; ++h) {
      for (var d = h * u, p = c[d], f = 0; f < u; ++f) {
        var m = c[d + f];
        m > p && (p = m);
      }
      l[h] = p;
    }
    return s;
  }, n.prototype.maximum = function(t, r) {
    return G([t, r], "maximum"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      return Math.max(a, o);
    });
  }, n.prototype.all = function(t, r) {
    G(t, "all"), Tt("all", r, t.rank);
    for (var a = ct(t.shape, r), o = a[0], i = a[1], s = je(o, t.dtype), u = Q(i), l = this.readSync(s.dataId), c = this.readSync(t.dataId), h = 0; h < l.length; ++h) {
      for (var d = h * u, p = c[d], f = 0; f < u; ++f) {
        var m = c[d + f];
        p = p && m;
      }
      l[h] = p;
    }
    return s;
  }, n.prototype.any = function(t, r) {
    G(t, "any"), Tt("any", r, t.rank);
    for (var a = ct(t.shape, r), o = a[0], i = a[1], s = je(o, t.dtype), u = Q(i), l = this.readSync(s.dataId), c = this.readSync(t.dataId), h = 0; h < l.length; ++h) {
      for (var d = h * u, p = c[d], f = 0; f < u; ++f) {
        var m = c[d + f];
        p = p || m;
      }
      l[h] = p;
    }
    return s;
  }, n.prototype.squaredDifference = function(t, r) {
    return G([t, r], "squaredDifference"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      var i = a - o;
      return i * i;
    });
  }, n.prototype.ceil = function(t) {
    G(t, "ceil");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) a[o] = Math.ceil(r[o]);
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.floor = function(t) {
    G(t, "floor");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) a[o] = Math.floor(r[o]);
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.sign = function(t) {
    G(t, "x");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) r[o] < 0 ? a[o] = -1 : r[o] > 0 ? a[o] = 1 : a[o] = 0;
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.isNaN = function(t) {
    G(t, "x");
    for (var r = this.readSync(t.dataId), a = new Uint8Array(r.length), o = 0; o < r.length; ++o) Number.isNaN(r[o]) && (a[o] = 1);
    return this.makeOutput(a, t.shape, "bool");
  }, n.prototype.isInf = function(t) {
    G(t, "x");
    for (var r = this.readSync(t.dataId), a = new Uint8Array(r.length), o = 0; o < r.length; ++o) Math.abs(r[o]) === 1 / 0 && (a[o] = 1);
    return this.makeOutput(a, t.shape, "bool");
  }, n.prototype.isFinite = function(t) {
    G(t, "x");
    for (var r = this.readSync(t.dataId), a = new Uint8Array(r.length), o = 0; o < r.length; ++o) Number.isFinite(r[o]) && (a[o] = 1);
    return this.makeOutput(a, t.shape, "bool");
  }, n.prototype.round = function(t) {
    G(t, "round");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) {
      var i = Math.floor(r[o]);
      r[o] - i < 0.5 ? a[o] = Math.floor(r[o]) : r[o] - i > 0.5 ? a[o] = Math.ceil(r[o]) : a[o] = i % 2 == 0 ? i : i + 1;
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.exp = function(t) {
    G(t, "exp");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) a[o] = Math.exp(r[o]);
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.expm1 = function(t) {
    G(t, "expm1");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) a[o] = Math.expm1(r[o]);
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.log = function(t) {
    G(t, "log");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) {
      var i = r[o];
      a[o] = Math.log(i);
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.log1p = function(t) {
    G(t, "log1p");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) {
      var i = r[o];
      a[o] = Math.log1p(i);
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.sqrt = function(t) {
    G(t, "sqrt");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) {
      var i = r[o];
      a[o] = Math.sqrt(i);
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.rsqrt = function(t) {
    G(t, "rsqrt");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) {
      var i = r[o];
      a[o] = 1 / Math.sqrt(i);
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.reciprocal = function(t) {
    G(t, "reciprocal");
    for (var r = this.readSync(t.dataId), a = new Float32Array(r.length), o = 0; o < r.length; ++o) a[o] = 1 / r[o];
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.linear = function(t) {
    return t;
  }, n.prototype.relu = function(t) {
    G(t, "relu");
    for (var r = je(t.shape, t.dtype), a = this.readSync(r.dataId), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) a[i] = Math.max(0, o[i]);
    return r;
  }, n.prototype.relu6 = function(t) {
    G(t, "relu");
    for (var r = je(t.shape, t.dtype), a = this.readSync(r.dataId), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) a[i] = Math.min(Math.max(0, o[i]), 6);
    return r;
  }, n.prototype.prelu = function(t, r) {
    return G([t, r], "prelu"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      return a < 0 ? o * a : a;
    });
  }, n.prototype.elu = function(t) {
    G(t, "elu");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) {
      var i = a[o];
      r[o] = i >= 0 ? i : Math.exp(i) - 1;
    }
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.eluDer = function(t, r) {
    G([t, r], "eluDer");
    for (var a = new Float32Array(r.size), o = this.readSync(r.dataId), i = this.readSync(t.dataId), s = 0; s < o.length; ++s) {
      var u = o[s];
      a[s] = u >= 1 ? i[s] : i[s] * (u + 1);
    }
    return this.makeOutput(a, r.shape, "float32");
  }, n.prototype.selu = function(t) {
    G(t, "selu");
    for (var r = Gu, a = Hu, o = new Float32Array(t.size), i = this.readSync(t.dataId), s = 0; s < i.length; ++s) {
      var u = i[s];
      o[s] = u >= 0 ? a * u : r * (Math.exp(u) - 1);
    }
    return this.makeOutput(o, t.shape, "float32");
  }, n.prototype.clip = function(t, r, a) {
    G(t, "clip");
    for (var o = new Float32Array(t.size), i = this.readSync(t.dataId), s = 0; s < i.length; ++s) {
      var u = i[s];
      o[s] = u > a ? a : u < r ? r : u;
    }
    return this.makeOutput(o, t.shape, "float32");
  }, n.prototype.abs = function(t) {
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.abs(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.complexAbs = function(t) {
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < t.size; ++o) {
      var i = a[2 * o], s = a[2 * o + 1];
      r[o] = Math.hypot(i, s);
    }
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.int = function(t) {
    G(t, "int");
    for (var r = new Int32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = a[o];
    return this.makeOutput(r, t.shape, "int32");
  }, n.prototype.sigmoid = function(t) {
    G(t, "sigmoid");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = 1 / (1 + Math.exp(-a[o]));
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.softplus = function(t) {
    G(t, "softplus");
    for (var r = Math.log(11920928955078125e-23) + 2, a = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) {
      var s = o[i] > -r, u = o[i] < r, l = Math.exp(o[i]), c = void 0;
      c = u ? l : s ? o[i] : Math.log(1 + l), a[i] = c;
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.sin = function(t) {
    G(t, "sin");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.sin(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.cos = function(t) {
    G(t, "cos");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.cos(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.tan = function(t) {
    G(t, "tan");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.tan(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.asin = function(t) {
    G(t, "asin");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.asin(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.acos = function(t) {
    G(t, "acos");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.acos(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.atan = function(t) {
    G(t, "atan");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.atan(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.atan2 = function(t, r) {
    return G([t, r], "atan2"), this.broadcastedBinaryOp(t, r, t.dtype, function(a, o) {
      return Math.atan2(a, o);
    });
  }, n.prototype.sinh = function(t) {
    G(t, "sinh");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.sinh(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.cosh = function(t) {
    G(t, "cosh");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.cosh(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.tanh = function(t) {
    G(t, "tanh");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Md(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.asinh = function(t) {
    G(t, "asinh");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.asinh(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.acosh = function(t) {
    G(t, "acosh");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.acosh(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.atanh = function(t) {
    G(t, "atanh");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) r[o] = Math.atanh(a[o]);
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.erf = function(t) {
    G(t, "erf");
    for (var r = new Float32Array(t.size), a = this.readSync(t.dataId), o = 0; o < a.length; ++o) {
      var i = Math.sign(a[o]), s = Math.abs(a[o]), u = 1 / (1 + 0.3275911 * s);
      r[o] = i * (1 - ((((1.061405429 * u - 1.453152027) * u + 1.421413741) * u - 0.284496736) * u + 0.254829592) * u * Math.exp(-s * s));
    }
    return this.makeOutput(r, t.shape, "float32");
  }, n.prototype.step = function(t, r) {
    r === void 0 && (r = 0), G(t, "step");
    for (var a = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) {
      var s = o[i];
      isNaN(s) ? a[i] = NaN : a[i] = s > 0 ? 1 : r;
    }
    return this.makeOutput(a, t.shape, "float32");
  }, n.prototype.fusedConv2d = function(t) {
    var r = t.input, a = t.filter, o = t.convInfo, i = t.bias, s = t.activation, u = t.preluActivationWeights, l = this.conv2d(r, a, o);
    return i && (l = this.add(l, i)), s && (l = Ji(this, l, s, u)), l;
  }, n.prototype.conv2d = function(t, r, a) {
    G([t, r], "conv2d");
    for (var o = a.filterHeight, i = a.filterWidth, s = a.dilationHeight, u = a.dilationWidth, l = a.padInfo.left, c = a.padInfo.top, h = a.dataFormat === "channelsLast", d = oe(a.outShape, t.dtype), p = t.strides[0], f = h ? t.strides[1] : t.strides[2], m = h ? t.strides[2] : 1, g = h ? 1 : t.strides[1], v = d.strides[0], y = h ? d.strides[1] : d.strides[2], b = h ? d.strides[2] : 1, x = h ? 1 : d.strides[1], C = this.readSync(t.dataId), N = this.readSync(r.dataId), T = d.values, I = 0; I < a.batchSize; ++I) for (var E = I * p, P = I * v, O = 0; O < a.outHeight; ++O) for (var R = P + O * y, z = O * a.strideHeight - c, j = 0; j < o; j++) {
      var B = z + j * s;
      if (!(B < 0 || B >= a.inHeight)) for (var H = j * r.strides[0], W = E + B * f, L = 0; L < a.outWidth; ++L) for (var $ = R + L * b, K = L * a.strideWidth - l, J = 0; J < i; J++) {
        var ee = K + J * u;
        if (!(ee < 0 || ee >= a.inWidth)) for (var ne = W + ee * m, ce = H + J * r.strides[1], he = 0; he < a.inChannels; ++he) {
          for (var pe = C[ne + he * g], ye = 0; ye < a.outChannels; ++ye) T[$ + ye * x] += pe * N[ce + ye];
          ce += a.outChannels;
        }
      }
    }
    return d.toTensor();
  }, n.prototype.conv3d = function(t, r, a) {
    for (var o = a.filterDepth, i = a.filterHeight, s = a.filterWidth, u = a.dilationDepth, l = a.dilationHeight, c = a.dilationWidth, h = a.padInfo.front, d = a.padInfo.left, p = a.padInfo.top, f = oe(a.outShape, t.dtype), m = this.readSync(t.dataId), g = this.readSync(r.dataId), v = f.values, y = 0; y < a.batchSize; ++y) for (var b = y * t.strides[0], x = y * f.strides[0], C = 0; C < a.outDepth; ++C) for (var N = x + C * f.strides[1], T = C * a.strideDepth - h, I = 0; I < o; I++) {
      var E = T + I * u;
      if (!(E < 0 || E >= a.inDepth)) for (var P = I * r.strides[0], O = b + E * t.strides[1], R = 0; R < a.outHeight; ++R) for (var z = N + R * f.strides[2], j = R * a.strideHeight - p, B = 0; B < i; B++) {
        var H = j + B * l;
        if (!(H < 0 || H >= a.inHeight)) for (var W = P + B * r.strides[1], L = O + H * t.strides[2], $ = 0; $ < a.outWidth; ++$) for (var K = z + $ * a.outChannels, J = $ * a.strideWidth - d, ee = 0; ee < s; ee++) {
          var ne = J + ee * c;
          if (!(ne < 0 || ne >= a.inWidth)) for (var ce = W + ee * r.strides[2], he = L + ne * a.inChannels, pe = ce, ye = 0; ye < a.inChannels; ++ye) {
            for (var me = m[he + ye], be = 0; be < a.outChannels; ++be) v[K + be] += me * g[pe + be];
            pe += a.outChannels;
          }
        }
      }
    }
    return f.toTensor();
  }, n.prototype.conv2dDerInput = function(t, r, a) {
    G([t, r], "conv2dDerInput");
    for (var o = oe(a.inShape, "float32"), i = o.values, s = this.readSync(t.dataId), u = this.readSync(r.dataId), l = r.strides, c = l[0], h = l[1], d = l[2], p = a.batchSize, f = a.filterHeight, m = a.filterWidth, g = a.inChannels, v = a.inHeight, y = a.inWidth, b = a.outChannels, x = a.outHeight, C = a.outWidth, N = a.strideHeight, T = a.strideWidth, I = a.dataFormat, E = f - 1 - a.padInfo.top, P = m - 1 - a.padInfo.left, O = I === "channelsLast", R = o.strides[0], z = O ? o.strides[1] : o.strides[2], j = O ? o.strides[2] : 1, B = O ? 1 : o.strides[1], H = t.strides[0], W = O ? t.strides[1] : t.strides[2], L = O ? t.strides[2] : 1, $ = O ? 1 : t.strides[1], K = 0; K < p; ++K) for (var J = 0; J < g; ++J) for (var ee = 0; ee < v; ++ee) for (var ne = ee - E, ce = Math.max(0, Math.ceil(ne / N)), he = Math.min(x, (f + ne) / N), pe = 0; pe < y; ++pe) {
      for (var ye = pe - P, me = Math.max(0, Math.ceil(ye / T)), be = Math.min(C, (m + ye) / T), We = 0, ge = ce; ge < he; ++ge) for (var Ie = ge * N - ne, Ce = me; Ce < be; ++Ce) for (var ze = H * K + W * ge + L * Ce, Me = c * (f - 1 - Ie) + h * (m - 1 - (Ce * T - ye)) + d * J, _e = 0; _e < b; ++_e)
        We += s[ze + $ * _e] * u[Me + _e];
      i[R * K + z * ee + j * pe + B * J] = We;
    }
    return o.toTensor();
  }, n.prototype.conv3dDerInput = function(t, r, a) {
    for (var o = oe(a.inShape, "float32"), i = o.values, s = o.strides, u = s[0], l = s[1], c = s[2], h = s[3], d = this.readSync(t.dataId), p = t.strides, f = p[0], m = p[1], g = p[2], v = p[3], y = this.readSync(r.dataId), b = r.strides, x = b[0], C = b[1], N = b[2], T = b[3], I = a.batchSize, E = a.filterDepth, P = a.filterHeight, O = a.filterWidth, R = a.inChannels, z = a.inDepth, j = a.inHeight, B = a.inWidth, H = a.outChannels, W = a.outDepth, L = a.outHeight, $ = a.outWidth, K = a.strideDepth, J = a.strideHeight, ee = a.strideWidth, ne = E - 1 - a.padInfo.front, ce = P - 1 - a.padInfo.top, he = O - 1 - a.padInfo.left, pe = 0; pe < I; ++pe) for (var ye = 0; ye < R; ++ye) for (var me = 0; me < z; ++me) for (var be = me - ne, We = Math.max(0, Math.ceil(be / K)), ge = Math.min(W, (E + be) / K), Ie = 0; Ie < j; ++Ie) for (var Ce = Ie - ce, ze = Math.max(0, Math.ceil(Ce / J)), Me = Math.min(L, (P + Ce) / J), _e = 0; _e < B; ++_e) {
      for (var nn = _e - he, rn = Math.max(0, Math.ceil(nn / ee)), Ct = Math.min($, (O + nn) / ee), _r = 0, gn = We; gn < ge; ++gn) for (var zn = gn * K - be, vn = ze; vn < Me; ++vn) for (var Br = vn * J - Ce, yn = rn; yn < Ct; ++yn) for (var Ti = f * pe + m * gn + g * vn + v * yn, jr = x * (E - 1 - zn) + C * (P - 1 - Br) + N * (O - 1 - (yn * ee - nn)) + T * ye, an = 0; an < H; ++an)
        _r += d[Ti + an] * y[jr + an];
      i[u * pe + l * me + c * Ie + h * _e + ye] = _r;
    }
    return o.toTensor();
  }, n.prototype.conv2dDerFilter = function(t, r, a) {
    G([t, r], "conv2dDerFilter");
    for (var o = a.strideHeight, i = a.strideWidth, s = a.filterHeight, u = a.filterWidth, l = a.dataFormat === "channelsLast", c = oe(a.filterShape, "float32"), h = a.padInfo.left, d = a.padInfo.top, p = this.bufferSync(t), f = this.bufferSync(r), m = 0; m < s; ++m) for (var g = Math.max(0, Math.ceil((d - m) / o)), v = Math.min(a.outHeight, (a.inHeight + d - m) / o), y = 0; y < u; ++y) for (var b = Math.max(0, Math.ceil((h - y) / i)), x = Math.min(a.outWidth, (a.inWidth + h - y) / i), C = 0; C < a.inChannels; ++C) for (var N = 0; N < a.outChannels; ++N) {
      for (var T = 0, I = 0; I < a.batchSize; ++I) for (var E = g; E < v; ++E) for (var P = m + E * o - d, O = b; O < x; ++O) {
        var R = y + O * i - h;
        T += l ? p.get(I, P, R, C) * f.get(I, E, O, N) : p.get(I, C, P, R) * f.get(I, N, E, O);
      }
      c.set(T, m, y, C, N);
    }
    return c.toTensor();
  }, n.prototype.conv3dDerFilter = function(t, r, a) {
    for (var o = a.strideDepth, i = a.strideHeight, s = a.strideWidth, u = a.filterDepth, l = a.filterHeight, c = a.filterWidth, h = oe(a.filterShape, "float32"), d = h.values, p = h.strides, f = p[0], m = p[1], g = p[2], v = p[3], y = this.readSync(r.dataId), b = r.strides, x = b[0], C = b[1], N = b[2], T = b[3], I = this.readSync(t.dataId), E = t.strides, P = E[0], O = E[1], R = E[2], z = E[3], j = a.padInfo.front, B = a.padInfo.left, H = a.padInfo.top, W = 0; W < u; ++W) for (var L = Math.max(0, Math.ceil((j - W) / o)), $ = Math.min(a.outDepth, (a.inDepth + j - W) / o), K = W * f, J = 0; J < l; ++J) for (var ee = Math.max(0, Math.ceil((H - J) / i)), ne = Math.min(a.outHeight, (a.inHeight + H - J) / i), ce = J * m + K, he = 0; he < c; ++he) for (var pe = Math.max(0, Math.ceil((B - he) / s)), ye = Math.min(a.outWidth, (a.inWidth + B - he) / s), me = he * g + ce, be = 0; be < a.inChannels; ++be) for (var We = be * v + me, ge = 0; ge < a.outChannels; ++ge) {
      for (var Ie = 0, Ce = 0; Ce < a.batchSize; ++Ce) for (var ze = Ce * P, Me = Ce * x, _e = L; _e < $; ++_e) for (var nn = (W + _e * o - j) * O + ze, rn = _e * C + Me, Ct = ee; Ct < ne; ++Ct) for (var _r = (J + Ct * i - H) * R + nn, gn = Ct * N + rn, zn = pe; zn < ye; ++zn) {
        var vn = zn * T + gn;
        Ie += I[(he + zn * s - B) * z + _r + be] * y[vn + ge];
      }
      d[We + ge] = Ie;
    }
    return h.toTensor();
  }, n.prototype.fusedDepthwiseConv2D = function(t) {
    var r = t.input, a = t.filter, o = t.convInfo, i = t.bias, s = t.activation, u = t.preluActivationWeights, l = this.depthwiseConv2D(r, a, o);
    return i && (l = this.add(l, i)), s && (l = Ji(this, l, s, u)), l;
  }, n.prototype.depthwiseConv2D = function(t, r, a) {
    G([t, r], "depthwiseConv2D");
    for (var o = a.filterHeight, i = a.filterWidth, s = a.dilationHeight, u = a.dilationWidth, l = a.padInfo.left, c = a.padInfo.top, h = a.outChannels / a.inChannels, d = oe(a.outShape, t.dtype), p = this.readSync(t.dataId), f = this.readSync(r.dataId), m = d.values, g = 0; g < a.batchSize; ++g) for (var v = g * t.strides[0], y = g * d.strides[0], b = 0; b < a.outHeight; ++b) for (var x = y + b * d.strides[1], C = b * a.strideHeight - l, N = 0; N < o; ++N) {
      var T = C + N * s;
      if (!(T < 0 || T >= a.inHeight)) for (var I = N * r.strides[0], E = v + T * t.strides[1], P = 0; P < a.outWidth; ++P) for (var O = x + P * d.strides[2], R = P * a.strideWidth - c, z = 0; z < i; ++z) {
        var j = R + z * u;
        if (!(j < 0 || j >= a.inWidth)) for (var B = I + z * r.strides[1], H = E + j * a.inChannels, W = O, L = B, $ = 0; $ < a.inChannels; ++$) {
          for (var K = p[H + $], J = 0; J < h; ++J) m[W + J] += K * f[L + J];
          W += h, L += h;
        }
      }
    }
    return d.toTensor();
  }, n.prototype.depthwiseConv2DDerInput = function(t, r, a) {
    G([t, r], "depthwiseConv2DDerInput");
    for (var o = oe(a.inShape, "float32"), i = o.values, s = o.strides, u = s[0], l = s[1], c = s[2], h = this.readSync(t.dataId), d = t.strides, p = d[0], f = d[1], m = d[2], g = this.readSync(r.dataId), v = r.strides, y = v[0], b = v[1], x = v[2], C = a.batchSize, N = a.filterHeight, T = a.filterWidth, I = a.inChannels, E = a.inHeight, P = a.inWidth, O = a.outChannels, R = a.outHeight, z = a.outWidth, j = a.strideHeight, B = a.strideWidth, H = N - 1 - a.padInfo.top, W = T - 1 - a.padInfo.left, L = O / I, $ = 0; $ < C; ++$) for (var K = 0; K < I; ++K) for (var J = 0; J < E; ++J) for (var ee = J - H, ne = Math.max(0, Math.ceil(ee / j)), ce = Math.min(R, (N + ee) / j), he = 0; he < P; ++he) {
      for (var pe = he - W, ye = Math.max(0, Math.ceil(pe / B)), me = Math.min(z, (T + pe) / B), be = 0, We = ne; We < ce; ++We) for (var ge = We * j - ee, Ie = ye; Ie < me; ++Ie) for (var Ce = p * $ + f * We + m * Ie, ze = y * (N - 1 - ge) + b * (T - 1 - (Ie * B - pe)) + x * K, Me = 0; Me < L; ++Me)
        be += h[Ce + (K * L + Me)] * g[ze + Me];
      i[u * $ + l * J + c * he + K] = be;
    }
    return o.toTensor();
  }, n.prototype.depthwiseConv2DDerFilter = function(t, r, a) {
    G([t, r], "depthwiseConv2DDerFilter");
    for (var o = a.strideHeight, i = a.strideWidth, s = a.filterHeight, u = a.filterWidth, l = oe(a.filterShape, "float32"), c = a.padInfo.left, h = a.padInfo.top, d = a.outChannels / a.inChannels, p = this.bufferSync(t), f = this.bufferSync(r), m = 0; m < s; ++m) for (var g = Math.max(0, Math.ceil((h - m) / o)), v = Math.min(a.outHeight, (a.inHeight + h - m) / o), y = 0; y < u; ++y) for (var b = Math.max(0, Math.ceil((c - y) / i)), x = Math.min(a.outWidth, (a.inWidth + c - y) / i), C = 0; C < a.outChannels; ++C) {
      for (var N = Math.trunc(C / d), T = C % d, I = 0, E = 0; E < a.batchSize; ++E) for (var P = g; P < v; ++P) for (var O = m + P * o - h, R = b; R < x; ++R) {
        var z = y + R * i - c;
        I += p.get(E, O, z, N) * f.get(E, P, R, C);
      }
      l.set(I, m, y, N, T);
    }
    return l.toTensor();
  }, n.prototype.tile = function(t, r) {
    return G(t, "tile"), Xp(this.bufferSync(t), r);
  }, n.prototype.pad = function(t, r, a) {
    G(t, "pad");
    var o = r.map(function(d, p) {
      return d[0] + t.shape[p] + d[1];
    }), i = r.map(function(d) {
      return d[0];
    }), s = this.bufferSync(t), u = oe(o, t.dtype);
    a !== 0 && u.values.fill(a);
    for (var l = 0; l < t.size; l++) {
      var c = s.indexToLoc(l), h = c.map(function(d, p) {
        return d + i[p];
      });
      u.set.apply(u, [s.get.apply(s, c)].concat(h));
    }
    return u.toTensor();
  }, n.prototype.gather = function(t, r, a) {
    G([t, r], "gather");
    var o = t.shape.slice(), i = this.readSync(r.dataId);
    o[a] = i.length;
    for (var s = oe(o, t.dtype), u = this.bufferSync(t), l = 0; l < s.size; ++l) {
      var c = s.indexToLoc(l), h = c.slice();
      h[a] = i[c[a]];
      var d = u.locToIndex(h);
      s.values[l] = u.values[d];
    }
    return s.toTensor();
  }, n.prototype.batchToSpaceND = function(t, r, a) {
    G([t], "batchToSpaceND");
    var o = r.reduce(function(h, d) {
      return h * d;
    }), i = Jo(t.shape, r, o), s = Xo(i.length, r.length), u = Qo(t.shape, r, o), l = tp(a, r.length), c = np(u, a, r.length);
    return Lt(t.reshape(i), s).reshape(u).slice(l, c);
  }, n.prototype.spaceToBatchND = function(t, r, a) {
    G([t], "spaceToBatchND");
    var o = r.reduce(function(d, p) {
      return d * p;
    }), i = [[0, 0]];
    i.push.apply(i, a);
    for (var s = 1 + r.length; s < t.shape.length; ++s) i.push([0, 0]);
    var u = t.pad(i), l = Jo(u.shape, r, o, !1), c = Xo(l.length, r.length, !1), h = Qo(u.shape, r, o, !1);
    return Lt(u.reshape(l), c).reshape(h);
  }, n.prototype.maxPool = function(t, r) {
    return G(t, "maxPool"), Ms(this.readSync(t.dataId), t.shape, t.dtype, t.strides, r, "max").toTensor();
  }, n.prototype.maxPoolBackprop = function(t, r, a, o) {
    G([r, a], "maxPoolBackprop");
    for (var i = this.readSync(r.dataId), s = oe(o.outShape, r.dtype, sm(i, r.shape, r.dtype, o).values), u = o.strideHeight, l = o.strideWidth, c = o.dilationHeight, h = o.dilationWidth, d = o.effectiveFilterHeight, p = o.effectiveFilterWidth, f = p - 1 - o.padInfo.left, m = d - 1 - o.padInfo.top, g = oe(r.shape, "float32"), v = this.bufferSync(t), y = 0; y < o.batchSize; ++y) for (var b = 0; b < o.inChannels; ++b) for (var x = 0; x < o.inHeight; ++x) for (var C = 0; C < o.inWidth; ++C) {
      for (var N = x - m, T = C - f, I = 0, E = 0; E < d; E += c) {
        var P = (N + E) / u;
        if (!(P < 0 || P >= o.outHeight || Math.floor(P) !== P)) for (var O = 0; O < p; O += h) {
          var R = (T + O) / l;
          if (!(R < 0 || R >= o.outWidth || Math.floor(R) !== R)) {
            var z = d * p - 1 - s.get(y, P, R, b) === E * p + O ? 1 : 0;
            z !== 0 && (I += v.get(y, P, R, b) * z);
          }
        }
      }
      g.set(I, y, x, C, b);
    }
    return g.toTensor();
  }, n.prototype.avgPoolBackprop = function(t, r, a) {
    G([t, r], "avgPoolBackprop");
    for (var o = a.strideHeight, i = a.strideWidth, s = a.filterHeight, u = a.filterWidth, l = a.dilationHeight, c = a.dilationWidth, h = a.effectiveFilterHeight, d = a.effectiveFilterWidth, p = d - 1 - a.padInfo.left, f = h - 1 - a.padInfo.top, m = oe(r.shape, "float32"), g = 1 / (s * u), v = this.bufferSync(t), y = 0; y < a.batchSize; ++y) for (var b = 0; b < a.inChannels; ++b) for (var x = 0; x < a.inHeight; ++x) for (var C = 0; C < a.inWidth; ++C) {
      for (var N = x - f, T = C - p, I = 0, E = 0; E < h; E += l) {
        var P = (N + E) / o;
        if (!(P < 0 || P >= a.outHeight || Math.floor(P) !== P)) for (var O = 0; O < d; O += c) {
          var R = (T + O) / i;
          R < 0 || R >= a.outWidth || Math.floor(R) !== R || (I += v.get(y, P, R, b));
        }
      }
      m.set(I * g, y, x, C, b);
    }
    return m.toTensor();
  }, n.prototype.pool3d = function(t, r, a) {
    G(t, "pool3d");
    for (var o = r.strideDepth, i = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, l = r.dilationHeight, c = r.dilationWidth, h = r.effectiveFilterDepth, d = r.effectiveFilterHeight, p = r.effectiveFilterWidth, f = r.padInfo.front, m = r.padInfo.top, g = r.padInfo.left, v = a === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, y = this.readSync(t.dataId), b = oe(r.outShape, t.dtype), x = b.values, C = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4], N = r.outShape[2] * r.outShape[3] * r.outShape[4], T = r.outShape[3] * r.outShape[4], I = r.outShape[4], E = 0; E < r.batchSize; ++E) for (var P = E * C, O = E * t.strides[0], R = 0; R < r.inChannels; ++R) for (var z = 0; z < r.outDepth; ++z) {
      for (var j = z * o - f, B = j; B < 0; ) B += u;
      for (var H = Math.min(r.inDepth, h + j), W = P + z * N, L = 0; L < r.outHeight; ++L) {
        for (var $ = L * i - m, K = $; K < 0; ) K += l;
        for (var J = Math.min(r.inHeight, d + $), ee = W + L * T, ne = 0; ne < r.outWidth; ++ne) {
          for (var ce = ne * s - g, he = ce; he < 0; ) he += c;
          for (var pe = Math.min(r.inWidth, p + ce), ye = ee + ne * I, me = v, be = 0, We = 0, ge = B; ge < H; ge += u) {
            for (var Ie = O + ge * t.strides[1], Ce = K; Ce < J; Ce += l) {
              for (var ze = Ie + Ce * t.strides[2], Me = he; Me < pe; Me += c) {
                var _e = y[ze + Me * t.strides[3] + R];
                if (a === "max" && _e > me ? me = _e : a === "avg" && (be += _e, We++), isNaN(me)) break;
              }
              if (isNaN(me)) break;
            }
            if (isNaN(me)) break;
          }
          x[ye + R] = a === "avg" ? be / We : me;
        }
      }
    }
    return b.toTensor();
  }, n.prototype.avgPool3d = function(t, r) {
    return G(t, "avgPool3d"), this.pool3d(t, r, "avg").toFloat();
  }, n.prototype.avgPool3dBackprop = function(t, r, a) {
    G([t, r], "avgPool3dBackprop");
    for (var o = a.strideDepth, i = a.strideHeight, s = a.strideWidth, u = a.filterDepth, l = a.filterHeight, c = a.filterWidth, h = a.dilationDepth, d = a.dilationHeight, p = a.dilationWidth, f = a.effectiveFilterDepth, m = a.effectiveFilterHeight, g = a.effectiveFilterWidth, v = f - 1 - a.padInfo.front, y = g - 1 - a.padInfo.left, b = m - 1 - a.padInfo.top, x = oe(r.shape, "float32"), C = 1 / (u * l * c), N = this.bufferSync(t), T = 0; T < a.batchSize; ++T) for (var I = 0; I < a.inChannels; ++I) for (var E = 0; E < a.inDepth; ++E) for (var P = 0; P < a.inHeight; ++P) for (var O = 0; O < a.inWidth; ++O) {
      for (var R = E - v, z = P - b, j = O - y, B = 0, H = 0; H < f; H += h) {
        var W = (R + H) / o;
        if (!(W < 0 || W >= a.outDepth || Math.floor(W) !== W)) for (var L = 0; L < m; L += d) {
          var $ = (z + L) / i;
          if (!($ < 0 || $ >= a.outHeight || Math.floor($) !== $)) for (var K = 0; K < g; K += p) {
            var J = (j + K) / s;
            J < 0 || J >= a.outWidth || Math.floor(J) !== J || (B += N.get(T, W, $, J, I));
          }
        }
      }
      x.set(B * C, T, E, P, O, I);
    }
    return x.toTensor();
  }, n.prototype.maxPool3d = function(t, r) {
    return G(t, "maxPool3d"), this.pool3d(t, r, "max").toFloat();
  }, n.prototype.maxPool3dPositions = function(t, r) {
    for (var a = oe(r.outShape, "int32"), o = r.strideDepth, i = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, l = r.dilationHeight, c = r.dilationWidth, h = r.effectiveFilterDepth, d = r.effectiveFilterHeight, p = r.effectiveFilterWidth, f = r.padInfo.front, m = r.padInfo.top, g = r.padInfo.left, v = this.bufferSync(t), y = 0; y < r.batchSize; ++y) for (var b = 0; b < r.inChannels; ++b) for (var x = 0; x < r.outDepth; ++x) {
      for (var C = x * o - f, N = C; N < 0; ) N += u;
      for (var T = Math.min(r.inDepth, h + C), I = 0; I < r.outHeight; ++I) {
        for (var E = I * i - m, P = E; P < 0; ) P += l;
        for (var O = Math.min(r.inHeight, d + E), R = 0; R < r.outWidth; ++R) {
          for (var z = R * s - g, j = z; j < 0; ) j += c;
          for (var B = Math.min(r.inWidth, p + z), H = Number.NEGATIVE_INFINITY, W = -1, L = N; L < T; L += u) for (var $ = L - C, K = P; K < O; K += l) for (var J = K - E, ee = j; ee < B; ee += c) {
            var ne = ee - z, ce = v.get(y, L, K, ee, b);
            ce >= H && (H = ce, W = $ * d * p + J * d + ne);
          }
          a.set(W, y, x, I, R, b);
        }
      }
    }
    return a.toTensor();
  }, n.prototype.maxPool3dBackprop = function(t, r, a, o) {
    G([r, a], "maxPool3dBackprop");
    for (var i = this.maxPool3dPositions(r, o), s = o.strideDepth, u = o.strideHeight, l = o.strideWidth, c = o.dilationDepth, h = o.dilationHeight, d = o.dilationWidth, p = o.effectiveFilterDepth, f = o.effectiveFilterHeight, m = o.effectiveFilterWidth, g = p - 1 - o.padInfo.front, v = m - 1 - o.padInfo.left, y = f - 1 - o.padInfo.top, b = oe(r.shape, "float32"), x = this.bufferSync(i), C = this.bufferSync(t), N = 0; N < o.batchSize; ++N) for (var T = 0; T < o.inChannels; ++T) for (var I = 0; I < o.inDepth; ++I) for (var E = 0; E < o.inHeight; ++E) for (var P = 0; P < o.inWidth; ++P) {
      for (var O = I - g, R = E - y, z = P - v, j = 0, B = 0; B < p; B += c) {
        var H = (O + B) / s;
        if (!(H < 0 || H >= o.outDepth || Math.floor(H) !== H)) for (var W = 0; W < f; W += h) {
          var L = (R + W) / u;
          if (!(L < 0 || L >= o.outHeight || Math.floor(L) !== L)) for (var $ = 0; $ < m; $ += d) {
            var K = (z + $) / l;
            if (!(K < 0 || K >= o.outWidth || Math.floor(K) !== K)) {
              var J = p * f * m - 1 - x.get(N, H, L, K, T) === B * f * m + W * m + $ ? 1 : 0;
              J !== 0 && (j += C.get(N, H, L, K, T) * J);
            }
          }
        }
      }
      b.set(j, N, I, E, P, T);
    }
    return b.toTensor();
  }, n.prototype.cast = function(t, r) {
    return Up(t, r, this);
  }, n.prototype.reshape = function(t, r) {
    return Rs(t, r);
  }, n.prototype.avgPool = function(t, r) {
    return G(t, "avgPool"), G(t, "maxPool"), Ms(this.readSync(t.dataId), t.shape, t.dtype, t.strides, r, "avg").toTensor().toFloat();
  }, n.prototype.resizeBilinear = function(t, r, a, o) {
    G(t, "resizeBilinear");
    for (var i = t.shape, s = i[0], u = i[1], l = i[2], c = i[3], h = this.readSync(t.dataId), d = new Float32Array(Q([s, r, a, c])), p = [o && r > 1 ? u - 1 : u, o && a > 1 ? l - 1 : l], f = [o && r > 1 ? r - 1 : r, o && a > 1 ? a - 1 : a], m = 0, g = p[0] / f[0], v = p[1] / f[1], y = 0; y < s; y++) for (var b = 0; b < r; b++) for (var x = g * b, C = Math.floor(x), N = x - C, T = Math.min(u - 1, Math.ceil(x)), I = y * t.strides[0] + C * t.strides[1], E = y * t.strides[0] + T * t.strides[1], P = 0; P < a; P++) for (var O = v * P, R = Math.floor(O), z = O - R, j = Math.min(l - 1, Math.ceil(O)), B = I + R * t.strides[2], H = E + R * t.strides[2], W = I + j * t.strides[2], L = E + j * t.strides[2], $ = 0; $ < c; $++) {
      var K = h[B + $], J = h[H + $], ee = K + (h[W + $] - K) * z, ne = ee + (J + (h[L + $] - J) * z - ee) * N;
      d[m++] = ne;
    }
    return rt(d, [s, r, a, c]);
  }, n.prototype.resizeBilinearBackprop = function(t, r, a) {
    G([t, r], "resizeBilinearBackprop");
    for (var o = r.shape, i = o[0], s = o[1], u = o[2], l = o[3], c = t.shape, h = c[1], d = c[2], p = new Float32Array(i * s * u * l), f = [a && h > 1 ? s - 1 : s, a && d > 1 ? u - 1 : u], m = [a && h > 1 ? h - 1 : h, a && d > 1 ? d - 1 : d], g = f[0] / m[0], v = f[1] / m[1], y = this.readSync(t.dataId), b = 0, x = 0; x < i; x++) for (var C = x * r.strides[0], N = 0; N < h; N++) for (var T = N * g, I = Math.floor(T), E = Math.min(Math.ceil(T), s - 1), P = C + I * r.strides[1], O = C + E * r.strides[1], R = T - I, z = 1 - R, j = 0; j < d; j++) for (var B = j * v, H = Math.floor(B), W = Math.min(Math.ceil(B), u - 1), L = B - H, $ = 1 - L, K = P + H * r.strides[2], J = P + W * r.strides[2], ee = O + H * r.strides[2], ne = O + W * r.strides[2], ce = z * $, he = z * L, pe = R * $, ye = R * L, me = 0; me < l; me++) {
      var be = y[b++];
      p[K + me] += be * ce, p[J + me] += be * he, p[ee + me] += be * pe, p[ne + me] += be * ye;
    }
    return pr(p, [i, u, s, l], r.dtype);
  }, n.prototype.resizeNearestNeighbor = function(t, r, a, o) {
    G(t, "resizeNearestNeighbor");
    for (var i = t.shape, s = i[0], u = i[1], l = i[2], c = i[3], h = this.readSync(t.dataId), d = new Float32Array(s * r * a * c), p = [o && r > 1 ? u - 1 : u, o && a > 1 ? l - 1 : l], f = [o && r > 1 ? r - 1 : r, o && a > 1 ? a - 1 : a], m = p[0] / f[0], g = p[1] / f[1], v = 0, y = 0; y < s; y++) for (var b = y * t.strides[0], x = 0; x < r; x++) for (var C = m * x, N = b + Math.min(u - 1, o ? Math.round(C) : Math.floor(C)) * t.strides[1], T = 0; T < a; T++) for (var I = g * T, E = N + Math.min(l - 1, o ? Math.round(I) : Math.floor(I)) * t.strides[2], P = 0; P < c; P++) {
      var O = h[E + P];
      d[v++] = O;
    }
    return rt(d, [s, r, a, c], t.dtype);
  }, n.prototype.resizeNearestNeighborBackprop = function(t, r, a) {
    G([t, r], "resizeNearestNeighborBackprop");
    for (var o = r.shape, i = o[0], s = o[1], u = o[2], l = o[3], c = t.shape, h = c[1], d = c[2], p = new Float32Array(i * s * u * l), f = this.readSync(t.dataId), m = [a && h > 1 ? s - 1 : s, a && d > 1 ? u - 1 : u], g = [a && h > 1 ? h - 1 : h, a && d > 1 ? d - 1 : d], v = m[0] / g[0], y = m[1] / g[1], b = 1 / v, x = 1 / y, C = 2 * Math.ceil(b) + 2, N = 2 * Math.ceil(x) + 2, T = 0; T < i; T++) for (var I = T * r.strides[0], E = 0; E < s; E++) for (var P = I + E * r.strides[1], O = Math.floor(E * b), R = Math.floor(O - C / 2), z = 0; z < u; z++) for (var j = P + z * r.strides[2], B = Math.floor(z * x), H = Math.floor(B - N / 2), W = 0; W < l; W++) {
      for (var L = 0, $ = 0; $ < C; $++) {
        var K = $ + R;
        if (!(K < 0 || K >= h)) {
          var J = I + K * t.strides[1], ee = K * v;
          if (E === Math.min(s - 1, a ? Math.round(ee) : Math.floor(ee))) for (var ne = 0; ne < N; ne++) {
            var ce = ne + H;
            if (!(ce < 0 || ce >= d)) {
              var he = J + ce * t.strides[2], pe = ce * y;
              z === Math.min(u - 1, a ? Math.round(pe) : Math.floor(pe)) && (L += f[he + W]);
            }
          }
        }
      }
      p[j + W] = L;
    }
    return pr(p, r.shape, r.dtype);
  }, n.prototype.batchNormalization = function(t, r, a, o, i, s) {
    G([t, r, a, i, s], "batchNorm");
    for (var u = this.readSync(t.dataId), l = this.readSync(r.dataId), c = this.readSync(a.dataId), h = i ? this.readSync(i.dataId) : new Float32Array([1]), d = s ? this.readSync(s.dataId) : new Float32Array([0]), p = new Float32Array(u.length), f = d.length, m = h.length, g = c.length, v = l.length, y = 0, b = 0, x = 0, C = 0, N = 0; N < u.length; ++N) p[N] = d[y++] + (u[N] - l[b++]) * h[x++] / Math.sqrt(c[C++] + o), y >= f && (y = 0), b >= v && (b = 0), x >= m && (x = 0), C >= g && (C = 0);
    return pr(p, t.shape);
  }, n.prototype.localResponseNormalization4D = function(t, r, a, o, i) {
    G(t, "localResponseNormalization4D");
    var s = t.shape[3], u = s - 1, l = this.readSync(t.dataId), c = t.size, h = new Float32Array(c);
    function d(g) {
      for (var v = g % s, y = g - v + Math.max(0, v - r), b = g - v + Math.min(v + r, u), x = 0; y <= b; y++) {
        var C = l[y];
        x += C * C;
      }
      return x;
    }
    for (var p = 0; p < c; p++) {
      var f = d(p), m = l[p] * Math.pow(a + o * f, -i);
      h[p] = m;
    }
    return pr(h, t.shape);
  }, n.prototype.LRNGrad = function(t, r, a, o, i, s, u) {
    G(t, "LRNGrad");
    for (var l = t.shape[3], c = this.readSync(t.dataId), h = this.readSync(r.dataId), d = this.readSync(a.dataId), p = new Float32Array(t.size), f = t.size, m = 0; m < f; m++) {
      for (var g = m % l, v = m - g + Math.max(0, g - o), y = m - g + Math.min(l, g + o + 1), b = 0, x = v; x < y; x++) b += Math.pow(h[x], 2);
      for (b = s * b + i, x = v; x < y; x++) {
        var C = -2 * s * u * h[x] * d[m] / b;
        m === x && (C += Math.pow(b, -u)), C *= c[m], p[x] += C;
      }
    }
    return pr(p, t.shape);
  }, n.prototype.multinomial = function(t, r, a, o) {
    G(t, "multinomial");
    for (var i = r ? t : vi(t), s = i.shape[0], u = i.shape[1], l = je([s, a], "int32"), c = this.readSync(l.dataId), h = this.readSync(i.dataId), d = 0; d < s; ++d) {
      var p = d * u, f = new Float32Array(u - 1);
      f[0] = h[p];
      for (var m = 1; m < f.length; ++m) f[m] = f[m - 1] + h[p + m];
      for (var g = yi(o.toString()), v = d * a, y = 0; y < a; ++y) {
        var b = g();
        c[v + y] = f.length;
        for (var x = 0; x < f.length; x++) if (b < f[x]) {
          c[v + y] = x;
          break;
        }
      }
    }
    return l;
  }, n.prototype.oneHot = function(t, r, a, o) {
    G(t, "oneHot");
    var i = new Float32Array(t.size * r);
    i.fill(o);
    for (var s = this.readSync(t.dataId), u = 0; u < t.size; ++u) s[u] >= 0 && s[u] < r && (i[u * r + s[u]] = a);
    return Cr(i, [t.size, r], "int32");
  }, n.prototype.nonMaxSuppression = function(t, r, a, o, i) {
    return G(t, "nonMaxSuppression"), ju(this.readSync(t.dataId), this.readSync(r.dataId), a, o, i);
  }, n.prototype.fft = function(t) {
    return this.fftBatch(t, !1);
  }, n.prototype.ifft = function(t) {
    return this.fftBatch(t, !0);
  }, n.prototype.fftBatch = function(t, r) {
    for (var a = t.shape[0], o = t.shape[1], i = oe(t.shape, "float32"), s = oe(t.shape, "float32"), u = Dt(t).as2D(a, o), l = Xt(t).as2D(a, o), c = 0; c < a; c++) for (var h = u.slice([c, 0], [1, o]), d = l.slice([c, 0], [1, o]), p = nt(h, d), f = this.readSync(this.fftImpl(p, r).dataId), m = 0; m < o; m++) {
      var g = Ll(f, m);
      i.values[c * o + m] = g.real, s.values[c * o + m] = g.imag;
    }
    return nt(i.toTensor(), s.toTensor()).as2D(a, o);
  }, n.prototype.fftImpl = function(t, r) {
    var a = t.as1D(), o = a.size;
    if (this.isExponentOf2(o)) {
      var i = this.fftRadix2(a, o, r).as2D(t.shape[0], t.shape[1]);
      return r && (i = nt(Dt(i).div(X(o)), Xt(i).div(X(o)))), i;
    }
    var s = this.readSync(t.dataId), u = function(l) {
      for (var c = new Float32Array(l.length / 2), h = new Float32Array(l.length / 2), d = 0; d < l.length; d += 2) c[d / 2] = l[d], h[d / 2] = l[d + 1];
      return { real: c, imag: h };
    }(this.fourierTransformByMatmul(s, o, r));
    return nt(u.real, u.imag).as2D(t.shape[0], t.shape[1]);
  }, n.prototype.isExponentOf2 = function(t) {
    return (t & t - 1) == 0;
  }, n.prototype.fftRadix2 = function(t, r, a) {
    if (r === 1) return t;
    var o = this.readSync(t.dataId), i = r / 2, s = function(v) {
      for (var y = Math.ceil(v.length / 4), b = new Float32Array(y), x = new Float32Array(y), C = 0; C < v.length; C += 4) b[Math.floor(C / 4)] = v[C], x[Math.floor(C / 4)] = v[C + 1];
      return { real: b, imag: x };
    }(o), u = nt(s.real, s.imag).as1D(), l = function(v) {
      for (var y = Math.floor(v.length / 4), b = new Float32Array(y), x = new Float32Array(y), C = 2; C < v.length; C += 4) b[Math.floor(C / 4)] = v[C], x[Math.floor(C / 4)] = v[C + 1];
      return { real: b, imag: x };
    }(o), c = nt(l.real, l.imag).as1D();
    u = this.fftRadix2(u, i, a), c = this.fftRadix2(c, i, a);
    var h = function(v, y) {
      for (var b = new Float32Array(v / 2), x = new Float32Array(v / 2), C = 0; C < Math.ceil(v / 2); C++) {
        var N = (y ? 2 : -2) * Math.PI * (C / v);
        b[C] = Math.cos(N), x[C] = Math.sin(N);
      }
      return { real: b, imag: x };
    }(r, a), d = nt(h.real, h.imag).mul(c), p = u.add(d), f = u.sub(d), m = Dt(p).concat(Dt(f)), g = Xt(p).concat(Xt(f));
    return nt(m, g).as1D();
  }, n.prototype.fourierTransformByMatmul = function(t, r, a) {
    for (var o = new Float32Array(2 * r), i = 0; i < r; i++) {
      for (var s = 0, u = 0, l = 0; l < r; l++) {
        var c = zv(i * l, r, a), h = Ll(t, l);
        s += h.real * c.real - h.imag * c.imag, u += h.real * c.imag + h.imag * c.real;
      }
      a && (s /= r, u /= r), Lv(o, s, u, i);
    }
    return o;
  }, n.prototype.depthToSpace = function(t, r, a) {
    A(a === "NHWC", function() {
      return "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + a;
    }), A(r > 1, function() {
      return "blockSize should be > 1 for depthToSpace, but was: " + r;
    });
    for (var o = t.shape[0], i = t.shape[1], s = t.shape[2], u = t.shape[3], l = i * r, c = s * r, h = u / (r * r), d = this.readSync(t.dataId), p = new Float32Array(o * l * c * h), f = 0, m = 0; m < o; ++m) for (var g = 0; g < l; ++g) for (var v = Math.floor(g / r), y = g % r, b = 0; b < c; ++b) for (var x = Math.floor(b / r), C = (y * r + b % r) * h, N = 0; N < h; ++N) {
      var T = N + C + u * (x + s * (v + i * m));
      p[f++] = d[T];
    }
    return pr(p, [o, l, c, h]);
  }, n.prototype.broadcastedBinaryOp = function(t, r, a, o) {
    var i = fe(t.shape, r.shape), s = oe(i, a), u = this.readSync(t.dataId), l = this.readSync(r.dataId), c = Kn(t.shape, i), h = Kn(r.shape, i), d = s.values;
    if (c.length + h.length === 0) for (var p = 0; p < d.length; ++p) d[p] = o(u[p % u.length], l[p % l.length]);
    else {
      var f = this.bufferSync(t), m = this.bufferSync(r), g = function(v) {
        var y = s.indexToLoc(v), b = y.slice(-t.rank);
        c.forEach(function(T) {
          return b[T] = 0;
        });
        var x = f.locToIndex(b), C = y.slice(-r.rank);
        h.forEach(function(T) {
          return C[T] = 0;
        });
        var N = m.locToIndex(C);
        d[v] = o(u[x], l[N]);
      };
      for (p = 0; p < d.length; ++p) g(p);
    }
    return s.toTensor();
  }, n.prototype.broadcastedBinaryComplexOp = function(t, r, a) {
    var o = fe(t.shape, r.shape), i = oe(o, "float32"), s = oe(o, "float32"), u = this.readSync(t.dataId), l = this.readSync(r.dataId), c = Kn(t.shape, o), h = Kn(r.shape, o), d = i.values, p = s.values;
    if (c.length + h.length === 0) for (var f = 0; f < d.length; f++) {
      var m = f % u.length, g = f % l.length, v = a(u[2 * m], u[2 * m + 1], l[2 * g], l[2 * g + 1]);
      d[f] = v.real, p[f] = v.imag;
    }
    else {
      var y = this.bufferSync(this.data.get(t.dataId).complexTensors.real), b = this.bufferSync(this.data.get(r.dataId).complexTensors.real), x = function(C) {
        var N = i.indexToLoc(C), T = N.slice(-t.rank);
        c.forEach(function(R) {
          return T[R] = 0;
        });
        var I = y.locToIndex(T), E = N.slice(-r.rank);
        h.forEach(function(R) {
          return E[R] = 0;
        });
        var P = b.locToIndex(E), O = a(u[2 * I], u[2 * I + 1], l[2 * P], l[2 * P + 1]);
        d[C] = O.real, p[C] = O.imag;
      };
      for (f = 0; f < d.length; f++) x(f);
    }
    return this.complex(i.toTensor(), s.toTensor());
  }, n.prototype.split = function(t, r, a) {
    return Jp(t, r, a);
  }, n.prototype.dispose = function() {
  }, n.prototype.floatPrecision = function() {
    return 32;
  }, n.prototype.epsilon = function() {
    return 1e-7;
  }, n.prototype.cropAndResize = function(t, r, a, o, i, s) {
    for (var u = t.shape, l = u[0], c = u[1], h = u[2], d = u[3], p = r.shape[0], f = o[0], m = o[1], g = oe([p, f, m, d], "float32"), v = this.readSync(r.dataId), y = this.readSync(a.dataId), b = this.readSync(t.dataId), x = t.strides, C = g.strides, N = 0; N < p; N++) {
      var T = 4 * N, I = v[T], E = v[T + 1], P = v[T + 2], O = v[T + 3], R = y[N];
      if (!(R >= l)) for (var z = f > 1 ? (P - I) * (c - 1) / (f - 1) : 0, j = m > 1 ? (O - E) * (h - 1) / (m - 1) : 0, B = 0; B < f; B++) {
        var H = f > 1 ? I * (c - 1) + B * z : 0.5 * (I + P) * (c - 1);
        if (H < 0 || H > c - 1) for (var W = 0; W < m; W++) for (var L = 0; L < d; L++) {
          var $ = L + W * C[2] + B * C[1] + N * C[0];
          g.values[$] = s;
        }
        else if (i === "bilinear") {
          var K = Math.floor(H), J = Math.ceil(H), ee = H - K;
          for (W = 0; W < m; W++)
            if ((ge = m > 1 ? E * (h - 1) + W * j : 0.5 * (E + O) * (h - 1)) < 0 || ge > h - 1) for (L = 0; L < d; L++)
              $ = L + W * C[2] + B * C[1] + N * C[0], g.values[$] = s;
            else {
              var ne = Math.floor(ge), ce = Math.ceil(ge), he = ge - ne;
              for (L = 0; L < d; L++) {
                var pe = b[$ = L + ne * x[2] + K * x[1] + R * x[0]], ye = b[$ = L + ce * x[2] + K * x[1] + R * x[0]], me = b[$ = L + ne * x[2] + J * x[1] + R * x[0]], be = pe + (ye - pe) * he, We = me + (b[$ = L + ce * x[2] + J * x[1] + R * x[0]] - me) * he;
                $ = L + W * C[2] + B * C[1] + N * C[0], g.values[$] = be + (We - be) * ee;
              }
            }
        } else for (W = 0; W < m; ++W) {
          var ge;
          if ((ge = m > 1 ? E * (h - 1) + W * j : 0.5 * (E + O) * (h - 1)) < 0 || ge > h - 1) for (L = 0; L < d; L++)
            $ = L + W * C[2] + B * C[1] + N * C[0], g.values[$] = s;
          else {
            var Ie = Math.round(ge), Ce = Math.round(H);
            for (L = 0; L < d; L++) {
              var ze = L + Ie * x[2] + Ce * x[1] + R * x[0], Me = L + W * C[2] + B * C[1] + N * C[0];
              g.values[Me] = b[ze];
            }
          }
        }
      }
    }
    return g.toTensor();
  }, n.prototype.sparseToDense = function(t, r, a, o) {
    var i = Yo(0, t, a), s = i.sliceRank, u = i.numUpdates, l = i.sliceSize, c = i.strides, h = i.outputSize;
    return this.scatter(t, r, a, h, l, u, s, c, o, !1);
  }, n.prototype.gatherND = function(t, r) {
    var a = r.shape, o = a[a.length - 1], i = jp(t, r), s = i[0], u = i[1], l = i[2], c = i[3];
    if (u === 0) return rt([], s, t.dtype);
    for (var h = new Ba([u, l], t.dtype), d = this.readSync(r.dataId), p = this.readSync(t.dataId), f = 0; f < u; f++) {
      for (var m = [], g = 0, v = 0; v < o; v++) {
        var y = d[f * o + v];
        g += y * c[v], m.push(y);
      }
      if (g < 0 || g >= t.size / l) throw new Error("Invalid indices: " + m + " does not index into " + t.shape);
      for (var b = 0; b < l; b++) h.values[f * l + b] = p[g * l + b];
    }
    return h.toTensor().reshape(s);
  }, n.prototype.scatterND = function(t, r, a) {
    var o = Yo(0, t, a), i = o.sliceRank, s = o.numUpdates, u = o.sliceSize, l = o.strides, c = o.outputSize, h = X(0);
    return this.scatter(t, r, a, c, u, s, i, l, h, !0);
  }, n.prototype.fill = function(t, r, a) {
    var o = Ma(a = a || da(r), Q(t));
    return o.fill(r), D.makeTensor(o, t, a, this);
  }, n.prototype.onesLike = function(t) {
    if (t.dtype === "string") throw new Error("onesLike is not supported for string tensors");
    return this.fill(t.shape, 1, t.dtype);
  }, n.prototype.zerosLike = function(t) {
    var r = Ma(t.dtype, Q(t.shape));
    return this.makeOutput(r, t.shape, t.dtype);
  }, n.prototype.linspace = function(t, r, a) {
    return Kp(t, r, a);
  }, n.prototype.scatter = function(t, r, a, o, i, s, u, l, c, h) {
    var d = [o / i, i], p = this.readSync(t.dataId), f = this.readSync(r.dataId);
    if (o === 0) return rt([], a, r.dtype);
    var m = new Ba(d, r.dtype);
    m.values.fill(this.readSync(c.dataId)[0]);
    for (var g = 0; g < s; g++) {
      for (var v = [], y = 0, b = 0; b < u; b++) {
        var x = p[g * u + b];
        v.push(x), y += x * l[b];
      }
      if (y < 0 || y >= o / i) throw new Error("Invalid indices: " + v + " does not index into " + a);
      for (var C = 0; C < i; C++) h ? m.values[y * i + C] += f[g * i + C] : m.values[y * i + C] = r.rank === 0 ? f[0] : f[g * i + C];
    }
    return m.toTensor().reshape(a);
  }, n;
}(Wp);
function um(e, n) {
  return { kernelName: e, backendName: "cpu", kernelFunc: function(t) {
    var r = t.inputs, a = t.backend, o = r, i = o.a, s = o.b, u = a;
    G([i, s], e);
    var l = u.data.get(i.dataId).values, c = u.data.get(s.dataId).values, h = n(i.shape, s.shape, l, c, i.dtype), d = h[0], p = h[1];
    return { dataId: u.write(d, p, i.dtype), shape: p, dtype: i.dtype };
  } };
}
function lm(e) {
  return function(n, t, r, a, o) {
    var i = fe(n, t), s = i.length, u = bt(i), l = Ar(o, Q(i)), c = n.length, h = t.length, d = bt(n), p = bt(t), f = Kn(n, i), m = Kn(t, i);
    if (f.length + m.length === 0) for (var g = 0; g < l.length; ++g) l[g] = e(r[g % r.length], a[g % a.length]);
    else {
      var v = function(y) {
        var b = Iu(y, s, u), x = b.slice(-c);
        f.forEach(function(I) {
          return x[I] = 0;
        });
        var C = Ho(x, c, d), N = b.slice(-h);
        m.forEach(function(I) {
          return N[I] = 0;
        });
        var T = Ho(N, h, p);
        l[y] = e(r[C], a[T]);
      };
      for (g = 0; g < l.length; ++g) v(g);
    }
    return [l, i];
  };
}
D.registerBackend("cpu", function() {
  return new c1();
}, 1);
var h1 = lm(function(e, n) {
  return e / n;
}), d1 = um(di, h1), p1 = { kernelName: "MaxPoolWithArgmax", backendName: "cpu", kernelFunc: function(e) {
  var n = e.inputs, t = e.attrs, r = e.backend, a = n.x, o = t, i = o.filterSize, s = o.strides, u = o.pad, l = o.includeBatchInIndex, c = r;
  G(a, "MaxPoolWithArgmax");
  var h = c.data.get(a.dataId).values, d = Ir(a.shape, i, s, [1, 1], u), p = function(y, b, x, C, N) {
    var T = Ms(y, 0, x, bt(b), N, "max"), I = sm(y, b, x, N, !0, C);
    return [T.values, I.values];
  }(h, a.shape, a.dtype, l, d), f = p[0], m = p[1], g = c.write(f, d.outShape, a.dtype), v = c.write(m, d.outShape, a.dtype);
  return [{ dataId: g, shape: d.outShape, dtype: a.dtype }, { dataId: v, shape: d.outShape, dtype: "int32" }];
} }, f1 = { kernelName: "NonMaxSuppressionV5", backendName: "cpu", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = e.attrs, a = n, o = a.boxes, i = a.scores, s = r, u = s.maxOutputSize, l = s.iouThreshold, c = s.scoreThreshold, h = s.softNmsSigma, d = t;
  G(o, "NonMaxSuppressionWithScore");
  var p = Vu(d.data.get(o.dataId).values, d.data.get(i.dataId).values, u, l, c, h);
  return [p.selectedIndices, p.selectedScores];
} }, m1 = { kernelName: "Square", backendName: "cpu", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = n.x, a = t;
  G(r, "square");
  for (var o = a.data.get(r.dataId).values, i = new Float32Array(o.length), s = 0; s < o.length; ++s) {
    var u = o[s];
    i[s] = u * u;
  }
  return { dataId: a.write(i, r.shape, r.dtype), shape: r.shape, dtype: r.dtype };
} }, g1 = lm(function(e, n) {
  var t = e - n;
  return t * t;
});
function cm(e, n, t, r, a) {
  for (var o = Q(n), i = n.length, s = bt(n), u = bt(a), l = Ar(t, Q(a)), c = 0; c < o; ++c) {
    for (var h = Iu(c, i, s), d = new Array(h.length), p = 0; p < d.length; p++) d[p] = h[r[p]];
    l[Ho(d, i, u)] = e[c];
  }
  return l;
}
for (var Xi = 0, uc = [f1, m1, um(pi, g1), d1, { kernelName: "Transpose", backendName: "cpu", kernelFunc: function(e) {
  var n = e.inputs, t = e.attrs, r = e.backend, a = n.x, o = t.perm, i = r;
  G(a, "transpose");
  for (var s = a.shape.length, u = new Array(s), l = 0; l < u.length; l++) u[l] = a.shape[o[l]];
  var c = cm(i.data.get(a.dataId).values, a.shape, a.dtype, o, u);
  return { dataId: i.write(c, u, a.dtype), shape: u, dtype: a.dtype };
} }, p1]; Xi < uc.length; Xi++)
  Od(uc[Xi]);
var Lr, v1 = function(e) {
  this.variableNames = ["A"];
  var n = ht(), t = e[0], r = e[1];
  this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(` + r + ".0, " + t + `.0);

        vec4 values = ` + n.texture2D + `(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
}, y1 = function(e) {
  this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
  var n = ht(), t = e[0], r = e[1];
  this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(` + r + ".0, " + t + `.0);
            vec4 values = ` + n.texture2D + `(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ` + n.output + ` = result;
      }
    `;
}, b1 = function(e, n) {
  this.variableNames = ["A"];
  for (var t = new Array(e.length), r = 0; r < t.length; r++) t[r] = e[n[r]];
  this.outputShape = t, this.rank = t.length;
  var a = De(this.rank), o = function(i) {
    var s = i.length;
    if (s > 6) throw Error("Transpose for rank " + s + " is not yet supported");
    for (var u = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], l = new Array(s), c = 0; c < i.length; c++) l[i[c]] = u[c];
    return l.join();
  }(n);
  this.userCode = `
    void main() {
      ` + a + ` resRC = getOutputCoords();
      setOutput(getA(` + o + `));
    }
    `;
}, x1 = function(e, n) {
  this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
  for (var t = new Array(e.length), r = 0; r < t.length; r++) t[r] = e[n[r]];
  if (this.outputShape = t, this.rank = t.length, this.rank > 6) throw Error("Packed transpose for rank " + this.rank + " is not yet supported.");
  var a = De(this.rank), o = Yp("rc", this.rank), i = new Array(this.rank);
  for (r = 0; r < n.length; r++) i[n[r]] = o[r];
  var s = "vec2(" + i.slice(-2).join() + ")", u = "++" + o[this.rank - 1] + " < " + t[this.rank - 1], l = "getChannel(getA(" + i.join() + "), " + s + ")";
  this.userCode = `
    void main() {
      ` + a + ` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ` + l + `;
      if(` + u + `) {
        result[1] = ` + l + `;
      }
      --` + o[this.rank - 1] + `;
      if(++` + o[this.rank - 2] + " < " + t[this.rank - 2] + `) {
        result[2] = ` + l + `;
        if(` + u + `) {
          result[3] = ` + l + `;
        }
      }
      setOutput(result);
    }
    `;
};
for (var Qi = 0, lc = [{ kernelName: "FromPixels", backendName: "webgl", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = e.attrs, a = n.pixels, o = r.numChannels, i = typeof HTMLVideoElement < "u" && a instanceof HTMLVideoElement, s = typeof HTMLImageElement < "u" && a instanceof HTMLImageElement, u = i ? [a.videoWidth, a.videoHeight] : [a.width, a.height], l = u[0], c = u[1], h = [c, l], d = [c, l, o];
  (s || i) && (Lr == null && (Lr = document.createElement("canvas").getContext("2d")), Lr.canvas.width = l, Lr.canvas.height = c, Lr.drawImage(a, 0, 0, l, c), a = Lr.canvas);
  var p = t.makeTensorInfo(h, "int32");
  t.texData.get(p.dataId).usage = Ot.PIXELS, t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId), a);
  var f = _().getBool("WEBGL_PACK") ? new y1(d) : new v1(d), m = t.runWebGLProgram(f, [p], "int32");
  return t.disposeData(p.dataId), m;
} }, { kernelName: di, backendName: "webgl", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = n;
  return function(a, o, i) {
    var s = new Ge(s0, a.shape, o.shape);
    return _().getBool("WEBGL_PACK_BINARY_OPERATIONS") && (s = new sn(u0, a.shape, o.shape, !0)), i.runWebGLProgram(s, [a, o], "float32");
  }(r.a, r.b, t);
} }, { kernelName: "NonMaxSuppressionV5", backendName: "webgl", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = e.attrs;
  Ko("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
  var a = n, o = a.boxes, i = a.scores, s = r, u = s.maxOutputSize, l = s.iouThreshold, c = s.scoreThreshold, h = s.softNmsSigma, d = t, p = Vu(d.readSync(o.dataId), d.readSync(i.dataId), u, l, c, h);
  return [p.selectedIndices, p.selectedScores];
} }, { kernelName: "Square", backendName: "webgl", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = n.x, a = t, o = new le(r.shape, "return x * x;");
  return a.runWebGLProgram(o, [r], r.dtype);
} }, { kernelName: pi, backendName: "webgl", kernelFunc: function(e) {
  var n = e.inputs, t = e.backend, r = n, a = r.a, o = r.b, i = t, s = _().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new sn("return (a - b) * (a - b);", a.shape, o.shape) : new Ge("return (a - b) * (a - b);", a.shape, o.shape);
  return i.compileAndRun(s, [a, o]);
} }, { kernelName: "Transpose", backendName: "webgl", kernelFunc: function(e) {
  for (var n, t = e.inputs, r = e.attrs, a = e.backend, o = t.x, i = r.perm, s = a, u = o.shape.length, l = new Array(u), c = 0; c < l.length; c++) l[c] = o.shape[i[c]];
  if (s.shouldExecuteOnCPU([o])) {
    var h = cm(s.texData.get(o.dataId).values, o.shape, o.dtype, i, l);
    n = s.makeTensorInfo(l, o.dtype), s.texData.get(n.dataId).values = h;
  } else n = function(d, p, f) {
    var m = _().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new x1(d.shape, p) : new b1(d.shape, p);
    return f.runWebGLProgram(m, [d], d.dtype);
  }(o, i, s);
  return n;
} }, { kernelName: "MaxPoolWithArgmax", backendName: "webgl", kernelFunc: function(e) {
  var n = e.inputs, t = e.attrs, r = e.backend, a = n.x, o = t, i = o.filterSize, s = o.strides, u = o.pad, l = o.includeBatchInIndex, c = r;
  A(a.shape.length === 4, function() {
    return "Error in maxPool: input must be rank 4 but got rank " + a.shape.length + ".";
  });
  var h = [1, 1];
  A(vt(s, h), function() {
    return "Error in maxPool: Either strides or dilations must be 1. Got strides " + s + " and dilations '" + h + "'";
  });
  var d = Ir(a.shape, i, s, h, u), p = function(f, m, g, v) {
    var y = new Oa(g, "max", !1), b = v.runWebGLProgram(y, [f], "float32");
    return y = new Oa(g, "max", !0, !0, m), [b, v.runWebGLProgram(y, [f], "float32")];
  }(a, l, d, c);
  return [p[0], p[1]];
} }]; Qi < lc.length; Qi++)
  Od(lc[Qi]);
for (var Yi = 0, cc = [{ kernelName: rp, inputsToSave: ["a", "b"], gradFunc: function(e, n) {
  var t = n[0], r = n[1], a = fe(t.shape, r.shape);
  return { a: function() {
    var o = e, i = Qe(t.shape, a);
    return i.length > 0 && (o = o.sum(i)), o.reshape(t.shape);
  }, b: function() {
    var o = e, i = Qe(r.shape, a);
    return i.length > 0 && (o = o.sum(i)), o.reshape(r.shape);
  } };
} }, { kernelName: "AddN", saveAllInputs: !0, gradFunc: function(e, n) {
  var t = {};
  return n.forEach(function(r, a) {
    t[a] = function() {
      return e.clone();
    };
  }), t;
} }, { kernelName: ap, gradFunc: function(e, n, t) {
  for (var r = t, a = r.inputShape, o = r.shape, i = Array.from(o), s = a.length - 1; s >= 0; s--) if (a[s] === o[s]) i[s] = 1;
  else if (a[s] !== 1) throw new Error("broadcastTo(): [" + a + "] cannot be broadcast to [" + o + "].");
  var u = [];
  for (s = 0; s < i.length; s++) i[s] > 1 && u.push(s);
  return { x: function() {
    return e.sum(u, !0);
  } };
} }, { kernelName: di, inputsToSave: ["a", "b"], gradFunc: function(e, n) {
  var t = n[0], r = n[1], a = fe(t.shape, r.shape);
  return { a: function() {
    var o = Bn(e, r.toFloat()), i = Qe(t.shape, a);
    return i.length > 0 ? Pn(o, i).reshape(t.shape) : o;
  }, b: function() {
    var o = e.mul(t.toFloat()), i = Qe(r.shape, a);
    i.length > 0 && (o = Pn(o, i).reshape(r.shape));
    var s = Ju(r);
    return fi(Bn(o, s.toFloat()));
  } };
} }, { kernelName: "FusedBatchNorm", inputsToSave: ["x", "mean", "variance", "scale"], gradFunc: function(e, n, t) {
  var r = t.varianceEpsilon, a = n[0], o = n[1], i = n[2], s = n[3], u = hf(a), l = s ?? X(1), c = Qe(o.shape, u.shape), h = [];
  if (o.rank === 1) {
    for (var d = 0; d < u.shape.length - 1; ++d) h.push(u.shape[d]);
    h.push(1);
  }
  var p = Rn(a, o), f = $e(e, l), m = Ru(_n(i, X(r))), g = $e($e($e(m, m), m), X(-0.5));
  return { x: function() {
    return o.rank === 1 ? un($e($e(e, kr(m.as4D(1, 1, 1, o.shape[0]), h)), l), a.shape) : un($e($e(e, m), l), a.shape);
  }, mean: function() {
    var v = $e($e(m, X(-1)), f);
    return o.rank === 1 && (v = Pn(v, c)), un(v, o.shape);
  }, variance: function() {
    var v = $e($e(g, p), f);
    return o.rank === 1 && (v = Pn(v, c)), un(v, o.shape);
  }, scale: function() {
    var v = $e(p, m), y = $e(e, v);
    return o.rank === 1 && (y = Pn(y, c)), un(y, o.shape);
  }, offset: function() {
    var v = e;
    return o.rank === 1 && (v = Pn(v, c)), un(v, o.shape);
  } };
} }, { kernelName: ip, gradFunc: function(e) {
  return { x: function() {
    return e.toFloat();
  } };
} }, { kernelName: op, inputsToSave: ["indices"], gradFunc: function(e, n) {
  var t = n[0];
  return { indices: function() {
    return je(t.shape, "float32");
  } };
} }, { kernelName: up, inputsToSave: ["x"], gradFunc: function(e, n, t) {
  var r = n[0], a = t.paddings.map(function(o) {
    return o[0];
  });
  return { x: function() {
    return e.slice(a, r.shape);
  } };
} }, { kernelName: "Square", inputsToSave: ["x"], gradFunc: function(e, n) {
  var t = n[0];
  return { x: function() {
    return e.mul(t.toFloat().mul(2));
  } };
} }, { kernelName: pi, inputsToSave: ["a", "b"], gradFunc: function(e, n) {
  var t = n[0], r = n[1], a = X(2);
  return { a: function() {
    return $e(e, $e(a, Rn(t, r)));
  }, b: function() {
    return $e(e, $e(a, Rn(r, t)));
  } };
} }, { kernelName: sp, inputsToSave: ["x"], gradFunc: function(e, n, t) {
  var r = n[0], a = t.reps;
  return { x: function() {
    var o = ve(r);
    if (r.rank === 1) for (var i = 0; i < a[0]; ++i) o = o.add(e.slice([i * r.shape[0]], [r.shape[0]]));
    else if (r.rank === 2) for (i = 0; i < a[0]; ++i) for (var s = 0; s < a[1]; ++s) o = o.add(e.slice([i * r.shape[0], s * r.shape[1]], [r.shape[0], r.shape[1]]));
    else if (r.rank === 3) for (i = 0; i < a[0]; ++i) for (s = 0; s < a[1]; ++s) for (var u = 0; u < a[2]; ++u) o = o.add(e.slice([i * r.shape[0], s * r.shape[1], u * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
    else {
      if (r.rank !== 4) throw new Error("Gradient for tile operation is not implemented for rank-" + r.rank + " tensors yet.");
      for (i = 0; i < a[0]; ++i) for (s = 0; s < a[1]; ++s) for (u = 0; u < a[2]; ++u) for (var l = 0; l < a[3]; ++l) o = o.add(e.slice([i * r.shape[0], s * r.shape[1], u * r.shape[2], l * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));
    }
    return o;
  } };
} }, { kernelName: "Transpose", gradFunc: function(e, n, t) {
  var r = Tu(t.perm);
  return { x: function() {
    return Lt(e, r);
  } };
} }]; Yi < cc.length; Yi++)
  Eg(cc[Yi]);
var w1 = function() {
  function e() {
  }
  return e.prototype.fetch = function(n, t) {
    return fetch(n, t);
  }, e.prototype.now = function() {
    return performance.now();
  }, e.prototype.encode = function(n, t) {
    if (t !== "utf-8" && t !== "utf8") throw new Error("Browser's encoder only supports utf-8, but got " + t);
    return this.textEncoder == null && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(n);
  }, e.prototype.decode = function(n, t) {
    return new TextDecoder(t).decode(n);
  }, e;
}();
_().get("IS_BROWSER") && _().setPlatform("browser", new w1());
var Zi, C1 = function() {
  return require("node-fetch");
}, k1 = function() {
  function e() {
    this.util = require("util"), this.textEncoder = new this.util.TextEncoder();
  }
  return e.prototype.fetch = function(n, t) {
    return _().global.fetch != null ? _().global.fetch(n, t) : (Zi == null && (Zi = C1()), Zi(n, t));
  }, e.prototype.now = function() {
    var n = process.hrtime();
    return 1e3 * n[0] + n[1] / 1e6;
  }, e.prototype.encode = function(n, t) {
    if (t !== "utf-8" && t !== "utf8") throw new Error("Node built-in encoder only supports utf-8, but got " + t);
    return this.textEncoder.encode(n);
  }, e.prototype.decode = function(n, t) {
    return n.length === 0 ? "" : new this.util.TextDecoder(t).decode(n);
  }, e;
}();
_().get("IS_NODE") && _().setPlatform("node", new k1());
var _s = { float32: 4, int32: 4, uint16: 2, uint8: 1, bool: 1 }, ri = 4;
function hm(e, n) {
  for (var t = {}, r = 0, a = function(s) {
    var u = s.name, l = s.dtype, c = s.shape, h = Q(c), d = void 0;
    if ("quantization" in s) {
      var p = s.quantization;
      if (p.dtype !== "uint8" && p.dtype !== "uint16") throw new Error("Weight " + s.name + " has unknown quantization dtype " + p.dtype + ". Supported quantization dtypes are: 'uint8' and 'uint16'.");
      var f = _s[p.dtype], m = e.slice(r, r + h * f), g = p.dtype === "uint8" ? new Uint8Array(m) : new Uint16Array(m);
      if (l === "float32") d = Float32Array.from(g, function(N) {
        return N * p.scale + p.min;
      });
      else {
        if (l !== "int32") throw new Error("Unsupported dtype in weight '" + u + "': " + l);
        d = Int32Array.from(g, function(N) {
          return Math.round(N * p.scale + p.min);
        });
      }
      r += h * f;
    } else if (l === "string") {
      var v = Q(s.shape);
      d = [];
      for (var y = 0; y < v; y++) {
        var b = new Uint32Array(e.slice(r, r + ri))[0];
        r += ri;
        var x = new Uint8Array(e.slice(r, r + b));
        d.push(x), r += b;
      }
    } else {
      var C = _s[l];
      if (m = e.slice(r, r + h * C), l === "float32") d = new Float32Array(m);
      else if (l === "int32") d = new Int32Array(m);
      else {
        if (l !== "bool") throw new Error("Unsupported dtype in weight '" + u + "': " + l);
        d = new Uint8Array(m);
      }
      r += h * C;
    }
    t[u] = rt(d, c, l);
  }, o = 0, i = n; o < i.length; o++)
    a(i[o]);
  return t;
}
function N1(e) {
  if (e === null) throw new Error("Invalid input value: " + JSON.stringify(e));
  var n = 0, t = [];
  e.forEach(function(o) {
    if (n += o.byteLength, t.push(o.byteLength === o.buffer.byteLength ? o : new o.constructor(o)), !(o instanceof Float32Array || o instanceof Int32Array || o instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + o.constructor.name);
  });
  var r = new Uint8Array(n), a = 0;
  return t.forEach(function(o) {
    r.set(new Uint8Array(o.buffer), a), a += o.byteLength;
  }), r.buffer;
}
var Bs = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");
function hc(e) {
  return Bs ? Buffer.byteLength(e) : new Blob([e]).size;
}
function pl(e) {
  var n = 0;
  e.forEach(function(a) {
    n += a.byteLength;
  });
  var t = new Uint8Array(n), r = 0;
  return e.forEach(function(a) {
    t.set(new Uint8Array(a), r), r += a.byteLength;
  }), t.buffer;
}
function dc(e) {
  for (e = e.trim(); e.endsWith("/"); ) e = e.slice(0, e.length - 1);
  var n = e.split("/");
  return n[n.length - 1];
}
function Qa(e) {
  if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return { dateSaved: /* @__PURE__ */ new Date(), modelTopologyType: "JSON", modelTopologyBytes: e.modelTopology == null ? 0 : hc(JSON.stringify(e.modelTopology)), weightSpecsBytes: e.weightSpecs == null ? 0 : hc(JSON.stringify(e.weightSpecs)), weightDataBytes: e.weightData == null ? 0 : e.weightData.byteLength };
}
var Rt = function() {
  function e() {
    this.saveRouters = [], this.loadRouters = [];
  }
  return e.getInstance = function() {
    return e.instance == null && (e.instance = new e()), e.instance;
  }, e.registerSaveRouter = function(n) {
    e.getInstance().saveRouters.push(n);
  }, e.registerLoadRouter = function(n) {
    e.getInstance().loadRouters.push(n);
  }, e.getSaveHandlers = function(n) {
    return e.getHandlers(n, "save");
  }, e.getLoadHandlers = function(n, t) {
    return e.getHandlers(n, "load", t);
  }, e.getHandlers = function(n, t, r) {
    var a = [];
    return (t === "load" ? e.getInstance().loadRouters : e.getInstance().saveRouters).forEach(function(o) {
      var i = o(n, r);
      i !== null && a.push(i);
    }), a;
  }, e;
}(), oa = "://", Qn = function() {
  function e() {
    this.managers = {};
  }
  return e.getInstance = function() {
    return e.instance == null && (e.instance = new e()), e.instance;
  }, e.registerManager = function(n, t) {
    A(n != null, function() {
      return "scheme must not be undefined or null.";
    }), n.endsWith(oa) && (n = n.slice(0, n.indexOf(oa))), A(n.length > 0, function() {
      return "scheme must not be an empty string.";
    });
    var r = e.getInstance();
    A(r.managers[n] == null, function() {
      return "A model store manager is already registered for scheme '" + n + "'.";
    }), r.managers[n] = t;
  }, e.getManager = function(n) {
    var t = this.getInstance().managers[n];
    if (t == null) throw new Error("Cannot find model manager for scheme '" + n + "'");
    return t;
  }, e.getSchemes = function() {
    return Object.keys(this.getInstance().managers);
  }, e;
}();
function Ro(e) {
  if (e.indexOf(oa) === -1) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + Qn.getSchemes().join(","));
  return { scheme: e.split(oa)[0], path: e.split(oa)[1] };
}
function pc(e, n, t) {
  return t === void 0 && (t = !1), Y(this, void 0, void 0, function() {
    var r, a, o, i, s, u, l, c, h;
    return Z(this, function(d) {
      switch (d.label) {
        case 0:
          return A(e !== n, function() {
            return "Old path and new path are the same: '" + e + "'";
          }), A((r = Rt.getLoadHandlers(e)).length > 0, function() {
            return "Copying failed because no load handler is found for source URL " + e + ".";
          }), A(r.length < 2, function() {
            return "Copying failed because more than one (" + r.length + ") load handlers for source URL " + e + ".";
          }), a = r[0], A((o = Rt.getSaveHandlers(n)).length > 0, function() {
            return "Copying failed because no save handler is found for destination URL " + n + ".";
          }), A(o.length < 2, function() {
            return "Copying failed because more than one (" + r.length + ") save handlers for destination URL " + n + ".";
          }), i = o[0], s = Ro(e).scheme, u = Ro(e).path, l = s === Ro(e).scheme, [4, a.load()];
        case 1:
          return c = d.sent(), t && l ? [4, Qn.getManager(s).removeModel(u)] : [3, 3];
        case 2:
          d.sent(), d.label = 3;
        case 3:
          return [4, i.save(c)];
        case 4:
          return h = d.sent(), !t || l ? [3, 6] : [4, Qn.getManager(s).removeModel(u)];
        case 5:
          d.sent(), d.label = 6;
        case 6:
          return [2, h.modelArtifactsInfo];
      }
    });
  });
}
var vr = "models_store", qn = "model_info_store";
function dm() {
  if (!_().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  var e = window || self, n = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
  if (n == null) throw new Error("The current browser does not appear to support IndexedDB.");
  return n;
}
function js(e) {
  var n = e.result;
  n.createObjectStore(vr, { keyPath: "modelPath" }), n.createObjectStore(qn, { keyPath: "modelPath" });
}
var ia = function() {
  function e(n) {
    if (this.indexedDB = dm(), n == null || !n) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this.modelPath = n;
  }
  return e.prototype.save = function(n) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        if (n.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return [2, this.databaseAction(this.modelPath, n)];
      });
    });
  }, e.prototype.load = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(n) {
        return [2, this.databaseAction(this.modelPath)];
      });
    });
  }, e.prototype.databaseAction = function(n, t) {
    var r = this;
    return new Promise(function(a, o) {
      var i = r.indexedDB.open("tensorflowjs", 1);
      i.onupgradeneeded = function() {
        return js(i);
      }, i.onsuccess = function() {
        var s = i.result;
        if (t == null) {
          var u = s.transaction(vr, "readonly"), l = u.objectStore(vr).get(r.modelPath);
          l.onsuccess = function() {
            if (l.result == null) return s.close(), o(new Error("Cannot find model with path '" + r.modelPath + "' in IndexedDB."));
            a(l.result.modelArtifacts);
          }, l.onerror = function(m) {
            return s.close(), o(l.error);
          }, u.oncomplete = function() {
            return s.close();
          };
        } else {
          var c, h = Qa(t), d = s.transaction(qn, "readwrite"), p = d.objectStore(qn), f = p.put({ modelPath: r.modelPath, modelArtifactsInfo: h });
          f.onsuccess = function() {
            var m = (c = s.transaction(vr, "readwrite")).objectStore(vr).put({ modelPath: r.modelPath, modelArtifacts: t, modelArtifactsInfo: h });
            m.onsuccess = function() {
              return a({ modelArtifactsInfo: h });
            }, m.onerror = function(g) {
              var v = (p = d.objectStore(qn)).delete(r.modelPath);
              v.onsuccess = function() {
                return s.close(), o(m.error);
              }, v.onerror = function(y) {
                return s.close(), o(m.error);
              };
            };
          }, f.onerror = function(m) {
            return s.close(), o(f.error);
          }, d.oncomplete = function() {
            c == null ? s.close() : c.oncomplete = function() {
              return s.close();
            };
          };
        }
      }, i.onerror = function(s) {
        return o(i.error);
      };
    });
  }, e.URL_SCHEME = "indexeddb://", e;
}(), fc = function(e) {
  return _().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(ia.URL_SCHEME) ? (n = e.slice(ia.URL_SCHEME.length), new ia(n)) : null;
  var n;
};
Rt.registerSaveRouter(fc), Rt.registerLoadRouter(fc);
var A1 = function() {
  function e() {
    this.indexedDB = dm();
  }
  return e.prototype.listModels = function() {
    return Y(this, void 0, void 0, function() {
      var n = this;
      return Z(this, function(t) {
        return [2, new Promise(function(r, a) {
          var o = n.indexedDB.open("tensorflowjs", 1);
          o.onupgradeneeded = function() {
            return js(o);
          }, o.onsuccess = function() {
            var i = o.result, s = i.transaction(qn, "readonly"), u = s.objectStore(qn).getAll();
            u.onsuccess = function() {
              for (var l = {}, c = 0, h = u.result; c < h.length; c++) {
                var d = h[c];
                l[d.modelPath] = d.modelArtifactsInfo;
              }
              r(l);
            }, u.onerror = function(l) {
              return i.close(), a(u.error);
            }, s.oncomplete = function() {
              return i.close();
            };
          }, o.onerror = function(i) {
            return a(o.error);
          };
        })];
      });
    });
  }, e.prototype.removeModel = function(n) {
    return Y(this, void 0, void 0, function() {
      var t = this;
      return Z(this, function(r) {
        var a;
        return n = (a = n).startsWith(ia.URL_SCHEME) ? a.slice(ia.URL_SCHEME.length) : a, [2, new Promise(function(o, i) {
          var s = t.indexedDB.open("tensorflowjs", 1);
          s.onupgradeneeded = function() {
            return js(s);
          }, s.onsuccess = function() {
            var u, l = s.result, c = l.transaction(qn, "readwrite"), h = c.objectStore(qn), d = h.get(n);
            d.onsuccess = function() {
              if (d.result == null) return l.close(), i(new Error("Cannot find model with path '" + n + "' in IndexedDB."));
              var p = h.delete(n), f = function() {
                var m = (u = l.transaction(vr, "readwrite")).objectStore(vr).delete(n);
                m.onsuccess = function() {
                  return o(d.result.modelArtifactsInfo);
                }, m.onerror = function(g) {
                  return i(d.error);
                };
              };
              p.onsuccess = f, p.onerror = function(m) {
                return f(), l.close(), i(d.error);
              };
            }, d.onerror = function(p) {
              return l.close(), i(d.error);
            }, c.oncomplete = function() {
              u == null ? l.close() : u.oncomplete = function() {
                return l.close();
              };
            };
          }, s.onerror = function(u) {
            return i(s.error);
          };
        })];
      });
    });
  }, e;
}();
if (_().getBool("IS_BROWSER")) try {
  Qn.registerManager(ia.URL_SCHEME, new A1());
} catch {
}
var Dn = "/", Yr = "tensorflowjs_models", pm = "info", I1 = "model_topology", E1 = "weight_specs", T1 = "weight_data", P1 = "model_metadata";
function fm(e) {
  return { info: [Yr, e, pm].join(Dn), topology: [Yr, e, I1].join(Dn), weightSpecs: [Yr, e, E1].join(Dn), weightData: [Yr, e, T1].join(Dn), modelMetadata: [Yr, e, P1].join(Dn) };
}
function S1(e) {
  var n = e.split(Dn);
  if (n.length < 3) throw new Error("Invalid key format: " + e);
  return n.slice(1, n.length - 1).join(Dn);
}
var sa = function() {
  function e(n) {
    if (!_().getBool("IS_BROWSER") || typeof window > "u" || window.localStorage === void 0) throw new Error("The current environment does not support local storage.");
    if (this.LS = window.localStorage, n == null || !n) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this.modelPath = n, this.keys = fm(this.modelPath);
  }
  return e.prototype.save = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r, a;
      return Z(this, function(o) {
        if (n.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        t = JSON.stringify(n.modelTopology), r = JSON.stringify(n.weightSpecs), a = Qa(n);
        try {
          return this.LS.setItem(this.keys.info, JSON.stringify(a)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, function(i) {
            if (Bs) return Buffer.from(i).toString("base64");
            for (var s = new Uint8Array(i), u = "", l = 0, c = s.length; l < c; l++) u += String.fromCharCode(s[l]);
            return btoa(u);
          }(n.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({ format: n.format, generatedBy: n.generatedBy, convertedBy: n.convertedBy, userDefinedMetadata: n.userDefinedMetadata })), [2, { modelArtifactsInfo: a }];
        } catch {
          throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error("Failed to save model '" + this.modelPath + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + a.modelTopologyBytes + ", weightSpecsBytes=" + a.weightSpecsBytes + ", weightDataBytes=" + a.weightDataBytes + ".");
        }
        return [2];
      });
    });
  }, e.prototype.load = function() {
    return Y(this, void 0, void 0, function() {
      var n, t, r, a, o, i, s;
      return Z(this, function(u) {
        if ((n = JSON.parse(this.LS.getItem(this.keys.info))) == null) throw new Error("In local storage, there is no model with name '" + this.modelPath + "'");
        if (n.modelTopologyType !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        if (t = {}, (r = JSON.parse(this.LS.getItem(this.keys.topology))) == null) throw new Error("In local storage, the topology of model '" + this.modelPath + "' is missing.");
        if (t.modelTopology = r, (a = JSON.parse(this.LS.getItem(this.keys.weightSpecs))) == null) throw new Error("In local storage, the weight specs of model '" + this.modelPath + "' are missing.");
        if (t.weightSpecs = a, (o = this.LS.getItem(this.keys.modelMetadata)) != null && (i = JSON.parse(o), t.format = i.format, t.generatedBy = i.generatedBy, t.convertedBy = i.convertedBy, t.userDefinedMetadata = i.userDefinedMetadata), (s = this.LS.getItem(this.keys.weightData)) == null) throw new Error("In local storage, the binary weight values of model '" + this.modelPath + "' are missing.");
        return t.weightData = function(l) {
          if (Bs) {
            var c = Buffer.from(l, "base64");
            return c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength);
          }
          for (var h = atob(l), d = new Uint8Array(h.length), p = 0; p < h.length; ++p) d.set([h.charCodeAt(p)], p);
          return d.buffer;
        }(s), [2, t];
      });
    });
  }, e.URL_SCHEME = "localstorage://", e;
}(), mc = function(e) {
  return _().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(sa.URL_SCHEME) ? (n = e.slice(sa.URL_SCHEME.length), new sa(n)) : null;
  var n;
};
Rt.registerSaveRouter(mc), Rt.registerLoadRouter(mc);
var D1 = function() {
  function e() {
    A(_().getBool("IS_BROWSER"), function() {
      return "Current environment is not a web browser";
    }), A(typeof window > "u" || window.localStorage !== void 0, function() {
      return "Current browser does not appear to support localStorage";
    }), this.LS = window.localStorage;
  }
  return e.prototype.listModels = function() {
    return Y(this, void 0, void 0, function() {
      var n, t, r, a, o, i;
      return Z(this, function(s) {
        for (n = {}, t = Yr + Dn, r = Dn + pm, a = 0; a < this.LS.length; ++a) (o = this.LS.key(a)).startsWith(t) && o.endsWith(r) && (i = S1(o), n[i] = JSON.parse(this.LS.getItem(o)));
        return [2, n];
      });
    });
  }, e.prototype.removeModel = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r;
      return Z(this, function(a) {
        var o;
        if (n = (o = n).startsWith(sa.URL_SCHEME) ? o.slice(sa.URL_SCHEME.length) : o, t = fm(n), this.LS.getItem(t.info) == null) throw new Error("Cannot find model at path '" + n + "'");
        return r = JSON.parse(this.LS.getItem(t.info)), this.LS.removeItem(t.info), this.LS.removeItem(t.topology), this.LS.removeItem(t.weightSpecs), this.LS.removeItem(t.weightData), [2, r];
      });
    });
  }, e;
}();
if (_().getBool("IS_BROWSER")) try {
  Qn.registerManager(sa.URL_SCHEME, new D1());
} catch {
}
var O1 = "model", R1 = ".json", F1 = ".weights.bin";
function gc(e) {
  return new Promise(function(n) {
    return setTimeout(n);
  }).then(e);
}
var es = function() {
  function e(n) {
    if (!_().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    n.startsWith(e.URL_SCHEME) && (n = n.slice(e.URL_SCHEME.length)), n != null && n.length !== 0 || (n = O1), this.modelTopologyFileName = n + R1, this.weightDataFileName = n + F1;
  }
  return e.prototype.save = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r, a, o, i, s;
      return Z(this, function(u) {
        switch (u.label) {
          case 0:
            if (typeof document > "u") throw new Error("Browser downloads are not supported in this environment since `document` is not present");
            if (t = window.URL.createObjectURL(new Blob([n.weightData], { type: "application/octet-stream" })), !(n.modelTopology instanceof ArrayBuffer)) return [3, 1];
            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
          case 1:
            return r = [{ paths: ["./" + this.weightDataFileName], weights: n.weightSpecs }], a = { modelTopology: n.modelTopology, format: n.format, generatedBy: n.generatedBy, convertedBy: n.convertedBy, weightsManifest: r }, o = window.URL.createObjectURL(new Blob([JSON.stringify(a)], { type: "application/json" })), (i = this.jsonAnchor == null ? document.createElement("a") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = o, [4, gc(function() {
              return i.dispatchEvent(new MouseEvent("click"));
            })];
          case 2:
            return u.sent(), n.weightData == null ? [3, 4] : ((s = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, s.href = t, [4, gc(function() {
              return s.dispatchEvent(new MouseEvent("click"));
            })]);
          case 3:
            u.sent(), u.label = 4;
          case 4:
            return [2, { modelArtifactsInfo: Qa(n) }];
        }
      });
    });
  }, e.URL_SCHEME = "downloads://", e;
}(), M1 = function() {
  function e(n) {
    if (n == null || n.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + n);
    this.files = n;
  }
  return e.prototype.load = function() {
    return Y(this, void 0, void 0, function() {
      var n, t, r = this;
      return Z(this, function(a) {
        return n = this.files[0], t = this.files.slice(1), [2, new Promise(function(o, i) {
          var s = new FileReader();
          s.onload = function(u) {
            var l = JSON.parse(u.target.result), c = l.modelTopology;
            if (c != null) {
              t.length === 0 && o({ modelTopology: c });
              var h = l.weightsManifest;
              if (h != null) {
                var d;
                try {
                  d = r.checkManifestAndWeightFiles(h, t);
                } catch (g) {
                  return void i(g);
                }
                var p = [], f = [], m = [];
                h.forEach(function(g) {
                  g.paths.forEach(function(v) {
                    f.push(v), m.push(null);
                  }), p.push.apply(p, g.weights);
                }), h.forEach(function(g) {
                  g.paths.forEach(function(v) {
                    var y = new FileReader();
                    y.onload = function(b) {
                      var x = b.target.result, C = f.indexOf(v);
                      m[C] = x, m.indexOf(null) === -1 && o({ modelTopology: c, weightSpecs: p, weightData: pl(m), format: l.format, generatedBy: l.generatedBy, convertedBy: l.convertedBy, userDefinedMetadata: l.userDefinedMetadata });
                    }, y.onerror = function(b) {
                      return i("Failed to weights data from file of path '" + v + "'.");
                    }, y.readAsArrayBuffer(d[v]);
                  });
                });
              } else i(new Error("weightManifest field is missing from file " + n.name));
            } else i(new Error("modelTopology field is missing from file " + n.name));
          }, s.onerror = function(u) {
            return i("Failed to read model topology and weights manifest JSON from file '" + n.name + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only.");
          }, s.readAsText(n);
        })];
      });
    });
  }, e.prototype.checkManifestAndWeightFiles = function(n, t) {
    for (var r = [], a = t.map(function(u) {
      return dc(u.name);
    }), o = {}, i = 0, s = n; i < s.length; i++)
      s[i].paths.forEach(function(u) {
        var l = dc(u);
        if (r.indexOf(l) !== -1) throw new Error("Duplicate file basename found in weights manifest: '" + l + "'");
        if (r.push(l), a.indexOf(l) === -1) throw new Error("Weight file with basename '" + l + "' is not provided.");
        o[u] = t[a.indexOf(l)];
      });
    if (r.length !== t.length) throw new Error("Mismatch in the number of files in weights manifest (" + r.length + ") and the number of weight files provided (" + t.length + ").");
    return o;
  }, e;
}();
function vc(e, n, t, r) {
  (function(o) {
    A(o != null && Array.isArray(o) && o.length > 0, function() {
      return "promises must be a none empty array";
    });
  })(e), function(o, i) {
    A(o >= 0 && o <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got startFraction " + o;
    }), A(i >= 0 && i <= 1, function() {
      return "Progress fraction must be in range [0, 1], but got endFraction " + i;
    }), A(i >= o, function() {
      return "startFraction must be no more than endFraction, but got startFraction " + o + " and endFraction " + i;
    });
  }(t = t ?? 0, r = r ?? 1);
  var a = 0;
  return Promise.all(e.map(function(o) {
    return o.then(function(i) {
      var s = t + ++a / e.length * (r - t);
      return n(s), i;
    }), o;
  }));
}
function mm(e, n) {
  return Y(this, void 0, void 0, function() {
    var t, r, a, o, i, s, u, l, c;
    return Z(this, function(h) {
      switch (h.label) {
        case 0:
          return n == null && (n = {}), t = n.fetchFunc == null ? _().platform.fetch : n.fetchFunc, r = e.map(function(d) {
            return t(d, n.requestInit, { isBinary: !0 });
          }), a = 0, o = 0.5, n.onProgress != null ? [3, 2] : [4, Promise.all(r)];
        case 1:
          return i = h.sent(), [3, 4];
        case 2:
          return [4, vc(r, n.onProgress, a, o)];
        case 3:
          i = h.sent(), h.label = 4;
        case 4:
          return s = i.map(function(d) {
            return d.arrayBuffer();
          }), u = 0.5, l = 1, n.onProgress != null ? [3, 6] : [4, Promise.all(s)];
        case 5:
          return c = h.sent(), [3, 8];
        case 6:
          return [4, vc(s, n.onProgress, u, l)];
        case 7:
          c = h.sent(), h.label = 8;
        case 8:
          return [2, c];
      }
    });
  });
}
function yc(e) {
  var n = this;
  return function(t, r, a) {
    return r === void 0 && (r = ""), Y(n, void 0, void 0, function() {
      var o, i, s, u, l, c, h, d, p, f;
      return Z(this, function(m) {
        switch (m.label) {
          case 0:
            if (o = t.map(function() {
              return !1;
            }), i = {}, s = a != null ? a.map(function() {
              return !1;
            }) : [], u = [], t.forEach(function(g, v) {
              var y = 0;
              g.weights.forEach(function(b) {
                var x = "quantization" in b ? b.quantization.dtype : b.dtype, C = _s[x] * Q(b.shape), N = function() {
                  o[v] = !0, i[v] == null && (i[v] = []), i[v].push({ manifestEntry: b, groupOffset: y, sizeBytes: C });
                };
                a != null ? a.forEach(function(T, I) {
                  T === b.name && (N(), s[I] = !0);
                }) : N(), u.push(b.name), y += C;
              });
            }), !s.every(function(g) {
              return g;
            })) throw l = a.filter(function(g, v) {
              return !s[v];
            }), new Error("Could not find weights in manifest with names: " + l.join(", ") + `. 
Manifest JSON has weights with names: ` + u.join(", ") + ".");
            return c = o.reduce(function(g, v, y) {
              return v && g.push(y), g;
            }, []), h = [], c.forEach(function(g) {
              t[g].paths.forEach(function(v) {
                var y = r + (r.endsWith("/") ? "" : "/") + v;
                h.push(y);
              });
            }), [4, e(h)];
          case 1:
            return d = m.sent(), p = {}, f = 0, c.forEach(function(g) {
              for (var v = t[g].paths.length, y = 0, b = 0; b < v; b++) y += d[f + b].byteLength;
              for (var x = new ArrayBuffer(y), C = new Uint8Array(x), N = 0, T = 0; T < v; T++) {
                var I = new Uint8Array(d[f + T]);
                C.set(I, N), N += I.byteLength;
              }
              i[g].forEach(function(E) {
                var P = hm(x.slice(E.groupOffset, E.groupOffset + E.sizeBytes), [E.manifestEntry]);
                for (var O in P) p[O] = P[O];
              }), f += v;
            }), [2, p];
        }
      });
    });
  };
}
Rt.registerSaveRouter(function(e) {
  return _().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(es.URL_SCHEME) ? function(n) {
    return n === void 0 && (n = "model"), new es(n);
  }(e.slice(es.URL_SCHEME.length)) : null;
});
var gm = function() {
  function e(n, t) {
    if (this.DEFAULT_METHOD = "POST", t == null && (t = {}), this.weightPathPrefix = t.weightPathPrefix, this.onProgress = t.onProgress, t.fetchFunc != null ? (A(typeof t.fetchFunc == "function", function() {
      return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)";
    }), this.fetch = t.fetchFunc) : this.fetch = _().platform.fetch, A(n != null && n.length > 0, function() {
      return "URL path for http must not be null, undefined or empty.";
    }), Array.isArray(n) && A(n.length === 2, function() {
      return "URL paths for http must have a length of 2, (actual length is " + n.length + ").";
    }), this.path = n, t.requestInit != null && t.requestInit.body != null) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this.requestInit = t.requestInit || {};
  }
  return e.prototype.save = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r, a, o;
      return Z(this, function(i) {
        switch (i.label) {
          case 0:
            if (n.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
            return (t = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit)).body = new FormData(), r = [{ paths: ["./model.weights.bin"], weights: n.weightSpecs }], a = { modelTopology: n.modelTopology, format: n.format, generatedBy: n.generatedBy, convertedBy: n.convertedBy, userDefinedMetadata: n.userDefinedMetadata, weightsManifest: r }, t.body.append("model.json", new Blob([JSON.stringify(a)], { type: "application/json" }), "model.json"), n.weightData != null && t.body.append("model.weights.bin", new Blob([n.weightData], { type: "application/octet-stream" }), "model.weights.bin"), [4, this.fetch(this.path, t)];
          case 1:
            if ((o = i.sent()).ok) return [2, { modelArtifactsInfo: Qa(n), responses: [o] }];
            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + o.status + ".");
        }
      });
    });
  }, e.prototype.load = function() {
    return Y(this, void 0, void 0, function() {
      var n, t, r, a, o, i, s, u, l, c, h, d;
      return Z(this, function(p) {
        switch (p.label) {
          case 0:
            return [4, this.fetch(this.path, this.requestInit)];
          case 1:
            if (!(n = p.sent()).ok) throw new Error("Request to " + this.path + " failed with status code " + n.status + ". Please verify this URL points to the model JSON of the model to load.");
            p.label = 2;
          case 2:
            return p.trys.push([2, 4, , 5]), [4, n.json()];
          case 3:
            return t = p.sent(), [3, 5];
          case 4:
            throw p.sent(), r = "Failed to parse model JSON of response from " + this.path + ".", this.path.endsWith(".pb") ? r += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : r += " Please make sure the server is serving valid JSON for this request.", new Error(r);
          case 5:
            if (a = t.modelTopology, o = t.weightsManifest, i = t.generatedBy, s = t.convertedBy, u = t.format, l = t.userDefinedMetadata, a == null && o == null) throw new Error("The JSON from HTTP path " + this.path + " contains neither model topology or manifest for weights.");
            return o == null ? [3, 7] : [4, this.loadWeights(o)];
          case 6:
            d = p.sent(), c = d[0], h = d[1], p.label = 7;
          case 7:
            return [2, { modelTopology: a, weightSpecs: c, weightData: h, userDefinedMetadata: l, generatedBy: i, convertedBy: s, format: u }];
        }
      });
    });
  }, e.prototype.loadWeights = function(n) {
    return Y(this, void 0, void 0, function() {
      var t, r, a, o, i, s, u, l, c, h, d;
      return Z(this, function(p) {
        switch (p.label) {
          case 0:
            for (t = Array.isArray(this.path) ? this.path[1] : this.path, r = function(f) {
              var m = f.lastIndexOf("/"), g = f.lastIndexOf("?"), v = f.substring(0, m), y = g > m ? f.substring(g) : "";
              return [v + "/", y];
            }(t), a = r[0], o = r[1], i = this.weightPathPrefix || a, s = [], u = 0, l = n; u < l.length; u++) c = l[u], s.push.apply(s, c.weights);
            return h = [], n.forEach(function(f) {
              f.paths.forEach(function(m) {
                h.push(i + m + o);
              });
            }), [4, mm(h, { requestInit: this.requestInit, fetchFunc: this.fetch, onProgress: this.onProgress })];
          case 1:
            return d = p.sent(), [2, [s, pl(d)]];
        }
      });
    });
  }, e.URL_SCHEME_REGEX = /^https?:\/\//, e;
}();
function Vs(e) {
  return e.match(gm.URL_SCHEME_REGEX) != null;
}
var bc = function(e, n) {
  return typeof fetch > "u" ? null : (Array.isArray(e) ? e.every(function(t) {
    return Vs(t);
  }) : Vs(e)) ? Ls(e, { onProgress: n }) : null;
};
function Ls(e, n) {
  return new gm(e, n);
}
Rt.registerSaveRouter(bc), Rt.registerLoadRouter(bc);
var ts = function() {
  function e(n) {
    this.modelArtifacts = n;
  }
  return e.prototype.load = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(n) {
        return [2, this.modelArtifacts];
      });
    });
  }, e;
}(), _1 = function() {
  function e(n) {
    this.saveHandler = n;
  }
  return e.prototype.save = function(n) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        return [2, this.saveHandler(n)];
      });
    });
  }, e;
}(), ka = Object.freeze({ browserFiles: function(e) {
  return new M1(e);
}, browserHTTPRequest: function(e, n) {
  return Ls(e, n);
}, concatenateArrayBuffers: pl, decodeWeights: hm, encodeWeights: function(e, n) {
  return Y(this, void 0, void 0, function() {
    var t, r, a, o, i, s = this;
    return Z(this, function(u) {
      switch (u.label) {
        case 0:
          for (t = [], r = [], a = Array.isArray(e) ? e.map(function(l) {
            return l.name;
          }) : Object.keys(e), o = function(l) {
            var c = a[l], h = Array.isArray(e) ? e[l].tensor : e[c];
            if (h.dtype !== "float32" && h.dtype !== "int32" && h.dtype !== "bool" && h.dtype !== "string") throw new Error("Unsupported dtype in weight '" + c + "': " + h.dtype);
            var d = { name: c, shape: h.shape, dtype: h.dtype };
            if (h.dtype === "string") {
              var p = new Promise(function(f) {
                return Y(s, void 0, void 0, function() {
                  var m, g, v, y, b, x, C;
                  return Z(this, function(N) {
                    switch (N.label) {
                      case 0:
                        return [4, h.bytes()];
                      case 1:
                        for (m = N.sent(), g = m.reduce(function(T, I) {
                          return T + I.length;
                        }, 0) + ri * m.length, v = new Uint8Array(g), y = 0, b = 0; b < m.length; b++) x = m[b], C = new Uint8Array(new Uint32Array([x.length]).buffer), v.set(C, y), y += ri, v.set(x, y), y += x.length;
                        return f(v), [2];
                    }
                  });
                });
              });
              r.push(p);
            } else r.push(h.data());
            n != null && (d.group = n), t.push(d);
          }, i = 0; i < a.length; ++i) o(i);
          return [4, Promise.all(r)];
        case 1:
          return [2, { data: N1(u.sent()), specs: t }];
      }
    });
  });
}, fromMemory: function(e, n, t, r) {
  return arguments.length === 1 ? e.modelTopology != null || e.weightSpecs != null ? new ts(e) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new ts({ modelTopology: e })) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new ts({ modelTopology: e, weightSpecs: n, weightData: t, trainingConfig: r }));
}, getLoadHandlers: function(e, n) {
  return Rt.getLoadHandlers(e, n);
}, getModelArtifactsInfoForJSON: Qa, getSaveHandlers: function(e) {
  return Rt.getSaveHandlers(e);
}, http: Ls, isHTTPScheme: Vs, loadWeights: function(e, n, t, r) {
  return n === void 0 && (n = ""), Y(this, void 0, void 0, function() {
    return Z(this, function(a) {
      return [2, yc(function(o) {
        return mm(o, { requestInit: r });
      })(e, n, t)];
    });
  });
}, registerLoadRouter: function(e) {
  return Rt.registerLoadRouter(e);
}, registerSaveRouter: function(e) {
  return Rt.registerSaveRouter(e);
}, weightsLoaderFactory: yc, withSaveHandler: function(e) {
  return new _1(e);
}, copyModel: function(e, n) {
  return Y(this, void 0, void 0, function() {
    return Z(this, function(t) {
      return [2, pc(e, n, !1)];
    });
  });
}, listModels: function() {
  return Y(this, void 0, void 0, function() {
    var e, n, t, r, a, o, i;
    return Z(this, function(s) {
      switch (s.label) {
        case 0:
          e = Qn.getSchemes(), n = {}, t = 0, r = e, s.label = 1;
        case 1:
          return t < r.length ? (a = r[t], [4, Qn.getManager(a).listModels()]) : [3, 4];
        case 2:
          for (i in o = s.sent()) n[a + oa + i] = o[i];
          s.label = 3;
        case 3:
          return t++, [3, 1];
        case 4:
          return [2, n];
      }
    });
  });
}, moveModel: function(e, n) {
  return Y(this, void 0, void 0, function() {
    return Z(this, function(t) {
      return [2, pc(e, n, !0)];
    });
  });
}, removeModel: function(e) {
  return Y(this, void 0, void 0, function() {
    var n;
    return Z(this, function(t) {
      return n = Ro(e), [2, Qn.getManager(n.scheme).removeModel(n.path)];
    });
  });
} }), zr;
S({ confusionMatrix_: function(e, n, t) {
  var r = k(e, "labels", "confusionMatrix"), a = k(n, "predictions", "confusionMatrix");
  A(t == null || t > 0 && Number.isInteger(t), function() {
    return "If provided, numClasses must be a positive integer, but got " + t;
  }), A(r.rank === 1, function() {
    return "Expected the rank of labels to be 1, but got " + r.rank;
  }), A(a.rank === 1, function() {
    return "Expected the rank of predictions to be 1, but got " + a.rank;
  }), A(r.shape[0] === a.shape[0], function() {
    return "Mismatch in the number of examples: " + r.shape[0] + " vs. " + a.shape[0] + ". Labels and predictions should have the same number of elements.";
  }), A(t > 0 && Number.isInteger(t), function() {
    return "numClasses is required to be a positive integer, but got " + t;
  });
  var o = za(r.asType("int32"), t), i = za(a.asType("int32"), t);
  return o.transpose().matMul(i).asType("int32");
} });
S({ fromPixels_: function(e, n) {
  if (n === void 0 && (n = 3), n > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (e == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  var t = !1, r = !1, a = !1, o = !1, i = !1;
  if (e.data instanceof Uint8Array) t = !0;
  else if (typeof ImageData < "u" && e instanceof ImageData) r = !0;
  else if (typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement) a = !0;
  else if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) o = !0;
  else {
    if (e.getContext == null) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + e.constructor.name);
    i = !0;
  }
  if (a && a && e.readyState < 2)
    throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");
  if (Dd("FromPixels", D.backendName) != null) return D.runKernel("FromPixels", { pixels: e }, { numChannels: n });
  var s, u, l = a ? [e.videoWidth, e.videoHeight] : [e.width, e.height], c = l[0], h = l[1];
  if (i ? s = e.getContext("2d").getImageData(0, 0, c, h).data : r || t ? s = e.data : (o || a) && (zr == null && (zr = document.createElement("canvas").getContext("2d")), zr.canvas.width = c, zr.canvas.height = h, zr.drawImage(e, 0, 0, c, h), s = zr.getImageData(0, 0, c, h).data), n === 4) u = new Int32Array(s);
  else {
    var d = c * h;
    u = new Int32Array(d * n);
    for (var p = 0; p < d; p++) for (var f = 0; f < n; ++f) u[p * n + f] = s[4 * p + f];
  }
  return Xd(u, [h, c, n], "int32");
} });
var B1 = function() {
  function e() {
  }
  return e.prototype.getClassName = function() {
    return this.constructor.className;
  }, e.fromConfig = function(n, t) {
    return new n(t);
  }, e;
}(), j1 = function() {
  function e() {
    this.classNameMap = {};
  }
  return e.getMap = function() {
    return e.instance == null && (e.instance = new e()), e.instance;
  }, e.register = function(n) {
    e.getMap().classNameMap[n.className] = [n, n.fromConfig];
  }, e;
}();
function Or(e) {
  A(e.className != null, function() {
    return "Class being registered does not have the static className property defined.";
  }), A(typeof e.className == "string", function() {
    return "className is required to be a string, but got type " + typeof e.className;
  }), A(e.className.length > 0, function() {
    return "Class being registered has an empty-string as its className, which is disallowed.";
  }), j1.register(e);
}
var Rr = function(e) {
  function n() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return en(n, e), n.prototype.minimize = function(t, r, a) {
    r === void 0 && (r = !1);
    var o = this.computeGradients(t, a), i = o.value, s = o.grads;
    if (a != null) {
      var u = a.map(function(l) {
        return { name: l.name, tensor: s[l.name] };
      });
      this.applyGradients(u);
    } else this.applyGradients(s);
    return xt(s), r ? i : (i.dispose(), null);
  }, Object.defineProperty(n.prototype, "iterations", { get: function() {
    return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
  }, enumerable: !0, configurable: !0 }), n.prototype.incrementIterations = function() {
    this.iterations_ = this.iterations + 1;
  }, n.prototype.computeGradients = function(t, r) {
    return Vv(t, r);
  }, n.prototype.dispose = function() {
    this.iterations_ != null && xt(this.iterations_);
  }, n.prototype.saveIterations = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        return this.iterations_ == null && (this.iterations_ = 0), [2, { name: "iter", tensor: X(this.iterations_, "int32") }];
      });
    });
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(r) {
        throw new Error("setWeights() is not implemented for this optimizer class " + this.getClassName());
      });
    });
  }, n.prototype.extractIterations = function(t) {
    return Y(this, void 0, void 0, function() {
      var r;
      return Z(this, function(a) {
        switch (a.label) {
          case 0:
            return r = this, [4, t[0].tensor.data()];
          case 1:
            return r.iterations_ = a.sent()[0], [2, t.slice(1)];
        }
      });
    });
  }, n;
}(B1);
Object.defineProperty(Rr, Symbol.hasInstance, { value: function(e) {
  return e.minimize != null && e.computeGradients != null && e.applyGradients != null;
} });
var V1 = function(e) {
  function n(t, r, a) {
    a === void 0 && (a = null);
    var o = e.call(this) || this;
    return o.learningRate = t, o.rho = r, o.epsilon = a, o.accumulatedGrads = [], o.accumulatedUpdates = [], a == null && (o.epsilon = D.backend.epsilon()), o;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(a) {
      return a.name;
    }) : Object.keys(t)).forEach(function(a, o) {
      var i = D.registeredVariables[a];
      r.accumulatedGrads[o] == null && (r.accumulatedGrads[o] = { originalName: a + "/accum_grad", variable: de(function() {
        return ve(i).variable(!1);
      }) }), r.accumulatedUpdates[o] == null && (r.accumulatedUpdates[o] = { originalName: a + "/accum_var", variable: de(function() {
        return ve(i).variable(!1);
      }) });
      var s = Array.isArray(t) ? t[o].tensor : t[a];
      if (s != null) {
        var u = r.accumulatedGrads[o].variable, l = r.accumulatedUpdates[o].variable;
        de(function() {
          var c = u.mul(r.rho).add(s.square().mul(1 - r.rho)), h = l.add(r.epsilon).sqrt().div(u.add(r.epsilon).sqrt()).mul(s), d = l.mul(r.rho).add(h.square().mul(1 - r.rho));
          u.assign(c), l.assign(d);
          var p = h.mul(-r.learningRate).add(i);
          i.assign(p);
        });
      }
    }), this.incrementIterations();
  }, n.prototype.dispose = function() {
    this.accumulatedUpdates != null && (xt(this.accumulatedGrads.map(function(t) {
      return t.variable;
    })), xt(this.accumulatedUpdates.map(function(t) {
      return t.variable;
    })));
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      var t;
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];
          case 1:
            return [2, [r.sent()].concat(t.map(function(a) {
              return { name: a.originalName, tensor: a.variable };
            }))];
        }
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      var r;
      return Z(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = a.sent(), r = t.length / 2, this.accumulatedGrads = t.slice(0, r).map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            }), this.accumulatedUpdates = t.slice(r, 2 * r).map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate, rho: this.rho, epsilon: this.epsilon };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate, r.rho, r.epsilon);
  }, n.className = "Adadelta", n;
}(Rr);
Or(V1);
var L1 = function(e) {
  function n(t, r) {
    r === void 0 && (r = 0.1);
    var a = e.call(this) || this;
    return a.learningRate = t, a.initialAccumulatorValue = r, a.accumulatedGrads = [], a;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(a) {
      return a.name;
    }) : Object.keys(t)).forEach(function(a, o) {
      var i = D.registeredVariables[a];
      r.accumulatedGrads[o] == null && (r.accumulatedGrads[o] = { originalName: a + "/accumulator", variable: de(function() {
        return ci(i.shape, r.initialAccumulatorValue).variable(!1);
      }) });
      var s = Array.isArray(t) ? t[o].tensor : t[a];
      if (s != null) {
        var u = r.accumulatedGrads[o].variable;
        de(function() {
          var l = u.add(s.square());
          u.assign(l);
          var c = s.div(l.add(D.backend.epsilon()).sqrt()).mul(-r.learningRate).add(i);
          i.assign(c);
        });
      }
    }), this.incrementIterations();
  }, n.prototype.dispose = function() {
    this.accumulatedGrads != null && xt(this.accumulatedGrads.map(function(t) {
      return t.variable;
    }));
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t.sent()].concat(this.accumulatedGrads.map(function(r) {
              return { name: r.originalName, tensor: r.variable };
            }))];
        }
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = r.sent(), this.accumulatedGrads = t.map(function(a) {
              return { originalName: a.name, variable: a.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate, initialAccumulatorValue: this.initialAccumulatorValue };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate, r.initialAccumulatorValue);
  }, n.className = "Adagrad", n;
}(Rr);
Or(L1);
var z1 = function(e) {
  function n(t, r, a, o) {
    o === void 0 && (o = null);
    var i = e.call(this) || this;
    return i.learningRate = t, i.beta1 = r, i.beta2 = a, i.epsilon = o, i.accumulatedFirstMoment = [], i.accumulatedSecondMoment = [], de(function() {
      i.accBeta1 = X(r).variable(), i.accBeta2 = X(a).variable();
    }), o == null && (i.epsilon = D.backend.epsilon()), i;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this, a = Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t);
    de(function() {
      var o = Rn(1, r.accBeta1), i = Rn(1, r.accBeta2);
      a.forEach(function(s, u) {
        var l = D.registeredVariables[s];
        r.accumulatedFirstMoment[u] == null && (r.accumulatedFirstMoment[u] = { originalName: s + "/m", variable: de(function() {
          return ve(l).variable(!1);
        }) }), r.accumulatedSecondMoment[u] == null && (r.accumulatedSecondMoment[u] = { originalName: s + "/v", variable: de(function() {
          return ve(l).variable(!1);
        }) });
        var c = Array.isArray(t) ? t[u].tensor : t[s];
        if (c != null) {
          var h = r.accumulatedFirstMoment[u].variable, d = r.accumulatedSecondMoment[u].variable, p = h.mul(r.beta1).add(c.mul(1 - r.beta1)), f = d.mul(r.beta2).add(c.square().mul(1 - r.beta2)), m = p.div(o), g = f.div(i);
          h.assign(p), d.assign(f);
          var v = m.div(g.sqrt().add(r.epsilon)).mul(-r.learningRate).add(l);
          l.assign(v);
        }
      }), r.accBeta1.assign(r.accBeta1.mul(r.beta1)), r.accBeta2.assign(r.accBeta2.mul(r.beta2));
    }), this.incrementIterations();
  }, n.prototype.dispose = function() {
    this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && xt(this.accumulatedFirstMoment.map(function(t) {
      return t.variable;
    })), this.accumulatedSecondMoment != null && xt(this.accumulatedSecondMoment.map(function(t) {
      return t.variable;
    }));
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      var t;
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];
          case 1:
            return [2, [r.sent()].concat(t.map(function(a) {
              return { name: a.originalName, tensor: a.variable };
            }))];
        }
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      var r, a = this;
      return Z(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = o.sent(), de(function() {
              a.accBeta1.assign(La(a.beta1, a.iterations_ + 1)), a.accBeta2.assign(La(a.beta2, a.iterations_ + 1));
            }), r = t.length / 2, this.accumulatedFirstMoment = t.slice(0, r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            }), this.accumulatedSecondMoment = t.slice(r, 2 * r).map(function(i) {
              return { originalName: i.name, variable: i.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate, r.beta1, r.beta2, r.epsilon);
  }, n.className = "Adam", n;
}(Rr);
Or(z1);
var G1 = function(e) {
  function n(t, r, a, o, i) {
    o === void 0 && (o = null), i === void 0 && (i = 0);
    var s = e.call(this) || this;
    return s.learningRate = t, s.beta1 = r, s.beta2 = a, s.epsilon = o, s.decay = i, s.accumulatedFirstMoment = [], s.accumulatedWeightedInfNorm = [], de(function() {
      s.iteration = X(0).variable(), s.accBeta1 = X(r).variable();
    }), o == null && (s.epsilon = D.backend.epsilon()), s;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this, a = Array.isArray(t) ? t.map(function(o) {
      return o.name;
    }) : Object.keys(t);
    de(function() {
      var o = Rn(1, r.accBeta1), i = Bn(-r.learningRate, r.iteration.mul(r.decay).add(1));
      a.forEach(function(s, u) {
        var l = D.registeredVariables[s];
        r.accumulatedFirstMoment[u] == null && (r.accumulatedFirstMoment[u] = { originalName: s + "/m", variable: ve(l).variable(!1) }), r.accumulatedWeightedInfNorm[u] == null && (r.accumulatedWeightedInfNorm[u] = { originalName: s + "/v", variable: ve(l).variable(!1) });
        var c = Array.isArray(t) ? t[u].tensor : t[s];
        if (c != null) {
          var h = r.accumulatedFirstMoment[u].variable, d = r.accumulatedWeightedInfNorm[u].variable, p = h.mul(r.beta1).add(c.mul(1 - r.beta1)), f = d.mul(r.beta2), m = c.abs(), g = f.maximum(m);
          h.assign(p), d.assign(g);
          var v = i.div(o).mul(p.div(g.add(r.epsilon))).add(l);
          l.assign(v);
        }
      }), r.iteration.assign(r.iteration.add(1)), r.accBeta1.assign(r.accBeta1.mul(r.beta1));
    }), this.incrementIterations();
  }, n.prototype.dispose = function() {
    this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && xt(this.accumulatedFirstMoment.map(function(t) {
      return t.variable;
    })), this.accumulatedWeightedInfNorm != null && xt(this.accumulatedWeightedInfNorm.map(function(t) {
      return t.variable;
    }));
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        throw new Error("getWeights() is not implemented for Adamax yet.");
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(r) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate, beta1: this.beta1, beta2: this.beta2, epsilon: this.epsilon, decay: this.decay };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate, r.beta1, r.beta2, r.epsilon, r.decay);
  }, n.className = "Adamax", n;
}(Rr);
Or(G1);
var vm = function(e) {
  function n(t) {
    var r = e.call(this) || this;
    return r.learningRate = t, r.setLearningRate(t), r;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(a) {
      return a.name;
    }) : Object.keys(t)).forEach(function(a, o) {
      var i = Array.isArray(t) ? t[o].tensor : t[a];
      if (i != null) {
        var s = D.registeredVariables[a];
        de(function() {
          var u = r.c.mul(i).add(s);
          s.assign(u);
        });
      }
    }), this.incrementIterations();
  }, n.prototype.setLearningRate = function(t) {
    this.learningRate = t, this.c != null && this.c.dispose(), this.c = uv(X(-t));
  }, n.prototype.dispose = function() {
    this.c.dispose();
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t.sent()]];
        }
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            if ((t = r.sent()).length !== 0) throw new Error("SGD optimizer does not have settable weights.");
            return [2];
        }
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate);
  }, n.className = "SGD", n;
}(Rr);
Or(vm);
var H1 = function(e) {
  function n(t, r, a) {
    a === void 0 && (a = !1);
    var o = e.call(this, t) || this;
    return o.learningRate = t, o.momentum = r, o.useNesterov = a, o.accumulations = [], o.m = X(o.momentum), o;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(a) {
      return a.name;
    }) : Object.keys(t)).forEach(function(a, o) {
      var i = D.registeredVariables[a];
      r.accumulations[o] == null && (r.accumulations[o] = { originalName: a + "/momentum", variable: de(function() {
        return ve(i).variable(!1);
      }) });
      var s = r.accumulations[o].variable, u = Array.isArray(t) ? t[o].tensor : t[a];
      u != null && de(function() {
        var l, c = r.m.mul(s).add(u);
        l = r.useNesterov ? r.c.mul(u.add(c.mul(r.m))).add(i) : r.c.mul(c).add(i), s.assign(c), i.assign(l);
      });
    }), this.incrementIterations();
  }, n.prototype.dispose = function() {
    this.m.dispose(), this.accumulations != null && xt(this.accumulations.map(function(t) {
      return t.variable;
    }));
  }, n.prototype.setMomentum = function(t) {
    this.momentum = t;
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(t) {
        switch (t.label) {
          case 0:
            return [4, this.saveIterations()];
          case 1:
            return [2, [t.sent()].concat(this.accumulations.map(function(r) {
              return { name: r.originalName, tensor: r.variable };
            }))];
        }
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = r.sent(), this.accumulations = t.map(function(a) {
              return { originalName: a.name, variable: a.tensor.variable(!1) };
            }), [2];
        }
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate, momentum: this.momentum, useNesterov: this.useNesterov };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate, r.momentum, r.useNesterov);
  }, n.className = "Momentum", n;
}(vm);
Or(H1);
var W1 = function(e) {
  function n(t, r, a, o, i) {
    r === void 0 && (r = 0.9), a === void 0 && (a = 0), o === void 0 && (o = null), i === void 0 && (i = !1);
    var s = e.call(this) || this;
    if (s.learningRate = t, s.decay = r, s.momentum = a, s.epsilon = o, s.accumulatedMeanSquares = [], s.accumulatedMoments = [], s.accumulatedMeanGrads = [], s.centered = i, o == null && (s.epsilon = D.backend.epsilon()), t == null) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    return s;
  }
  return en(n, e), n.prototype.applyGradients = function(t) {
    var r = this;
    (Array.isArray(t) ? t.map(function(a) {
      return a.name;
    }) : Object.keys(t)).forEach(function(a, o) {
      var i = D.registeredVariables[a];
      r.accumulatedMeanSquares[o] == null && (r.accumulatedMeanSquares[o] = { originalName: a + "/rms", variable: de(function() {
        return ve(i).variable(!1);
      }) }), r.accumulatedMoments[o] == null && (r.accumulatedMoments[o] = { originalName: a + "/momentum", variable: de(function() {
        return ve(i).variable(!1);
      }) }), r.accumulatedMeanGrads[o] == null && r.centered && (r.accumulatedMeanGrads[o] = { originalName: a + "/mg", variable: de(function() {
        return ve(i).variable(!1);
      }) });
      var s = Array.isArray(t) ? t[o].tensor : t[a];
      if (s != null) {
        var u = r.accumulatedMeanSquares[o].variable, l = r.accumulatedMoments[o].variable;
        de(function() {
          var c = u.mul(r.decay).add(s.square().mul(1 - r.decay));
          if (r.centered) {
            var h = r.accumulatedMeanGrads[o].variable, d = h.mul(r.decay).add(s.mul(1 - r.decay)), p = l.mul(r.momentum).add(s.mul(r.learningRate).div(c.sub(d.square().add(r.epsilon)).sqrt()));
            u.assign(c), h.assign(d), l.assign(p);
            var f = i.sub(p);
            i.assign(f);
          } else {
            var m = u.mul(r.decay).add(s.square().mul(1 - r.decay));
            p = l.mul(r.momentum).add(s.mul(r.learningRate).div(m.add(r.epsilon).sqrt())), u.assign(m), l.assign(p), f = i.sub(p), i.assign(f);
          }
        });
      }
    }), this.incrementIterations();
  }, n.prototype.dispose = function() {
    this.accumulatedMeanSquares != null && xt(this.accumulatedMeanSquares.map(function(t) {
      return t.variable;
    })), this.accumulatedMeanGrads != null && this.centered && xt(this.accumulatedMeanGrads.map(function(t) {
      return t.variable;
    })), this.accumulatedMoments != null && xt(this.accumulatedMoments.map(function(t) {
      return t.variable;
    }));
  }, n.prototype.getWeights = function() {
    return Y(this, void 0, void 0, function() {
      var t;
      return Z(this, function(r) {
        switch (r.label) {
          case 0:
            return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];
          case 1:
            return [2, [r.sent()].concat(t.map(function(a) {
              return { name: a.originalName, tensor: a.variable };
            }))];
        }
      });
    });
  }, n.prototype.setWeights = function(t) {
    return Y(this, void 0, void 0, function() {
      var r;
      return Z(this, function(a) {
        switch (a.label) {
          case 0:
            return [4, this.extractIterations(t)];
          case 1:
            return t = a.sent(), r = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, r).map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            }), this.accumulatedMoments = t.slice(r, 2 * r).map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * r, 3 * r).map(function(o) {
              return { originalName: o.name, variable: o.tensor.variable(!1) };
            })), [2];
        }
      });
    });
  }, n.prototype.getConfig = function() {
    return { learningRate: this.learningRate, decay: this.decay, momentum: this.momentum, epsilon: this.epsilon, centered: this.centered };
  }, n.fromConfig = function(t, r) {
    return new t(r.learningRate, r.decay, r.momentum, r.epsilon, r.centered);
  }, n.className = "RMSProp", n;
}(Rr);
Or(W1);
Ve.prototype.add = function(e) {
  return _n(this, e);
}, Ve.prototype.broadcastTo = function(e) {
  return gf(this, e);
}, Ve.prototype.div = function(e) {
  return Bn(this, e);
}, Ve.prototype.divNoNan = function(e) {
  return Uu(this, e);
}, Ve.prototype.squaredDifference = function(e) {
  return Xu(this, e);
}, Ve.prototype.tile = function(e) {
  return kr(this, e);
}, Ve.prototype.oneHot = function(e, n, t) {
  return n === void 0 && (n = 1), t === void 0 && (t = 0), za(this, e, n, t);
}, Ve.prototype.transpose = function(e) {
  return Lt(this, e);
}, Ve.prototype.pad = function(e, n) {
  return ir(this, e, n);
}, Ve.prototype.batchNorm = function(e, n, t, r, a) {
  return fa(this, e, n, t, r, a);
}, M = l1;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var qt, xc, zs = function() {
  return (zs = Object.assign || function(e) {
    for (var n, t = 1, r = arguments.length; t < r; t++) for (var a in n = arguments[t]) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
    return e;
  }).apply(this, arguments);
};
function Yn(e, n, t, r) {
  return new (t || (t = Promise))(function(a, o) {
    function i(l) {
      try {
        u(r.next(l));
      } catch (c) {
        o(c);
      }
    }
    function s(l) {
      try {
        u(r.throw(l));
      } catch (c) {
        o(c);
      }
    }
    function u(l) {
      l.done ? a(l.value) : new t(function(c) {
        c(l.value);
      }).then(i, s);
    }
    u((r = r.apply(e, [])).next());
  });
}
function Zn(e, n) {
  var t, r, a, o, i = { label: 0, sent: function() {
    if (1 & a[0]) throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(u) {
    return function(l) {
      return function(c) {
        if (t) throw new TypeError("Generator is already executing.");
        for (; i; ) try {
          if (t = 1, r && (a = 2 & c[0] ? r.return : c[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, c[1])).done) return a;
          switch (r = 0, a && (c = [2 & c[0], a.value]), c[0]) {
            case 0:
            case 1:
              a = c;
              break;
            case 4:
              return i.label++, { value: c[1], done: !1 };
            case 5:
              i.label++, r = c[1], c = [0];
              continue;
            case 7:
              c = i.ops.pop(), i.trys.pop();
              continue;
            default:
              if (!(a = (a = i.trys).length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                i = 0;
                continue;
              }
              if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
                i.label = c[1];
                break;
              }
              if (c[0] === 6 && i.label < a[1]) {
                i.label = a[1], a = c;
                break;
              }
              if (a && i.label < a[2]) {
                i.label = a[2], i.ops.push(c);
                break;
              }
              a[2] && i.ops.pop(), i.trys.pop();
              continue;
          }
          c = n.call(e, i);
        } catch (h) {
          c = [6, h], r = 0;
        } finally {
          t = a = 0;
        }
        if (5 & c[0]) throw c[1];
        return { value: c[0] ? c[1] : void 0, done: !0 };
      }([u, l]);
    };
  }
}
(function(e) {
  e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF";
})(qt || (qt = {})), function(e) {
  (function(n) {
    n[n.LEGACY = 0] = "LEGACY", n[n.V1 = 1] = "V1", n[n.V2 = 2] = "V2";
  })(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}));
}(xc || (xc = {}));
var $1 = {};
function ym(e) {
  return $1[e];
}
function w(e, n, t, r) {
  var a = n.inputParams[e];
  if (a && a.inputIndexStart !== void 0) {
    var o = a.inputIndexStart, i = a.inputIndexEnd === 0 ? void 0 : a.inputIndexEnd === void 0 ? o + 1 : a.inputIndexEnd;
    if (a.type === "tensor") return gt(n.inputNames[a.inputIndexStart], t, r);
    if (a.type === "tensors") return n.inputNames.slice(o, i).map(function(l) {
      return gt(l, t, r);
    });
    var s = Array.prototype.slice.call(gt(n.inputNames.slice(o)[0], t, r).dataSync());
    return a.type === "number" ? s[0] : s;
  }
  var u = n.attrParams[e];
  return u && u.value;
}
function gt(e, n, t) {
  var r = Et(e), a = r[0], o = r[1], i = t.currentContextIds.find(function(s) {
    return !!n[ai(a, s)];
  });
  return i !== void 0 ? n[ai(a, i)][o] : void 0;
}
function U1(e, n, t) {
  return n[ai(e, t.currentContextId)];
}
function ua(e, n) {
  var t = Et(e), r = t[0], a = t[1];
  return [ai(r, n && n.currentContextId), a];
}
function ai(e, n) {
  return n ? e + "-" + n : e;
}
function Et(e) {
  var n = e.lastIndexOf(":");
  return n === -1 ? [e, 0] : [e.substring(0, n), Number(e.substring(n + 1))];
}
function ns(e, n) {
  for (var t = [], r = 0; r < e.length; r += n) t.push(e.slice(r, r + n));
  return t;
}
var K1 = [{ tfOpName: "Add", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "AddV2", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "AddN", category: "arithmetic", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "BiasAdd", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Sub", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "RealDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Div", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "DivNoNan", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "FloorDiv", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Mul", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Maximum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }] }, { tfOpName: "Minimum", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }] }, { tfOpName: "Pow", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "SquaredDifference", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Mod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "FloorMod", category: "arithmetic", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }], q1 = Object.freeze({ json: K1 }), J1 = [{ tfOpName: "Abs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Acos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Asin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Atan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Atan2", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Ceil", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "ClipByValue", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "clip_value_min", name: "clipValueMin", type: "number" }, { tfName: "clip_value_max", name: "clipValueMax", type: "number" }] }, { tfOpName: "Complex", category: "basic_math", inputs: [{ start: 0, name: "real", type: "tensor" }, { start: 1, name: "imag", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "ComplexAbs", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Cos", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Cosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Elu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Exp", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Floor", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Log", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Imag", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: !0 }] }, { tfOpName: "Neg", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Real", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "Tout", name: "outputType", type: "dtype", notSupported: !0 }] }, { tfOpName: "Prelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "alpha", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Relu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Relu6", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "clipValueMin", name: "clipValueMin", type: "number", defaultValue: 0 }, { tfName: "clipValueMax", name: "clipValueMax", type: "number", defaultValue: 6 }] }, { tfOpName: "Selu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Sigmoid", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Sin", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Sinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Sqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Rsqrt", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Square", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Tan", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Tanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Sign", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Round", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Expm1", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Log1p", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Reciprocal", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Softplus", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Asinh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Acosh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Atanh", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Erf", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Prod", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axes", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool", notSupported: !0 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "LeakyRelu", category: "basic_math", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "alpha", name: "alpha", type: "number", defaultValue: 0.2 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }], X1 = Object.freeze({ json: J1 }), Q1 = [{ tfOpName: "LoopCond", category: "control", inputs: [{ start: 0, name: "pred", type: "tensor" }] }, { tfOpName: "Switch", category: "control", inputs: [{ start: 0, name: "data", type: "tensor" }, { start: 1, name: "pred", type: "tensor" }] }, { tfOpName: "Merge", category: "control", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }] }, { tfOpName: "Enter", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "frame_name", name: "frameName", type: "string" }, { tfName: "is_constant", name: "isConstant", type: "bool" }] }, { tfOpName: "Exit", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "NextIteration", category: "control", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "TensorArrayV3", category: "control", inputs: [{ start: 0, name: "size", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }, { tfName: "dynamic_size", name: "dynamicSize", type: "bool" }, { tfName: "clear_after_read", name: "clearAfterRead", type: "bool" }, { tfName: "identical_element_shapes", name: "identicalElementShapes", type: "bool" }, { tfName: "tensor_array_name", name: "name", type: "string" }] }, { tfOpName: "TensorArrayWriteV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "TensorArrayReadV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "index", type: "number" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "TensorArrayGatherV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape", name: "elementShape", type: "shape" }] }, { tfOpName: "TensorArrayScatterV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "indices", type: "number[]" }, { start: 2, name: "tensor", type: "tensor" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArrayConcatV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "flowIn", type: "number" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "element_shape_except0", name: "elementShapeExcept0", type: "shape", notSupported: !0 }] }, { tfOpName: "TensorArraySplitV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "tensor", type: "tensor" }, { start: 2, name: "lengths", type: "number[]" }, { start: 3, name: "flowIn", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "TensorArraySizeV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }, { start: 1, name: "flowIn", type: "number" }] }, { tfOpName: "TensorArrayCloseV3", category: "control", inputs: [{ start: 0, name: "tensorArrayId", type: "number" }] }], Y1 = Object.freeze({ json: Q1 }), Z1 = [{ tfOpName: "AvgPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "MaxPool", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "MaxPoolWithArgmax", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "include_batch_in_index", name: "includeBatchInIndex", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "AvgPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "MaxPool3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }, { tfName: "ksize", name: "kernelSize", type: "number[]" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Conv1D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "stride", name: "stride", type: "number" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NWC" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "dilation", name: "dilation", type: "number", defaultValue: 1 }] }, { tfOpName: "Conv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "useCudnnOnGpu", name: "useCudnnOnGpu", type: "bool" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "_FusedConv2D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "explicit_paddings", name: "explicitPaddings", type: "number[]", defaultValue: [] }, { tfName: "use_cudnn_on_gpu", name: "useCudnnOnGpu", type: "bool", defaultValue: !0 }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }] }, { tfOpName: "Conv2DBackpropInput", category: "convolution", inputs: [{ start: 2, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 0, name: "outputShape", type: "number[]" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }] }, { tfOpName: "DepthwiseConv2d", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "DepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "input", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }, { tfOpName: "FusedDepthwiseConv2dNative", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }, { tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]", defaultValue: [1, 1, 1, 1] }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }] }, { tfOpName: "Conv3D", category: "convolution", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "filter", type: "tensor" }], attrs: [{ tfName: "strides", name: "strides", type: "number[]" }, { tfName: "padding", name: "pad", type: "string" }, { tfName: "data_format", name: "dataFormat", type: "string", defaultValue: "NHWC" }, { tfName: "dilations", name: "dilations", type: "number[]" }] }], ex = Object.freeze({ json: Z1 }), tx = [{ tfOpName: "Fill", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }, { start: 1, name: "value", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "LinSpace", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "num", type: "number" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "OneHot", category: "creation", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "depth", type: "number" }, { start: 2, name: "onValue", type: "number", defaultValue: 1 }, { start: 3, name: "offValue", type: "number", defaultValue: 0 }], attrs: [{ tfName: "axis", name: "axis", type: "number", notSupported: !0 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Ones", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "OnesLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "RandomUniform", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "minval", name: "minval", type: "number", defaultValue: 0 }, { tfName: "maxval", name: "maxval", type: "number", defaultValue: 1 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "seed", name: "seed", type: "number", defaultValue: 0 }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: !0 }, { tfName: "T", name: "T", type: "number", notSupported: !0 }] }, { tfOpName: "Range", category: "creation", inputs: [{ start: 0, name: "start", type: "number" }, { start: 1, name: "stop", type: "number" }, { start: 2, name: "step", type: "number", defaultValue: 0 }], attrs: [{ tfName: "Tidx", name: "dtype", type: "dtype" }] }, { tfOpName: "TruncatedNormal", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "means", name: "mean", type: "number", defaultValue: 0 }, { tfName: "stddev", name: "stdDev", type: "number", defaultValue: 1 }, { tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number", defaultValue: 0, notSupported: !0 }, { tfName: "dtype", name: "dtype", type: "dtype" }, { tfName: "T", name: "T", type: "number", notSupported: !0 }] }, { tfOpName: "Zeros", category: "creation", inputs: [{ start: 0, name: "shape", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "ZerosLike", category: "creation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype" }] }, { tfOpName: "Multinomial", category: "creation", inputs: [{ start: 0, name: "logits", type: "tensor" }, { start: 1, name: "numSamples", type: "number" }], attrs: [{ tfName: "seed", name: "seed", type: "number" }, { tfName: "seed2", name: "seed2", type: "number" }, { tfName: "T", name: "dtype", type: "dtype" }, { tfName: "output_dtype", name: "output_dtype", type: "dtype" }] }], nx = Object.freeze({ json: tx }), rx = [{ tfOpName: "NonMaxSuppressionV2", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV3", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }] }, { tfOpName: "NonMaxSuppressionV5", category: "dynamic", inputs: [{ start: 0, name: "boxes", type: "tensor" }, { start: 1, name: "scores", type: "tensor" }, { start: 2, name: "maxOutputSize", type: "number" }, { start: 3, name: "iouThreshold", type: "number" }, { start: 4, name: "scoreThreshold", type: "number" }, { start: 5, name: "softNmsSigma", type: "number" }] }, { tfOpName: "Where", category: "dynamic", inputs: [{ start: 0, name: "condition", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "ListDiff", category: "dynamic", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "y", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }], ax = Object.freeze({ json: rx }), ox = [{ tfOpName: "TopKV2", category: "evaluation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "k", type: "number" }], attrs: [{ tfName: "sorted", name: "sorted", type: "bool" }] }], ix = Object.freeze({ json: ox }), sx = [{ tfOpName: "PlaceholderWithDefault", category: "graph", inputs: [{ start: 0, name: "default", type: "tensor" }], attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Placeholder", category: "graph", attrs: [{ tfName: "shape", name: "shape", type: "shape" }, { tfName: "dtype", name: "dtype", type: "dtype" }] }, { tfOpName: "Const", category: "graph" }, { tfOpName: "Identity", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IdentityN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Snapshot", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Rank", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Size", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "Shape", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "ShapeN", category: "graph", inputs: [{ start: 0, end: 0, name: "x", type: "tensors" }] }, { tfOpName: "Print", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "data", type: "tensors" }], attrs: [{ tfName: "message", name: "message", type: "string" }, { tfName: "first_n", name: "firstN", type: "number", notSupported: !0 }, { tfName: "summarize", name: "summarize", type: "number", defaultValue: 3 }] }, { tfOpName: "NoOp", category: "graph", inputs: [] }, { tfOpName: "StopGradient", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "FakeQuantWithMinMaxVars", category: "graph", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "min", name: "min", type: "number" }, { tfName: "max", name: "max", type: "number" }] }], ux = Object.freeze({ json: sx }), lx = [{ tfOpName: "ResizeBilinear", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "ResizeNearestNeighbor", category: "image", inputs: [{ start: 0, name: "images", type: "tensor" }, { start: 1, name: "size", type: "number[]" }], attrs: [{ tfName: "align_corners", name: "alignCorners", type: "bool" }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "CropAndResize", category: "image", inputs: [{ start: 0, name: "image", type: "tensor" }, { start: 1, name: "boxes", type: "tensor" }, { start: 2, name: "boxInd", type: "tensor" }, { start: 3, name: "cropSize", type: "number[]" }], attrs: [{ tfName: "method", name: "method", type: "string" }, { tfName: "extrapolation_value", name: "extrapolationValue", type: "number" }] }], cx = Object.freeze({ json: lx }), hx = [{ tfOpName: "Equal", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "NotEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Greater", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "GreaterEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Less", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "LessEqual", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "LogicalAnd", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "LogicalNot", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "LogicalOr", category: "logical", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Select", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "SelectV2", category: "logical", inputs: [{ start: 0, name: "condition", type: "tensor" }, { start: 1, name: "a", type: "tensor" }, { start: 2, name: "b", type: "tensor" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }], dx = Object.freeze({ json: hx }), px = [{ tfOpName: "_FusedMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }, { start: 2, end: 0, name: "args", type: "tensors" }], attrs: [{ tfName: "num_args", name: "numArgs", type: "number" }, { tfName: "fused_ops", name: "fusedOps", type: "string[]", defaultValue: [] }, { tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-4 }, { tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: !1 }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: !1 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "MatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "transpose_a", name: "transposeA", type: "bool", defaultValue: !1 }, { tfName: "transpose_b", name: "transposeB", type: "bool", defaultValue: !1 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "BatchMatMul", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: !1 }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: !1 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "BatchMatMulV2", category: "matrices", inputs: [{ start: 0, name: "a", type: "tensor" }, { start: 1, name: "b", type: "tensor" }], attrs: [{ tfName: "adj_x", name: "transposeA", type: "bool", defaultValue: !1 }, { tfName: "adj_y", name: "transposeB", type: "bool", defaultValue: !1 }, { tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }, { tfOpName: "Transpose", category: "matrices", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "perm", type: "number[]" }], attrs: [{ tfName: "T", name: "dtype", type: "dtype", notSupported: !0 }] }], fx = Object.freeze({ json: px }), mx = [{ tfOpName: "FusedBatchNorm", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }] }, { tfOpName: "FusedBatchNormV2", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }] }, { tfOpName: "FusedBatchNormV3", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "scale", type: "tensor" }, { start: 2, name: "offset", type: "tensor" }, { start: 3, name: "mean", type: "tensor" }, { start: 4, name: "variance", type: "tensor" }], attrs: [{ tfName: "epsilon", name: "epsilon", type: "number", defaultValue: 1e-3 }, { tfName: "data_format", name: "dataFormat", type: "string", notSupported: !0 }] }, { tfOpName: "LRN", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "depth_radius", name: "radius", type: "number", defaultValue: 5 }, { tfName: "bias", name: "bias", type: "number", defaultValue: 1 }, { tfName: "alpha", name: "alpha", type: "number", defaultValue: 1 }, { tfName: "beta", name: "beta", type: "number", defaultValue: 0.5 }] }, { tfOpName: "Softmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "LogSoftmax", category: "normalization", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "normalization", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: !0, notSupported: !0 }] }], gx = Object.freeze({ json: mx }), vx = [{ tfOpName: "Max", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Mean", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Min", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Sum", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "All", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "Any", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }, { tfOpName: "ArgMax", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "ArgMin", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Prod", category: "reduction", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }], attrs: [{ tfName: "keep_dims", name: "keepDims", type: "bool" }] }], yx = Object.freeze({ json: vx }), bx = [{ tfOpName: "ConcatV2", category: "slice_join", inputs: [{ start: 0, end: -1, name: "tensors", type: "tensors" }, { start: -1, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "Concat", category: "slice_join", inputs: [{ start: 1, end: 0, name: "tensors", type: "tensors" }, { start: 0, name: "axis", type: "number" }], attrs: [{ tfName: "N", name: "n", type: "number", defaultValue: 2 }] }, { tfOpName: "GatherV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Gather", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "validate_indices", name: "validateIndices", type: "bool", notSupported: !0 }] }, { tfOpName: "Reverse", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "dims", type: "bool", notSupported: !0 }] }, { tfOpName: "ReverseV2", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number[]" }] }, { tfOpName: "Slice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "size", type: "number[]" }] }, { tfOpName: "StridedSlice", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "begin", type: "number[]" }, { start: 2, name: "end", type: "number[]" }, { start: 3, name: "strides", type: "number[]" }], attrs: [{ tfName: "begin_mask", name: "beginMask", type: "number", defaultValue: 0 }, { tfName: "end_mask", name: "endMask", type: "number", defaultValue: 0 }, { tfName: "new_axis_mask", name: "newAxisMask", type: "number", defaultValue: 0 }, { tfName: "ellipsis_mask", name: "ellipsisMask", type: "number", defaultValue: 0 }, { tfName: "shrink_axis_mask", name: "shrinkAxisMask", type: "number", defaultValue: 0 }] }, { tfOpName: "Pack", category: "slice_join", inputs: [{ start: 0, end: 0, name: "tensors", type: "tensors" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "Unpack", category: "slice_join", inputs: [{ start: 0, name: "tensor", type: "tensor" }], attrs: [{ tfName: "axis", name: "axis", type: "number", defaultValue: 0 }, { tfName: "num", name: "num", type: "number", defaultValue: 0, notSupported: !0 }] }, { tfOpName: "Tile", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "reps", type: "number[]" }] }, { tfOpName: "Split", category: "slice_join", inputs: [{ start: 0, name: "axis", type: "number", defaultValue: 0 }, { start: 1, name: "x", type: "tensor" }], attrs: [{ tfName: "num_split", name: "numOrSizeSplits", type: "number", defaultValue: 1 }] }, { tfOpName: "SplitV", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "numOrSizeSplits", type: "number[]" }, { start: 2, name: "axis", type: "number", defaultValue: 0 }] }, { tfOpName: "ScatterNd", category: "slice_join", inputs: [{ start: 0, name: "indices", type: "tensor" }, { start: 1, name: "values", type: "tensor" }, { start: 2, name: "shape", type: "number[]" }] }, { tfOpName: "GatherNd", category: "slice_join", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "indices", type: "tensor" }] }, { tfOpName: "SparseToDense", category: "slice_join", inputs: [{ start: 0, name: "sparseIndices", type: "tensor" }, { start: 1, name: "outputShape", type: "number[]" }, { start: 2, name: "sparseValues", type: "tensor" }, { start: 3, name: "defaultValue", type: "tensor" }], attrs: [{ tfName: "validate_indices", name: "validateIndices", type: "bool", defaultValue: !1, notSupported: !0 }] }], xx = Object.freeze({ json: bx }), wx = [{ tfOpName: "FFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "IFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }] }, { tfOpName: "RFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: !0 }] }, { tfOpName: "IRFFT", category: "spectral", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "fft_length", type: "number", notSupported: !0 }] }], Cx = Object.freeze({ json: wx }), kx = [{ tfOpName: "Cast", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "SrcT", name: "sdtype", type: "dtype", notSupported: !0 }, { tfName: "DstT", name: "dtype", type: "dtype" }] }, { tfOpName: "ExpandDims", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "axis", type: "number" }] }, { tfOpName: "Pad", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }], attrs: [{ tfName: "constant_value", name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "PadV2", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "padding", type: "number[]" }, { start: 2, name: "constantValue", type: "number", defaultValue: 0 }] }, { tfOpName: "Reshape", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "shape", type: "number[]" }] }, { tfOpName: "Squeeze", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "axis", tfDeprecatedName: "squeeze_dims", name: "axis", type: "number[]" }] }, { tfOpName: "SpaceToBatchND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "paddings", type: "number[]" }] }, { tfOpName: "BatchToSpaceND", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }, { start: 1, name: "blockShape", type: "number[]" }, { start: 2, name: "crops", type: "number[]" }] }, { tfOpName: "DepthToSpace", category: "transformation", inputs: [{ start: 0, name: "x", type: "tensor" }], attrs: [{ tfName: "block_size", name: "blockSize", type: "number" }, { tfName: "data_format", name: "dataFormat", type: "string" }] }], Nx = Object.freeze({ json: kx }), Ax = function() {
  function e() {
    var n = [q1, X1, Y1, ex, nx, ax, ix, dx, cx, ux, fx, gx, yx, xx, Cx, Nx], t = [].concat.apply([], n.map(function(r) {
      return r.json;
    }));
    this.opMappers = t.reduce(function(r, a) {
      return r[a.tfOpName] = a, r;
    }, {});
  }
  return Object.defineProperty(e, "Instance", { get: function() {
    return this._instance || (this._instance = new this());
  }, enumerable: !0, configurable: !0 }), e.prototype.transformGraph = function(n, t) {
    var r = this;
    t === void 0 && (t = {});
    var a = [], o = [], i = n.node.reduce(function(d, p) {
      return d[p.name] = r.mapNode(p), p.op.startsWith("Placeholder") && a.push(d[p.name]), p.op === "Const" && o.push(d[p.name]), d;
    }, {}), s = [], u = [], l = {}, c = {};
    t != null && (l = this.mapSignatureEntries(t.inputs), c = this.mapSignatureEntries(t.outputs));
    var h = Object.keys(i);
    return h.forEach(function(d) {
      var p = i[d];
      p.inputNames.forEach(function(f) {
        var m = ua(f)[0];
        p.inputs.push(i[m]), i[m].children.push(p);
      });
    }), Object.keys(c).length === 0 ? h.forEach(function(d) {
      var p = i[d];
      p.children.length === 0 && u.push(p);
    }) : Object.keys(c).forEach(function(d) {
      var p = ua(d)[0], f = i[p];
      f != null && (f.signatureKey = c[d], u.push(f));
    }), Object.keys(l).length > 0 ? Object.keys(l).forEach(function(d) {
      var p = ua(d)[0], f = i[p];
      f && (f.signatureKey = l[d], s.push(f));
    }) : s = a, { nodes: i, inputs: s, outputs: u, weights: o, placeholders: a, signature: t };
  }, e.prototype.mapSignatureEntries = function(n) {
    return Object.keys(n || {}).reduce(function(t, r) {
      return t[n[r].name] = r, t;
    }, {});
  }, e.prototype.mapNode = function(n) {
    var t = ym(n.op) || this.opMappers[n.op] || {};
    n.attr == null && (n.attr = {});
    var r = { name: n.name, op: n.op, category: t.category, inputNames: (n.input || []).map(function(a) {
      return a.startsWith("^") ? a.substr(1) : a;
    }), inputs: [], children: [], inputParams: {}, attrParams: {}, rawAttrs: n.attr };
    return t.inputs != null && (r.inputParams = t.inputs.reduce(function(a, o) {
      return a[o.name] = { type: o.type, inputIndexStart: o.start, inputIndexEnd: o.end }, a;
    }, {})), t.attrs != null && (r.attrParams = t.attrs.reduce(function(a, o) {
      var i = o.type, s = void 0;
      switch (o.type) {
        case "string":
          (s = Gs(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Gs(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "string[]":
          (s = Js(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Js(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "number":
          (s = Ws(n.attr, o.tfName, o.defaultValue || 0)) === void 0 && o.tfDeprecatedName && (s = Ws(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "number[]":
          (s = qs(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = qs(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "bool":
          (s = Hs(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Hs(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "bool[]":
          (s = Qs(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Qs(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "shape":
          (s = Ks(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Ks(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "shape[]":
          (s = Xs(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Xs(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "dtype":
          (s = $s(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = $s(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "dtype[]":
          (s = Us(n.attr, o.tfName, o.defaultValue)) === void 0 && o.tfDeprecatedName && (s = Us(n.attr, o.tfDeprecatedName, o.defaultValue));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error("Unsupported param type: " + o.type + " for op: " + n.op);
      }
      return a[o.name] = { value: s, type: i }, a;
    }, {})), r;
  }, e;
}();
function Ix(e) {
  var n = _().global;
  if (n.atob !== void 0) return n.atob(e);
  if (typeof Buffer < "u") return new Buffer(e, "base64").toString();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function bm(e, n) {
  var t = Array.isArray(e) ? String.fromCharCode.apply(null, e) : Ix(e);
  return n ? t : t.toLowerCase();
}
function Gs(e, n, t, r) {
  r === void 0 && (r = !1);
  var a = e[n];
  return a != null ? bm(a.s, r) : t;
}
function Hs(e, n, t) {
  var r = e[n];
  return r ? r.b : t;
}
function Ws(e, n, t) {
  var r = e[n] || {}, a = r.i != null ? r.i : r.f != null ? r.f : t;
  return typeof a == "number" ? a : parseInt(a, 10);
}
function xm(e) {
  switch (typeof e == "string" && (e = qt[e]), e) {
    case qt.DT_FLOAT:
      return "float32";
    case qt.DT_INT32:
    case qt.DT_INT64:
    case qt.DT_INT8:
    case qt.DT_UINT8:
      return "int32";
    case qt.DT_BOOL:
      return "bool";
    case qt.DT_DOUBLE:
      return "float32";
    case qt.DT_STRING:
      return "string";
    default:
      return null;
  }
}
function $s(e, n, t) {
  var r = e[n];
  return r && r.type ? xm(r.type) : t;
}
function Us(e, n, t) {
  var r = e[n];
  return r && r.list && r.list.type ? r.list.type.map(function(a) {
    return xm(a);
  }) : t;
}
function wm(e) {
  if (!e.unknownRank) return e.dim != null ? e.dim.map(function(n) {
    return typeof n.size == "number" ? n.size : parseInt(n.size, 10);
  }) : [];
}
function Ks(e, n, t) {
  var r = e[n];
  return r && r.shape ? wm(r.shape) : t;
}
function qs(e, n, t) {
  var r = e[n];
  return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function(a) {
    return typeof a == "number" ? a : parseInt(a, 10);
  }) : t;
}
function Js(e, n, t, r) {
  r === void 0 && (r = !1);
  var a = e[n];
  return a && a.list && a.list.s ? a.list.s.map(function(o) {
    return bm(o, r);
  }) : t;
}
function Xs(e, n, t) {
  var r = e[n];
  return r && r.list && r.list.shape ? r.list.shape.map(function(a) {
    return wm(a);
  }) : t;
}
function Qs(e, n, t) {
  var r = e[n];
  return r && r.list && r.list.b ? r.list.b : t;
}
var Ex = function() {
  function e(n, t, r) {
    var a = this;
    this.node = n, this.tensorMap = t, this.context = r, this.inputs = [], this.attrs = {}, this.inputs = n.inputNames.map(function(o) {
      return a.getInput(o);
    }), n.rawAttrs != null && (this.attrs = Object.keys(n.rawAttrs).reduce(function(o, i) {
      return o[i] = a.getAttr(i), o;
    }, {}));
  }
  return e.prototype.getInput = function(n) {
    return gt(n, this.tensorMap, this.context);
  }, e.prototype.getAttr = function(n, t) {
    var r = this.node.rawAttrs[n];
    if (r.tensor != null) return gt(n, this.tensorMap, this.context);
    if (r.i != null || r.f != null) return Ws(this.node.rawAttrs, n, t);
    if (r.s != null) return Gs(this.node.rawAttrs, n, t);
    if (r.b != null) return Hs(this.node.rawAttrs, n, t);
    if (r.shape != null) return Ks(this.node.rawAttrs, n, t);
    if (r.type != null) return $s(this.node.rawAttrs, n, t);
    if (r.list != null) {
      if (r.list.i != null || r.list.f != null) return qs(this.node.rawAttrs, n, t);
      if (r.list.s != null) return Js(this.node.rawAttrs, n, t);
      if (r.list.shape != null) return Xs(this.node.rawAttrs, n, t);
      if (r.list.b != null) return Qs(this.node.rawAttrs, n, t);
      if (r.list.type != null) return Us(this.node.rawAttrs, n, t);
    }
    return t;
  }, e;
}(), Tx = function(e, n, t) {
  switch (e.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [_n(w("a", e, n, t), w("b", e, n, t))];
    case "AddN":
      return [cf(w("tensors", e, n, t))];
    case "FloorMod":
    case "Mod":
      return [Bp(w("a", e, n, t), w("b", e, n, t))];
    case "Mul":
      return [$e(w("a", e, n, t), w("b", e, n, t))];
    case "RealDiv":
    case "Div":
      return [Bn(w("a", e, n, t), w("b", e, n, t))];
    case "DivNoNan":
      return [Uu(w("a", e, n, t), w("b", e, n, t))];
    case "FloorDiv":
      return [Fu(w("a", e, n, t), w("b", e, n, t))];
    case "Sub":
      return [Rn(w("a", e, n, t), w("b", e, n, t))];
    case "Minimum":
      return [Mu(w("a", e, n, t), w("b", e, n, t))];
    case "Maximum":
      return [mi(w("a", e, n, t), w("b", e, n, t))];
    case "Pow":
      return [La(w("a", e, n, t), w("b", e, n, t))];
    case "SquaredDifference":
      return [Xu(w("a", e, n, t), w("b", e, n, t))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Px = function(e, n, t) {
  switch (e.op) {
    case "Abs":
    case "ComplexAbs":
      return [lp(w("x", e, n, t))];
    case "Acos":
      return [cp(w("x", e, n, t))];
    case "Acosh":
      return [hp(w("x", e, n, t))];
    case "Asin":
      return [dp(w("x", e, n, t))];
    case "Asinh":
      return [pp(w("x", e, n, t))];
    case "Atan":
      return [fp(w("x", e, n, t))];
    case "Atan2":
      return [_p(w("x", e, n, t), w("y", e, n, t))];
    case "Atanh":
      return [mp(w("x", e, n, t))];
    case "Ceil":
      return [gp(w("x", e, n, t))];
    case "Complex":
      return [nt(w("real", e, n, t), w("imag", e, n, t))];
    case "Cos":
      return [yp(w("x", e, n, t))];
    case "Cosh":
      return [bp(w("x", e, n, t))];
    case "Elu":
      return [nl(w("x", e, n, t))];
    case "Erf":
      return [xp(w("x", e, n, t))];
    case "Exp":
      return [wp(w("x", e, n, t))];
    case "Expm1":
      return [Cp(w("x", e, n, t))];
    case "Floor":
      return [kp(w("x", e, n, t))];
    case "Log":
      return [Np(w("x", e, n, t))];
    case "Log1p":
      return [Ap(w("x", e, n, t))];
    case "Imag":
      return [Xt(w("x", e, n, t))];
    case "Neg":
      return [fi(w("x", e, n, t))];
    case "Reciprocal":
      return [Ip(w("x", e, n, t))];
    case "Real":
      return [Dt(w("x", e, n, t))];
    case "Relu":
      return [al(w("x", e, n, t))];
    case "Round":
      return [Ep(w("x", e, n, t))];
    case "Selu":
      return [Qf(w("x", e, n, t))];
    case "Sigmoid":
      return [Tp(w("x", e, n, t))];
    case "Sin":
      return [Sp(w("x", e, n, t))];
    case "Sign":
      return [Pp(w("x", e, n, t))];
    case "Sinh":
      return [Dp(w("x", e, n, t))];
    case "Softplus":
      return [Op(w("x", e, n, t))];
    case "Sqrt":
      return [Rp(w("x", e, n, t))];
    case "Square":
      return [Ju(w("x", e, n, t))];
    case "Tanh":
      return [Mp(w("x", e, n, t))];
    case "Tan":
      return [Fp(w("x", e, n, t))];
    case "Relu6":
    case "ClipByValue":
      return [vp(w("x", e, n, t), w("clipValueMin", e, n, t), w("clipValueMax", e, n, t))];
    case "Rsqrt":
      return [Ru(gt(e.inputNames[0], n, t))];
    case "Prod":
      return [tl(w("x", e, n, t), w("axes", e, n, t))];
    case "LeakyRelu":
      return [Jf(w("x", e, n, t), w("alpha", e, n, t))];
    case "Prelu":
      return [rl(w("x", e, n, t), w("alpha", e, n, t))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Sx = function() {
  function e(n, t, r, a, o, i, s) {
    this.name = n, this.dtype = t, this.maxSize = r, this.elementShape = a, this.identicalElementShapes = o, this.dynamicSize = i, this.clearAfterRead = s, this.tensors = [], this.closed_ = !1, this.id = e.nextId++;
  }
  return Object.defineProperty(e.prototype, "closed", { get: function() {
    return this.closed_;
  }, enumerable: !0, configurable: !0 }), e.prototype.clearAndClose = function() {
    this.tensors.forEach(function(n) {
      return n.tensor.dispose();
    }), this.tensors = [], this.closed_ = !0;
  }, e.prototype.size = function() {
    return this.tensors.length;
  }, e.prototype.read = function(n) {
    if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
    if (n < 0 || n >= this.tensors.length) throw new Error("Tried to read from index " + n + ", but array size is: " + this.tensors.length);
    var t = this.tensors[n];
    if (t.cleared) throw new Error("TensorArray " + this.name + ": Could not read index " + n + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
    return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;
  }, e.prototype.readMany = function(n) {
    var t = this;
    return n.map(function(r) {
      return t.read(r);
    });
  }, e.prototype.write = function(n, t) {
    if (this.closed_) throw new Error("TensorArray " + this.name + " has already been closed.");
    if (n < 0 || !this.dynamicSize && n >= this.maxSize) throw new Error("Tried to write to index " + n + ", but array is not resizeable and size is: " + this.maxSize);
    var r = this.tensors[n] || {};
    if (t.dtype !== this.dtype) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + n + `,
          because the value dtype is ` + t.dtype + ", but TensorArray dtype is " + this.dtype + ".");
    if (this.size() !== 0 || this.elementShape != null && this.elementShape.length !== 0 || (this.elementShape = t.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t.shape, "TensorArray " + this.name + ": Could not write to TensorArray index " + n + "."), r && r.read) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + n + ", because it has already been read.");
    if (r && r.written) throw new Error("TensorArray " + this.name + ": Could not write to TensorArray index " + n + ", because it has already been written.");
    r.tensor = t, r.written = !0, this.tensors[n] = r;
  }, e.prototype.writeMany = function(n, t) {
    var r = this;
    if (n.length !== t.length) throw new Error("TensorArray " + this.name + ": could not write multiple tensors,because the index size: " + n.length + " is not the same as tensors size: " + t.length + ".");
    n.forEach(function(a, o) {
      return r.write(a, t[o]);
    });
  }, e.prototype.gather = function(n, t) {
    if (t && t !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but gather requested dtype " + t);
    if (!n) {
      n = [];
      for (var r = 0; r < this.size(); r++) n.push(r);
    }
    if (n.length === 0) return rt([], [0].concat(this.elementShape));
    var a = this.readMany(n);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, a[0].shape, "TensorArray shape mismatch: "), Mn(a, 0);
  }, e.prototype.concat = function(n) {
    if (n && n !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but concat requested dtype " + n);
    if (this.size() === 0) return rt([], [0].concat(this.elementShape));
    for (var t = [], r = 0; r < this.size(); r++) t.push(r);
    var a = this.readMany(t);
    return this.assertShapesMatchAllowUndefinedSize(this.elementShape, a[0].shape, "TensorArray shape mismatch: tensor array shape (" + this.elementShape + ") vs first tensor shape (" + a[0].shape + ")"), Gt(a, 0);
  }, e.prototype.scatter = function(n, t) {
    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
    if (n.length !== t.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + n.length + " vs. " + t.shape[0]);
    var r = Math.max.apply(Math, n);
    if (!this.dynamicSize && r >= this.maxSize) throw new Error("Max index must be < array size (" + r + "  vs. " + this.maxSize + ")");
    this.writeMany(n, qa(t, 0));
  }, e.prototype.split = function(n, t) {
    var r = this;
    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is " + this.dtype + " but tensor has dtype " + t.dtype);
    var a = 0, o = n.map(function(c) {
      return a += c;
    });
    if (a !== t.shape[0]) throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ` + a + ", and tensor's shape is: " + t.shape);
    if (!this.dynamicSize && n.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (" + this.maxSize + " vs. " + n.length + "), and the TensorArray is not marked as dynamically resizeable");
    var i = a === 0 ? 0 : t.size / a, s = [];
    de(function() {
      t = t.reshape([1, a, i]);
      for (var c = 0; c < n.length; ++c) {
        var h = [0, c === 0 ? 0 : o[c - 1], 0], d = [1, n[c], i];
        s[c] = hn(t, h, d).reshape(r.elementShape);
      }
      return s;
    });
    for (var u = [], l = 0; l < n.length; l++) u[l] = l;
    this.writeMany(u, s);
  }, e.prototype.assertShapesMatchAllowUndefinedSize = function(n, t, r) {
    r === void 0 && (r = ""), tr.assert(this.shapesEqualAllowUndefinedSize(n, t), function() {
      return r + " Shapes " + n + " and " + t + " must match";
    });
  }, e.prototype.shapesEqualAllowUndefinedSize = function(n, t) {
    if (n.length !== t.length) return !1;
    for (var r = 0; r < n.length; r++) if (n[r] !== -1 && t[r] !== -1 && n[r] !== t[r]) return !1;
    return !0;
  }, e.nextId = 0, e;
}(), Dx = void 0, Ox = function(e, n, t) {
  return Yn(Dx, void 0, void 0, function() {
    var r, a, o, i, s, u, l, c, h, d, p, f, m, g, v, y, b, x, C, N, T, I, E, P, O, R, z, j, B, H, W, L, $, K, J;
    return Zn(this, function(ee) {
      switch (ee.label) {
        case 0:
          switch (e.op) {
            case "LoopCond":
              return [3, 1];
            case "Switch":
              return [3, 2];
            case "Merge":
              return [3, 4];
            case "Enter":
              return [3, 5];
            case "Exit":
              return [3, 6];
            case "NextIteration":
              return [3, 7];
            case "TensorArrayV3":
              return [3, 8];
            case "TensorArrayWriteV3":
              return [3, 9];
            case "TensorArrayReadV3":
              return [3, 10];
            case "TensorArrayGatherV3":
              return [3, 11];
            case "TensorArrayScatterV3":
              return [3, 12];
            case "TensorArrayConcatV3":
              return [3, 13];
            case "TensorArraySplitV3":
              return [3, 14];
            case "TensorArraySizeV3":
              return [3, 15];
            case "TensorArrayCloseV3":
              return [3, 16];
          }
          return [3, 17];
        case 1:
          return [2, [w("pred", e, n, t).clone()]];
        case 2:
          return r = w("pred", e, n, t), a = w("data", e, n, t), [4, r.data()];
        case 3:
          return [2, ee.sent()[0] ? [void 0, a.clone()] : [a.clone(), void 0]];
        case 4:
          return [2, (o = e.inputNames.find(function(ne) {
            return gt(ne, n, t) !== void 0;
          })) ? [gt(o, n, t).clone()] : void 0];
        case 5:
          return i = w("frameName", e, n, t), s = w("tensor", e, n, t), t.enterFrame(i), [2, [s.clone()]];
        case 6:
          return u = w("tensor", e, n, t), t.exitFrame(), [2, [u.clone()]];
        case 7:
          return l = w("tensor", e, n, t), t.nextIteration(), [2, [l.clone()]];
        case 8:
          return c = w("size", e, n, t), h = w("dtype", e, n, t), d = w("elementShape", e, n, t), p = w("dynamicSize", e, n, t), f = w("clearAfterRead", e, n, t), m = w("identicalElementShapes", e, n, t), g = w("name", e, n, t), v = new Sx(g, h, c, d, m, p, f), t.addTensorArray(v), [2, [X(v.id), X(1)]];
        case 9:
          return y = w("tensorArrayId", e, n, t), b = w("index", e, n, t), x = w("tensor", e, n, t), t.getTensorArray(y).write(b, x), [2, [X(1)]];
        case 10:
          return C = w("tensorArrayId", e, n, t), N = w("index", e, n, t), [2, [t.getTensorArray(C).read(N)]];
        case 11:
          return T = w("tensorArrayId", e, n, t), I = w("indices", e, n, t), E = w("dtype", e, n, t), [2, [t.getTensorArray(T).gather(I, E)]];
        case 12:
          return P = w("tensorArrayId", e, n, t), O = w("indices", e, n, t), R = w("tensor", e, n, t), t.getTensorArray(P).scatter(O, R), [2, [X(1)]];
        case 13:
          return z = w("tensorArrayId", e, n, t), j = t.getTensorArray(z), B = w("dtype", e, n, t), [2, [j.concat(B)]];
        case 14:
          return H = w("tensorArrayId", e, n, t), W = w("tensor", e, n, t), L = w("lengths", e, n, t), t.getTensorArray(H).split(L, W), [2, [X(1)]];
        case 15:
          return $ = w("tensorArrayId", e, n, t), K = t.getTensorArray($), [2, [X(K.size(), "int32")]];
        case 16:
          return J = w("tensorArrayId", e, n, t), t.getTensorArray(J).clearAndClose(), [2, [X(0)]];
        case 17:
          throw TypeError("Node type " + e.op + " is not implemented");
      }
    });
  });
}, Rx = function(e, n, t) {
  switch (e.op) {
    case "Conv1D":
      var r = w("stride", e, n, t), a = w("pad", e, n, t), o = w("dataFormat", e, n, t).toUpperCase(), i = w("dilation", e, n, t);
      return [Tf(w("x", e, n, t), w("filter", e, n, t), r, a, o, i)];
    case "Conv2D":
      r = w("strides", e, n, t), a = w("pad", e, n, t), o = w("dataFormat", e, n, t).toUpperCase();
      var s = w("dilations", e, n, t);
      return [ma(w("x", e, n, t), w("filter", e, n, t), [r[1], r[2]], a, o, [s[1], s[2]])];
    case "_FusedConv2D":
    case "FusedDepthwiseConv2dNative":
      var u = w("fusedOps", e, n, t), l = u[0], c = u[1], h = l === "biasadd", d = c === "prelu", p = l === "fusedbatchnorm", f = w("numArgs", e, n, t);
      if (h) {
        if (d && f !== 2) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!d && f !== 1) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
      }
      if (p) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");
      r = w("strides", e, n, t), a = w("pad", e, n, t), o = w("dataFormat", e, n, t).toUpperCase(), s = w("dilations", e, n, t);
      var m = w("args", e, n, t), g = m[0], v = m[1];
      return [(e.op === "_FusedConv2D" ? ni.conv2d : ni.depthwiseConv2d)({ x: w("x", e, n, t), filter: w("filter", e, n, t), strides: [r[1], r[2]], pad: a, dataFormat: o, dilations: [s[1], s[2]], bias: g, activation: c, preluActivationWeights: v })];
    case "Conv2DBackpropInput":
    case "Conv2dTranspose":
      var y = w("outputShape", e, n, t);
      return r = w("strides", e, n, t), a = w("pad", e, n, t), [Rf(w("x", e, n, t), w("filter", e, n, t), y, [r[1], r[2]], a)];
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d":
      return r = w("strides", e, n, t), a = w("pad", e, n, t), s = w("dilations", e, n, t), o = w("dataFormat", e, n, t).toUpperCase(), [wi(w("input", e, n, t), w("filter", e, n, t), [r[1], r[2]], a, o, [s[1], s[2]])];
    case "Conv3D":
      return r = w("strides", e, n, t), a = w("pad", e, n, t), o = w("dataFormat", e, n, t).toUpperCase(), s = w("dilations", e, n, t), [Pf(w("x", e, n, t), w("filter", e, n, t), [r[1], r[2], r[3]], a, o, [s[1], s[2], s[3]])];
    case "AvgPool":
      r = w("strides", e, n, t), a = w("pad", e, n, t);
      var b = w("kernelSize", e, n, t);
      return [Bf(w("x", e, n, t), [b[1], b[2]], [r[1], r[2]], a)];
    case "MaxPool":
      return r = w("strides", e, n, t), a = w("pad", e, n, t), b = w("kernelSize", e, n, t), [_f(w("x", e, n, t), [b[1], b[2]], [r[1], r[2]], a)];
    case "MaxPoolWithArgmax":
      r = w("strides", e, n, t), a = w("pad", e, n, t), b = w("kernelSize", e, n, t);
      var x = w("includeBatchInIndex", e, n, t), C = Lf(w("x", e, n, t), [b[1], b[2]], [r[1], r[2]], a, x);
      return [C.result, C.indexes];
    case "AvgPool3D":
      return r = w("strides", e, n, t), a = w("pad", e, n, t), b = w("kernelSize", e, n, t), [Vf(w("x", e, n, t), [b[1], b[2], b[3]], [r[1], r[2], r[3]], a)];
    case "MaxPool3D":
      return r = w("strides", e, n, t), a = w("pad", e, n, t), b = w("kernelSize", e, n, t), [jf(w("x", e, n, t), [b[1], b[2], b[3]], [r[1], r[2], r[3]], a)];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Fx = function(e, n, t) {
  switch (e.op) {
    case "Fill":
      var r = w("shape", e, n, t), a = w("dtype", e, n, t), o = w("value", e, n, t);
      return [ci(r, o, a)];
    case "LinSpace":
      var i = w("start", e, n, t), s = w("stop", e, n, t), u = w("num", e, n, t);
      return [Qd(i, s, u)];
    case "Multinomial":
      var l = w("logits", e, n, t), c = w("numSamples", e, n, t), h = w("seed", e, n, t);
      return [bf(l, c, h)];
    case "OneHot":
      var d = w("indices", e, n, t), p = w("depth", e, n, t), f = w("onValue", e, n, t), m = w("offValue", e, n, t);
      return [za(d, p, f, m)];
    case "Ones":
      return [Pr(w("shape", e, n, t), w("dtype", e, n, t))];
    case "OnesLike":
      return [Pu(w("x", e, n, t))];
    case "RandomUniform":
      return [qu(w("shape", e, n, t), w("minval", e, n, t), w("maxval", e, n, t), w("dtype", e, n, t))];
    case "Range":
      i = w("start", e, n, t);
      var g = w("stop", e, n, t), v = w("step", e, n, t);
      return [Va(i, g, v, w("dtype", e, n, t))];
    case "TruncatedNormal":
      r = w("shape", e, n, t);
      var y = w("mean", e, n, t), b = w("stdDev", e, n, t);
      return h = w("seed", e, n, t), [xf(r, y, b, w("dtype", e, n, t), h)];
    case "Zeros":
      return [je(w("shape", e, n, t), w("dtype", e, n, t))];
    case "ZerosLike":
      return [ve(w("x", e, n, t))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Mx = void 0, _x = function(e, n, t) {
  return Yn(Mx, void 0, void 0, function() {
    var r, a, o, i, s, u, l, c;
    return Zn(this, function(h) {
      switch (h.label) {
        case 0:
          switch (e.op) {
            case "NonMaxSuppressionV5":
            case "NonMaxSuppressionV3":
            case "NonMaxSuppressionV2":
              return [3, 1];
            case "Where":
              return [3, 5];
            case "ListDiff":
              return [3, 7];
          }
          return [3, 8];
        case 1:
          return r = w("boxes", e, n, t), a = w("scores", e, n, t), o = w("maxOutputSize", e, n, t), i = w("iouThreshold", e, n, t), s = w("scoreThreshold", e, n, t), e.op !== "NonMaxSuppressionV5" ? [3, 3] : (u = w("softNmsSigma", e, n, t), [4, aa.nonMaxSuppressionWithScoreAsync(r, a, o, i, s, u)]);
        case 2:
          return [2, [(c = h.sent()).selectedIndices, c.selectedScores]];
        case 3:
          return [4, aa.nonMaxSuppressionAsync(r, a, o, i, s)];
        case 4:
          return [2, [h.sent()]];
        case 5:
          return l = w("condition", e, n, t).asType("bool"), [4, $u(l)];
        case 6:
          return c = [h.sent()], l.dispose(), [2, c];
        case 7:
          return [2, ep(w("x", e, n, t), w("y", e, n, t))];
        case 8:
          throw TypeError("Node type " + e.op + " is not implemented");
      }
    });
  });
}, Bx = function(e, n, t) {
  switch (e.op) {
    case "TopKV2":
      var r = w("x", e, n, t), a = w("k", e, n, t), o = w("sorted", e, n, t), i = tm(r, a, o);
      return [i.values, i.indices];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, jx = function(e, n, t) {
  switch (e.op) {
    case "Const":
      return n[e.name];
    case "PlaceholderWithDefault":
      var r = w("default", e, n, t);
      return [gt(e.name, n, t) || r];
    case "Placeholder":
      return [gt(e.name, n, t)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars":
      return [w("x", e, n, t).clone()];
    case "IdentityN":
      return w("x", e, n, t).map(function(l) {
        return l.clone();
      });
    case "Snapshot":
      return [w("x", e, n, t).clone()];
    case "Shape":
      return [Fn(w("x", e, n, t).shape, "int32")];
    case "ShapeN":
      return w("x", e, n, t).map(function(l) {
        return Fn(l.shape);
      });
    case "Size":
      return [X(w("x", e, n, t).size, "int32")];
    case "Rank":
      return [X(w("x", e, n, t).rank, "int32")];
    case "NoOp":
      return [X(1)];
    case "Print":
      var a = w("x", e, n, t), o = w("data", e, n, t), i = w("message", e, n, t), s = w("summarize", e, n, t);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(i);
      for (var u = 0; u < o.length; u++) console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0, s));
      return [a];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Vx = function(e, n, t) {
  switch (e.op) {
    case "ResizeBilinear":
      var r = w("images", e, n, t), a = w("size", e, n, t), o = w("alignCorners", e, n, t);
      return [aa.resizeBilinear(r, [a[0], a[1]], o)];
    case "ResizeNearestNeighbor":
      return r = w("images", e, n, t), a = w("size", e, n, t), o = w("alignCorners", e, n, t), [aa.resizeNearestNeighbor(r, [a[0], a[1]], o)];
    case "CropAndResize":
      var i = w("image", e, n, t), s = w("boxes", e, n, t), u = w("boxInd", e, n, t), l = w("cropSize", e, n, t), c = w("method", e, n, t), h = w("extrapolationValue", e, n, t);
      return [aa.cropAndResize(i, s, u, l, c, h)];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Lx = function(e, n, t) {
  switch (e.op) {
    case "Equal":
      return [Qu(w("a", e, n, t), w("b", e, n, t))];
    case "NotEqual":
      return [Nf(w("a", e, n, t), w("b", e, n, t))];
    case "Greater":
      return [wf(w("a", e, n, t), w("b", e, n, t))];
    case "GreaterEqual":
      return [Yu(w("a", e, n, t), w("b", e, n, t))];
    case "Less":
      return [Cf(w("a", e, n, t), w("b", e, n, t))];
    case "LessEqual":
      return [kf(w("a", e, n, t), w("b", e, n, t))];
    case "LogicalAnd":
      return [Xa(w("a", e, n, t), w("b", e, n, t))];
    case "LogicalNot":
      return [vf(w("a", e, n, t))];
    case "LogicalOr":
      return [Wu(w("a", e, n, t), w("b", e, n, t))];
    case "Select":
    case "SelectV2":
      return [nr(w("condition", e, n, t), w("a", e, n, t), w("b", e, n, t))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, zx = function(e, n, t) {
  switch (e.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [el(w("a", e, n, t), w("b", e, n, t), w("transposeA", e, n, t), w("transposeB", e, n, t))];
    case "Transpose":
      return [Lt(w("x", e, n, t), w("perm", e, n, t))];
    case "_FusedMatMul":
      var r = w("fusedOps", e, n, t), a = r[0], o = r[1], i = a === "biasadd", s = o === "prelu", u = w("numArgs", e, n, t);
      if (i) {
        if (s && u !== 2) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!s && u !== 1) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }
      var l = w("args", e, n, t), c = l[0], h = l[1];
      return [ni.matMul({ a: w("a", e, n, t), b: w("b", e, n, t), transposeA: w("transposeA", e, n, t), transposeB: w("transposeB", e, n, t), bias: c, activation: o, preluActivationWeights: h })];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Gx = function(e, n, t) {
  switch (e.op) {
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
    case "FusedBatchNormV3":
      return [fa(w("x", e, n, t), w("mean", e, n, t), w("variance", e, n, t), w("offset", e, n, t), w("scale", e, n, t), w("epsilon", e, n, t))];
    case "LRN":
      return [Yf(w("x", e, n, t), w("radius", e, n, t), w("bias", e, n, t), w("alpha", e, n, t), w("beta", e, n, t))];
    case "Softmax":
      return [vi(w("x", e, n, t))];
    case "LogSoftmax":
      return [Gp(w("x", e, n, t))];
    case "SparseToDense":
      return [il(w("sparseIndices", e, n, t), w("outputShape", e, n, t), w("sparseValues", e, n, t), w("defaultValue", e, n, t))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Hx = function(e, n, t) {
  switch (e.op) {
    case "Max":
      var r = w("axis", e, n, t), a = w("keepDims", e, n, t);
      return [Uf(w("x", e, n, t), r, a)];
    case "Mean":
      return r = w("axis", e, n, t), a = w("keepDims", e, n, t), [Kf(w("x", e, n, t), r, a)];
    case "Min":
      return r = w("axis", e, n, t), a = w("keepDims", e, n, t), [qf(w("x", e, n, t), r, a)];
    case "Sum":
      return r = w("axis", e, n, t), a = w("keepDims", e, n, t), [Pn(w("x", e, n, t), r, a)];
    case "All":
      return r = w("axis", e, n, t), a = w("keepDims", e, n, t), [Gf(w("x", e, n, t), r, a)];
    case "Any":
      return r = w("axis", e, n, t), a = w("keepDims", e, n, t), [Hf(w("x", e, n, t), r, a)];
    case "ArgMax":
      return r = w("axis", e, n, t), [Wf(w("x", e, n, t), r)];
    case "ArgMin":
      return r = w("axis", e, n, t), [$f(w("x", e, n, t), r)];
    case "Prod":
      return r = w("axis", e, n, t), a = w("keepDims", e, n, t), [tl(w("x", e, n, t), r, a)];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Wx = function(e, n, t) {
  switch (e.op) {
    case "ConcatV2":
    case "Concat":
      var r = w("n", e, n, t), a = w("axis", e, n, t), o = w("tensors", e, n, t);
      return o = o.slice(0, r), [Gt(o, a)];
    case "GatherV2":
    case "Gather":
      a = w("axis", e, n, t);
      var i = w("x", e, n, t), s = w("indices", e, n, t);
      return [xi(i, s.asType("int32"), a)];
    case "ReverseV2":
    case "Reverse":
      return a = w("axis", e, n, t), i = w("x", e, n, t), [ga(i, a)];
    case "Slice":
      var u = w("begin", e, n, t), l = w("size", e, n, t);
      return [hn(w("x", e, n, t), u, l)];
    case "StridedSlice":
      u = w("begin", e, n, t);
      var c = w("end", e, n, t), h = w("strides", e, n, t), d = w("beginMask", e, n, t), p = w("endMask", e, n, t), f = w("ellipsisMask", e, n, t), m = w("newAxisMask", e, n, t), g = w("shrinkAxisMask", e, n, t), v = w("x", e, n, t);
      if (u.length === 1 && v.shape.length > 1) for (var y = 1; y < v.shape.length; y++) u.push(0), c.push(v.shape[y]), h.push(h[0]);
      return [em(v, u, c, h, d, p, f, m, g)];
    case "Pack":
      return de(function() {
        var P = w("axis", e, n, t), O = w("tensors", e, n, t), R = O[0].shape, z = O[0].squeeze().shape, j = O.map(function(B) {
          var H = tr.arraysEqual(B.shape, R);
          if (!H && !tr.arraysEqual(B.squeeze().shape, z)) throw new Error("the input tensors shape does not match");
          return H ? B : B.reshape(R);
        });
        return [Mn(j, P)];
      });
    case "Unpack":
      return de(function() {
        var P = w("axis", e, n, t), O = w("tensor", e, n, t);
        return qa(O, P);
      });
    case "Tile":
      var b = w("reps", e, n, t);
      return [kr(w("x", e, n, t), b)];
    case "Split":
    case "SplitV":
      a = w("axis", e, n, t);
      var x = w("numOrSizeSplits", e, n, t);
      return hi(w("x", e, n, t), x, a);
    case "ScatterNd":
      s = w("indices", e, n, t);
      var C = w("values", e, n, t), N = w("shape", e, n, t);
      return [nm(s, C, N)];
    case "GatherNd":
      var T = w("x", e, n, t);
      return s = w("indices", e, n, t), [rm(T, s)];
    case "SparseToDense":
      s = w("sparseIndices", e, n, t), N = w("outputShape", e, n, t);
      var I = w("sparseValues", e, n, t), E = w("defaultValue", e, n, t);
      return [il(s, I, N, I.dtype === E.dtype ? E : E.asType(I.dtype))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, $x = function(e, n, t) {
  switch (e.op) {
    case "FFT":
      return [Ci(w("x", e, n, t))];
    case "IFFT":
      return [Ga(w("x", e, n, t))];
    case "RFFT":
      return [ki(w("x", e, n, t))];
    case "IRFFT":
      return [ol(w("x", e, n, t))];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
}, Ux = function(e, n, t) {
  switch (e.op) {
    case "Cast":
      return [Yd(w("x", e, n, t), w("dtype", e, n, t))];
    case "ExpandDims":
      var r = w("axis", e, n, t);
      return [Tn(w("x", e, n, t), r)];
    case "Squeeze":
      return r = w("axis", e, n, t), [Ou(w("x", e, n, t), r)];
    case "Reshape":
      return [un(w("x", e, n, t), w("shape", e, n, t))];
    case "PadV2":
    case "Pad":
      return [ir(w("x", e, n, t), ns(w("padding", e, n, t), 2), w("constantValue", e, n, t))];
    case "SpaceToBatchND":
      var a = w("blockShape", e, n, t), o = ns(w("paddings", e, n, t), 2);
      return [Du(w("x", e, n, t), a, o)];
    case "BatchToSpaceND":
      a = w("blockShape", e, n, t);
      var i = ns(w("crops", e, n, t), 2);
      return [Su(w("x", e, n, t), a, i)];
    case "DepthToSpace":
      var s = w("blockSize", e, n, t), u = w("dataFormat", e, n, t).toUpperCase();
      return [Zd(w("x", e, n, t), s, u)];
    default:
      throw TypeError("Node type " + e.op + " is not implemented");
  }
};
function wc(e, n, t) {
  var r = function(a, o, i) {
    switch (a.category) {
      case "arithmetic":
        return de(function() {
          return Tx(a, o, i);
        });
      case "basic_math":
        return de(function() {
          return Px(a, o, i);
        });
      case "control":
        return Ox(a, o, i);
      case "convolution":
        return de(function() {
          return Rx(a, o, i);
        });
      case "creation":
        return de(function() {
          return Fx(a, o, i);
        });
      case "dynamic":
        return _x(a, o, i);
      case "evaluation":
        return de(function() {
          return Bx(a, o, i);
        });
      case "image":
        return de(function() {
          return Vx(a, o, i);
        });
      case "graph":
        return de(function() {
          return jx(a, o, i);
        });
      case "logical":
        return de(function() {
          return Lx(a, o, i);
        });
      case "matrices":
        return de(function() {
          return zx(a, o, i);
        });
      case "normalization":
        return de(function() {
          return Gx(a, o, i);
        });
      case "reduction":
        return de(function() {
          return Hx(a, o, i);
        });
      case "slice_join":
        return de(function() {
          return Wx(a, o, i);
        });
      case "spectral":
        return de(function() {
          return $x(a, o, i);
        });
      case "transformation":
        return de(function() {
          return Ux(a, o, i);
        });
      case "custom":
        var s = ym(a.op);
        if (s && s.customExecutor) return s.customExecutor(new Ex(a, o, i));
        throw TypeError("Custom op " + a.op + " is not registered.");
      default:
        throw TypeError("Unknown op '" + a.op + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
    }
  }(e, n, t);
  return r instanceof Promise ? r.then(function(a) {
    return [].concat(a);
  }) : [].concat(r);
}
var Cc = function() {
  function e(n, t) {
    this.weightMap = n, this.tensorArrayMap = t, this.rootContext = { id: 0, frameName: "", iterationId: 0 }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds();
  }
  return e.prototype.newFrame = function(n, t) {
    return { id: n, frameName: t, iterationId: 0 };
  }, Object.defineProperty(e.prototype, "currentContext", { get: function() {
    return this.contexts;
  }, set: function(n) {
    this.contexts !== n && (this.contexts = n, this.generateCurrentContextIds());
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "currentContextId", { get: function() {
    return this._currentContextIds[0];
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "currentContextIds", { get: function() {
    return this._currentContextIds;
  }, enumerable: !0, configurable: !0 }), e.prototype.generateCurrentContextIds = function() {
    for (var n = [], t = 0; t < this.contexts.length - 1; t++) {
      var r = this.contexts.slice(0, this.contexts.length - t);
      n.push(this.contextIdforContexts(r));
    }
    n.push(""), this._currentContextIds = n;
  }, e.prototype.contextIdforContexts = function(n) {
    return n ? n.map(function(t) {
      return t.id === 0 && t.iterationId === 0 ? "" : t.frameName + "-" + t.iterationId;
    }).join("/") : "";
  }, e.prototype.enterFrame = function(n) {
    this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, n)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
  }, e.prototype.exitFrame = function() {
    if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
    this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
  }, e.prototype.nextIteration = function() {
    if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
    this.contexts = this.contexts.slice(), this.lastId++;
    var n = Object.assign({}, this.contexts[this.contexts.length - 1]);
    n.iterationId += 1, n.id = this.lastId, this.contexts.splice(-1, 1, n), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
  }, e.prototype.getWeight = function(n) {
    return this.weightMap[n];
  }, e.prototype.addTensorArray = function(n) {
    this.tensorArrayMap[n.id] = n;
  }, e.prototype.getTensorArray = function(n) {
    return this.tensorArrayMap[n];
  }, e;
}();
function kc(e, n, t) {
  for (var r = /* @__PURE__ */ new Set(), a = [], o = null, i = null, s = /* @__PURE__ */ new Set(), u = Object.keys(e).map(function(h) {
    return Et(h)[0];
  }), l = n.slice(); l.length > 0; ) {
    var c = l.pop();
    (Cm(c) || Xx(c)) && o == null && (i = (o = c).children.map(function(h) {
      return h.name;
    }).filter(function(h) {
      return r.has(h);
    })), r.add(c.name), t[c.name] == null && u.indexOf(c.name) === -1 && (c.inputs.length !== 0 ? c.inputs.forEach(function(h) {
      s.has(h.name) || (s.add(h.name), l.push(h));
    }) : a.push(c.name));
  }
  return { inputs: e, outputs: n, usedNodes: r, missingInputs: a, dynamicNode: o, syncInputs: i };
}
function Kx(e, n, t) {
  var r = t.usedNodes, a = t.inputs, o = [];
  Object.keys(a).map(function(l) {
    return Et(l)[0];
  }).map(function(l) {
    return e.nodes[l];
  }).forEach(function(l) {
    r.has(l.name) && o.push(l);
  }), e.weights.forEach(function(l) {
    r.has(l.name) && o.push(l);
  });
  for (var i = /* @__PURE__ */ new Set(), s = []; o.length > 0; ) {
    var u = o.pop();
    i.add(u.name), n[u.name] || s.push(u), u.children.forEach(function(l) {
      !i.has(l.name) && r.has(l.name) && l.inputs.every(function(c) {
        return i.has(c.name);
      }) && o.push(l);
    });
  }
  return s;
}
var qx = ["Switch", "Merge", "Enter", "Exit", "NextIteration"], Jx = ["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"];
function Cm(e) {
  return qx.indexOf(e.op) >= 0;
}
function Xx(e) {
  return Jx.indexOf(e.op) >= 0;
}
var Qx = function() {
  function e(n) {
    this.graph = n, this.compiledMap = /* @__PURE__ */ new Map(), this._weightMap = {}, this.SEPERATOR = ",", this._outputs = n.outputs, this._inputs = n.inputs, this._signature = n.signature;
  }
  return Object.defineProperty(e.prototype, "weightMap", { get: function() {
    return this._weightMap;
  }, set: function(n) {
    var t = Object.keys(n).map(function(r) {
      return n[r].map(function(a) {
        return a.id;
      });
    });
    this.weightIds = [].concat.apply([], t), this._weightMap = n;
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "inputs", { get: function() {
    return this._inputs.map(function(n) {
      return { name: n.name, shape: n.attrParams.shape ? n.attrParams.shape.value : void 0, dtype: n.attrParams.dtype ? n.attrParams.dtype.value : void 0 };
    });
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "outputs", { get: function() {
    return this._outputs.map(function(n) {
      return { name: n.name, shape: n.attrParams.shape ? n.attrParams.shape.value : void 0, dtype: n.attrParams.dtype ? n.attrParams.dtype.value : void 0 };
    });
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "inputNodes", { get: function() {
    return this._inputs.map(function(n) {
      return n.signatureKey || n.name;
    });
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "outputNodes", { get: function() {
    return this._outputs.map(function(n) {
      return n.signatureKey || n.name;
    });
  }, enumerable: !0, configurable: !0 }), e.prototype.getCompilationKey = function(n, t) {
    var r = n.map(function(o) {
      return o.name;
    }).sort(), a = t.map(function(o) {
      return o.name;
    }).sort();
    return r.join(this.SEPERATOR) + "--" + a.join(this.SEPERATOR);
  }, e.prototype.compile = function(n, t) {
    var r = kc(n, t, this.weightMap), a = r.missingInputs, o = r.dynamicNode, i = r.syncInputs;
    if (o != null) throw new Error("This execution contains the node '" + o.name + "', which has the dynamic op '" + o.op + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + i + "]");
    if (a.length > 0) {
      var s = t.map(function(l) {
        return l.name;
      }), u = Object.keys(n);
      throw new Error("Cannot compute the outputs [" + s + "] from the provided inputs [" + u + "]. Missing the following inputs: [" + a + "]");
    }
    return Kx(this.graph, this.weightMap, r);
  }, e.prototype.execute = function(n, t) {
    var r = this;
    n = this.mapInputs(n);
    var a = Object.keys(n).sort();
    this.checkInputs(n), this.checkInputShapeAndType(n), t = this.mapOutputs(t), this.checkOutputs(t);
    var o = a.map(function(c) {
      return r.graph.nodes[Et(c)[0]];
    }), i = t.map(function(c) {
      return r.graph.nodes[Et(c)[0]];
    }), s = this.getCompilationKey(o, i), u = this.compiledMap.get(s);
    u == null && (u = this.compile(n, i), this.compiledMap.set(s, u));
    var l = {};
    return de(function() {
      var c = new Cc(r._weightMap, l), h = zs({}, r.weightMap);
      Object.keys(n).forEach(function(v) {
        var y = Et(v), b = y[0], x = [];
        x[y[1]] = n[v], h[b] = x;
      });
      for (var d = r.getFrozenTensorIds(h), p = {}, f = 0; f < u.length; f++) {
        var m = u[f];
        if (!h[m.name]) {
          var g = wc(m, h, c);
          if (g instanceof Promise) throw new Error("The execution of the op '" + m.op + "' returned a promise. Please use model.executeAsync() instead.");
          h[m.name] = g, r.checkTensorForDisposal(m.name, m, h, c, d, t, p);
        }
      }
      return t.map(function(v) {
        return gt(v, h, c);
      });
    });
  }, e.prototype.getFrozenTensorIds = function(n) {
    var t = [].concat.apply([], Object.keys(n).map(function(r) {
      return n[r];
    }).map(function(r) {
      return r.map(function(a) {
        return a.id;
      });
    }));
    return new Set(t);
  }, e.prototype.checkTensorForDisposal = function(n, t, r, a, o, i, s) {
    t.category !== "control" && i.indexOf(n) === -1 && (r[n].forEach(function(u) {
      u != null && (s[u.id] = (s[u.id] || 0) + t.children.length);
    }), t.inputs.forEach(function(u) {
      if (u.category !== "control") {
        var l = U1(u.name, r, a);
        l != null && l.forEach(function(c) {
          if (c && !o.has(c.id)) {
            var h = s[c.id];
            h === 1 ? (c.dispose(), delete s[c.id]) : h != null && s[c.id]--;
          }
        });
      }
    }));
  }, e.prototype.executeAsync = function(n, t) {
    return Yn(this, void 0, void 0, function() {
      var r, a, o, i, s, u, l = this;
      return Zn(this, function(c) {
        switch (c.label) {
          case 0:
            return n = this.mapInputs(n), this.checkInputs(n), this.checkInputShapeAndType(n), t = this.mapOutputs(t), this.checkOutputs(t), r = {}, a = new Cc(this._weightMap, r), [4, this.executeWithControlFlow(n, a, t)];
          case 1:
            return o = c.sent(), i = t.map(function(h) {
              return gt(h, o, a);
            }), s = new Set(i.map(function(h) {
              return h.id;
            })), u = new Set(Object.keys(n).map(function(h) {
              return n[h].id;
            })), Object.keys(o).forEach(function(h) {
              o[h].forEach(function(d) {
                !d || d.isDisposed || s.has(d.id) || u.has(d.id) || l.weightIds.indexOf(d.id) !== -1 || d.dispose();
              });
            }), [2, i];
        }
      });
    });
  }, e.prototype.executeWithControlFlow = function(n, t, r) {
    return Yn(this, void 0, void 0, function() {
      var a, o, i, s, u, l, c, h, d, p, f, m, g, v, y, b, x = this;
      return Zn(this, function(C) {
        switch (C.label) {
          case 0:
            a = Object.keys(n), o = a.map(function(N) {
              return x.graph.nodes[Et(N)[0]];
            }), i = r.map(function(N) {
              return x.graph.nodes[Et(N)[0]];
            }), s = kc(n, i, this.weightMap), u = s.usedNodes, l = s.missingInputs, c = s.dynamicNode, h = s.syncInputs, d = o.concat(this.graph.weights).map(function(N) {
              return { node: N, contexts: t.currentContext };
            }), p = zs({}, this.weightMap), Object.keys(n).forEach(function(N) {
              var T = Et(N), I = T[0], E = [];
              E[T[1]] = n[N], p[I] = E;
            }), f = {}, m = this.getFrozenTensorIds(p), g = {}, C.label = 1;
          case 1:
            return d.length > 0 ? (v = this.processStack(o, d, t, p, g, m, r, f, u), [4, Promise.all(v)]) : [3, 3];
          case 2:
            return C.sent(), [3, 1];
          case 3:
            if (c == null && console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), (y = i.filter(function(N) {
              return !Cm(N) && !gt(N.name, p, t);
            }).map(function(N) {
              return N.name;
            })).length > 0) throw b = "", c != null && (b = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + h + "]"), new Error("Cannot compute the outputs [" + y + "] from the provided inputs [" + a + "]. Consider providing the following inputs: [" + l + "]. " + b);
            return [2, p];
        }
      });
    });
  }, e.prototype.processStack = function(n, t, r, a, o, i, s, u, l) {
    for (var c = this, h = [], d = function() {
      var f = t.pop();
      r.currentContext = f.contexts;
      var m = "";
      if (f.node.op === "Enter" && w("isConstant", f.node, a, r) && (m = ua(f.node.name, r)[0]), n.indexOf(f.node) === -1) {
        var g = wc(f.node, a, r);
        m || (m = ua(f.node.name, r)[0]);
        var v = r.currentContext;
        g instanceof Promise ? h.push(g.then(function(y) {
          return a[m] = y, r.currentContext = v, c.checkTensorForDisposal(m, f.node, a, r, i, s, u), c.processChildNodes(f.node, t, r, a, o, l), y;
        })) : (a[m] = g, p.checkTensorForDisposal(m, f.node, a, r, i, s, u), p.processChildNodes(f.node, t, r, a, o, l));
      } else p.processChildNodes(f.node, t, r, a, o, l);
    }, p = this; t.length > 0; ) d();
    return h;
  }, e.prototype.processChildNodes = function(n, t, r, a, o, i) {
    n.children.forEach(function(s) {
      var u = ua(s.name, r)[0];
      !o[u] && i.has(s.name) && (s.op === "Merge" ? s.inputNames.some(function(l) {
        return !!gt(l, a, r);
      }) && (o[u] = !0, t.push({ contexts: r.currentContext, node: s })) : s.inputNames.every(function(l) {
        return !!gt(l, a, r);
      }) && (o[u] = !0, t.push({ contexts: r.currentContext, node: s })));
    });
  }, e.prototype.dispose = function() {
    var n = this;
    Object.keys(this.weightMap).forEach(function(t) {
      return n.weightMap[t].forEach(function(r) {
        return r.dispose();
      });
    });
  }, e.prototype.checkInputShapeAndType = function(n) {
    var t = this;
    Object.keys(n).forEach(function(r) {
      var a = n[r], o = Et(r)[0], i = t.graph.nodes[o];
      if (i.attrParams.shape && i.attrParams.shape.value) {
        var s = i.attrParams.shape.value, u = s.length === a.shape.length && a.shape.every(function(l, c) {
          return s[c] === -1 || s[c] === l;
        });
        tr.assert(u, function() {
          return "The shape of dict['" + i.name + "'] provided in model.execute(dict) must be [" + s + "], but was [" + a.shape + "]";
        });
      }
      i.attrParams.dtype && i.attrParams.dtype.value && tr.assert(a.dtype === i.attrParams.dtype.value, function() {
        return "The dtype of dict['" + i.name + "'] provided in model.execute(dict) must be " + i.attrParams.dtype.value + ", but was " + a.dtype;
      });
    });
  }, e.prototype.mapInputs = function(n) {
    var t = {};
    for (var r in n)
      this._signature != null && this._signature.inputs != null && this._signature.inputs[r] != null ? t[this._signature.inputs[r].name] = n[r] : t[r] = n[r];
    return t;
  }, e.prototype.checkInputs = function(n) {
    var t = this, r = Object.keys(n).filter(function(a) {
      var o = Et(a)[0];
      return t.graph.nodes[o] == null;
    });
    if (r.length > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + r + "] that are not part of graph");
  }, e.prototype.mapOutputs = function(n) {
    var t = this;
    return n.map(function(r) {
      return t._signature != null && t._signature.outputs != null && t._signature.outputs[r] != null ? t._signature.outputs[r].name : r;
    }, {});
  }, e.prototype.checkOutputs = function(n) {
    var t = this;
    n.forEach(function(r) {
      var a = Et(r)[0];
      if (!t.graph.nodes[a]) throw new Error("The output '" + r + "' is not found in the graph");
    });
  }, e;
}(), Yx = "?tfjs-format=file", Zx = "model.json", ew = function() {
  function e(n, t) {
    t === void 0 && (t = {}), this.modelUrl = n, this.loadOptions = t, this.version = "n/a", t == null && (this.loadOptions = {});
  }
  return Object.defineProperty(e.prototype, "modelVersion", { get: function() {
    return this.version;
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "inputNodes", { get: function() {
    return this.executor.inputNodes;
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "outputNodes", { get: function() {
    return this.executor.outputNodes;
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "inputs", { get: function() {
    return this.executor.inputs;
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "outputs", { get: function() {
    return this.executor.outputs;
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "weights", { get: function() {
    return this.executor.weightMap;
  }, enumerable: !0, configurable: !0 }), e.prototype.findIOHandler = function() {
    var n = this.modelUrl;
    if (n.load != null) this.handler = n;
    else if (this.loadOptions.requestInit != null) this.handler = ka.browserHTTPRequest(n, this.loadOptions);
    else {
      var t = ka.getLoadHandlers(n, this.loadOptions.onProgress);
      if (t.length === 0) t.push(ka.browserHTTPRequest(n, this.loadOptions));
      else if (t.length > 1) throw new Error("Found more than one (" + t.length + ") load handlers for URL '" + [n] + "'");
      this.handler = t[0];
    }
  }, e.prototype.load = function() {
    return Yn(this, void 0, void 0, function() {
      var n, t, r, a;
      return Zn(this, function(o) {
        switch (o.label) {
          case 0:
            if (this.findIOHandler(), this.handler.load == null) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
            return n = this, [4, this.handler.load()];
          case 1:
            return n.artifacts = o.sent(), t = this.artifacts.modelTopology, r = {}, this.artifacts.userDefinedMetadata != null && (r = this.artifacts.userDefinedMetadata.signature), this.version = t.versions.producer + "." + t.versions.minConsumer, a = ka.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs), this.executor = new Qx(Ax.Instance.transformGraph(t, r)), this.executor.weightMap = this.convertTensorMapToTensorsMap(a), [2, !0];
        }
      });
    });
  }, e.prototype.save = function(n, t) {
    return Yn(this, void 0, void 0, function() {
      var r;
      return Zn(this, function(a) {
        if (typeof n == "string") {
          if ((r = ka.getSaveHandlers(n)).length === 0) throw new Error("Cannot find any save handlers for URL '" + n + "'");
          if (r.length > 1) throw new Error("Found more than one (" + r.length + ") save handlers for URL '" + n + "'");
          n = r[0];
        }
        if (n.save == null) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
        return [2, n.save(this.artifacts)];
      });
    });
  }, e.prototype.predict = function(n, t) {
    return this.execute(n, this.outputNodes);
  }, e.prototype.normalizeInputs = function(n) {
    if (!(n instanceof Ve || Array.isArray(n))) return n;
    if ((n = Array.isArray(n) ? n : [n]).length !== this.inputNodes.length) throw new Error("Input tensor count mismatch,the graph model has " + this.inputNodes.length + " placeholders, while there are " + n.length + " input tensors.");
    return this.inputNodes.reduce(function(t, r, a) {
      return t[r] = n[a], t;
    }, {});
  }, e.prototype.normalizeOutputs = function(n) {
    return n = n || this.outputNodes, Array.isArray(n) ? n : [n];
  }, e.prototype.execute = function(n, t) {
    n = this.normalizeInputs(n), t = this.normalizeOutputs(t);
    var r = this.executor.execute(n, t);
    return r.length > 1 ? r : r[0];
  }, e.prototype.executeAsync = function(n, t) {
    return Yn(this, void 0, void 0, function() {
      var r;
      return Zn(this, function(a) {
        switch (a.label) {
          case 0:
            return n = this.normalizeInputs(n), t = this.normalizeOutputs(t), [4, this.executor.executeAsync(n, t)];
          case 1:
            return [2, (r = a.sent()).length > 1 ? r : r[0]];
        }
      });
    });
  }, e.prototype.convertTensorMapToTensorsMap = function(n) {
    return Object.keys(n).reduce(function(t, r) {
      return t[r] = [n[r]], t;
    }, {});
  }, e.prototype.dispose = function() {
    this.executor.dispose();
  }, e;
}();
function tw(e, n) {
  return n === void 0 && (n = {}), Yn(this, void 0, void 0, function() {
    var t;
    return Zn(this, function(r) {
      switch (r.label) {
        case 0:
          if (e == null) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
          return n == null && (n = {}), n.fromTFHub && e.load == null && (e.endsWith("/") || (e += "/"), e = "" + e + Zx + Yx), [4, (t = new ew(e, n)).load()];
        case 1:
          return r.sent(), [2, t];
      }
    });
  });
}
/**
    * @license
    * Copyright 2019 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
function Ta(e, n, t, r) {
  return new (t || (t = Promise))(function(a, o) {
    function i(l) {
      try {
        u(r.next(l));
      } catch (c) {
        o(c);
      }
    }
    function s(l) {
      try {
        u(r.throw(l));
      } catch (c) {
        o(c);
      }
    }
    function u(l) {
      l.done ? a(l.value) : new t(function(c) {
        c(l.value);
      }).then(i, s);
    }
    u((r = r.apply(e, [])).next());
  });
}
function Pa(e, n) {
  var t, r, a, o, i = { label: 0, sent: function() {
    if (1 & a[0]) throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(u) {
    return function(l) {
      return function(c) {
        if (t) throw new TypeError("Generator is already executing.");
        for (; i; ) try {
          if (t = 1, r && (a = 2 & c[0] ? r.return : c[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, c[1])).done) return a;
          switch (r = 0, a && (c = [2 & c[0], a.value]), c[0]) {
            case 0:
            case 1:
              a = c;
              break;
            case 4:
              return i.label++, { value: c[1], done: !1 };
            case 5:
              i.label++, r = c[1], c = [0];
              continue;
            case 7:
              c = i.ops.pop(), i.trys.pop();
              continue;
            default:
              if (!(a = (a = i.trys).length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                i = 0;
                continue;
              }
              if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
                i.label = c[1];
                break;
              }
              if (c[0] === 6 && i.label < a[1]) {
                i.label = a[1], a = c;
                break;
              }
              if (a && i.label < a[2]) {
                i.label = a[2], i.ops.push(c);
                break;
              }
              a[2] && i.ops.pop(), i.trys.pop();
              continue;
          }
          c = n.call(e, i);
        } catch (h) {
          c = [6, h], r = 0;
        } finally {
          t = a = 0;
        }
        if (5 & c[0]) throw c[1];
        return { value: c[0] ? c[1] : void 0, done: !0 };
      }([u, l]);
    };
  }
}
function km(e, n, t, r) {
  return new (t || (t = Promise))(function(a, o) {
    function i(l) {
      try {
        u(r.next(l));
      } catch (c) {
        o(c);
      }
    }
    function s(l) {
      try {
        u(r.throw(l));
      } catch (c) {
        o(c);
      }
    }
    function u(l) {
      l.done ? a(l.value) : new t(function(c) {
        c(l.value);
      }).then(i, s);
    }
    u((r = r.apply(e, [])).next());
  });
}
function Nm(e, n) {
  var t, r, a, o, i = { label: 0, sent: function() {
    if (1 & a[0]) throw a[1];
    return a[1];
  }, trys: [], ops: [] };
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(u) {
    return function(l) {
      return function(c) {
        if (t) throw new TypeError("Generator is already executing.");
        for (; i; ) try {
          if (t = 1, r && (a = 2 & c[0] ? r.return : c[0] ? r.throw || ((a = r.return) && a.call(r), 0) : r.next) && !(a = a.call(r, c[1])).done) return a;
          switch (r = 0, a && (c = [2 & c[0], a.value]), c[0]) {
            case 0:
            case 1:
              a = c;
              break;
            case 4:
              return i.label++, { value: c[1], done: !1 };
            case 5:
              i.label++, r = c[1], c = [0];
              continue;
            case 7:
              c = i.ops.pop(), i.trys.pop();
              continue;
            default:
              if (!(a = (a = i.trys).length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                i = 0;
                continue;
              }
              if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
                i.label = c[1];
                break;
              }
              if (c[0] === 6 && i.label < a[1]) {
                i.label = a[1], a = c;
                break;
              }
              if (a && i.label < a[2]) {
                i.label = a[2], i.ops.push(c);
                break;
              }
              a[2] && i.ops.pop(), i.trys.pop();
              continue;
          }
          c = n.call(e, i);
        } catch (h) {
          c = [6, h], r = 0;
        } finally {
          t = a = 0;
        }
        if (5 & c[0]) throw c[1];
        return { value: c[0] ? c[1] : void 0, done: !0 };
      }([u, l]);
    };
  }
}
var Am = function(e) {
  for (var n = [], t = 0, r = e; t < r.length; t++) {
    var a = r[t];
    n.push(a);
  }
  return n;
}, Nc = function() {
  this.parent = null, this.children = {}, this.end = !1, this.word = [[], 0, 0];
}, nw = function() {
  function e() {
    this.root = new Nc();
  }
  return e.prototype.insert = function(n, t, r) {
    for (var a = this.root, o = Am(n), i = 0; i < o.length; i++) a.children[o[i]] || (a.children[o[i]] = new Nc(), a.children[o[i]].parent = a, a.children[o[i]].word[0] = a.word[0].concat(o[i])), a = a.children[o[i]], i === o.length - 1 && (a.end = !0, a.word[1] = t, a.word[2] = r);
  }, e.prototype.commonPrefixSearch = function(n) {
    for (var t = [], r = this.root.children[n[0]], a = 0; a < n.length && r; a++) r.end && t.push(r.word), r = r.children[n[a + 1]];
    return t.length || t.push([[n[0]], 0, 0]), t;
  }, e;
}(), Ac = "▁";
function rw(e) {
  var n = e.normalize("NFKC");
  return Ac + n.replace(/ /g, Ac);
}
var aw = 6, ow = function() {
  function e(n) {
    this.vocabulary = n, this.trie = new nw();
    for (var t = aw; t < this.vocabulary.length; t++) this.trie.insert(this.vocabulary[t][0], this.vocabulary[t][1], t);
  }
  return e.prototype.encode = function(n) {
    var t = [], r = [], a = [];
    n = rw(n);
    for (var o = Am(n), i = 0; i <= o.length; i++) t.push({}), r.push(0), a.push(0);
    for (i = 0; i < o.length; i++) for (var s = this.trie.commonPrefixSearch(o.slice(i)), u = 0; u < s.length; u++) {
      var l = s[u], c = { key: l[0], score: l[1], index: l[2] };
      t[i + (h = l[0].length)][i] == null && (t[i + h][i] = []), t[i + h][i].push(c);
    }
    for (var h = 0; h <= o.length; h++) for (var d in t[h]) {
      var p = t[h][d];
      for (u = 0; u < p.length; u++) {
        var f = p[u], m = f.score + a[h - f.key.length];
        (a[h] === 0 || m >= a[h]) && (a[h] = m, r[h] = p[u].index);
      }
    }
    for (var g = [], v = r.length - 1; v > 0; ) g.push(r[v]), v -= this.vocabulary[r[v]][0].length;
    var y = [], b = !1;
    for (i = 0; i < g.length; i++) {
      var x = g[i];
      b && x === 0 || y.push(x), b = x === 0;
    }
    return y.reverse();
  }, e;
}(), iw = "https://storage.googleapis.com/tfjs-models/savedmodel/universal_sentence_encoder/";
function sw(e) {
  return km(this, void 0, void 0, function() {
    var n;
    return Nm(this, function(t) {
      switch (t.label) {
        case 0:
          return [4, uw(e)];
        case 1:
          return n = t.sent(), [2, new ow(n)];
      }
    });
  });
}
function uw(e) {
  return e === void 0 && (e = iw + "vocab.json"), km(this, void 0, void 0, function() {
    return Nm(this, function(n) {
      switch (n.label) {
        case 0:
          return [4, tr.fetch(e)];
        case 1:
          return [2, n.sent().json()];
      }
    });
  });
}
function lw(e, n) {
  return Ta(this, void 0, void 0, function() {
    var t;
    return Pa(this, function(r) {
      switch (r.label) {
        case 0:
          return [4, (t = new cw(e, n)).load()];
        case 1:
          return r.sent(), [2, t];
      }
    });
  });
}
var cw = function() {
  function e(n, t) {
    n === void 0 && (n = 0.85), t === void 0 && (t = []), this.threshold = n, this.toxicityLabels = t;
  }
  return e.prototype.loadModel = function() {
    return Ta(this, void 0, void 0, function() {
      return Pa(this, function(n) {
        return [2, tw("https://tfhub.dev/tensorflow/tfjs-model/toxicity/1/default/1", { fromTFHub: !0 })];
      });
    });
  }, e.prototype.loadTokenizer = function() {
    return Ta(this, void 0, void 0, function() {
      return Pa(this, function(n) {
        return [2, sw()];
      });
    });
  }, e.prototype.load = function() {
    return Ta(this, void 0, void 0, function() {
      var n, t, r, a = this;
      return Pa(this, function(o) {
        switch (o.label) {
          case 0:
            return [4, Promise.all([this.loadModel(), this.loadTokenizer()])];
          case 1:
            return n = o.sent(), t = n[0], r = n[1], this.model = t, this.tokenizer = r, this.labels = t.outputs.map(function(i) {
              return i.name.split("/")[0];
            }), this.toxicityLabels.length === 0 ? this.toxicityLabels = this.labels : tr.assert(this.toxicityLabels.every(function(i) {
              return a.labels.indexOf(i) > -1;
            }), function() {
              return "toxicityLabels argument must contain only items from the model heads " + a.labels.join(", ") + ", got " + a.toxicityLabels.join(", ");
            }), [2];
        }
      });
    });
  }, e.prototype.classify = function(n) {
    return Ta(this, void 0, void 0, function() {
      var t, r, a, o, i, s, u, l = this;
      return Pa(this, function(c) {
        switch (c.label) {
          case 0:
            for (typeof n == "string" && (n = [n]), t = n.map(function(h) {
              return l.tokenizer.encode(h);
            }), r = t.map(function(h, d) {
              return h.map(function(p, f) {
                return [d, f];
              });
            }), a = [], o = 0; o < r.length; o++) a = a.concat(r[o]);
            return i = Cr(a, [a.length, 2], "int32"), s = Fn(tr.flatten(t), "int32"), [4, this.model.executeAsync({ Placeholder_1: i, Placeholder: s })];
          case 1:
            return u = c.sent(), i.dispose(), s.dispose(), [2, u.map(function(h, d) {
              return { data: h, headIndex: d };
            }).filter(function(h) {
              return l.toxicityLabels.indexOf(l.labels[h.headIndex]) > -1;
            }).map(function(h) {
              for (var d = h.data.dataSync(), p = [], f = 0; f < n.length; f++) {
                var m = d.slice(2 * f, 2 * f + 2), g = null;
                Math.max(m[0], m[1]) > l.threshold && (g = m[0] < m[1]), p.push({ probabilities: m, match: g });
              }
              return { label: l.labels[h.headIndex], results: p };
            })];
        }
      });
    });
  }, e;
}();
let hw = {
  one: {},
  two: {},
  three: {},
  four: {}
}, dw = {
  one: {},
  two: {},
  three: {}
}, pw = {}, fw = [];
const Ys = { methods: hw, model: dw, compute: pw, hooks: fw }, mw = (e) => Object.prototype.toString.call(e) === "[object Array]", gw = {
  /** add metadata to term objects */
  compute: function(e) {
    const { world: n } = this, t = n.compute;
    return typeof e == "string" && t.hasOwnProperty(e) ? t[e](this) : mw(e) ? e.forEach((r) => {
      n.compute.hasOwnProperty(r) ? t[r](this) : console.warn("no compute:", e);
    }) : typeof e == "function" ? e(this) : console.warn("no compute:", e), this;
  }
}, vw = function(e) {
  return this.fullPointer.forEach((t, r) => {
    let a = this.update([t]);
    e(a, r);
  }), this;
}, yw = function(e, n) {
  let r = this.fullPointer.map((o, i) => {
    let s = this.update([o]), u = e(s, i);
    return u === void 0 ? this.none() : u;
  });
  if (r.length === 0)
    return n || this.update([]);
  if (r[0] !== void 0 && (typeof r[0] == "string" || typeof r[0] == "object" && (r[0] === null || !r[0].isView)))
    return r;
  let a = [];
  return r.forEach((o) => {
    a = a.concat(o.fullPointer);
  }), this.toView(a);
}, bw = function(e) {
  let n = this.fullPointer;
  return n = n.filter((r, a) => {
    let o = this.update([r]);
    return e(o, a);
  }), this.update(n);
}, xw = function(e) {
  let t = this.fullPointer.find((r, a) => {
    let o = this.update([r]);
    return e(o, a);
  });
  return this.update([t]);
}, ww = function(e) {
  return this.fullPointer.some((t, r) => {
    let a = this.update([t]);
    return e(a, r);
  });
}, Cw = function(e = 1) {
  let n = this.fullPointer, t = Math.floor(Math.random() * n.length);
  return t + e > this.length && (t = this.length - e, t = t < 0 ? 0 : t), n = n.slice(t, t + e), this.update(n);
}, kw = { forEach: vw, map: yw, filter: bw, find: xw, some: ww, random: Cw }, Yt = {
  /** */
  termList: function() {
    return this.methods.one.termList(this.docs);
  },
  /** return individual terms*/
  terms: function(e) {
    let n = this.match(".");
    return typeof e == "number" ? n.eq(e) : n;
  },
  /** */
  groups: function(e) {
    if (e || e === 0)
      return this.update(this._groups[e] || []);
    let n = {};
    return Object.keys(this._groups).forEach((t) => {
      n[t] = this.update(this._groups[t]);
    }), n;
  },
  /** */
  eq: function(e) {
    let n = this.pointer;
    return n || (n = this.docs.map((t, r) => [r])), n[e] ? this.update([n[e]]) : this.none();
  },
  /** */
  first: function() {
    return this.eq(0);
  },
  /** */
  last: function() {
    let e = this.fullPointer.length - 1;
    return this.eq(e);
  },
  /** grab term[0] for every match */
  firstTerms: function() {
    return this.match("^.");
  },
  /** grab the last term for every match  */
  lastTerms: function() {
    return this.match(".$");
  },
  /** */
  slice: function(e, n) {
    let t = this.pointer || this.docs.map((r, a) => [a]);
    return t = t.slice(e, n), this.update(t);
  },
  /** return a view of the entire document */
  all: function() {
    return this.update().toView();
  },
  /**  */
  fullSentences: function() {
    let e = this.fullPointer.map((n) => [n[0]]);
    return this.update(e).toView();
  },
  /** return a view of no parts of the document */
  none: function() {
    return this.update([]);
  },
  /** are these two views looking at the same words? */
  isDoc: function(e) {
    if (!e || !e.isView)
      return !1;
    let n = this.fullPointer, t = e.fullPointer;
    return !n.length === t.length ? !1 : n.every((r, a) => t[a] ? r[0] === t[a][0] && r[1] === t[a][1] && r[2] === t[a][2] : !1);
  },
  /** how many seperate terms does the document have? */
  wordCount: function() {
    return this.docs.reduce((e, n) => (e += n.filter((t) => t.text !== "").length, e), 0);
  },
  // is the pointer the full sentence?
  isFull: function() {
    let e = this.pointer;
    if (!e)
      return !0;
    if (e.length === 0 || e[0][0] !== 0)
      return !1;
    let n = 0, t = 0;
    return this.document.forEach((r) => n += r.length), this.docs.forEach((r) => t += r.length), n === t;
  },
  // return the nth elem of a doc
  getNth: function(e) {
    return typeof e == "number" ? this.eq(e) : typeof e == "string" ? this.if(e) : this;
  }
};
Yt.group = Yt.groups;
Yt.fullSentence = Yt.fullSentences;
Yt.sentence = Yt.fullSentences;
Yt.lastTerm = Yt.lastTerms;
Yt.firstTerm = Yt.firstTerms;
const Zs = Object.assign({}, Yt, gw, kw);
Zs.get = Zs.eq;
class er {
  constructor(n, t, r = {}) {
    [
      ["document", n],
      ["world", Ys],
      ["_groups", r],
      ["_cache", null],
      ["viewType", "View"]
    ].forEach((o) => {
      Object.defineProperty(this, o[0], {
        value: o[1],
        writable: !0
      });
    }), this.ptrs = t;
  }
  /* getters:  */
  get docs() {
    let n = this.document;
    return this.ptrs && (n = Ys.methods.one.getDoc(this.ptrs, this.document)), n;
  }
  get pointer() {
    return this.ptrs;
  }
  get methods() {
    return this.world.methods;
  }
  get model() {
    return this.world.model;
  }
  get hooks() {
    return this.world.hooks;
  }
  get isView() {
    return !0;
  }
  // is the view not-empty?
  get found() {
    return this.docs.length > 0;
  }
  // how many matches we have
  get length() {
    return this.docs.length;
  }
  // return a more-hackable pointer
  get fullPointer() {
    let { docs: n, ptrs: t, document: r } = this;
    return (t || n.map((o, i) => [i])).map((o) => {
      let [i, s, u, l, c] = o;
      return s = s || 0, u = u || (r[i] || []).length, r[i] && r[i][s] && (l = l || r[i][s].id, r[i][u - 1] && (c = c || r[i][u - 1].id)), [i, s, u, l, c];
    });
  }
  // create a new View, from this one
  update(n) {
    let t = new er(this.document, n);
    if (this._cache && n && n.length > 0) {
      let r = [];
      n.forEach((a, o) => {
        let [i, s, u] = a;
        a.length === 1 ? r[o] = this._cache[i] : s === 0 && this.document[i].length === u && (r[o] = this._cache[i]);
      }), r.length > 0 && (t._cache = r);
    }
    return t.world = this.world, t;
  }
  // create a new View, from this one
  toView(n) {
    return new er(this.document, n || this.pointer);
  }
  fromText(n) {
    const { methods: t } = this;
    let r = t.one.tokenize.fromString(n, this.world), a = new er(r);
    return a.world = this.world, a.compute(["normal", "freeze", "lexicon"]), this.world.compute.preTagger && a.compute("preTagger"), a.compute("unfreeze"), a;
  }
  clone() {
    let n = this.document.slice(0);
    n = n.map((r) => r.map((a) => (a = Object.assign({}, a), a.tags = new Set(a.tags), a)));
    let t = this.update(this.pointer);
    return t.document = n, t._cache = this._cache, t;
  }
}
Object.assign(er.prototype, Zs);
const Nw = "14.14.4", Ic = function(e) {
  return e && typeof e == "object" && !Array.isArray(e);
};
function Im(e, n) {
  if (Ic(n))
    for (const t in n)
      Ic(n[t]) ? (e[t] || Object.assign(e, { [t]: {} }), Im(e[t], n[t])) : Object.assign(e, { [t]: n[t] });
  return e;
}
function Aw(e, n) {
  for (const t in n)
    e[t] = e[t] || {}, Object.assign(e[t], n[t]);
  return e;
}
const Iw = function(e, n) {
  let t = e.two.models || {};
  Object.keys(n).forEach((r) => {
    n[r].pastTense && (t.toPast && (t.toPast.ex[r] = n[r].pastTense), t.fromPast && (t.fromPast.ex[n[r].pastTense] = r)), n[r].presentTense && (t.toPresent && (t.toPresent.ex[r] = n[r].presentTense), t.fromPresent && (t.fromPresent.ex[n[r].presentTense] = r)), n[r].gerund && (t.toGerund && (t.toGerund.ex[r] = n[r].gerund), t.fromGerund && (t.fromGerund.ex[n[r].gerund] = r)), n[r].comparative && (t.toComparative && (t.toComparative.ex[r] = n[r].comparative), t.fromComparative && (t.fromComparative.ex[n[r].comparative] = r)), n[r].superlative && (t.toSuperlative && (t.toSuperlative.ex[r] = n[r].superlative), t.fromSuperlative && (t.fromSuperlative.ex[n[r].superlative] = r));
  });
}, Ew = function(e, n, t, r) {
  const { methods: a, model: o, compute: i, hooks: s } = n;
  e.methods && Aw(a, e.methods), e.model && Im(o, e.model), e.irregulars && Iw(o, e.irregulars), e.compute && Object.assign(i, e.compute), s && (n.hooks = s.concat(e.hooks || [])), e.api && e.api(t), e.lib && Object.keys(e.lib).forEach((u) => r[u] = e.lib[u]), e.tags && r.addTags(e.tags), e.words && r.addWords(e.words), e.frozen && r.addWords(e.frozen, !0), e.mutate && e.mutate(n, r);
}, Tw = function(e) {
  const n = typeof process > "u" || !process.env ? self.env || {} : process.env;
  return n.DEBUG_TAGS = e === "tagger" || e === !0 ? !0 : "", n.DEBUG_MATCH = e === "match" || e === !0 ? !0 : "", n.DEBUG_CHUNKS = e === "chunker" || e === !0 ? !0 : "", this;
}, Pw = (e) => Object.prototype.toString.call(e) === "[object Object]", eu = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, Sw = function(e) {
  return e.map((n) => n.terms.map((t) => (eu(t.tags) && (t.tags = new Set(t.tags)), t)));
}, Dw = function(e) {
  return e.map((n) => n.map((t) => ({
    text: t,
    normal: t,
    //cleanup
    pre: "",
    post: " ",
    tags: /* @__PURE__ */ new Set()
  })));
}, Em = function(e, n, t) {
  const { methods: r } = t;
  let a = new n([]);
  if (a.world = t, typeof e == "number" && (e = String(e)), !e)
    return a;
  if (typeof e == "string") {
    let o = r.one.tokenize.fromString(e, t);
    return new n(o);
  }
  if (Pw(e) && e.isView)
    return new n(e.document, e.ptrs);
  if (eu(e)) {
    if (eu(e[0])) {
      let i = Dw(e);
      return new n(i);
    }
    let o = Sw(e);
    return new n(o);
  }
  return a;
};
let oi = Object.assign({}, Ys);
const se = function(e, n) {
  n && se.addWords(n);
  let t = Em(e, er, oi);
  return e && t.compute(oi.hooks), t;
};
Object.defineProperty(se, "_world", {
  value: oi,
  writable: !0
});
se.tokenize = function(e, n) {
  const { compute: t } = this._world;
  n && se.addWords(n);
  let r = Em(e, er, oi);
  return t.contractions && r.compute(["alias", "normal", "machine", "contractions"]), r;
};
se.plugin = function(e) {
  return Ew(e, this._world, er, this), this;
};
se.extend = se.plugin;
se.world = function() {
  return this._world;
};
se.model = function() {
  return this._world.model;
};
se.methods = function() {
  return this._world.methods;
};
se.hooks = function() {
  return this._world.hooks;
};
se.verbose = Tw;
se.version = Nw;
const Ow = function(e) {
  return e.map((t) => {
    let r = /* @__PURE__ */ new Set();
    return t.forEach((a) => {
      a.normal !== "" && r.add(a.normal), a.switch && r.add(`%${a.switch}%`), a.implicit && r.add(a.implicit), a.machine && r.add(a.machine), a.root && r.add(a.root), a.alias && a.alias.forEach((i) => r.add(i));
      let o = Array.from(a.tags);
      for (let i = 0; i < o.length; i += 1)
        r.add("#" + o[i]);
    }), r;
  });
}, Rw = {
  one: {
    cacheDoc: Ow
  }
}, Fw = {
  /** */
  cache: function() {
    return this._cache = this.methods.one.cacheDoc(this.document), this;
  },
  /** */
  uncache: function() {
    return this._cache = null, this;
  }
}, Mw = function(e) {
  Object.assign(e.prototype, Fw);
}, _w = {
  cache: function(e) {
    e._cache = e.methods.one.cacheDoc(e.document);
  }
}, Bw = {
  api: Mw,
  compute: _w,
  methods: Rw
}, jw = {
  /** */
  toLowerCase: function() {
    return this.termList().forEach((e) => {
      e.text = e.text.toLowerCase();
    }), this;
  },
  /** */
  toUpperCase: function() {
    return this.termList().forEach((e) => {
      e.text = e.text.toUpperCase();
    }), this;
  },
  /** */
  toTitleCase: function() {
    return this.termList().forEach((e) => {
      e.text = e.text.replace(/^ *[a-z\u00C0-\u00FF]/, (n) => n.toUpperCase());
    }), this;
  },
  /** */
  toCamelCase: function() {
    return this.docs.forEach((e) => {
      e.forEach((n, t) => {
        t !== 0 && (n.text = n.text.replace(/^ *[a-z\u00C0-\u00FF]/, (r) => r.toUpperCase())), t !== e.length - 1 && (n.post = "");
      });
    }), this;
  }
}, Ec = (e) => new RegExp("^\\p{Lu}[\\p{Ll}'’]", "u").test(e) || new RegExp("^\\p{Lu}$", "u").test(e), Vw = (e) => e.replace(new RegExp("^\\p{Ll}", "u"), (n) => n.toUpperCase()), Lw = (e) => e.replace(new RegExp("^\\p{Lu}", "u"), (n) => n.toLowerCase()), Tm = (e, n, t) => {
  if (t.forEach((r) => r.dirty = !0), e) {
    let r = [n, 0].concat(t);
    Array.prototype.splice.apply(e, r);
  }
  return e;
}, na = function(e) {
  const n = / $/, t = /[-–—]/;
  let r = e[e.length - 1];
  r && !n.test(r.post) && !t.test(r.post) && (r.post += " ");
}, Tc = (e, n, t) => {
  const r = /[-.?!,;:)–—'"]/g;
  let a = e[n - 1];
  if (!a)
    return;
  let o = a.post;
  if (r.test(o)) {
    let i = o.match(r).join(""), s = t[t.length - 1];
    s.post = i + s.post, a.post = a.post.replace(r, "");
  }
}, zw = function(e, n, t) {
  let r = e[n];
  if (n !== 0 || !Ec(r.text))
    return;
  t[0].text = Vw(t[0].text);
  let a = e[n];
  a.tags.has("ProperNoun") || a.tags.has("Acronym") || Ec(a.text) && a.text.length > 1 && (a.text = Lw(a.text));
}, Gw = function(e, n, t, r) {
  let [a, o, i] = n;
  o === 0 || i === r[a].length ? na(t) : (na(t), na([e[n[1]]])), zw(e, o, t), Tm(e, o, t);
}, Hw = function(e, n, t, r) {
  let [a, , o] = n, i = (r[a] || []).length;
  o < i ? (Tc(e, o, t), na(t)) : i === o && (na(e), Tc(e, o, t), r[a + 1] && (t[t.length - 1].post += " ")), Tm(e, n[2], t), n[4] = t[t.length - 1].id;
};
let Na = 0;
const Pc = (e) => (e = e.length < 3 ? "0" + e : e, e.length < 3 ? "0" + e : e), Pm = function(e) {
  let [n, t] = e.index || [0, 0];
  Na += 1, Na = Na > 46655 ? 0 : Na, n = n > 46655 ? 0 : n, t = t > 1294 ? 0 : t;
  let r = Pc(Na.toString(36));
  r += Pc(n.toString(36));
  let a = t.toString(36);
  a = a.length < 2 ? "0" + a : a, r += a;
  let o = parseInt(Math.random() * 36, 10);
  return r += o.toString(36), e.normal + "|" + r.toUpperCase();
}, Sc = function(e) {
  e.has("@hasContraction") && typeof e.contractions == "function" && e.grow("@hasContraction").contractions().expand();
}, Dc = (e) => Object.prototype.toString.call(e) === "[object Array]", Ww = function(e) {
  return e = e.map((n) => (n.id = Pm(n), n)), e;
}, $w = function(e, n) {
  const { methods: t } = n;
  return typeof e == "string" ? t.one.tokenize.fromString(e, n)[0] : typeof e == "object" && e.isView ? e.clone().docs[0] || [] : Dc(e) ? Dc(e[0]) ? e[0] : e : [];
}, Oc = function(e, n, t) {
  const { document: r, world: a } = n;
  n.uncache();
  let o = n.fullPointer, i = n.fullPointer;
  n.forEach((u, l) => {
    let c = u.fullPointer[0], [h] = c, d = r[h], p = $w(e, a);
    p.length !== 0 && (p = Ww(p), t ? (Sc(n.update([c]).firstTerm()), Gw(d, c, p, r)) : (Sc(n.update([c]).lastTerm()), Hw(d, c, p, r)), r[h] && r[h][c[1]] && (c[3] = r[h][c[1]].id), i[l] = c, c[2] += p.length, o[l] = c);
  });
  let s = n.toView(o);
  return n.ptrs = i, s.compute(["id", "index", "freeze", "lexicon"]), s.world.compute.preTagger && s.compute("preTagger"), s.compute("unfreeze"), s;
}, Er = {
  insertAfter: function(e) {
    return Oc(e, this, !1);
  },
  insertBefore: function(e) {
    return Oc(e, this, !0);
  }
};
Er.append = Er.insertAfter;
Er.prepend = Er.insertBefore;
Er.insert = Er.insertAfter;
const Uw = /\$[0-9a-z]+/g, fl = {}, Kw = (e) => new RegExp("^\\p{Lu}[\\p{Ll}'’]", "u").test(e) || new RegExp("^\\p{Lu}$", "u").test(e), qw = (e) => e.replace(new RegExp("^\\p{Ll}", "u"), (n) => n.toUpperCase()), Jw = (e) => e.replace(new RegExp("^\\p{Lu}", "u"), (n) => n.toLowerCase()), Xw = function(e, n, t) {
  return e.forEach((r) => {
    let a = n(r);
    r.replaceWith(a, t);
  }), e;
}, Qw = function(e, n) {
  if (typeof e != "string")
    return e;
  let t = n.groups();
  return e = e.replace(Uw, (r) => {
    let a = r.replace(/\$/, "");
    return t.hasOwnProperty(a) ? t[a].text() : r;
  }), e;
};
fl.replaceWith = function(e, n = {}) {
  let t = this.fullPointer, r = this;
  if (this.uncache(), typeof e == "function")
    return Xw(r, e, n);
  let a = r.docs[0];
  if (!a) return r;
  let o = n.possessives && a[a.length - 1].tags.has("Possessive"), i = n.case && Kw(a[0].text);
  e = Qw(e, r);
  let s = this.update(t);
  t = t.map((d) => d.slice(0, 3));
  let u = (s.docs[0] || []).map((d) => Array.from(d.tags)), l = s.docs[0][0].pre, c = s.docs[0][s.docs[0].length - 1].post;
  if (typeof e == "string" && (e = this.fromText(e).compute("id")), r.insertAfter(e), s.has("@hasContraction") && r.contractions && r.grow("@hasContraction+").contractions().expand(), r.delete(s), o) {
    let d = r.docs[0], p = d[d.length - 1];
    p.tags.has("Possessive") || (p.text += "'s", p.normal += "'s", p.tags.add("Possessive"));
  }
  if (l && r.docs[0] && (r.docs[0][0].pre = l), c && r.docs[0]) {
    let d = r.docs[0][r.docs[0].length - 1];
    d.post.trim() || (d.post = c);
  }
  let h = r.toView(t).compute(["index", "freeze", "lexicon"]);
  if (h.world.compute.preTagger && h.compute("preTagger"), h.compute("unfreeze"), n.tags && h.terms().forEach((d, p) => {
    d.tagSafe(u[p]);
  }), !h.docs[0] || !h.docs[0][0]) return h;
  if (n.case) {
    let d = i ? qw : Jw;
    h.docs[0][0].text = d(h.docs[0][0].text);
  }
  return h;
};
fl.replace = function(e, n, t) {
  if (e && !n)
    return this.replaceWith(e, t);
  let r = this.match(e);
  return r.found ? (this.soften(), r.replaceWith(n, t)) : this;
};
const Yw = function(e, n) {
  let t = e.length - 1, r = e[t], a = e[t - n];
  a && r && (a.post += r.post, a.post = a.post.replace(/ +([.?!,;:])/, "$1"), a.post = a.post.replace(/[,;:]+([.?!])/, "$1"));
}, Zw = function(e, n) {
  n.forEach((t) => {
    let [r, a, o] = t, i = o - a;
    e[r] && (o === e[r].length && o > 1 && Yw(e[r], i), e[r].splice(a, i));
  });
  for (let t = e.length - 1; t >= 0; t -= 1)
    if (e[t].length === 0 && (e.splice(t, 1), t === e.length && e[t - 1])) {
      let r = e[t - 1], a = r[r.length - 1];
      a && (a.post = a.post.trimEnd());
    }
  return e;
}, e2 = function(e, n) {
  return e = e.map((t) => {
    let [r] = t;
    return n[r] && n[r].forEach((a) => {
      let o = a[2] - a[1];
      t[1] <= a[1] && t[2] >= a[2] && (t[2] -= o);
    }), t;
  }), e.forEach((t, r) => {
    if (t[1] === 0 && t[2] == 0)
      for (let a = r + 1; a < e.length; a += 1)
        e[a][0] -= 1, e[a][0] < 0 && (e[a][0] = 0);
  }), e = e.filter((t) => t[2] - t[1] > 0), e = e.map((t) => (t[3] = null, t[4] = null, t)), e;
}, tu = {
  /** */
  remove: function(e) {
    const { indexN: n } = this.methods.one.pointer;
    this.uncache();
    let t = this.all(), r = this;
    e && (t = this, r = this.match(e));
    let a = !t.ptrs;
    r.has("@hasContraction") && r.contractions && r.grow("@hasContraction").contractions().expand();
    let o = t.fullPointer, i = r.fullPointer.reverse(), s = Zw(this.document, i), u = n(i);
    return o = e2(o, u), t.ptrs = o, t.document = s, t.compute("index"), a && (t.ptrs = void 0), e ? t.toView(o) : (this.ptrs = [], t.none());
  }
};
tu.delete = tu.remove;
const Ha = {
  /** add this punctuation or whitespace before each match: */
  pre: function(e, n) {
    return e === void 0 && this.found ? this.docs[0][0].pre : (this.docs.forEach((t) => {
      let r = t[0];
      n === !0 ? r.pre += e : r.pre = e;
    }), this);
  },
  /** add this punctuation or whitespace after each match: */
  post: function(e, n) {
    if (e === void 0) {
      let t = this.docs[this.docs.length - 1];
      return t[t.length - 1].post;
    }
    return this.docs.forEach((t) => {
      let r = t[t.length - 1];
      n === !0 ? r.post += e : r.post = e;
    }), this;
  },
  /** remove whitespace from start/end */
  trim: function() {
    if (!this.found)
      return this;
    let e = this.docs, n = e[0][0];
    n.pre = n.pre.trimStart();
    let t = e[e.length - 1], r = t[t.length - 1];
    return r.post = r.post.trimEnd(), this;
  },
  /** connect words with hyphen, and remove whitespace */
  hyphenate: function() {
    return this.docs.forEach((e) => {
      e.forEach((n, t) => {
        t !== 0 && (n.pre = ""), e[t + 1] && (n.post = "-");
      });
    }), this;
  },
  /** remove hyphens between words, and set whitespace */
  dehyphenate: function() {
    const e = /[-–—]/;
    return this.docs.forEach((n) => {
      n.forEach((t) => {
        e.test(t.post) && (t.post = " ");
      });
    }), this;
  },
  /** add quotations around these matches */
  toQuotations: function(e, n) {
    return e = e || '"', n = n || '"', this.docs.forEach((t) => {
      t[0].pre = e + t[0].pre;
      let r = t[t.length - 1];
      r.post = n + r.post;
    }), this;
  },
  /** add brackets around these matches */
  toParentheses: function(e, n) {
    return e = e || "(", n = n || ")", this.docs.forEach((t) => {
      t[0].pre = e + t[0].pre;
      let r = t[t.length - 1];
      r.post = n + r.post;
    }), this;
  }
};
Ha.deHyphenate = Ha.dehyphenate;
Ha.toQuotation = Ha.toQuotations;
const t2 = (e, n) => e.normal < n.normal ? -1 : e.normal > n.normal ? 1 : 0, n2 = (e, n) => {
  let t = e.normal.trim().length, r = n.normal.trim().length;
  return t < r ? 1 : t > r ? -1 : 0;
}, r2 = (e, n) => e.words < n.words ? 1 : e.words > n.words ? -1 : 0, a2 = (e, n) => e[0] < n[0] ? 1 : e[0] > n[0] ? -1 : e[1] > n[1] ? 1 : -1, o2 = function(e) {
  let n = {};
  return e.forEach((t) => {
    n[t.normal] = n[t.normal] || 0, n[t.normal] += 1;
  }), e.sort((t, r) => {
    let a = n[t.normal], o = n[r.normal];
    return a < o ? 1 : a > o ? -1 : 0;
  }), e;
}, rs = { alpha: t2, length: n2, wordCount: r2, sequential: a2, byFreq: o2 }, i2 = /* @__PURE__ */ new Set(["index", "sequence", "seq", "sequential", "chron", "chronological"]), s2 = /* @__PURE__ */ new Set(["freq", "frequency", "topk", "repeats"]), u2 = /* @__PURE__ */ new Set(["alpha", "alphabetical"]), l2 = function(e, n) {
  let t = e.fullPointer;
  return t = t.sort((r, a) => (r = e.update([r]), a = e.update([a]), n(r, a))), e.ptrs = t, e;
}, c2 = function(e) {
  let { docs: n, pointer: t } = this;
  if (this.uncache(), typeof e == "function")
    return l2(this, e);
  e = e || "alpha";
  let r = t || n.map((o, i) => [i]), a = n.map((o, i) => ({
    index: i,
    words: o.length,
    normal: o.map((s) => s.machine || s.normal || "").join(" "),
    pointer: r[i]
  }));
  return i2.has(e) && (e = "sequential"), u2.has(e) && (e = "alpha"), s2.has(e) ? (a = rs.byFreq(a), this.update(a.map((o) => o.pointer))) : typeof rs[e] == "function" ? (a = a.sort(rs[e]), this.update(a.map((o) => o.pointer))) : this;
}, h2 = function() {
  let e = this.pointer || this.docs.map((n, t) => [t]);
  return e = [].concat(e), e = e.reverse(), this._cache && (this._cache = this._cache.reverse()), this.update(e);
}, d2 = function() {
  let e = /* @__PURE__ */ new Set();
  return this.filter((t) => {
    let r = t.text("machine");
    return e.has(r) ? !1 : (e.add(r), !0);
  });
}, p2 = { unique: d2, reverse: h2, sort: c2 }, f2 = (e) => Object.prototype.toString.call(e) === "[object Array]", Sm = function(e, n) {
  if (e.length > 0) {
    let t = e[e.length - 1], r = t[t.length - 1];
    / /.test(r.post) === !1 && (r.post += " ");
  }
  return e = e.concat(n), e;
}, m2 = function(e, n) {
  if (e.document === n.document) {
    let r = e.fullPointer.concat(n.fullPointer);
    return e.toView(r).compute("index");
  }
  return n.fullPointer.forEach((r) => {
    r[0] += e.document.length;
  }), e.document = Sm(e.document, n.docs), e.all();
}, g2 = {
  // add string as new match/sentence
  concat: function(e) {
    if (typeof e == "string") {
      let n = this.fromText(e);
      if (!this.found || !this.ptrs)
        this.document = this.document.concat(n.document);
      else {
        let t = this.fullPointer, r = t[t.length - 1][0];
        this.document.splice(r, 0, ...n.document);
      }
      return this.all().compute("index");
    }
    if (typeof e == "object" && e.isView)
      return m2(this, e);
    if (f2(e)) {
      let n = Sm(this.document, e);
      return this.document = n, this.all();
    }
    return this;
  }
}, v2 = function() {
  return this.ptrs = this.fullPointer, this;
}, y2 = function() {
  let e = this.ptrs;
  return !e || e.length < 1 ? this : (e = e.map((n) => n.slice(0, 3)), this.ptrs = e, this);
}, b2 = { harden: v2, soften: y2 }, x2 = Object.assign({}, jw, Er, fl, tu, Ha, p2, g2, b2), w2 = function(e) {
  Object.assign(e.prototype, x2);
}, C2 = {
  id: function(e) {
    let n = e.docs;
    for (let t = 0; t < n.length; t += 1)
      for (let r = 0; r < n[t].length; r += 1) {
        let a = n[t][r];
        a.id = a.id || Pm(a);
      }
  }
}, k2 = {
  api: w2,
  compute: C2
}, N2 = [
  // simple mappings
  { word: "@", out: ["at"] },
  { word: "arent", out: ["are", "not"] },
  { word: "alot", out: ["a", "lot"] },
  { word: "brb", out: ["be", "right", "back"] },
  { word: "cannot", out: ["can", "not"] },
  { word: "dun", out: ["do", "not"] },
  { word: "can't", out: ["can", "not"] },
  { word: "shan't", out: ["should", "not"] },
  { word: "won't", out: ["will", "not"] },
  { word: "that's", out: ["that", "is"] },
  { word: "what's", out: ["what", "is"] },
  { word: "let's", out: ["let", "us"] },
  // { word: "there's", out: ['there', 'is'] },
  { word: "dunno", out: ["do", "not", "know"] },
  { word: "gonna", out: ["going", "to"] },
  { word: "gotta", out: ["have", "got", "to"] },
  //hmm
  { word: "gimme", out: ["give", "me"] },
  { word: "outta", out: ["out", "of"] },
  { word: "tryna", out: ["trying", "to"] },
  { word: "gtg", out: ["got", "to", "go"] },
  { word: "im", out: ["i", "am"] },
  { word: "imma", out: ["I", "will"] },
  { word: "imo", out: ["in", "my", "opinion"] },
  { word: "irl", out: ["in", "real", "life"] },
  { word: "ive", out: ["i", "have"] },
  { word: "rn", out: ["right", "now"] },
  { word: "tbh", out: ["to", "be", "honest"] },
  { word: "wanna", out: ["want", "to"] },
  { word: "c'mere", out: ["come", "here"] },
  { word: "c'mon", out: ["come", "on"] },
  // shoulda, coulda
  { word: "shoulda", out: ["should", "have"] },
  { word: "coulda", out: ["coulda", "have"] },
  { word: "woulda", out: ["woulda", "have"] },
  { word: "musta", out: ["must", "have"] },
  { word: "tis", out: ["it", "is"] },
  { word: "twas", out: ["it", "was"] },
  { word: "y'know", out: ["you", "know"] },
  { word: "ne'er", out: ["never"] },
  { word: "o'er", out: ["over"] },
  // contraction-part mappings
  { after: "ll", out: ["will"] },
  { after: "ve", out: ["have"] },
  { after: "re", out: ["are"] },
  { after: "m", out: ["am"] },
  // french contractions
  { before: "c", out: ["ce"] },
  { before: "m", out: ["me"] },
  { before: "n", out: ["ne"] },
  { before: "qu", out: ["que"] },
  { before: "s", out: ["se"] },
  { before: "t", out: ["tu"] },
  // t'aime
  // missing apostrophes
  { word: "shouldnt", out: ["should", "not"] },
  { word: "couldnt", out: ["could", "not"] },
  { word: "wouldnt", out: ["would", "not"] },
  { word: "hasnt", out: ["has", "not"] },
  { word: "wasnt", out: ["was", "not"] },
  { word: "isnt", out: ["is", "not"] },
  { word: "cant", out: ["can", "not"] },
  { word: "dont", out: ["do", "not"] },
  { word: "wont", out: ["will", "not"] },
  // apostrophe d
  { word: "howd", out: ["how", "did"] },
  { word: "whatd", out: ["what", "did"] },
  { word: "whend", out: ["when", "did"] },
  { word: "whered", out: ["where", "did"] }
], kt = !0, A2 = {
  st: kt,
  nd: kt,
  rd: kt,
  th: kt,
  am: kt,
  pm: kt,
  max: kt,
  "°": kt,
  s: kt,
  // 1990s
  e: kt,
  // 18e - french/spanish ordinal
  er: kt,
  //french 1er
  ère: kt,
  //''
  ème: kt
  //french 2ème
}, I2 = {
  one: {
    contractions: N2,
    numberSuffixes: A2
  }
}, as = function(e, n, t) {
  let [r, a] = n;
  !t || t.length === 0 || (t = t.map((o, i) => (o.implicit = o.text, o.machine = o.text, o.pre = "", o.post = "", o.text = "", o.normal = "", o.index = [r, a + i], o)), t[0] && (t[0].pre = e[r][a].pre, t[t.length - 1].post = e[r][a].post, t[0].text = e[r][a].text, t[0].normal = e[r][a].normal), e[r].splice(a, 1, ...t));
}, E2 = /'/, T2 = /* @__PURE__ */ new Set([
  "what",
  "how",
  "when",
  "where",
  "why"
]), P2 = /* @__PURE__ */ new Set([
  "be",
  "go",
  "start",
  "think",
  "need"
]), S2 = /* @__PURE__ */ new Set([
  "been",
  "gone"
]), D2 = function(e, n) {
  let t = e[n].normal.split(E2)[0];
  if (T2.has(t))
    return [t, "did"];
  if (e[n + 1]) {
    if (S2.has(e[n + 1].normal))
      return [t, "had"];
    if (P2.has(e[n + 1].normal))
      return [t, "would"];
  }
  return null;
}, O2 = function(e, n) {
  return e[n].normal === "ain't" || e[n].normal === "aint" ? null : [e[n].normal.replace(/n't/, ""), "not"];
}, ml = /'/, R2 = /(e|é|aison|sion|tion)$/, F2 = /(age|isme|acle|ege|oire)$/, M2 = (e, n) => {
  let t = e[n].normal.split(ml)[1];
  return t && t.endsWith("e") ? ["la", t] : ["le", t];
}, _2 = (e, n) => {
  let t = e[n].normal.split(ml)[1];
  return t && R2.test(t) && !F2.test(t) ? ["du", t] : t && t.endsWith("s") ? ["des", t] : ["de", t];
}, B2 = (e, n) => ["je", e[n].normal.split(ml)[1]], os = {
  preJ: B2,
  preL: M2,
  preD: _2
}, j2 = /^([0-9.]{1,4}[a-z]{0,2}) ?[-–—] ?([0-9]{1,4}[a-z]{0,2})$/i, V2 = /^([0-9]{1,2}(:[0-9][0-9])?(am|pm)?) ?[-–—] ?([0-9]{1,2}(:[0-9][0-9])?(am|pm)?)$/i, L2 = /^[0-9]{3}-[0-9]{4}$/, z2 = function(e, n) {
  let t = e[n], r = t.text.match(j2);
  return r !== null ? t.tags.has("PhoneNumber") === !0 || L2.test(t.text) ? null : [r[1], "to", r[2]] : (r = t.text.match(V2), r !== null ? [r[1], "to", r[4]] : null);
}, G2 = /^([+-]?[0-9][.,0-9]*)([a-z°²³µ/]+)$/, H2 = function(e, n, t) {
  const r = t.model.one.numberSuffixes || {};
  let o = e[n].text.match(G2);
  if (o !== null) {
    let i = o[2].toLowerCase().trim();
    return r.hasOwnProperty(i) ? null : [o[1], i];
  }
  return null;
}, Rc = /'/, W2 = /^[0-9][^-–—]*[-–—].*?[0-9]/, Fc = function(e, n, t, r) {
  let a = n.update();
  a.document = [e];
  let o = t + r;
  t > 0 && (t -= 1), e[o] && (o += 1), a.ptrs = [[0, t, o]];
}, Mc = {
  // ain't
  t: (e, n) => O2(e, n),
  // how'd
  d: (e, n) => D2(e, n)
}, _c = {
  // j'aime
  j: (e, n) => os.preJ(e, n),
  // l'amour
  l: (e, n) => os.preL(e, n),
  // d'amerique
  d: (e, n) => os.preD(e, n)
}, $2 = function(e, n, t, r) {
  for (let a = 0; a < e.length; a += 1) {
    let o = e[a];
    if (o.word === n.normal)
      return o.out;
    if (r !== null && r === o.after)
      return [t].concat(o.out);
    if (t !== null && t === o.before && r && r.length > 2)
      return o.out.concat(r);
  }
  return null;
}, is = function(e, n) {
  let t = n.fromText(e.join(" "));
  return t.compute(["id", "alias"]), t.docs[0];
}, U2 = function(e, n) {
  for (let t = n + 1; t < 5 && e[t]; t += 1)
    if (e[t].normal === "been")
      return ["there", "has"];
  return ["there", "is"];
}, K2 = (e) => {
  let { world: n, document: t } = e;
  const { model: r, methods: a } = n;
  let o = r.one.contractions || [];
  t.forEach((i, s) => {
    for (let u = i.length - 1; u >= 0; u -= 1) {
      let l = null, c = null;
      if (Rc.test(i[u].normal) === !0) {
        let d = i[u].normal.split(Rc);
        l = d[0], c = d[1];
      }
      let h = $2(o, i[u], l, c);
      if (!h && Mc.hasOwnProperty(c) && (h = Mc[c](i, u, n)), !h && _c.hasOwnProperty(l) && (h = _c[l](i, u)), l === "there" && c === "s" && (h = U2(i, u)), h) {
        h = is(h, e), as(t, [s, u], h), Fc(t[s], e, u, h.length);
        continue;
      }
      if (W2.test(i[u].normal)) {
        h = z2(i, u), h && (h = is(h, e), as(t, [s, u], h), a.one.setTag(h, "NumberRange", n), h[2] && h[2].tags.has("Time") && a.one.setTag([h[0]], "Time", n, null, "time-range"), Fc(t[s], e, u, h.length));
        continue;
      }
      h = H2(i, u, n), h && (h = is(h, e), as(t, [s, u], h), a.one.setTag([h[1]], "Unit", n, null, "contraction-unit"));
    }
  });
}, q2 = { contractions: K2 }, J2 = {
  model: I2,
  compute: q2,
  hooks: ["contractions"]
}, Bc = function(e) {
  const n = e.world, { model: t, methods: r } = e.world, a = r.one.setTag, { frozenLex: o } = t.one, i = t.one._multiCache || {};
  e.docs.forEach((s) => {
    for (let u = 0; u < s.length; u += 1) {
      let l = s[u], c = l.machine || l.normal;
      if (i[c] !== void 0 && s[u + 1]) {
        let h = u + i[c] - 1;
        for (let d = h; d > u; d -= 1) {
          let p = s.slice(u, d + 1), f = p.map((m) => m.machine || m.normal).join(" ");
          if (o.hasOwnProperty(f) === !0) {
            a(p, o[f], n, !1, "1-frozen-multi-lexicon"), p.forEach((m) => m.frozen = !0);
            continue;
          }
        }
      }
      if (o[c] !== void 0 && o.hasOwnProperty(c)) {
        a([l], o[c], n, !1, "1-freeze-lexicon"), l.frozen = !0;
        continue;
      }
    }
  });
}, X2 = function(e) {
  return e.docs.forEach((n) => {
    n.forEach((t) => {
      delete t.frozen;
    });
  }), e;
}, Q2 = { frozen: Bc, freeze: Bc, unfreeze: X2 }, jc = (e) => "\x1B[34m" + e + "\x1B[0m", Vc = (e) => "\x1B[3m\x1B[2m" + e + "\x1B[0m", Lc = function(e) {
  e.docs.forEach((n) => {
    console.log(jc(`
  ┌─────────`)), n.forEach((t) => {
      let r = `  ${Vc("│")}  `, a = t.implicit || t.text || "-";
      t.frozen === !0 ? r += `${jc(a)} ❄️` : r += Vc(a), console.log(r);
    });
  });
}, Y2 = {
  // add .compute('freeze')
  compute: Q2,
  mutate: (e) => {
    const n = e.methods.one;
    n.termMethods.isFrozen = (t) => t.frozen === !0, n.debug.freeze = Lc, n.debug.frozen = Lc;
  },
  api: function(e) {
    e.prototype.freeze = function() {
      return this.docs.forEach((n) => {
        n.forEach((t) => {
          t.frozen = !0;
        });
      }), this;
    }, e.prototype.unfreeze = function() {
      this.compute("unfreeze");
    }, e.prototype.isFrozen = function() {
      return this.match("@isFrozen+");
    };
  },
  // run it in init
  hooks: ["freeze"]
}, Z2 = function(e, n, t) {
  const { model: r, methods: a } = t, o = a.one.setTag, i = r.one._multiCache || {}, { lexicon: s } = r.one || {};
  let u = e[n], l = u.machine || u.normal;
  if (i[l] !== void 0 && e[n + 1]) {
    let c = n + i[l] - 1;
    for (let h = c; h > n; h -= 1) {
      let d = e.slice(n, h + 1);
      if (d.length <= 1)
        return !1;
      let p = d.map((f) => f.machine || f.normal).join(" ");
      if (s.hasOwnProperty(p) === !0) {
        let f = s[p];
        return o(d, f, t, !1, "1-multi-lexicon"), f && f.length === 2 && (f[0] === "PhrasalVerb" || f[1] === "PhrasalVerb") && o([d[1]], "Particle", t, !1, "1-phrasal-particle"), !0;
      }
    }
    return !1;
  }
  return null;
}, zc = /^(under|over|mis|re|un|dis|semi|pre|post)-?/, eC = /* @__PURE__ */ new Set(["Verb", "Infinitive", "PastTense", "Gerund", "PresentTense", "Adjective", "Participle"]), tC = function(e, n, t) {
  const { model: r, methods: a } = t, o = a.one.setTag, { lexicon: i } = r.one;
  let s = e[n], u = s.machine || s.normal;
  if (i[u] !== void 0 && i.hasOwnProperty(u))
    return o([s], i[u], t, !1, "1-lexicon"), !0;
  if (s.alias) {
    let l = s.alias.find((c) => i.hasOwnProperty(c));
    if (l)
      return o([s], i[l], t, !1, "1-lexicon-alias"), !0;
  }
  if (zc.test(u) === !0) {
    let l = u.replace(zc, "");
    if (i.hasOwnProperty(l) && l.length > 3 && eC.has(i[l]))
      return o([s], i[l], t, !1, "1-lexicon-prefix"), !0;
  }
  return null;
}, nC = function(e) {
  const n = e.world;
  e.docs.forEach((t) => {
    for (let r = 0; r < t.length; r += 1)
      if (t[r].tags.size === 0) {
        let a = null;
        a = a || Z2(t, r, n), a = a || tC(t, r, n);
      }
  });
}, rC = {
  lexicon: nC
}, aC = function(e) {
  let n = {}, t = {};
  return Object.keys(e).forEach((r) => {
    let a = e[r];
    r = r.toLowerCase().trim(), r = r.replace(/'s\b/, "");
    let o = r.split(/ /);
    o.length > 1 && (t[o[0]] === void 0 || o.length > t[o[0]]) && (t[o[0]] = o.length), n[r] = n[r] || a;
  }), delete n[""], delete n[null], delete n[" "], { lex: n, _multi: t };
}, oC = {
  one: {
    expandLexicon: aC
  }
}, iC = function(e, n = !1) {
  const t = this.world(), { methods: r, model: a } = t;
  if (!e)
    return;
  if (Object.keys(e).forEach((s) => {
    typeof e[s] == "string" && e[s].startsWith("#") && (e[s] = e[s].replace(/^#/, ""));
  }), n === !0) {
    let { lex: s, _multi: u } = r.one.expandLexicon(e, t);
    Object.assign(a.one._multiCache, u), Object.assign(a.one.frozenLex, s);
    return;
  }
  if (r.two.expandLexicon) {
    let { lex: s, _multi: u } = r.two.expandLexicon(e, t);
    Object.assign(a.one.lexicon, s), Object.assign(a.one._multiCache, u);
  }
  let { lex: o, _multi: i } = r.one.expandLexicon(e, t);
  Object.assign(a.one.lexicon, o), Object.assign(a.one._multiCache, i);
}, sC = { addWords: iC }, uC = {
  one: {
    lexicon: {},
    //setup blank lexicon
    _multiCache: {},
    frozenLex: {}
    //2nd lexicon
  }
}, lC = {
  model: uC,
  methods: oC,
  compute: rC,
  lib: sC,
  hooks: ["lexicon"]
}, cC = function(e, n) {
  const { methods: t, model: r } = n;
  return t.one.tokenize.splitTerms(e, r).map((o) => t.one.tokenize.splitWhitespace(o, r)).map((o) => o.text.toLowerCase());
}, Dm = function(e, n) {
  let t = [{}], r = [null], a = [0], o = [], i = 0;
  e.forEach(function(s) {
    let u = 0, l = cC(s, n);
    for (let c = 0; c < l.length; c++) {
      let h = l[c];
      t[u] && t[u].hasOwnProperty(h) ? u = t[u][h] : (i++, t[u][h] = i, t[i] = {}, u = i, r[i] = null);
    }
    r[u] = [l.length];
  });
  for (let s in t[0])
    i = t[0][s], a[i] = 0, o.push(i);
  for (; o.length; ) {
    let s = o.shift(), u = Object.keys(t[s]);
    for (let l = 0; l < u.length; l += 1) {
      let c = u[l], h = t[s][c];
      for (o.push(h), i = a[s]; i > 0 && !t[i].hasOwnProperty(c); )
        i = a[i];
      if (t.hasOwnProperty(i)) {
        let d = t[i][c];
        a[h] = d, r[d] && (r[h] = r[h] || [], r[h] = r[h].concat(r[d]));
      } else
        a[h] = 0;
    }
  }
  return { goNext: t, endAs: r, failTo: a };
}, hC = function(e, n, t) {
  let r = 0, a = [];
  for (let o = 0; o < e.length; o++) {
    let i = e[o][t.form] || e[o].normal;
    for (; r > 0 && (n.goNext[r] === void 0 || !n.goNext[r].hasOwnProperty(i)); )
      r = n.failTo[r] || 0;
    if (n.goNext[r].hasOwnProperty(i) && (r = n.goNext[r][i], n.endAs[r])) {
      let s = n.endAs[r];
      for (let u = 0; u < s.length; u++) {
        let l = s[u], c = e[o - l + 1], [h, d] = c.index;
        a.push([h, d, d + l, c.id]);
      }
    }
  }
  return a;
}, dC = function(e, n) {
  for (let t = 0; t < e.length; t += 1)
    if (n.has(e[t]) === !0)
      return !1;
  return !0;
}, pC = function(e, n, t) {
  let r = [];
  t.form = t.form || "normal";
  let a = e.docs;
  if (!n.goNext || !n.goNext[0])
    return console.error("Compromise invalid lookup trie"), e.none();
  let o = Object.keys(n.goNext[0]);
  for (let i = 0; i < a.length; i++) {
    if (e._cache && e._cache[i] && dC(o, e._cache[i]) === !0)
      continue;
    let s = a[i], u = hC(s, n, t);
    u.length > 0 && (r = r.concat(u));
  }
  return e.update(r);
}, fC = (e) => Object.prototype.toString.call(e) === "[object Object]";
function mC(e) {
  e.prototype.lookup = function(n, t = {}) {
    if (!n)
      return this.none();
    typeof n == "string" && (n = [n]);
    let r = fC(n) ? n : Dm(n, this.world), a = pC(this, r, t);
    return a = a.settle(), a;
  };
}
const ss = (e, n) => {
  for (let t = e.length - 1; t >= 0; t -= 1)
    if (e[t] !== n)
      return e = e.slice(0, t + 1), e;
  return e;
}, gC = function(e) {
  return e.goNext = e.goNext.map((n) => {
    if (Object.keys(n).length !== 0)
      return n;
  }), e.goNext = ss(e.goNext, void 0), e.failTo = ss(e.failTo, 0), e.endAs = ss(e.endAs, null), e;
}, nu = {
  /** turn an array or object into a compressed trie*/
  buildTrie: function(e) {
    const n = Dm(e, this.world());
    return gC(n);
  }
};
nu.compile = nu.buildTrie;
const vC = {
  api: mC,
  lib: nu
}, Gc = function(e, n) {
  return n && e.forEach((t) => {
    let r = t[0];
    n[r] && (t[0] = n[r][0], t[1] += n[r][1], t[2] += n[r][1]);
  }), e;
}, Om = function(e, n) {
  let { ptrs: t, byGroup: r } = e;
  return t = Gc(t, n), Object.keys(r).forEach((a) => {
    r[a] = Gc(r[a], n);
  }), { ptrs: t, byGroup: r };
}, Ya = function(e, n, t) {
  const r = t.methods.one;
  return typeof e == "number" && (e = String(e)), typeof e == "string" && (e = r.killUnicode(e, t), e = r.parseMatch(e, n, t)), e;
}, Rm = (e) => Object.prototype.toString.call(e) === "[object Object]", Za = (e) => e && Rm(e) && e.isView === !0, eo = (e) => e && Rm(e) && e.isNet === !0, yC = function(e, n, t) {
  const r = this.methods.one;
  if (Za(e))
    return this.intersection(e);
  if (eo(e))
    return this.sweep(e, { tagger: !1 }).view.settle();
  e = Ya(e, t, this.world);
  let a = { regs: e, group: n }, o = r.match(this.docs, a, this._cache), { ptrs: i, byGroup: s } = Om(o, this.fullPointer), u = this.toView(i);
  return u._groups = s, u;
}, bC = function(e, n, t) {
  const r = this.methods.one;
  if (Za(e))
    return this.intersection(e).eq(0);
  if (eo(e))
    return this.sweep(e, { tagger: !1, matchOne: !0 }).view;
  e = Ya(e, t, this.world);
  let a = { regs: e, group: n, justOne: !0 }, o = r.match(this.docs, a, this._cache), { ptrs: i, byGroup: s } = Om(o, this.fullPointer), u = this.toView(i);
  return u._groups = s, u;
}, xC = function(e, n, t) {
  const r = this.methods.one;
  if (Za(e))
    return this.intersection(e).fullPointer.length > 0;
  if (eo(e))
    return this.sweep(e, { tagger: !1 }).view.found;
  e = Ya(e, t, this.world);
  let a = { regs: e, group: n, justOne: !0 };
  return r.match(this.docs, a, this._cache).ptrs.length > 0;
}, wC = function(e, n, t) {
  const r = this.methods.one;
  if (Za(e))
    return this.filter((u) => u.intersection(e).found);
  if (eo(e)) {
    let u = this.sweep(e, { tagger: !1 }).view.settle();
    return this.if(u);
  }
  e = Ya(e, t, this.world);
  let a = { regs: e, group: n, justOne: !0 }, o = this.fullPointer, i = this._cache || [];
  o = o.filter((u, l) => {
    let c = this.update([u]);
    return r.match(c.docs, a, i[l]).ptrs.length > 0;
  });
  let s = this.update(o);
  return this._cache && (s._cache = o.map((u) => i[u[0]])), s;
}, CC = function(e, n, t) {
  const { methods: r } = this, a = r.one;
  if (Za(e))
    return this.filter((s) => !s.intersection(e).found);
  if (eo(e)) {
    let s = this.sweep(e, { tagger: !1 }).view.settle();
    return this.ifNo(s);
  }
  e = Ya(e, t, this.world);
  let o = this._cache || [], i = this.filter((s, u) => {
    let l = { regs: e, group: n, justOne: !0 };
    return a.match(s.docs, l, o[u]).ptrs.length === 0;
  });
  return this._cache && (i._cache = i.ptrs.map((s) => o[s[0]])), i;
}, kC = { matchOne: bC, match: yC, has: xC, if: wC, ifNo: CC }, NC = function(e, n, t) {
  const { indexN: r } = this.methods.one.pointer;
  let a = [], o = r(this.fullPointer);
  Object.keys(o).forEach((s) => {
    let u = o[s].sort((l, c) => l[1] > c[1] ? 1 : -1)[0];
    u[1] > 0 && a.push([u[0], 0, u[1]]);
  });
  let i = this.toView(a);
  return e ? i.match(e, n, t) : i;
}, AC = function(e, n, t) {
  const { indexN: r } = this.methods.one.pointer;
  let a = [], o = r(this.fullPointer), i = this.document;
  Object.keys(o).forEach((u) => {
    let l = o[u].sort((d, p) => d[1] > p[1] ? -1 : 1)[0], [c, , h] = l;
    h < i[c].length && a.push([c, h, i[c].length]);
  });
  let s = this.toView(a);
  return e ? s.match(e, n, t) : s;
}, IC = function(e, n, t) {
  typeof e == "string" && (e = this.world.methods.one.parseMatch(e, t, this.world)), e[e.length - 1].end = !0;
  let r = this.fullPointer;
  return this.forEach((a, o) => {
    let i = a.before(e, n);
    if (i.found) {
      let s = i.terms();
      r[o][1] -= s.length, r[o][3] = s.docs[0][0].id;
    }
  }), this.update(r);
}, EC = function(e, n, t) {
  typeof e == "string" && (e = this.world.methods.one.parseMatch(e, t, this.world)), e[0].start = !0;
  let r = this.fullPointer;
  return this.forEach((a, o) => {
    let i = a.after(e, n);
    if (i.found) {
      let s = i.terms();
      r[o][2] += s.length, r[o][4] = null;
    }
  }), this.update(r);
}, TC = function(e, n, t) {
  return this.growRight(e, n, t).growLeft(e, n, t);
}, PC = { before: NC, after: AC, growLeft: IC, growRight: EC, grow: TC }, Fm = function(e, n) {
  return [e[0], e[1], n[2]];
}, SC = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, gl = (e, n, t) => typeof e == "string" || SC(e) ? n.match(e, t) : e || n.none(), vl = function(e, n) {
  let [t, r, a] = e;
  return n.document[t] && n.document[t][r] && (e[3] = e[3] || n.document[t][r].id, n.document[t][a - 1] && (e[4] = e[4] || n.document[t][a - 1].id)), e;
}, ha = {};
ha.splitOn = function(e, n) {
  const { splitAll: t } = this.methods.one.pointer;
  let r = gl(e, this, n).fullPointer, a = t(this.fullPointer, r), o = [];
  return a.forEach((i) => {
    o.push(i.passthrough), o.push(i.before), o.push(i.match), o.push(i.after);
  }), o = o.filter((i) => i), o = o.map((i) => vl(i, this)), this.update(o);
};
ha.splitBefore = function(e, n) {
  const { splitAll: t } = this.methods.one.pointer;
  let r = gl(e, this, n).fullPointer, a = t(this.fullPointer, r);
  for (let i = 0; i < a.length; i += 1)
    !a[i].after && a[i + 1] && a[i + 1].before && a[i].match && a[i].match[0] === a[i + 1].before[0] && (a[i].after = a[i + 1].before, delete a[i + 1].before);
  let o = [];
  return a.forEach((i) => {
    o.push(i.passthrough), o.push(i.before), i.match && i.after ? o.push(Fm(i.match, i.after)) : o.push(i.match);
  }), o = o.filter((i) => i), o = o.map((i) => vl(i, this)), this.update(o);
};
ha.splitAfter = function(e, n) {
  const { splitAll: t } = this.methods.one.pointer;
  let r = gl(e, this, n).fullPointer, a = t(this.fullPointer, r), o = [];
  return a.forEach((i) => {
    o.push(i.passthrough), i.before && i.match ? o.push(Fm(i.before, i.match)) : (o.push(i.before), o.push(i.match)), o.push(i.after);
  }), o = o.filter((i) => i), o = o.map((i) => vl(i, this)), this.update(o);
};
ha.split = ha.splitAfter;
const DC = function(e, n) {
  return !e || !n || e[0] !== n[0] ? !1 : e[2] === n[1];
}, Hc = function(e, n, t) {
  const r = e.world, a = r.methods.one.parseMatch;
  n = n || ".$", t = t || "^.";
  let o = a(n, {}, r), i = a(t, {}, r);
  o[o.length - 1].end = !0, i[0].start = !0;
  let s = e.fullPointer, u = [s[0]];
  for (let l = 1; l < s.length; l += 1) {
    let c = u[u.length - 1], h = s[l], d = e.update([c]), p = e.update([h]);
    DC(c, h) && d.has(o) && p.has(i) ? u[u.length - 1] = [c[0], c[1], h[2], c[3], h[4]] : u.push(h);
  }
  return e.update(u);
}, OC = {
  //  merge only if conditions are met
  joinIf: function(e, n) {
    return Hc(this, e, n);
  },
  // merge all neighbouring matches
  join: function() {
    return Hc(this);
  }
}, Zt = Object.assign({}, kC, PC, ha, OC);
Zt.lookBehind = Zt.before;
Zt.lookBefore = Zt.before;
Zt.lookAhead = Zt.after;
Zt.lookAfter = Zt.after;
Zt.notIf = Zt.ifNo;
const RC = function(e) {
  Object.assign(e.prototype, Zt);
}, FC = /(?:^|\s)([![^]*(?:<[^<]*>)?\/.*?[^\\/]\/[?\]+*$~]*)(?:\s|$)/, MC = /([!~[^]*(?:<[^<]*>)?\([^)]+[^\\)]\)[?\]+*$~]*)(?:\s|$)/, _C = / /g, BC = (e) => /^[![^]*(<[^<]*>)?\(/.test(e) && /\)[?\]+*$~]*$/.test(e), Wc = (e) => /^[![^]*(<[^<]*>)?\//.test(e) && /\/[?\]+*$~]*$/.test(e), $c = function(e) {
  return e = e.map((n) => n.trim()), e = e.filter((n) => n), e;
}, jC = function(e) {
  let n = e.split(FC), t = [];
  n.forEach((a) => {
    if (Wc(a)) {
      t.push(a);
      return;
    }
    t = t.concat(a.split(MC));
  }), t = $c(t);
  let r = [];
  return t.forEach((a) => {
    BC(a) || Wc(a) ? r.push(a) : r = r.concat(a.split(_C));
  }), r = $c(r), r;
}, Uc = /\{([0-9]+)?(, *[0-9]*)?\}/, Kc = /&&/, VC = new RegExp(/^<\s*(\S+)\s*>/), qc = (e) => e.charAt(0).toUpperCase() + e.substring(1), _t = (e) => e.charAt(e.length - 1), Nt = (e) => e.charAt(0), Zr = (e) => e.substring(1), ea = (e) => e.substring(0, e.length - 1), Aa = function(e) {
  return e = Zr(e), e = ea(e), e;
}, Mm = function(e, n) {
  let t = {};
  for (let r = 0; r < 2; r += 1) {
    if (_t(e) === "$" && (t.end = !0, e = ea(e)), Nt(e) === "^" && (t.start = !0, e = Zr(e)), _t(e) === "?" && (t.optional = !0, e = ea(e)), (Nt(e) === "[" || _t(e) === "]") && (t.group = null, Nt(e) === "[" && (t.groupStart = !0), _t(e) === "]" && (t.groupEnd = !0), e = e.replace(/^\[/, ""), e = e.replace(/\]$/, ""), Nt(e) === "<")) {
      const a = VC.exec(e);
      a.length >= 2 && (t.group = a[1], e = e.replace(a[0], ""));
    }
    if (_t(e) === "+" && (t.greedy = !0, e = ea(e)), e !== "*" && _t(e) === "*" && e !== "\\*" && (t.greedy = !0, e = ea(e)), Nt(e) === "!" && (t.negative = !0, e = Zr(e)), Nt(e) === "~" && _t(e) === "~" && e.length > 2 && (e = Aa(e), t.fuzzy = !0, t.min = n.fuzzy || 0.85, /\(/.test(e) === !1))
      return t.word = e, t;
    if (Nt(e) === "/" && _t(e) === "/")
      return e = Aa(e), n.caseSensitive && (t.use = "text"), t.regex = new RegExp(e), t;
    if (Uc.test(e) === !0 && (e = e.replace(Uc, (a, o, i) => (i === void 0 ? (t.min = Number(o), t.max = Number(o)) : (i = i.replace(/, */, ""), o === void 0 ? (t.min = 0, t.max = Number(i)) : (t.min = Number(o), t.max = Number(i || 999))), t.greedy = !0, t.min || (t.optional = !0), ""))), Nt(e) === "(" && _t(e) === ")") {
      Kc.test(e) ? (t.choices = e.split(Kc), t.operator = "and") : (t.choices = e.split("|"), t.operator = "or"), t.choices[0] = Zr(t.choices[0]);
      let a = t.choices.length - 1;
      t.choices[a] = ea(t.choices[a]), t.choices = t.choices.map((o) => o.trim()), t.choices = t.choices.filter((o) => o), t.choices = t.choices.map((o) => o.split(/ /g).map((i) => Mm(i, n))), e = "";
    }
    if (Nt(e) === "{" && _t(e) === "}") {
      if (e = Aa(e), t.root = e, /\//.test(e)) {
        let a = t.root.split(/\//);
        t.root = a[0], t.pos = a[1], t.pos === "adj" && (t.pos = "Adjective"), t.pos = t.pos.charAt(0).toUpperCase() + t.pos.substr(1).toLowerCase(), a[2] !== void 0 && (t.sense = a[2]);
      }
      return t;
    }
    if (Nt(e) === "<" && _t(e) === ">")
      return e = Aa(e), t.chunk = qc(e), t.greedy = !0, t;
    if (Nt(e) === "%" && _t(e) === "%")
      return e = Aa(e), t.switch = e, t;
  }
  return Nt(e) === "#" ? (t.tag = Zr(e), t.tag = qc(t.tag), t) : Nt(e) === "@" ? (t.method = Zr(e), t) : e === "." ? (t.anything = !0, t) : e === "*" ? (t.anything = !0, t.greedy = !0, t.optional = !0, t) : (e && (e = e.replace("\\*", "*"), e = e.replace("\\.", "."), n.caseSensitive ? t.use = "text" : e = e.toLowerCase(), t.word = e), t);
}, LC = /[a-z0-9][-–—][a-z]/i, zC = function(e, n) {
  let t = n.model.one.prefixes;
  for (let r = e.length - 1; r >= 0; r -= 1) {
    let a = e[r];
    if (a.word && LC.test(a.word)) {
      let o = a.word.split(/[-–—]/g);
      if (t.hasOwnProperty(o[0]))
        continue;
      o = o.filter((i) => i).reverse(), e.splice(r, 1), o.forEach((i) => {
        let s = Object.assign({}, a);
        s.word = i, e.splice(r, 0, s);
      });
    }
  }
  return e;
}, Jc = function(e, n) {
  let { all: t } = n.methods.two.transform.verb || {}, r = e.root;
  return t ? t(r, n.model) : [];
}, Xc = function(e, n) {
  let { all: t } = n.methods.two.transform.noun || {};
  return t ? t(e.root, n.model) : [e.root];
}, Qc = function(e, n) {
  let { all: t } = n.methods.two.transform.adjective || {};
  return t ? t(e.root, n.model) : [e.root];
}, GC = function(e, n) {
  return e = e.map((t) => {
    if (t.root)
      if (n.methods.two && n.methods.two.transform) {
        let r = [];
        t.pos ? t.pos === "Verb" ? r = r.concat(Jc(t, n)) : t.pos === "Noun" ? r = r.concat(Xc(t, n)) : t.pos === "Adjective" && (r = r.concat(Qc(t, n))) : (r = r.concat(Jc(t, n)), r = r.concat(Xc(t, n)), r = r.concat(Qc(t, n))), r = r.filter((a) => a), r.length > 0 && (t.operator = "or", t.fastOr = new Set(r));
      } else
        t.machine = t.root, delete t.id, delete t.root;
    return t;
  }), e;
}, HC = function(e) {
  let n = 0, t = null;
  for (let r = 0; r < e.length; r++) {
    const a = e[r];
    a.groupStart === !0 && (t = a.group, t === null && (t = String(n), n += 1)), t !== null && (a.group = t), a.groupEnd === !0 && (t = null);
  }
  return e;
}, WC = function(e) {
  return e.map((n) => {
    if (n.choices !== void 0) {
      if (n.operator !== "or" || n.fuzzy === !0)
        return n;
      n.choices.every((r) => {
        if (r.length !== 1)
          return !1;
        let a = r[0];
        return a.fuzzy === !0 || a.start || a.end ? !1 : a.word !== void 0 && a.negative !== !0 && a.optional !== !0 && a.method !== !0;
      }) === !0 && (n.fastOr = /* @__PURE__ */ new Set(), n.choices.forEach((r) => {
        n.fastOr.add(r[0].word);
      }), delete n.choices);
    }
    return n;
  });
}, $C = function(e) {
  return e.map((n) => (n.fuzzy && n.choices && n.choices.forEach((t) => {
    t.length === 1 && t[0].word && (t[0].fuzzy = !0, t[0].min = n.min);
  }), n));
}, UC = function(e) {
  return e = HC(e), e = WC(e), e = $C(e), e;
}, KC = function(e, n, t) {
  if (e == null || e === "")
    return [];
  n = n || {}, typeof e == "number" && (e = String(e));
  let r = jC(e);
  return r = r.map((a) => Mm(a, n)), r = zC(r, t), r = GC(r, t), r = UC(r), r;
}, qC = function(e, n) {
  for (let t of n)
    if (e.has(t))
      return !0;
  return !1;
}, JC = function(e, n) {
  for (let t = 0; t < e.length; t += 1) {
    let r = e[t];
    if (!(r.optional === !0 || r.negative === !0 || r.fuzzy === !0)) {
      if (r.word !== void 0 && n.has(r.word) === !1 || r.tag !== void 0 && n.has("#" + r.tag) === !1)
        return !0;
      if (r.fastOr && qC(r.fastOr, n) === !1)
        return !1;
    }
  }
  return !1;
}, XC = function(e, n) {
  let t = e.length, r = n.length;
  if (t === 0)
    return r;
  if (r === 0)
    return t;
  let a = (r > t ? r : t) + 1;
  if (Math.abs(t - r) > (a || 100))
    return a || 100;
  let o = [];
  for (let d = 0; d < a; d++)
    o[d] = [d], o[d].length = a;
  for (let d = 0; d < a; d++)
    o[0][d] = d;
  let i, s, u, l, c, h;
  for (let d = 1; d <= t; ++d)
    for (s = e[d - 1], i = 1; i <= r; ++i) {
      if (d === i && o[d][i] > 4)
        return t;
      u = n[i - 1], l = s === u ? 0 : 1, c = o[d - 1][i] + 1, (h = o[d][i - 1] + 1) < c && (c = h), (h = o[d - 1][i - 1] + l) < c && (c = h), d > 1 && i > 1 && s === n[i - 2] && e[d - 2] === u && (h = o[d - 2][i - 2] + l) < c ? o[d][i] = h : o[d][i] = c;
    }
  return o[t][r];
}, QC = function(e, n, t = 3) {
  if (e === n)
    return 1;
  if (e.length < t || n.length < t)
    return 0;
  const r = XC(e, n);
  let a = Math.max(e.length, n.length);
  return 1 - (a === 0 ? 0 : r / a);
}, YC = /([\u0022\uFF02\u0027\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F])/, ZC = /([\u0022\uFF02\u0027\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4])/, Yc = /^[-–—]$/, Zc = / [-–—]{1,3} /, on = (e, n) => e.post.indexOf(n) !== -1, Wa = {
  /** does it have a quotation symbol?  */
  hasQuote: (e) => YC.test(e.pre) || ZC.test(e.post),
  /** does it have a comma?  */
  hasComma: (e) => on(e, ","),
  /** does it end in a period? */
  hasPeriod: (e) => on(e, ".") === !0 && on(e, "...") === !1,
  /** does it end in an exclamation */
  hasExclamation: (e) => on(e, "!"),
  /** does it end with a question mark? */
  hasQuestionMark: (e) => on(e, "?") || on(e, "¿"),
  /** is there a ... at the end? */
  hasEllipses: (e) => on(e, "..") || on(e, "…"),
  /** is there a semicolon after term word? */
  hasSemicolon: (e) => on(e, ";"),
  /** is there a colon after term word? */
  hasColon: (e) => on(e, ":"),
  /** is there a slash '/' in term word? */
  hasSlash: (e) => /\//.test(e.text),
  /** a hyphen connects two words like-term */
  hasHyphen: (e) => Yc.test(e.post) || Yc.test(e.pre),
  /** a dash separates words - like that */
  hasDash: (e) => Zc.test(e.post) || Zc.test(e.pre),
  /** is it multiple words combinded */
  hasContraction: (e) => !!e.implicit,
  /** is it an acronym */
  isAcronym: (e) => e.tags.has("Acronym"),
  /** does it have any tags */
  isKnown: (e) => e.tags.size > 0,
  /** uppercase first letter, then a lowercase */
  isTitleCase: (e) => new RegExp("^\\p{Lu}[a-z'\\u00C0-\\u00FF]", "u").test(e.text),
  /** uppercase all letters */
  isUpperCase: (e) => new RegExp("^\\p{Lu}+$", "u").test(e.text)
};
Wa.hasQuotation = Wa.hasQuote;
let at = function() {
};
const ek = function(e, n, t, r) {
  if (n.anything === !0)
    return !0;
  if (n.start === !0 && t !== 0 || n.end === !0 && t !== r - 1)
    return !1;
  if (n.id !== void 0 && n.id === e.id)
    return !0;
  if (n.word !== void 0)
    return n.use ? n.word === e[n.use] : e.machine !== null && e.machine === n.word || e.alias !== void 0 && e.alias.hasOwnProperty(n.word) || n.fuzzy === !0 && (n.word === e.root || QC(n.word, e.normal) >= n.min) || e.alias && e.alias.some((a) => a === n.word) ? !0 : n.word === e.text || n.word === e.normal;
  if (n.tag !== void 0)
    return e.tags.has(n.tag) === !0;
  if (n.method !== void 0)
    return typeof Wa[n.method] == "function" && Wa[n.method](e) === !0;
  if (n.pre !== void 0)
    return e.pre && e.pre.includes(n.pre);
  if (n.post !== void 0)
    return e.post && e.post.includes(n.post);
  if (n.regex !== void 0) {
    let a = e.normal;
    return n.use && (a = e[n.use]), n.regex.test(a);
  }
  if (n.chunk !== void 0)
    return e.chunk === n.chunk;
  if (n.switch !== void 0)
    return e.switch === n.switch;
  if (n.machine !== void 0)
    return e.normal === n.machine || e.machine === n.machine || e.root === n.machine;
  if (n.sense !== void 0)
    return e.sense === n.sense;
  if (n.fastOr !== void 0) {
    if (n.pos && !e.tags.has(n.pos))
      return null;
    let a = e.root || e.implicit || e.machine || e.normal;
    return n.fastOr.has(a) || n.fastOr.has(e.text);
  }
  return n.choices !== void 0 ? n.operator === "and" ? n.choices.every((a) => at(e, a, t, r)) : n.choices.some((a) => at(e, a, t, r)) : !1;
};
at = function(e, n, t, r) {
  let a = ek(e, n, t, r);
  return n.negative === !0 ? !a : a;
};
const tk = function(e, n) {
  let t = Object.assign({}, e.regs[e.r], { start: !1, end: !1 }), r = e.t;
  for (; e.t < e.terms.length; e.t += 1) {
    if (n && at(e.terms[e.t], n, e.start_i + e.t, e.phrase_length))
      return e.t;
    let a = e.t - r + 1;
    if (t.max !== void 0 && a === t.max)
      return e.t;
    if (at(e.terms[e.t], t, e.start_i + e.t, e.phrase_length) === !1)
      return t.min !== void 0 && a < t.min ? null : e.t;
  }
  return e.t;
}, nk = function(e, n) {
  let t = e.t;
  if (!n)
    return e.terms.length;
  for (; t < e.terms.length; t += 1)
    if (at(e.terms[t], n, e.start_i + t, e.phrase_length) === !0)
      return t;
  return null;
}, rk = function(e, n) {
  if (e.end === !0 && e.greedy === !0 && n.start_i + n.t < n.phrase_length - 1) {
    let t = Object.assign({}, e, { end: !1 });
    if (at(n.terms[n.t], t, n.start_i + n.t, n.phrase_length) === !0)
      return !0;
  }
  return !1;
}, Ai = function(e, n) {
  return e.groups[e.inGroup] || (e.groups[e.inGroup] = {
    start: n,
    length: 0
  }), e.groups[e.inGroup];
}, ak = function(e) {
  let { regs: n } = e, t = n[e.r], r = nk(e, n[e.r + 1]);
  if (r === null || r === 0 || t.min !== void 0 && r - e.t < t.min)
    return null;
  if (t.max !== void 0 && r - e.t > t.max)
    return e.t = e.t + t.max, !0;
  if (e.hasGroup === !0) {
    const a = Ai(e, e.t);
    a.length = r - e.t;
  }
  return e.t = r, !0;
}, ok = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, _m = function(e, n = 0) {
  let t = e.regs[e.r], r = !1;
  for (let a = 0; a < t.choices.length; a += 1) {
    let o = t.choices[a];
    if (!ok(o))
      return !1;
    if (r = o.every((i, s) => {
      let u = 0, l = e.t + s + n + u;
      if (e.terms[l] === void 0)
        return !1;
      let c = at(e.terms[l], i, l + e.start_i, e.phrase_length);
      if (c === !0 && i.greedy === !0)
        for (let h = 1; h < e.terms.length; h += 1) {
          let d = e.terms[l + h];
          if (d)
            if (at(d, i, e.start_i + h, e.phrase_length) === !0)
              u += 1;
            else
              break;
        }
      return n += u, c;
    }), r) {
      n += o.length;
      break;
    }
  }
  return r && t.greedy === !0 ? _m(e, n) : n;
}, ik = function(e) {
  let n = 0;
  return e.regs[e.r].choices.every((a) => {
    let o = a.every((i, s) => {
      let u = e.t + s;
      return e.terms[u] === void 0 ? !1 : at(e.terms[u], i, u, e.phrase_length);
    });
    return o === !0 && a.length > n && (n = a.length), o;
  }) === !0 ? n : !1;
}, sk = function(e) {
  const { regs: n } = e;
  let t = n[e.r], r = _m(e);
  if (r) {
    if (t.negative === !0)
      return null;
    if (e.hasGroup === !0) {
      const a = Ai(e, e.t);
      a.length += r;
    }
    if (t.end === !0) {
      let a = e.phrase_length;
      if (e.t + e.start_i + r !== a)
        return null;
    }
    return e.t += r, !0;
  } else if (!t.optional)
    return null;
  return !0;
}, uk = function(e) {
  const { regs: n } = e;
  let t = n[e.r], r = ik(e);
  if (r) {
    if (t.negative === !0)
      return null;
    if (e.hasGroup === !0) {
      const a = Ai(e, e.t);
      a.length += r;
    }
    if (t.end === !0) {
      let a = e.phrase_length - 1;
      if (e.t + e.start_i !== a)
        return null;
    }
    return e.t += r, !0;
  } else if (!t.optional)
    return null;
  return !0;
}, lk = function(e, n, t) {
  let r = 0;
  for (let a = e.t; a < e.terms.length; a += 1) {
    let o = at(e.terms[a], n, e.start_i + e.t, e.phrase_length);
    if (o || t && (o = at(e.terms[a], t, e.start_i + e.t, e.phrase_length), o) || (r += 1, n.max !== void 0 && r === n.max))
      break;
  }
  return r === 0 || n.min && n.min > r ? !1 : (e.t += r, !0);
}, ck = function(e) {
  const { regs: n } = e;
  let t = n[e.r], r = Object.assign({}, t);
  if (r.negative = !1, at(e.terms[e.t], r, e.start_i + e.t, e.phrase_length))
    return !1;
  if (t.optional) {
    let o = n[e.r + 1];
    o && (at(e.terms[e.t], o, e.start_i + e.t, e.phrase_length) ? e.r += 1 : o.optional && n[e.r + 2] && at(e.terms[e.t], n[e.r + 2], e.start_i + e.t, e.phrase_length) && (e.r += 2));
  }
  return t.greedy ? lk(e, r, n[e.r + 1]) : (e.t += 1, !0);
}, hk = function(e) {
  const { regs: n } = e;
  let t = n[e.r], r = e.terms[e.t], a = at(r, n[e.r + 1], e.start_i + e.t, e.phrase_length);
  if (t.negative || a) {
    let o = e.terms[e.t + 1];
    (!o || !at(o, n[e.r + 1], e.start_i + e.t, e.phrase_length)) && (e.r += 1);
  }
}, dk = function(e) {
  const { regs: n, phrase_length: t } = e;
  let r = n[e.r];
  return e.t = tk(e, n[e.r + 1]), e.t === null || r.min && r.min > e.t || r.end === !0 && e.start_i + e.t !== t ? null : !0;
}, pk = function(e) {
  let n = e.terms[e.t], t = e.regs[e.r];
  if (n.implicit && e.terms[e.t + 1]) {
    if (!e.terms[e.t + 1].implicit)
      return;
    t.word === n.normal && (e.t += 1), t.method === "hasContraction" && (e.t += 1);
  }
}, fk = function(e, n) {
  let t = e.regs[e.r];
  const r = Ai(e, n);
  e.t > 1 && t.greedy ? r.length += e.t - n : r.length++;
}, us = function(e) {
  const { regs: n } = e;
  let t = n[e.r], r = e.terms[e.t], a = e.t;
  return t.optional && n[e.r + 1] && t.negative ? !0 : (t.optional && n[e.r + 1] && hk(e), r.implicit && e.terms[e.t + 1] && pk(e), e.t += 1, t.end === !0 && e.t !== e.terms.length && t.greedy !== !0 || t.greedy === !0 && !dk(e) ? null : (e.hasGroup === !0 && fk(e, a), !0));
}, yl = function(e, n, t, r) {
  if (e.length === 0 || n.length === 0)
    return null;
  let a = {
    t: 0,
    terms: e,
    r: 0,
    regs: n,
    groups: {},
    start_i: t,
    phrase_length: r,
    inGroup: null
  };
  for (; a.r < n.length; a.r += 1) {
    let s = n[a.r];
    if (a.hasGroup = !!s.group, a.hasGroup === !0 ? a.inGroup = s.group : a.inGroup = null, !a.terms[a.t]) {
      if (n.slice(a.r).some((c) => !c.optional) === !1)
        break;
      return null;
    }
    if (s.anything === !0 && s.greedy === !0) {
      if (!ak(a))
        return null;
      continue;
    }
    if (s.choices !== void 0 && s.operator === "or") {
      if (!sk(a))
        return null;
      continue;
    }
    if (s.choices !== void 0 && s.operator === "and") {
      if (!uk(a))
        return null;
      continue;
    }
    if (s.anything === !0) {
      if (s.negative && s.anything || !us(a))
        return null;
      continue;
    }
    if (rk(s, a) === !0) {
      if (!us(a))
        return null;
      continue;
    }
    if (s.negative) {
      if (!ck(a))
        return null;
      continue;
    }
    if (at(a.terms[a.t], s, a.start_i + a.t, a.phrase_length) === !0) {
      if (!us(a))
        return null;
      continue;
    }
    if (s.optional !== !0)
      return null;
  }
  let o = [null, t, a.t + t];
  if (o[1] === o[2])
    return null;
  let i = {};
  return Object.keys(a.groups).forEach((s) => {
    let u = a.groups[s], l = t + u.start;
    i[s] = [null, l, l + u.length];
  }), { pointer: o, groups: i };
}, mk = function(e, n) {
  let t = [], r = {};
  return e.length === 0 ? { ptrs: t, byGroup: r } : (typeof n == "number" && (n = String(n)), n ? e.forEach((a) => {
    a.groups[n] && t.push(a.groups[n]);
  }) : e.forEach((a) => {
    t.push(a.pointer), Object.keys(a.groups).forEach((o) => {
      r[o] = r[o] || [], r[o].push(a.groups[o]);
    });
  }), { ptrs: t, byGroup: r });
}, gk = function(e, n, t) {
  return e = e.filter((r) => {
    let [a, o, i] = r.pointer, s = t[a].slice(o, i);
    for (let u = 0; u < s.length; u += 1) {
      let l = s.slice(u);
      if (yl(l, n, u, s.length) !== null)
        return !1;
    }
    return !0;
  }), e;
}, Bm = function(e, n) {
  return e.pointer[0] = n, Object.keys(e.groups).forEach((t) => {
    e.groups[t][0] = n;
  }), e;
}, vk = function(e, n, t) {
  let r = yl(e, n, 0, e.length);
  return r ? (r = Bm(r, t), r) : null;
}, yk = function(e, n, t) {
  t = t || [];
  let { regs: r, group: a, justOne: o } = n, i = [];
  if (!r || r.length === 0)
    return { ptrs: [], byGroup: {} };
  const s = r.filter((u) => u.optional !== !0 && u.negative !== !0).length;
  e: for (let u = 0; u < e.length; u += 1) {
    let l = e[u];
    if (!(t[u] && JC(r, t[u]))) {
      if (r[0].start === !0) {
        let c = vk(l, r, u);
        c && i.push(c);
        continue;
      }
      for (let c = 0; c < l.length; c += 1) {
        let h = l.slice(c);
        if (h.length < s)
          break;
        let d = yl(h, r, c, l.length);
        if (d) {
          if (d = Bm(d, u), i.push(d), o === !0)
            break e;
          let p = d.pointer[2];
          Math.abs(p - 1) > c && (c = Math.abs(p - 1));
        }
      }
    }
  }
  return r[r.length - 1].end === !0 && (i = i.filter((u) => {
    let l = u.pointer[0];
    return e[l].length === u.pointer[2];
  })), n.notIf && (i = gk(i, n.notIf, e)), i = mk(i, a), i.ptrs.forEach((u) => {
    let [l, c, h] = u;
    u[3] = e[l][c].id, u[4] = e[l][h - 1].id;
  }), i;
}, bk = {
  one: {
    termMethods: Wa,
    parseMatch: KC,
    match: yk
  }
}, xk = {
  /** pre-parse any match statements */
  parseMatch: function(e, n) {
    const t = this.world();
    let r = t.methods.one.killUnicode;
    return r && (e = r(e, t)), t.methods.one.parseMatch(e, n, t);
  }
}, wk = {
  api: RC,
  methods: bk,
  lib: xk
}, Ck = /^\../, kk = /^#./, Nk = (e) => (e = e.replace(/&/g, "&amp;"), e = e.replace(/</g, "&lt;"), e = e.replace(/>/g, "&gt;"), e = e.replace(/"/g, "&quot;"), e = e.replace(/'/g, "&apos;"), e), Ak = function(e) {
  let n = "", t = "</span>";
  return e = Nk(e), Ck.test(e) ? n = `<span class="${e.replace(/^\./, "")}"` : kk.test(e) ? n = `<span id="${e.replace(/^#/, "")}"` : (n = `<${e}`, t = `</${e}>`), n += ">", { start: n, end: t };
}, Ik = function(e, n) {
  let t = {}, r = {};
  return Object.keys(n).forEach((a) => {
    let o = n[a], i = Ak(a);
    typeof o == "string" && (o = e.match(o)), o.docs.forEach((s) => {
      if (s.every((c) => c.implicit))
        return;
      let u = s[0].id;
      t[u] = t[u] || [], t[u].push(i.start);
      let l = s[s.length - 1].id;
      r[l] = r[l] || [], r[l].push(i.end);
    });
  }), { starts: t, ends: r };
}, Ek = function(e) {
  let { starts: n, ends: t } = Ik(this, e), r = "";
  return this.docs.forEach((a) => {
    for (let o = 0; o < a.length; o += 1) {
      let i = a[o];
      n.hasOwnProperty(i.id) && (r += n[i.id].join("")), r += i.pre || "", r += i.text || "", t.hasOwnProperty(i.id) && (r += t[i.id].join("")), r += i.post || "";
    }
  }), r;
}, Tk = { html: Ek }, jm = /[,:;)\]*.?~!\u0022\uFF02\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4—-]+$/, ru = /^[(['"*~\uFF02\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F]+/, Pk = /[,:;)('"\u201D\]]/, Sk = /^[-–—]$/, Dk = / /, mr = function(e, n, t = !0) {
  let r = "";
  return e.forEach((a) => {
    let o = a.pre || "", i = a.post || "";
    n.punctuation === "some" && (o = o.replace(ru, ""), Sk.test(i) && (i = " "), i = i.replace(Pk, ""), i = i.replace(/\?!+/, "?"), i = i.replace(/!+/, "!"), i = i.replace(/\?+/, "?"), i = i.replace(/\.{2,}/, ""), a.tags.has("Abbreviation") && (i = i.replace(/\./, ""))), n.whitespace === "some" && (o = o.replace(/\s/, ""), i = i.replace(/\s+/, " ")), n.keepPunct || (o = o.replace(ru, ""), i === "-" ? i = " " : i = i.replace(jm, ""));
    let s = a[n.form || "text"] || a.normal || "";
    n.form === "implicit" && (s = a.implicit || a.text), n.form === "root" && a.implicit && (s = a.root || a.implicit || a.normal), (n.form === "machine" || n.form === "implicit" || n.form === "root") && a.implicit && (!i || !Dk.test(i)) && (i += " "), r += o + s + i;
  }), t === !1 && (r = r.trim()), n.lowerCase === !0 && (r = r.toLowerCase()), r;
}, Ok = function(e, n) {
  let t = "";
  if (!e || !e[0] || !e[0][0])
    return t;
  for (let r = 0; r < e.length; r += 1)
    t += mr(e[r], n, !0);
  if (n.keepSpace || (t = t.trim()), n.keepEndPunct === !1) {
    e[0][0].tags.has("Emoticon") || (t = t.replace(ru, ""));
    let r = e[e.length - 1];
    r[r.length - 1].tags.has("Emoticon") || (t = t.replace(jm, "")), t.endsWith("'") && !t.endsWith("s'") && (t = t.replace(/'/, ""));
  }
  return n.cleanWhitespace === !0 && (t = t.trim()), t;
}, rr = {
  text: {
    form: "text"
  },
  normal: {
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "normal"
  },
  machine: {
    keepSpace: !1,
    whitespace: "some",
    punctuation: "some",
    case: "none",
    unicode: "some",
    form: "machine"
  },
  root: {
    keepSpace: !1,
    whitespace: "some",
    punctuation: "some",
    case: "some",
    unicode: "some",
    form: "root"
  },
  implicit: {
    form: "implicit"
  }
};
rr.clean = rr.normal;
rr.reduced = rr.root;
let Vm = [], yr = 0;
for (; yr < 64; )
  Vm[yr] = 0 | Math.sin(++yr % Math.PI) * 4294967296;
const bl = function(e) {
  let n, t, r, a = [n = 1732584193, t = 4023233417, ~n, ~t], o = [], i = decodeURI(encodeURI(e)) + "", s = i.length;
  for (e = --s / 4 + 2 | 15, o[--e] = s * 8; ~s; )
    o[s >> 2] |= i.charCodeAt(s) << 8 * s--;
  for (yr = i = 0; yr < e; yr += 16) {
    for (s = a; i < 64; s = [
      r = s[3],
      n + ((r = s[0] + [n & t | ~n & r, r & n | ~r & t, n ^ t ^ r, t ^ (n | ~r)][s = i >> 4] + Vm[i] + ~~o[yr | [i, 5 * i + 1, 3 * i + 5, 7 * i][s] & 15]) << (s = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21][4 * s + i++ % 4]) | r >>> -s),
      n,
      t
    ])
      n = s[1] | 0, t = s[2];
    for (i = 4; i; ) a[--i] += s[i];
  }
  for (e = ""; i < 32; )
    e += (a[i >> 3] >> (1 ^ i++) * 4 & 15).toString(16);
  return e;
}, Rk = {
  text: !0,
  terms: !0
};
let eh = { case: "none", unicode: "some", form: "machine", punctuation: "some" };
const ls = function(e, n) {
  return Object.assign({}, e, n);
}, jn = {
  text: (e) => mr(e, { keepPunct: !0 }, !1),
  normal: (e) => mr(e, ls(rr.normal, { keepPunct: !0 }), !1),
  implicit: (e) => mr(e, ls(rr.implicit, { keepPunct: !0 }), !1),
  machine: (e) => mr(e, eh, !1),
  root: (e) => mr(e, ls(eh, { form: "root" }), !1),
  hash: (e) => bl(mr(e, { keepPunct: !0 }, !1)),
  offset: (e) => {
    let n = jn.text(e).length;
    return {
      index: e[0].offset.index,
      start: e[0].offset.start,
      length: n
    };
  },
  terms: (e) => e.map((n) => {
    let t = Object.assign({}, n);
    return t.tags = Array.from(n.tags), t;
  }),
  confidence: (e, n, t) => n.eq(t).confidence(),
  syllables: (e, n, t) => n.eq(t).syllables(),
  sentence: (e, n, t) => n.eq(t).fullSentence().text(),
  dirty: (e) => e.some((n) => n.dirty === !0)
};
jn.sentences = jn.sentence;
jn.clean = jn.normal;
jn.reduced = jn.root;
const Fk = function(e, n) {
  return n = n || {}, typeof n == "string" && (n = {}), n = Object.assign({}, Rk, n), n.offset && e.compute("offset"), e.docs.map((t, r) => {
    let a = {};
    return Object.keys(n).forEach((o) => {
      n[o] && jn[o] && (a[o] = jn[o](t, e, r));
    }), a;
  });
}, au = {
  /** return data */
  json: function(e) {
    let n = Fk(this, e);
    return typeof e == "number" ? n[e] : n;
  }
};
au.data = au.json;
const Mk = () => typeof window < "u" && window.document, _k = function(e) {
  let n = this.methods.one.debug || {};
  return e && n.hasOwnProperty(e) ? (n[e](this), this) : Mk() ? (n.clientSide(this), this) : (n.tags(this), this);
}, Bk = function(e) {
  let n = e.pre || "", t = e.post || "";
  return n + e.text + t;
}, jk = function(e, n) {
  let t = {};
  return Object.keys(n).forEach((r) => {
    e.match(r).fullPointer.forEach((o) => {
      t[o[3]] = { fn: n[r], end: o[2] };
    });
  }), t;
}, Lm = function(e, n) {
  let t = jk(e, n), r = "";
  return e.docs.forEach((a, o) => {
    for (let i = 0; i < a.length; i += 1) {
      let s = a[i];
      if (t.hasOwnProperty(s.id)) {
        let { fn: u, end: l } = t[s.id], c = e.update([[o, i, l]]);
        r += a[i].pre || "", r += u(c), i = l - 1, r += a[i].post || "";
      } else
        r += Bk(s);
    }
  }), r;
}, Vk = (e) => Object.prototype.toString.call(e) === "[object Object]", Lk = function(e) {
  let n = {};
  return e.forEach((r) => {
    n[r] = n[r] || 0, n[r] += 1;
  }), Object.keys(n).map((r) => ({ normal: r, count: n[r] })).sort((r, a) => r.count > a.count ? -1 : 0);
}, zk = function(e) {
  if (Vk(e))
    return Lm(this, e);
  if (e === "text")
    return this.text();
  if (e === "normal")
    return this.text("normal");
  if (e === "root")
    return this.text("root");
  if (e === "machine" || e === "reduced")
    return this.text("machine");
  if (e === "hash" || e === "md5")
    return bl(this.text());
  if (e === "json")
    return this.json();
  if (e === "offset" || e === "offsets")
    return this.compute("offset"), this.json({ offset: !0 });
  if (e === "array")
    return this.docs.map((t) => t.reduce((r, a) => r + a.pre + a.text + a.post, "").trim()).filter((t) => t);
  if (e === "freq" || e === "frequency" || e === "topk")
    return Lk(this.json({ normal: !0 }).map((n) => n.normal));
  if (e === "terms") {
    let n = [];
    return this.docs.forEach((t) => {
      let r = t.map((a) => a.text);
      r = r.filter((a) => a), n = n.concat(r);
    }), n;
  }
  return e === "tags" ? this.docs.map((n) => n.reduce((t, r) => (t[r.implicit || r.normal] = Array.from(r.tags), t), {})) : e === "debug" ? this.debug() : this.text();
}, Gk = {
  /** */
  debug: _k,
  /** */
  out: zk,
  /** */
  wrap: function(e) {
    return Lm(this, e);
  }
}, Hk = (e) => Object.prototype.toString.call(e) === "[object Object]", Wk = {
  /** */
  text: function(e) {
    let n = {};
    if (e && typeof e == "string" && rr.hasOwnProperty(e) ? n = Object.assign({}, rr[e]) : e && Hk(e) && (n = Object.assign({}, e)), n.keepSpace === void 0 && !this.isFull() && (n.keepSpace = !1), n.keepEndPunct === void 0 && this.pointer) {
      let t = this.pointer[0];
      t && t[1] ? n.keepEndPunct = !1 : n.keepEndPunct = !0;
    }
    return n.keepPunct === void 0 && (n.keepPunct = !0), n.keepSpace === void 0 && (n.keepSpace = !0), Ok(this.docs, n);
  }
}, $k = Object.assign({}, Gk, Wk, au, Tk), Uk = function(e) {
  Object.assign(e.prototype, $k);
}, Kk = function(e) {
  console.log("%c -=-=- ", "background-color:#6699cc;"), e.forEach((n) => {
    console.groupCollapsed(n.text());
    let r = n.docs[0].map((a) => {
      let o = a.text || "-";
      a.implicit && (o = "[" + a.implicit + "]");
      let i = "[" + Array.from(a.tags).join(", ") + "]";
      return { text: o, tags: i };
    });
    console.table(r, ["text", "tags"]), console.groupEnd();
  });
}, xn = "\x1B[0m", Pt = {
  green: (e) => "\x1B[32m" + e + xn,
  red: (e) => "\x1B[31m" + e + xn,
  blue: (e) => "\x1B[34m" + e + xn,
  magenta: (e) => "\x1B[35m" + e + xn,
  cyan: (e) => "\x1B[36m" + e + xn,
  yellow: (e) => "\x1B[33m" + e + xn,
  black: (e) => "\x1B[30m" + e + xn,
  dim: (e) => "\x1B[2m" + e + xn,
  i: (e) => "\x1B[3m" + e + xn
}, qk = function(e, n) {
  return n.one.tagSet && (e = e.map((t) => {
    if (!n.one.tagSet.hasOwnProperty(t))
      return t;
    const r = n.one.tagSet[t].color || "blue";
    return Pt[r](t);
  })), e.join(", ");
}, Jk = function(e) {
  let { docs: n, model: t } = e;
  n.length === 0 && console.log(Pt.blue(`
     ──────`)), n.forEach((r) => {
    console.log(Pt.blue(`
  ┌─────────`)), r.forEach((a) => {
      let o = [...a.tags || []], i = a.text || "-";
      a.sense && (i = `{${a.normal}/${a.sense}}`), a.implicit && (i = "[" + a.implicit + "]"), i = Pt.yellow(i);
      let s = "'" + i + "'";
      if (a.reference) {
        let l = e.update([a.reference]).text("normal");
        s += ` - ${Pt.dim(Pt.i("[" + l + "]"))}`;
      }
      s = s.padEnd(18);
      let u = Pt.blue("  │ ") + Pt.i(s) + "  - " + qk(o, t);
      console.log(u);
    });
  }), console.log(`
`);
}, Xk = function(e) {
  let { docs: n } = e;
  console.log(""), n.forEach((t) => {
    let r = [];
    t.forEach((a) => {
      a.chunk === "Noun" ? r.push(Pt.blue(a.implicit || a.normal)) : a.chunk === "Verb" ? r.push(Pt.green(a.implicit || a.normal)) : a.chunk === "Adjective" ? r.push(Pt.yellow(a.implicit || a.normal)) : a.chunk === "Pivot" ? r.push(Pt.red(a.implicit || a.normal)) : r.push(a.implicit || a.normal);
    }), console.log(r.join(" "), `
`);
  }), console.log(`
`);
}, Qk = (e, n, t) => {
  let r = t * 9, a = n.start + r, o = a + n.length, i = e.substring(0, a), s = e.substring(a, o), u = e.substring(o, e.length);
  return [i, s, u];
}, Yk = function(e, n, t) {
  let r = Qk(e, n, t);
  return `${r[0]}${Pt.blue(r[1])}${r[2]}`;
}, Zk = function(e) {
  if (!e.found)
    return;
  let n = {};
  e.fullPointer.forEach((t) => {
    n[t[0]] = n[t[0]] || [], n[t[0]].push(t);
  }), Object.keys(n).forEach((t) => {
    let a = e.update([[Number(t)]]).text();
    e.update(n[t]).json({ offset: !0 }).forEach((s, u) => {
      a = Yk(a, s.offset, u);
    }), console.log(a);
  }), console.log(`
`);
}, eN = {
  tags: Jk,
  clientSide: Kk,
  chunks: Xk,
  highlight: Zk
}, tN = {
  api: Uk,
  methods: {
    one: {
      hash: bl,
      debug: eN
    }
  }
}, zm = function(e, n) {
  if (e[0] !== n[0])
    return !1;
  let [, t, r] = e, [, a, o] = n;
  return t <= a && r > a || a <= t && o > t;
}, nN = function(e) {
  let n = e[0][1], t = e[0][2];
  return e.forEach((r) => {
    r[1] < n && (n = r[1]), r[2] > t && (t = r[2]);
  }), [e[0][0], n, t];
}, Ii = function(e) {
  let n = {};
  return e.forEach((t) => {
    n[t[0]] = n[t[0]] || [], n[t[0]].push(t);
  }), n;
}, rN = function(e) {
  let n = {};
  for (let t = 0; t < e.length; t += 1)
    n[e[t].join(",")] = e[t];
  return Object.values(n);
}, aN = function(e, n) {
  let [t, r] = e, a = n[1], o = n[2], i = {};
  if (r < a) {
    let s = a < e[2] ? a : e[2];
    i.before = [t, r, s];
  }
  return i.match = n, e[2] > o && (i.after = [t, o, e[2]]), i;
}, oN = function(e, n) {
  return e[1] <= n[1] && n[2] <= e[2];
}, Gm = function(e, n) {
  let t = Ii(n), r = [];
  return e.forEach((a) => {
    let [o] = a, i = t[o] || [];
    if (i = i.filter((u) => oN(a, u)), i.length === 0) {
      r.push({ passthrough: a });
      return;
    }
    i = i.sort((u, l) => u[1] - l[1]);
    let s = a;
    i.forEach((u, l) => {
      let c = aN(s, u);
      i[l + 1] ? (r.push({ before: c.before, match: c.match }), c.after && (s = c.after)) : r.push(c);
    });
  }), r;
}, iN = 20, sN = function(e, n, t) {
  for (let r = 0; r < iN; r += 1) {
    if (n[t - r]) {
      let a = n[t - r].findIndex((o) => o.id === e);
      if (a !== -1)
        return [t - r, a];
    }
    if (n[t + r]) {
      let a = n[t + r].findIndex((o) => o.id === e);
      if (a !== -1)
        return [t + r, a];
    }
  }
  return null;
}, uN = function(e, n) {
  let [t, r, , , a] = e, o = n[t], i = o.findIndex((s) => s.id === a);
  return i === -1 ? (e[2] = n[t].length, e[4] = o.length ? o[o.length - 1].id : null) : e[2] = i, n[t].slice(r, e[2] + 1);
}, lN = function(e, n) {
  let t = [];
  return e.forEach((r, a) => {
    if (!r)
      return;
    let [o, i, s, u, l] = r, c = n[o] || [];
    if (i === void 0 && (i = 0), s === void 0 && (s = c.length), u && (!c[i] || c[i].id !== u)) {
      let h = sN(u, n, o);
      if (h !== null) {
        let d = s - i;
        c = n[h[0]].slice(h[1], h[1] + d);
        let p = c[0] ? c[0].id : null;
        e[a] = [h[0], h[1], h[1] + d, p];
      }
    } else
      c = c.slice(i, s);
    c.length !== 0 && i !== s && (l && c[c.length - 1].id !== l && (c = uN(r, n)), t.push(c));
  }), t = t.filter((r) => r.length > 0), t;
}, cN = function(e) {
  let n = [];
  for (let t = 0; t < e.length; t += 1)
    for (let r = 0; r < e[t].length; r += 1)
      n.push(e[t][r]);
  return n;
}, hN = {
  one: {
    termList: cN,
    getDoc: lN,
    pointer: {
      indexN: Ii,
      splitAll: Gm
    }
  }
}, Hm = function(e, n) {
  let t = e.concat(n), r = Ii(t), a = [];
  return t.forEach((o) => {
    let [i] = o;
    if (r[i].length === 1) {
      a.push(o);
      return;
    }
    let s = r[i].filter((l) => zm(o, l));
    s.push(o);
    let u = nN(s);
    a.push(u);
  }), a = rN(a), a;
}, Wm = function(e, n) {
  let t = [];
  return Gm(e, n).forEach((a) => {
    a.passthrough && t.push(a.passthrough), a.before && t.push(a.before), a.after && t.push(a.after);
  }), t;
}, dN = function(e, n) {
  let t = e[1] < n[1] ? n[1] : e[1], r = e[2] > n[2] ? n[2] : e[2];
  return t < r ? [e[0], t, r] : null;
}, pN = function(e, n) {
  let t = Ii(n), r = [];
  return e.forEach((a) => {
    let o = t[a[0]] || [];
    o = o.filter((i) => zm(a, i)), o.length !== 0 && o.forEach((i) => {
      let s = dN(a, i);
      s && r.push(s);
    });
  }), r;
}, fN = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, xl = (e, n) => typeof e == "string" || fN(e) ? n.match(e) : e || n.none(), to = function(e, n) {
  return e.map((t) => {
    let [r, a] = t;
    return n[r] && n[r][a] && (t[3] = n[r][a].id), t;
  });
}, dn = {};
dn.union = function(e) {
  e = xl(e, this);
  let n = Hm(this.fullPointer, e.fullPointer);
  return n = to(n, this.document), this.toView(n);
};
dn.and = dn.union;
dn.intersection = function(e) {
  e = xl(e, this);
  let n = pN(this.fullPointer, e.fullPointer);
  return n = to(n, this.document), this.toView(n);
};
dn.not = function(e) {
  e = xl(e, this);
  let n = Wm(this.fullPointer, e.fullPointer);
  return n = to(n, this.document), this.toView(n);
};
dn.difference = dn.not;
dn.complement = function() {
  let e = this.all(), n = Wm(e.fullPointer, this.fullPointer);
  return n = to(n, this.document), this.toView(n);
};
dn.settle = function() {
  let e = this.fullPointer;
  return e.forEach((n) => {
    e = Hm(e, [n]);
  }), e = to(e, this.document), this.update(e);
};
const mN = function(e) {
  Object.assign(e.prototype, dn);
}, gN = {
  methods: hN,
  api: mN
}, vN = {
  // compile a list of matches into a match-net
  buildNet: function(e) {
    let t = this.methods().one.buildNet(e, this.world());
    return t.isNet = !0, t;
  }
}, yN = function(e) {
  e.prototype.sweep = function(n, t = {}) {
    const { world: r, docs: a } = this, { methods: o } = r;
    let i = o.one.bulkMatch(a, n, this.methods, t);
    t.tagger !== !1 && o.one.bulkTagger(i, a, this.world), i = i.map((u) => {
      let l = u.pointer, c = a[l[0]][l[1]], h = l[2] - l[1];
      return c.index && (u.pointer = [
        c.index[0],
        c.index[1],
        l[1] + h
      ]), u;
    });
    let s = i.map((u) => u.pointer);
    return i = i.map((u) => (u.view = this.update([u.pointer]), delete u.regs, delete u.needs, delete u.pointer, delete u._expanded, u)), {
      view: this.update(s),
      found: i
    };
  };
}, ou = function(e) {
  return e.optional === !0 || e.negative === !0 ? null : e.tag ? "#" + e.tag : e.word ? e.word : e.switch ? `%${e.switch}%` : null;
}, bN = function(e) {
  let n = [];
  return e.forEach((t) => {
    n.push(ou(t)), t.operator === "and" && t.choices && t.choices.forEach((r) => {
      r.forEach((a) => {
        n.push(ou(a));
      });
    });
  }), n.filter((t) => t);
}, xN = function(e) {
  let n = [], t = 0;
  return e.forEach((r) => {
    r.operator === "or" && !r.optional && !r.negative && (r.fastOr && Array.from(r.fastOr).forEach((a) => {
      n.push(a);
    }), r.choices && r.choices.forEach((a) => {
      a.forEach((o) => {
        let i = ou(o);
        i && n.push(i);
      });
    }), t += 1);
  }), { wants: n, count: t };
}, wN = function(e, n) {
  const t = n.methods.one.parseMatch;
  return e.forEach((r) => {
    r.regs = t(r.match, {}, n), typeof r.ifNo == "string" && (r.ifNo = [r.ifNo]), r.notIf && (r.notIf = t(r.notIf, {}, n)), r.needs = bN(r.regs);
    let { wants: a, count: o } = xN(r.regs);
    r.wants = a, r.minWant = o, r.minWords = r.regs.filter((i) => !i.optional).length;
  }), e;
}, CN = function(e, n) {
  e = wN(e, n);
  let t = {};
  e.forEach((a) => {
    a.needs.forEach((o) => {
      t[o] = Array.isArray(t[o]) ? t[o] : [], t[o].push(a);
    }), a.wants.forEach((o) => {
      t[o] = Array.isArray(t[o]) ? t[o] : [], t[o].push(a);
    });
  }), Object.keys(t).forEach((a) => {
    let o = {};
    t[a] = t[a].filter((i) => typeof o[i.match] == "boolean" ? !1 : (o[i.match] = !0, !0));
  });
  let r = e.filter((a) => a.needs.length === 0 && a.wants.length === 0);
  return {
    hooks: t,
    always: r
  };
}, kN = function(e, n) {
  return e.map((t, r) => {
    let a = [];
    Object.keys(n).forEach((i) => {
      e[r].has(i) && (a = a.concat(n[i]));
    });
    let o = {};
    return a = a.filter((i) => typeof o[i.match] == "boolean" ? !1 : (o[i.match] = !0, !0)), a;
  });
}, NN = function(e, n) {
  return e.map((t, r) => {
    let a = n[r];
    return t = t.filter((o) => o.needs.every((i) => a.has(i))), t = t.filter((o) => !(o.ifNo !== void 0 && o.ifNo.some((i) => a.has(i)) === !0)), t = t.filter((o) => o.wants.length === 0 ? !0 : o.wants.filter((s) => a.has(s)).length >= o.minWant), t;
  });
}, AN = function(e, n, t, r, a) {
  let o = [];
  for (let i = 0; i < e.length; i += 1)
    for (let s = 0; s < e[i].length; s += 1) {
      let u = e[i][s], l = r.one.match([n[i]], u);
      if (l.ptrs.length > 0 && (l.ptrs.forEach((c) => {
        c[0] = i;
        let h = Object.assign({}, u, { pointer: c });
        u.unTag !== void 0 && (h.unTag = u.unTag), o.push(h);
      }), a.matchOne === !0))
        return [o[0]];
    }
  return o;
}, IN = function(e, n) {
  return e.map((t, r) => {
    let a = n[r].length;
    return t = t.filter((o) => a >= o.minWords), t;
  });
}, EN = function(e, n, t, r = {}) {
  let a = t.one.cacheDoc(e), o = kN(a, n.hooks);
  return o = NN(o, a), n.always.length > 0 && (o = o.map((s) => s.concat(n.always))), o = IN(o, e), AN(o, e, a, t, r);
}, TN = function(e, n, t) {
  let r = t.one.tagSet;
  if (!r.hasOwnProperty(n))
    return !0;
  let a = r[n].not || [];
  for (let o = 0; o < e.length; o += 1) {
    let i = e[o];
    for (let s = 0; s < a.length; s += 1)
      if (i.tags.has(a[s]) === !0)
        return !1;
  }
  return !0;
}, PN = function(e, n, t) {
  const { model: r, methods: a } = t, { getDoc: o, setTag: i, unTag: s } = a.one, u = a.two.looksPlural;
  return e.length === 0 ? e : ((typeof process > "u" || !process.env ? self.env || {} : process.env).DEBUG_TAGS && console.log(`

  \x1B[32m→ ${e.length} post-tagger:\x1B[0m`), e.map((c) => {
    if (!c.tag && !c.chunk && !c.unTag)
      return;
    let h = c.reason || c.match, d = o([c.pointer], n)[0];
    if (!(c.safe === !0 && (TN(d, c.tag, r) === !1 || d[d.length - 1].post === "-"))) {
      if (c.tag !== void 0) {
        if (i(d, c.tag, t, c.safe, `[post] '${h}'`), c.tag === "Noun" && u) {
          let p = d[d.length - 1];
          u(p.text) ? i([p], "Plural", t, c.safe, "quick-plural") : i([p], "Singular", t, c.safe, "quick-singular");
        }
        c.freeze === !0 && d.forEach((p) => p.frozen = !0);
      }
      c.unTag !== void 0 && s(d, c.unTag, t, c.safe, h), c.chunk && d.forEach((p) => p.chunk = c.chunk);
    }
  }));
}, SN = {
  buildNet: CN,
  bulkMatch: EN,
  bulkTagger: PN
}, DN = {
  lib: vN,
  api: yN,
  methods: {
    one: SN
  }
}, $m = / /, th = function(e, n) {
  n === "Noun" && (e.chunk = n), n === "Verb" && (e.chunk = n);
}, Um = function(e, n, t, r) {
  if (e.tags.has(n) === !0 || n === ".")
    return null;
  e.frozen === !0 && (r = !0);
  let a = t[n];
  if (a) {
    if (a.not && a.not.length > 0)
      for (let o = 0; o < a.not.length; o += 1) {
        if (r === !0 && e.tags.has(a.not[o]))
          return null;
        e.tags.delete(a.not[o]);
      }
    if (a.parents && a.parents.length > 0)
      for (let o = 0; o < a.parents.length; o += 1)
        e.tags.add(a.parents[o]), th(e, a.parents[o]);
  }
  return e.tags.add(n), e.dirty = !0, th(e, n), !0;
}, ON = function(e, n, t, r) {
  let a = n.split($m);
  e.forEach((o, i) => {
    let s = a[i];
    s && (s = s.replace(/^#/, ""), Um(o, s, t, r));
  });
}, RN = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, FN = (e, n, t = "") => {
  const r = (i) => "\x1B[33m\x1B[3m" + i + "\x1B[0m", a = (i) => "\x1B[3m" + i + "\x1B[0m";
  let o = e.map((i) => i.text || "[" + i.implicit + "]").join(" ");
  typeof n != "string" && n.length > 2 && (n = n.slice(0, 2).join(", #") + " +"), n = typeof n != "string" ? n.join(", #") : n, console.log(` ${r(o).padEnd(24)} \x1B[32m→\x1B[0m #${n.padEnd(22)}  ${a(t)}`);
}, Km = function(e, n, t = {}, r, a) {
  const o = t.model.one.tagSet || {};
  if (!n)
    return;
  const i = typeof process > "u" || !process.env ? self.env || {} : process.env;
  if (i && i.DEBUG_TAGS && FN(e, n, a), RN(n) === !0) {
    n.forEach((s) => Km(e, s, t, r));
    return;
  }
  if (typeof n != "string") {
    console.warn(`compromise: Invalid tag '${n}'`);
    return;
  }
  if (n = n.trim(), $m.test(n)) {
    ON(e, n, o, r);
    return;
  }
  n = n.replace(/^#/, "");
  for (let s = 0; s < e.length; s += 1)
    Um(e[s], n, o, r);
}, MN = function(e, n, t) {
  n = n.trim().replace(/^#/, "");
  for (let r = 0; r < e.length; r += 1) {
    let a = e[r];
    if (a.frozen === !0)
      continue;
    if (n === "*") {
      a.tags.clear();
      continue;
    }
    let o = t[n];
    if (o && o.children.length > 0)
      for (let i = 0; i < o.children.length; i += 1)
        a.tags.delete(o.children[i]);
    a.tags.delete(n);
  }
}, _N = function(e, n, t) {
  if (!t.hasOwnProperty(n))
    return !0;
  let r = t[n].not || [];
  for (let a = 0; a < r.length; a += 1)
    if (e.tags.has(r[a]))
      return !1;
  return !0;
}, Jn = function(e) {
  return e.children = e.children || [], e._cache = e._cache || {}, e.props = e.props || {}, e._cache.parents = e._cache.parents || [], e._cache.children = e._cache.children || [], e;
}, BN = /^ *(#|\/\/)/, jN = function(e) {
  let n = e.trim().split(/->/), t = [];
  n.forEach((a) => {
    t = t.concat(function(o) {
      if (!(o = o.trim())) return null;
      if (/^\[/.test(o) && /\]$/.test(o)) {
        let i = (o = (o = o.replace(/^\[/, "")).replace(/\]$/, "")).split(/,/);
        return i = i.map((s) => s.trim()).filter((s) => s), i = i.map((s) => Jn({ id: s })), i;
      }
      return [Jn({ id: o })];
    }(a));
  }), t = t.filter((a) => a);
  let r = t[0];
  for (let a = 1; a < t.length; a += 1) r.children.push(t[a]), r = t[a];
  return t[0];
}, On = (e, n) => {
  let t = [], r = [e];
  for (; r.length > 0; ) {
    let a = r.pop();
    t.push(a), a.children && a.children.forEach((o) => {
      n && n(a, o), r.push(o);
    });
  }
  return t;
}, wl = (e) => Object.prototype.toString.call(e) === "[object Array]", po = (e) => (e = e || "").trim(), VN = function(e = []) {
  return typeof e == "string" ? function(t) {
    let r = t.split(/\r?\n/), a = [];
    r.forEach((i) => {
      if (!i.trim() || BN.test(i)) return;
      let s = ((u) => {
        const l = /^( {2}|\t)/;
        let c = 0;
        for (; l.test(u); ) u = u.replace(l, ""), c += 1;
        return c;
      })(i);
      a.push({ indent: s, node: jN(i) });
    });
    let o = function(i) {
      let s = { children: [] };
      return i.forEach((u, l) => {
        u.indent === 0 ? s.children = s.children.concat(u.node) : i[l - 1] && function(c, h) {
          let d = c[h].indent;
          for (; h >= 0; h -= 1) if (c[h].indent < d) return c[h];
          return c[0];
        }(i, l).node.children.push(u.node);
      }), s;
    }(a);
    return o = Jn(o), o;
  }(e) : wl(e) ? function(t) {
    let r = {};
    t.forEach((o) => {
      r[o.id] = o;
    });
    let a = Jn({});
    return t.forEach((o) => {
      if ((o = Jn(o)).parent) if (r.hasOwnProperty(o.parent)) {
        let i = r[o.parent];
        delete o.parent, i.children.push(o);
      } else console.warn(`[Grad] - missing node '${o.parent}'`);
      else a.children.push(o);
    }), a;
  }(e) : (On(n = e).forEach(Jn), n);
  var n;
}, LN = (e) => "\x1B[31m" + e + "\x1B[0m", zN = (e) => "\x1B[2m" + e + "\x1B[0m", iu = function(e, n) {
  let t = "-> ";
  n && (t = zN("→ "));
  let r = "";
  return On(e).forEach((a, o) => {
    let i = a.id || "";
    if (n && (i = LN(i)), o === 0 && !a.id) return;
    let s = a._cache.parents.length;
    r += "    ".repeat(s) + t + i + `
`;
  }), r;
}, nh = function(e) {
  let n = On(e);
  n.forEach((r) => {
    delete (r = Object.assign({}, r)).children;
  });
  let t = n[0];
  return t && !t.id && Object.keys(t.props).length === 0 && n.shift(), n;
}, rh = { text: iu, txt: iu, array: nh, flat: nh }, ah = function(e, n) {
  return n === "nested" || n === "json" ? e : n === "debug" ? (console.log(iu(e, !0)), null) : rh.hasOwnProperty(n) ? rh[n](e) : e;
}, cs = (e) => {
  On(e, (n, t) => {
    n.id && (n._cache.parents = n._cache.parents || [], t._cache.parents = n._cache.parents.concat([n.id]));
  });
}, GN = (e, n) => (Object.keys(n).forEach((t) => {
  if (n[t] instanceof Set) {
    let r = e[t] || /* @__PURE__ */ new Set();
    e[t] = /* @__PURE__ */ new Set([...r, ...n[t]]);
  } else if (((r) => r && typeof r == "object" && !Array.isArray(r))(n[t])) {
    let r = e[t] || {};
    e[t] = Object.assign({}, n[t], r);
  } else wl(n[t]) ? e[t] = n[t].concat(e[t] || []) : e[t] === void 0 && (e[t] = n[t]);
}), e), HN = /\//;
let WN = class Fo {
  constructor(n = {}) {
    Object.defineProperty(this, "json", { enumerable: !1, value: n, writable: !0 });
  }
  get children() {
    return this.json.children;
  }
  get id() {
    return this.json.id;
  }
  get found() {
    return this.json.id || this.json.children.length > 0;
  }
  props(n = {}) {
    let t = this.json.props || {};
    return typeof n == "string" && (t[n] = !0), this.json.props = Object.assign(t, n), this;
  }
  get(n) {
    if (n = po(n), !HN.test(n)) {
      let r = this.json.children.find((a) => a.id === n);
      return new Fo(r);
    }
    let t = ((r, a) => {
      let o = ((i) => typeof i != "string" ? i : (i = i.replace(/^\//, "")).split(/\//))(a = a || "");
      for (let i = 0; i < o.length; i += 1) {
        let s = r.children.find((u) => u.id === o[i]);
        if (!s) return null;
        r = s;
      }
      return r;
    })(this.json, n) || Jn({});
    return new Fo(t);
  }
  add(n, t = {}) {
    if (wl(n)) return n.forEach((a) => this.add(po(a), t)), this;
    n = po(n);
    let r = Jn({ id: n, props: t });
    return this.json.children.push(r), new Fo(r);
  }
  remove(n) {
    return n = po(n), this.json.children = this.json.children.filter((t) => t.id !== n), this;
  }
  nodes() {
    return On(this.json).map((n) => (delete (n = Object.assign({}, n)).children, n));
  }
  cache() {
    return ((n) => {
      let t = On(n, (a, o) => {
        a.id && (a._cache.parents = a._cache.parents || [], a._cache.children = a._cache.children || [], o._cache.parents = a._cache.parents.concat([a.id]));
      }), r = {};
      t.forEach((a) => {
        a.id && (r[a.id] = a);
      }), t.forEach((a) => {
        a._cache.parents.forEach((o) => {
          r.hasOwnProperty(o) && r[o]._cache.children.push(a.id);
        });
      }), n._cache.children = Object.keys(r);
    })(this.json), this;
  }
  list() {
    return On(this.json);
  }
  fillDown() {
    var n;
    return n = this.json, On(n, (t, r) => {
      r.props = GN(r.props, t.props);
    }), this;
  }
  depth() {
    cs(this.json);
    let n = On(this.json), t = n.length > 1 ? 1 : 0;
    return n.forEach((r) => {
      if (r._cache.parents.length === 0) return;
      let a = r._cache.parents.length + 1;
      a > t && (t = a);
    }), t;
  }
  out(n) {
    return cs(this.json), ah(this.json, n);
  }
  debug() {
    return cs(this.json), ah(this.json, "debug"), this;
  }
};
const qm = function(e) {
  let n = VN(e);
  return new WN(n);
};
qm.prototype.plugin = function(e) {
  e(this);
};
const Gr = {
  Noun: "blue",
  Verb: "green",
  Negative: "green",
  Date: "red",
  Value: "red",
  Adjective: "magenta",
  Preposition: "cyan",
  Conjunction: "cyan",
  Determiner: "cyan",
  Hyphenated: "cyan",
  Adverb: "cyan"
}, $N = function(e) {
  if (Gr.hasOwnProperty(e.id))
    return Gr[e.id];
  if (Gr.hasOwnProperty(e.is))
    return Gr[e.is];
  let n = e._cache.parents.find((t) => Gr[t]);
  return Gr[n];
}, UN = function(e) {
  const n = {};
  return e.forEach((t) => {
    let { not: r, also: a, is: o, novel: i } = t.props, s = t._cache.parents;
    a && (s = s.concat(a)), n[t.id] = {
      is: o,
      not: r,
      novel: i,
      also: a,
      parents: s,
      children: t._cache.children,
      color: $N(t)
    };
  }), Object.keys(n).forEach((t) => {
    let r = new Set(n[t].not);
    n[t].not.forEach((a) => {
      n[a] && n[a].children.forEach((o) => r.add(o));
    }), n[t].not = Array.from(r);
  }), n;
}, oh = function(e) {
  return e ? typeof e == "string" ? [e] : e : [];
}, KN = function(e, n) {
  return Object.keys(e).forEach((t) => {
    e[t].isA && (e[t].is = e[t].isA), e[t].notA && (e[t].not = e[t].notA), e[t].is && typeof e[t].is == "string" && !n.hasOwnProperty(e[t].is) && !e.hasOwnProperty(e[t].is) && (e[e[t].is] = {}), e[t].not && typeof e[t].not == "string" && !e.hasOwnProperty(e[t].not) && !n.hasOwnProperty(e[t].not) && !e.hasOwnProperty(e[t].not) && (e[e[t].not] = {});
  }), e;
}, qN = function(e, n) {
  return e = KN(e, n), Object.keys(e).forEach((t) => {
    e[t].children = oh(e[t].children), e[t].not = oh(e[t].not);
  }), Object.keys(e).forEach((t) => {
    (e[t].not || []).forEach((a) => {
      e[a] && e[a].not && e[a].not.push(t);
    });
  }), e;
}, JN = function(e) {
  const n = Object.keys(e).map((r) => {
    let a = e[r];
    const o = { not: new Set(a.not), also: a.also, is: a.is, novel: a.novel };
    return { id: r, parent: a.is, props: o, children: [] };
  });
  return qm(n).cache().fillDown().out("array");
}, XN = function(e) {
  return Object.keys(e).forEach((n) => {
    e[n] = Object.assign({}, e[n]), e[n].novel = !0;
  }), e;
}, QN = function(e, n) {
  Object.keys(n).length > 0 && (e = XN(e)), e = qN(e, n);
  let t = Object.assign({}, n, e);
  const r = JN(t);
  return UN(r);
}, YN = {
  one: {
    setTag: Km,
    unTag: MN,
    addTags: QN,
    canBe: _N
  }
}, ih = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, ZN = {
  /** add a given tag, to all these terms */
  tag: function(e, n = "", t) {
    if (!this.found || !e)
      return this;
    let r = this.termList();
    if (r.length === 0)
      return this;
    const { methods: a, verbose: o, world: i } = this;
    return o === !0 && console.log(" +  ", e, n || ""), ih(e) ? e.forEach((s) => a.one.setTag(r, s, i, t, n)) : a.one.setTag(r, e, i, t, n), this.uncache(), this;
  },
  /** add a given tag, only if it is consistent */
  tagSafe: function(e, n = "") {
    return this.tag(e, n, !0);
  },
  /** remove a given tag from all these terms */
  unTag: function(e, n) {
    if (!this.found || !e)
      return this;
    let t = this.termList();
    if (t.length === 0)
      return this;
    const { methods: r, verbose: a, model: o } = this;
    a === !0 && console.log(" -  ", e, n || "");
    let i = o.one.tagSet;
    return ih(e) ? e.forEach((s) => r.one.unTag(t, s, i)) : r.one.unTag(t, e, i), this.uncache(), this;
  },
  /** return only the terms that can be this tag  */
  canBe: function(e) {
    e = e.replace(/^#/, "");
    let n = this.model.one.tagSet, t = this.methods.one.canBe, r = [];
    this.document.forEach((o, i) => {
      o.forEach((s, u) => {
        t(s, e, n) || r.push([i, u, u + 1]);
      });
    });
    let a = this.update(r);
    return this.difference(a);
  }
}, eA = function(e) {
  Object.assign(e.prototype, ZN);
}, tA = function(e) {
  const { model: n, methods: t } = this.world(), r = n.one.tagSet, a = t.one.addTags;
  let o = a(e, r);
  return n.one.tagSet = o, this;
}, nA = { addTags: tA }, sh = /* @__PURE__ */ new Set(["Auxiliary", "Possessive"]), rA = function(e, n) {
  return e = e.sort((t, r) => {
    if (sh.has(t) || !n.hasOwnProperty(r))
      return 1;
    if (sh.has(r) || !n.hasOwnProperty(t))
      return -1;
    let a = n[t].children || [], o = a.length;
    a = n[r].children || [];
    let i = a.length;
    return o - i;
  }), e;
}, aA = function(e) {
  const { document: n, world: t } = e, r = t.model.one.tagSet;
  n.forEach((a) => {
    a.forEach((o) => {
      let i = Array.from(o.tags);
      o.tagRank = rA(i, r);
    });
  });
}, oA = {
  model: {
    one: { tagSet: {} }
  },
  compute: {
    tagRank: aA
  },
  methods: YN,
  api: eA,
  lib: nA
}, iA = /([.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s)/g, sA = /^[.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s$/, uA = /((?:\r?\n|\r)+)/, lA = function(e) {
  let n = [], t = e.split(uA);
  for (let r = 0; r < t.length; r++) {
    let a = t[r].split(iA);
    for (let o = 0; o < a.length; o++)
      a[o + 1] && sA.test(a[o + 1]) === !0 && (a[o] += a[o + 1], a[o + 1] = ""), a[o] !== "" && n.push(a[o]);
  }
  return n;
}, cA = /[a-z0-9\u00C0-\u00FF\u00a9\u00ae\u2000-\u3300\ud000-\udfff]/i, hA = /\S/, dA = function(e) {
  let n = [];
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (!(r === void 0 || r === "")) {
      if (hA.test(r) === !1 || cA.test(r) === !1) {
        if (n[n.length - 1]) {
          n[n.length - 1] += r;
          continue;
        } else if (e[t + 1]) {
          e[t + 1] = r + e[t + 1];
          continue;
        }
      }
      n.push(r);
    }
  }
  return n;
}, pA = function(e, n) {
  const t = n.methods.one.tokenize.isSentence, r = n.model.one.abbreviations || /* @__PURE__ */ new Set();
  let a = [];
  for (let o = 0; o < e.length; o++) {
    let i = e[o];
    e[o + 1] && t(i, r) === !1 ? e[o + 1] = i + (e[o + 1] || "") : i && i.length > 0 && (a.push(i), e[o] = "");
  }
  return a;
}, uh = 280, Jm = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "＂": "＂",
  // 'StraightDoubleQuotesWide'
  // '\u0027': '\u0027', // 'StraightSingleQuotes'
  "“": "”",
  // 'CommaDoubleQuotes'
  // '\u2018': '\u2019', // 'CommaSingleQuotes'
  "‟": "”",
  // 'CurlyDoubleQuotesReversed'
  // '\u201B': '\u2019', // 'CurlySingleQuotesReversed'
  "„": "”",
  // 'LowCurlyDoubleQuotes'
  "⹂": "”",
  // 'LowCurlyDoubleQuotesReversed'
  "‚": "’",
  // 'LowCurlySingleQuotes'
  "«": "»",
  // 'AngleDoubleQuotes'
  "‹": "›",
  // 'AngleSingleQuotes'
  "‵": "′",
  // 'PrimeSingleQuotes'
  "‶": "″",
  // 'PrimeDoubleQuotes'
  "‷": "‴",
  // 'PrimeTripleQuotes'
  "〝": "〞",
  // 'PrimeDoubleQuotes'
  // '\u0060': '\u00B4', // 'PrimeSingleQuotes'
  "〟": "〞"
  // 'LowPrimeDoubleQuotesReversed'
}, fA = RegExp("[" + Object.keys(Jm).join("") + "]", "g"), mA = RegExp("[" + Object.values(Jm).join("") + "]", "g"), lh = function(e) {
  if (!e)
    return !1;
  let n = e.match(mA);
  return n !== null && n.length === 1;
}, gA = function(e) {
  let n = [];
  for (let t = 0; t < e.length; t += 1) {
    let a = e[t].match(fA);
    if (a !== null && a.length === 1) {
      if (lh(e[t + 1]) && e[t + 1].length < uh) {
        e[t] += e[t + 1], n.push(e[t]), e[t + 1] = "", t += 1;
        continue;
      }
      if (lh(e[t + 2])) {
        let o = e[t + 1] + e[t + 2];
        if (o.length < uh) {
          e[t] += o, n.push(e[t]), e[t + 1] = "", e[t + 2] = "", t += 2;
          continue;
        }
      }
    }
    n.push(e[t]);
  }
  return n;
}, vA = 250, ch = /\(/g, yA = /\)/g, bA = function(e) {
  let n = [];
  for (let t = 0; t < e.length; t += 1) {
    let a = e[t].match(ch);
    if (a !== null && a.length === 1 && e[t + 1] && e[t + 1].length < vA && e[t + 1].match(yA) !== null && a.length === 1 && !ch.test(e[t + 1])) {
      e[t] += e[t + 1], n.push(e[t]), e[t + 1] = "", t += 1;
      continue;
    }
    n.push(e[t]);
  }
  return n;
}, xA = /\S/, hh = /^\s+/, wA = function(e, n) {
  if (e = e || "", e = String(e), !e || typeof e != "string" || xA.test(e) === !1)
    return [];
  e = e.replace(" ", " ");
  let t = lA(e), r = dA(t);
  if (r = pA(r, n), r = gA(r), r = bA(r), r.length === 0)
    return [e];
  for (let a = 1; a < r.length; a += 1) {
    let o = r[a].match(hh);
    o !== null && (r[a - 1] += o[0], r[a] = r[a].replace(hh, ""));
  }
  return r;
}, CA = function(e, n) {
  let t = e.split(/[-–—]/);
  if (t.length <= 1)
    return !1;
  const { prefixes: r, suffixes: a } = n.one;
  return t[0].length === 1 && /[a-z]/i.test(t[0]) || r.hasOwnProperty(t[0]) || (t[1] = t[1].trim().replace(/[.?!]$/, ""), a.hasOwnProperty(t[1])) ? !1 : /^([a-z\u00C0-\u00FF`"'/]+)[-–—]([a-z0-9\u00C0-\u00FF].*)/i.test(e) === !0 || /^[('"]?([0-9]{1,4})[-–—]([a-z\u00C0-\u00FF`"'/-]+[)'"]?$)/i.test(e) === !0;
}, kA = function(e) {
  let n = [];
  const t = e.split(/[-–—]/);
  let r = "-", a = e.match(/[-–—]/);
  a && a[0] && (r = a);
  for (let o = 0; o < t.length; o++)
    o === t.length - 1 ? n.push(t[o]) : n.push(t[o] + r);
  return n;
}, NA = function(e) {
  const n = /^[0-9]{1,4}(:[0-9][0-9])?([a-z]{1,2})? ?[-–—] ?$/, t = /^[0-9]{1,4}([a-z]{1,2})? ?$/;
  for (let r = 0; r < e.length - 1; r += 1)
    e[r + 1] && n.test(e[r]) && t.test(e[r + 1]) && (e[r] = e[r] + e[r + 1], e[r + 1] = null);
  return e;
}, AA = new RegExp("\\p{L} ?\\/ ?\\p{L}+$", "u"), IA = function(e) {
  for (let n = 1; n < e.length - 1; n++)
    AA.test(e[n]) && (e[n - 1] += e[n] + e[n + 1], e[n] = null, e[n + 1] = null);
  return e;
}, EA = /\S/, TA = /^[!?.]+$/, PA = /(\S+)/;
let su = [
  ".",
  "?",
  "!",
  ":",
  ";",
  "-",
  "–",
  "—",
  "--",
  "...",
  "(",
  ")",
  "[",
  "]",
  '"',
  "'",
  "`",
  "«",
  "»",
  "*",
  "•"
];
su = su.reduce((e, n) => (e[n] = !0, e), {});
const SA = function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}, DA = function(e, n) {
  let t = [], r = [];
  if (e = e || "", typeof e == "number" && (e = String(e)), SA(e))
    return e;
  const a = e.split(PA);
  for (let i = 0; i < a.length; i++) {
    if (CA(a[i], n) === !0) {
      r = r.concat(kA(a[i]));
      continue;
    }
    r.push(a[i]);
  }
  let o = "";
  for (let i = 0; i < r.length; i++) {
    let s = r[i];
    EA.test(s) === !0 && su.hasOwnProperty(s) === !1 && TA.test(s) === !1 ? (t.length > 0 ? (t[t.length - 1] += o, t.push(s)) : t.push(o + s), o = "") : o += s;
  }
  return o && (t.length === 0 && (t[0] = ""), t[t.length - 1] += o), t = IA(t), t = NA(t), t = t.filter((i) => i), t;
}, dh = new RegExp("\\p{Letter}", "u"), fo = /[\p{Number}\p{Currency_Symbol}]/u, OA = /^[a-z]\.([a-z]\.)+/i, RA = /[sn]['’]$/, FA = function(e, n) {
  let { prePunctuation: t, postPunctuation: r, emoticons: a } = n.one, o = e, i = "", s = "", u = Array.from(e);
  if (a.hasOwnProperty(e.trim()))
    return { str: e.trim(), pre: i, post: " " };
  let l = u.length;
  for (let c = 0; c < l; c += 1) {
    let h = u[0];
    if (t[h] !== !0) {
      if ((h === "+" || h === "-") && fo.test(u[1]) || h === "'" && h.length === 3 && fo.test(u[1]) || dh.test(h) || fo.test(h))
        break;
      i += u.shift();
    }
  }
  l = u.length;
  for (let c = 0; c < l; c += 1) {
    let h = u[u.length - 1];
    if (r[h] !== !0) {
      if (dh.test(h) || fo.test(h))
        break;
      h === "." && OA.test(o) === !0 || h === "'" && RA.test(o) === !0 || (s = u.pop() + s);
    }
  }
  return e = u.join(""), e === "" && (o = o.replace(/ *$/, (c) => (s = c || "", "")), e = o, i = ""), { str: e, pre: i, post: s };
}, MA = (e, n) => {
  let { str: t, pre: r, post: a } = FA(e, n);
  return {
    text: t,
    pre: r,
    post: a,
    tags: /* @__PURE__ */ new Set()
  };
}, _A = function(e, n) {
  const t = n.model.one.unicode || {};
  e = e || "";
  let r = e.split("");
  return r.forEach((a, o) => {
    t[a] && (r[o] = t[a]);
  }), r.join("");
}, BA = function(e) {
  e = e || "", e = e.toLowerCase(), e = e.trim();
  let n = e;
  return e = e.replace(/[,;.!?]+$/, ""), e = e.replace(/\u2026/g, "..."), e = e.replace(/\u2013/g, "-"), /^[:;]/.test(e) === !1 && (e = e.replace(/\.{3,}$/g, ""), e = e.replace(/[",.!:;?)]+$/g, ""), e = e.replace(/^['"(]+/g, "")), e = e.replace(/[\u200B-\u200D\uFEFF]/g, ""), e = e.trim(), e === "" && (e = n), e = e.replace(/([0-9]),([0-9])/g, "$1$2"), e;
}, jA = /([A-Z]\.)+[A-Z]?,?$/, VA = /^[A-Z]\.,?$/, LA = /[A-Z]{2,}('s|,)?$/, zA = /([a-z]\.)+[a-z]\.?$/, GA = function(e) {
  return jA.test(e) === !0 || zA.test(e) === !0 || VA.test(e) === !0 || LA.test(e) === !0;
}, HA = function(e) {
  return GA(e) && (e = e.replace(/\./g, "")), e;
}, Xm = function(e, n) {
  const t = n.methods.one.killUnicode;
  let r = e.text || "";
  r = BA(r), r = t(r, n), r = HA(r), e.normal = r;
}, WA = function(e, n) {
  const { methods: t, model: r } = n, { splitSentences: a, splitTerms: o, splitWhitespace: i } = t.one.tokenize;
  return e = e || "", e = a(e, n).map((u) => {
    let l = o(u, r);
    return l = l.map((c) => i(c, r)), l.forEach((c) => {
      Xm(c, n);
    }), l;
  }), e;
}, $A = /[ .][A-Z]\.? *$/i, UA = /(?:\u2026|\.{2,}) *$/, KA = new RegExp("\\p{L}", "u"), qA = /\. *$/, JA = /^[A-Z]\. $/, XA = function(e, n) {
  if (KA.test(e) === !1 || $A.test(e) === !0 || e.length === 3 && JA.test(e) || UA.test(e) === !0)
    return !1;
  let r = e.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, "").split(" "), a = r[r.length - 1].toLowerCase();
  return !(n.hasOwnProperty(a) === !0 && qA.test(e) === !0);
}, QA = {
  one: {
    killUnicode: _A,
    tokenize: {
      splitSentences: wA,
      isSentence: XA,
      splitTerms: DA,
      splitWhitespace: MA,
      fromString: WA
    }
  }
}, YA = {
  "&": "and",
  "@": "at",
  "%": "percent",
  plz: "please",
  bein: "being"
}, ZA = [
  "approx",
  "apt",
  "bc",
  "cyn",
  "eg",
  "esp",
  "est",
  "etc",
  "ex",
  "exp",
  "prob",
  //probably
  "pron",
  // Pronunciation
  "gal",
  //gallon
  "min",
  "pseud",
  "fig",
  //figure
  "jd",
  "lat",
  //latitude
  "lng",
  //longitude
  "vol",
  //volume
  "fm",
  //not am
  "def",
  //definition
  "misc",
  "plz",
  //please
  "ea",
  //each
  "ps",
  "sec",
  //second
  "pt",
  "pref",
  //preface
  "pl",
  //plural
  "pp",
  //pages
  "qt",
  //quarter
  "fr",
  //french
  "sq",
  "nee",
  //given name at birth
  "ss",
  //ship, or sections
  "tel",
  "temp",
  "vet",
  "ver",
  //version
  "fem",
  //feminine
  "masc",
  //masculine
  "eng",
  //engineering/english
  "adj",
  //adjective
  "vb",
  //verb
  "rb",
  //adverb
  "inf",
  //infinitive
  "situ",
  // in situ
  "vivo",
  "vitro",
  "wr"
  //world record
], eI = [
  "adj",
  "adm",
  "adv",
  "asst",
  "atty",
  "bldg",
  "brig",
  "capt",
  "cmdr",
  "comdr",
  "cpl",
  "det",
  "dr",
  "esq",
  "gen",
  "gov",
  "hon",
  "jr",
  "llb",
  "lt",
  "maj",
  "messrs",
  "mlle",
  "mme",
  "mr",
  "mrs",
  "ms",
  "mstr",
  "phd",
  "prof",
  "pvt",
  "rep",
  "reps",
  "res",
  "rev",
  "sen",
  "sens",
  "sfc",
  "sgt",
  "sir",
  "sr",
  "supt",
  "surg"
  //miss
  //misses
], tI = ["jan", "feb", "mar", "apr", "jun", "jul", "aug", "sep", "sept", "oct", "nov", "dec"], nI = [
  "ad",
  "al",
  "arc",
  "ba",
  "bl",
  "ca",
  "cca",
  "col",
  "corp",
  "ft",
  "fy",
  "ie",
  "lit",
  "ma",
  "md",
  "pd",
  "tce"
], rI = ["dept", "univ", "assn", "bros", "inc", "ltd", "co"], aI = [
  "rd",
  "st",
  "dist",
  "mt",
  "ave",
  "blvd",
  "cl",
  // 'ct',
  "cres",
  "hwy",
  //states
  "ariz",
  "cal",
  "calif",
  "colo",
  "conn",
  "fla",
  "fl",
  "ga",
  "ida",
  "ia",
  "kan",
  "kans",
  "minn",
  "neb",
  "nebr",
  "okla",
  "penna",
  "penn",
  "pa",
  "dak",
  "tenn",
  "tex",
  "ut",
  "vt",
  "va",
  "wis",
  "wisc",
  "wy",
  "wyo",
  "usafa",
  "alta",
  "ont",
  "que",
  "sask"
], oI = [
  "dl",
  "ml",
  "gal",
  // 'ft', //ambiguous
  "qt",
  "pt",
  "tbl",
  "tsp",
  "tbsp",
  "km",
  "dm",
  //decimeter
  "cm",
  "mm",
  "mi",
  "td",
  "hr",
  //hour
  "hrs",
  //hour
  "kg",
  "hg",
  "dg",
  //decigram
  "cg",
  //centigram
  "mg",
  //milligram
  "µg",
  //microgram
  "lb",
  //pound
  "oz",
  //ounce
  "sq ft",
  "hz",
  //hertz
  "mps",
  //meters per second
  "mph",
  "kmph",
  //kilometers per hour
  "kb",
  //kilobyte
  "mb",
  //megabyte
  // 'gb', //ambig
  "tb",
  //terabyte
  "lx",
  //lux
  "lm",
  //lumen
  // 'pa', //ambig
  "fl oz",
  //
  "yb"
];
let iI = [
  [ZA],
  [oI, "Unit"],
  [nI, "Noun"],
  [eI, "Honorific"],
  [tI, "Month"],
  [rI, "Organization"],
  [aI, "Place"]
], Qm = {}, Mo = {};
iI.forEach((e) => {
  e[0].forEach((n) => {
    Qm[n] = !0, Mo[n] = "Abbreviation", e[1] !== void 0 && (Mo[n] = [Mo[n], e[1]]);
  });
});
const sI = [
  "anti",
  "bi",
  "co",
  "contra",
  "de",
  "extra",
  "infra",
  "inter",
  "intra",
  "macro",
  "micro",
  "mis",
  "mono",
  "multi",
  "peri",
  "pre",
  "pro",
  "proto",
  "pseudo",
  "re",
  "sub",
  "supra",
  "trans",
  "tri",
  "un",
  "out",
  //out-lived
  "ex"
  //ex-wife
  // 'counter',
  // 'mid',
  // 'out',
  // 'non',
  // 'over',
  // 'post',
  // 'semi',
  // 'super', //'super-cool'
  // 'ultra', //'ulta-cool'
  // 'under',
  // 'whole',
].reduce((e, n) => (e[n] = !0, e), {}), uI = {
  like: !0,
  ish: !0,
  less: !0,
  able: !0,
  elect: !0,
  type: !0,
  designate: !0
  // 'fold':true,
};
let ph = {
  "!": "¡",
  "?": "¿Ɂ",
  '"': '“”"❝❞',
  "'": "‘‛❛❜’",
  "-": "—–",
  a: "ªÀÁÂÃÄÅàáâãäåĀāĂăĄąǍǎǞǟǠǡǺǻȀȁȂȃȦȧȺΆΑΔΛάαλАаѦѧӐӑӒӓƛæ",
  b: "ßþƀƁƂƃƄƅɃΒβϐϦБВЪЬвъьѢѣҌҍ",
  c: "¢©ÇçĆćĈĉĊċČčƆƇƈȻȼͻͼϲϹϽϾСсєҀҁҪҫ",
  d: "ÐĎďĐđƉƊȡƋƌ",
  e: "ÈÉÊËèéêëĒēĔĕĖėĘęĚěƐȄȅȆȇȨȩɆɇΈΕΞΣέεξϵЀЁЕеѐёҼҽҾҿӖӗễ",
  f: "ƑƒϜϝӺӻҒғſ",
  g: "ĜĝĞğĠġĢģƓǤǥǦǧǴǵ",
  h: "ĤĥĦħƕǶȞȟΉΗЂЊЋНнђћҢңҤҥҺһӉӊ",
  I: "ÌÍÎÏ",
  i: "ìíîïĨĩĪīĬĭĮįİıƖƗȈȉȊȋΊΐΪίιϊІЇіїi̇",
  j: "ĴĵǰȷɈɉϳЈј",
  k: "ĶķĸƘƙǨǩΚκЌЖКжкќҚқҜҝҞҟҠҡ",
  l: "ĹĺĻļĽľĿŀŁłƚƪǀǏǐȴȽΙӀӏ",
  m: "ΜϺϻМмӍӎ",
  n: "ÑñŃńŅņŇňŉŊŋƝƞǸǹȠȵΝΠήηϞЍИЙЛПийлпѝҊҋӅӆӢӣӤӥπ",
  o: "ÒÓÔÕÖØðòóôõöøŌōŎŏŐőƟƠơǑǒǪǫǬǭǾǿȌȍȎȏȪȫȬȭȮȯȰȱΌΘΟθοσόϕϘϙϬϴОФоѲѳӦӧӨөӪӫ",
  p: "ƤΡρϷϸϼРрҎҏÞ",
  q: "Ɋɋ",
  r: "ŔŕŖŗŘřƦȐȑȒȓɌɍЃГЯгяѓҐґ",
  s: "ŚśŜŝŞşŠšƧƨȘșȿЅѕ",
  t: "ŢţŤťŦŧƫƬƭƮȚțȶȾΓΤτϮТт",
  u: "ÙÚÛÜùúûüŨũŪūŬŭŮůŰűŲųƯưƱƲǓǔǕǖǗǘǙǚǛǜȔȕȖȗɄΰυϋύ",
  v: "νѴѵѶѷ",
  w: "ŴŵƜωώϖϢϣШЩшщѡѿ",
  x: "×ΧχϗϰХхҲҳӼӽӾӿ",
  y: "ÝýÿŶŷŸƳƴȲȳɎɏΎΥΫγψϒϓϔЎУучўѰѱҮүҰұӮӯӰӱӲӳ",
  z: "ŹźŻżŽžƵƶȤȥɀΖ"
}, Ym = {};
Object.keys(ph).forEach(function(e) {
  ph[e].split("").forEach(function(n) {
    Ym[n] = e;
  });
});
const lI = {
  "#": !0,
  //#hastag
  "@": !0,
  //@atmention
  _: !0,
  //underscore
  "°": !0,
  // '+': true,//+4
  // '\\-',//-4  (escape)
  // '.',//.4
  // zero-width chars
  "​": !0,
  "‌": !0,
  "‍": !0,
  "\uFEFF": !0
}, cI = {
  "%": !0,
  //88%
  _: !0,
  //underscore
  "°": !0,
  //degrees, italian ordinal
  // '\'',// sometimes
  // zero-width chars
  "​": !0,
  "‌": !0,
  "‍": !0,
  "\uFEFF": !0
}, hI = {
  "<3": !0,
  "</3": !0,
  "<\\3": !0,
  ":^P": !0,
  ":^p": !0,
  ":^O": !0,
  ":^3": !0
}, dI = {
  one: {
    aliases: YA,
    abbreviations: Qm,
    prefixes: sI,
    suffixes: uI,
    prePunctuation: lI,
    postPunctuation: cI,
    lexicon: Mo,
    //give this one forward
    unicode: Ym,
    emoticons: hI
  }
}, fh = /\//, pI = /[a-z]\.[a-z]/i, fI = /[0-9]/, mI = function(e, n) {
  let t = e.normal || e.text || e.machine;
  const r = n.model.one.aliases;
  if (r.hasOwnProperty(t) && (e.alias = e.alias || [], e.alias.push(r[t])), fh.test(t) && !pI.test(t) && !fI.test(t)) {
    let a = t.split(fh);
    a.length <= 3 && a.forEach((o) => {
      o = o.trim(), o !== "" && (e.alias = e.alias || [], e.alias.push(o));
    });
  }
  return e;
}, gI = new RegExp("^\\p{Letter}+-\\p{Letter}+$", "u"), vI = function(e) {
  let n = e.implicit || e.normal || e.text;
  n = n.replace(/['’]s$/, ""), n = n.replace(/s['’]$/, "s"), n = n.replace(/([aeiou][ktrp])in'$/, "$1ing"), gI.test(n) && (n = n.replace(/-/g, "")), n = n.replace(/^[#@]/, ""), n !== e.normal && (e.machine = n);
}, yI = function(e) {
  let n = e.docs, t = {};
  for (let r = 0; r < n.length; r += 1)
    for (let a = 0; a < n[r].length; a += 1) {
      let o = n[r][a], i = o.machine || o.normal;
      t[i] = t[i] || 0, t[i] += 1;
    }
  for (let r = 0; r < n.length; r += 1)
    for (let a = 0; a < n[r].length; a += 1) {
      let o = n[r][a], i = o.machine || o.normal;
      o.freq = t[i];
    }
}, bI = function(e) {
  let n = 0, t = 0, r = e.document;
  for (let a = 0; a < r.length; a += 1)
    for (let o = 0; o < r[a].length; o += 1) {
      let i = r[a][o];
      i.offset = {
        index: t,
        start: n + i.pre.length,
        length: i.text.length
      }, n += i.pre.length + i.text.length + i.post.length, t += 1;
    }
}, xI = function(e) {
  let n = e.document;
  for (let t = 0; t < n.length; t += 1)
    for (let r = 0; r < n[t].length; r += 1)
      n[t][r].index = [t, r];
}, wI = function(e) {
  let n = 0, t = e.docs;
  for (let r = 0; r < t.length; r += 1)
    for (let a = 0; a < t[r].length; a += 1)
      t[r][a].normal !== "" && (n += 1, t[r][a].wordCount = n);
}, hs = function(e, n) {
  let t = e.docs;
  for (let r = 0; r < t.length; r += 1)
    for (let a = 0; a < t[r].length; a += 1)
      n(t[r][a], e.world);
}, CI = {
  alias: (e) => hs(e, mI),
  machine: (e) => hs(e, vI),
  normal: (e) => hs(e, Xm),
  freq: yI,
  offset: bI,
  index: xI,
  wordCount: wI
}, kI = {
  compute: CI,
  methods: QA,
  model: dI,
  hooks: ["alias", "machine", "index", "id"]
}, NI = function(e) {
  const n = e.model.one.typeahead, t = e.docs;
  if (t.length === 0 || Object.keys(n).length === 0)
    return;
  let r = t[t.length - 1] || [], a = r[r.length - 1];
  if (!a.post && n.hasOwnProperty(a.normal)) {
    let o = n[a.normal];
    a.implicit = o, a.machine = o, a.typeahead = !0, e.compute.preTagger && e.last().unTag("*").compute(["lexicon", "preTagger"]);
  }
}, AI = { typeahead: NI }, II = function() {
  const e = this.docs;
  if (e.length === 0)
    return this;
  let n = e[e.length - 1] || [], t = n[n.length - 1];
  return t.typeahead === !0 && t.machine && (t.text = t.machine, t.normal = t.machine), this;
}, EI = function(e) {
  e.prototype.autoFill = II;
}, TI = function(e, n, t) {
  let r = {}, a = [], o = t.prefixes || {};
  return e.forEach((i) => {
    i = i.toLowerCase().trim();
    let s = i.length;
    n.max && s > n.max && (s = n.max);
    for (let u = n.min; u < s; u += 1) {
      let l = i.substring(0, u);
      if (!(n.safe && t.model.one.lexicon.hasOwnProperty(l))) {
        if (o.hasOwnProperty(l) === !0) {
          a.push(l);
          continue;
        }
        if (r.hasOwnProperty(l) === !0) {
          a.push(l);
          continue;
        }
        r[l] = i;
      }
    }
  }), r = Object.assign({}, o, r), a.forEach((i) => {
    delete r[i];
  }), r;
}, PI = (e) => Object.prototype.toString.call(e) === "[object Object]", SI = {
  safe: !0,
  min: 3
}, DI = function(e = [], n = {}) {
  let t = this.model();
  n = Object.assign({}, SI, n), PI(e) && (Object.assign(t.one.lexicon, e), e = Object.keys(e));
  let r = TI(e, n, this.world());
  return Object.keys(r).forEach((a) => {
    if (t.one.typeahead.hasOwnProperty(a)) {
      delete t.one.typeahead[a];
      return;
    }
    t.one.typeahead[a] = r[a];
  }), this;
}, OI = {
  typeahead: DI
}, RI = {
  one: {
    typeahead: {}
    //set a blank key-val
  }
}, FI = {
  model: RI,
  api: EI,
  lib: OI,
  compute: AI,
  hooks: ["typeahead"]
};
se.extend(k2);
se.extend(tN);
se.extend(wk);
se.extend(gN);
se.extend(oA);
se.plugin(J2);
se.extend(kI);
se.extend(Y2);
se.plugin(Bw);
se.extend(vC);
se.extend(FI);
se.extend(lC);
se.extend(DN);
const Zm = {
  // -a
  addendum: "addenda",
  corpus: "corpora",
  criterion: "criteria",
  curriculum: "curricula",
  genus: "genera",
  memorandum: "memoranda",
  opus: "opera",
  ovum: "ova",
  phenomenon: "phenomena",
  referendum: "referenda",
  // -ae
  alga: "algae",
  alumna: "alumnae",
  antenna: "antennae",
  formula: "formulae",
  larva: "larvae",
  nebula: "nebulae",
  vertebra: "vertebrae",
  // -is
  analysis: "analyses",
  axis: "axes",
  diagnosis: "diagnoses",
  parenthesis: "parentheses",
  prognosis: "prognoses",
  synopsis: "synopses",
  thesis: "theses",
  neurosis: "neuroses",
  // -x
  appendix: "appendices",
  index: "indices",
  matrix: "matrices",
  ox: "oxen",
  sex: "sexes",
  // -i
  alumnus: "alumni",
  bacillus: "bacilli",
  cactus: "cacti",
  fungus: "fungi",
  hippopotamus: "hippopotami",
  libretto: "libretti",
  modulus: "moduli",
  nucleus: "nuclei",
  octopus: "octopi",
  radius: "radii",
  stimulus: "stimuli",
  syllabus: "syllabi",
  // -ie
  cookie: "cookies",
  calorie: "calories",
  auntie: "aunties",
  movie: "movies",
  pie: "pies",
  rookie: "rookies",
  tie: "ties",
  zombie: "zombies",
  // -f
  leaf: "leaves",
  loaf: "loaves",
  thief: "thieves",
  // ee-
  foot: "feet",
  goose: "geese",
  tooth: "teeth",
  // -eaux
  beau: "beaux",
  chateau: "chateaux",
  tableau: "tableaux",
  // -ses
  bus: "buses",
  gas: "gases",
  circus: "circuses",
  crisis: "crises",
  virus: "viruses",
  database: "databases",
  excuse: "excuses",
  abuse: "abuses",
  avocado: "avocados",
  barracks: "barracks",
  child: "children",
  clothes: "clothes",
  echo: "echoes",
  embargo: "embargoes",
  epoch: "epochs",
  deer: "deer",
  halo: "halos",
  man: "men",
  woman: "women",
  mosquito: "mosquitoes",
  mouse: "mice",
  person: "people",
  quiz: "quizzes",
  rodeo: "rodeos",
  shoe: "shoes",
  sombrero: "sombreros",
  stomach: "stomachs",
  tornado: "tornados",
  tuxedo: "tuxedos",
  volcano: "volcanoes"
}, mh = {
  Comparative: "true¦bett1f0;arth0ew0in0;er",
  Superlative: "true¦earlier",
  PresentTense: "true¦bests,sounds",
  Condition: "true¦lest,unless",
  PastTense: "true¦began,came,d4had,kneel3l2m0sa4we1;ea0sg2;nt;eap0i0;ed;id",
  Participle: "true¦0:09;a06b01cZdXeat0fSgQhPoJprov0rHs7t6u4w1;ak0ithdra02o2r1;i02uY;k0v0;nd1pr04;ergoJoJ;ak0hHo3;e9h7lain,o6p5t4un3w1;o1um;rn;g,k;ol0reS;iQok0;ught,wn;ak0o1runk;ne,wn;en,wn;ewriNi1uJ;dd0s0;ut3ver1;do4se0t1;ak0h2;do2g1;roG;ne;ast0i7;iv0o1;ne,tt0;all0loBor1;bi3g2s1;ak0e0;iv0o9;dd0;ove,r1;a5eamt,iv0;hos0lu1;ng;e4i3lo2ui1;lt;wn;tt0;at0en,gun;r2w1;ak0ok0;is0;en",
  Gerund: "true¦accord0be0doin,go0result0stain0;ing",
  Expression: "true¦a0Yb0Uc0Sd0Oe0Mfarew0Lg0FhZjeez,lWmVnToOpLsJtIuFvEw7y0;a5e3i1u0;ck,p;k04p0;ee,pee;a0p,s;!h;!a,h,y;a5h2o1t0;af,f;rd up,w;atsoever,e1o0;a,ops;e,w;hoo,t;ery w06oi0L;gh,h0;! 0h,m;huh,oh;here nPsk,ut tut;h0ic;eesh,hh,it,oo;ff,h1l0ow,sst;ease,s,z;ew,ooey;h1i,mg,o0uch,w,y;h,o,ps;! 0h;hTmy go0wT;d,sh;a7evertheless,o0;!pe;eh,mm;ah,eh,m1ol0;!s;ao,fao;aCeBi9o2u0;h,mph,rra0zzC;h,y;l1o0;r6y9;la,y0;! 0;c1moCsmok0;es;ow;!p hip hoor0;ay;ck,e,llo,y;ha1i,lleluj0;ah;!ha;ah,ee4o1r0;eat scott,r;l1od0sh; grief,bye;ly;! whiz;ell;e0h,t cetera,ureka,ww,xcuse me;k,p;'oh,a0rat,uh;m0ng;mit,n0;!it;mon,o0;ngratulations,wabunga;a2oo1r0tw,ye;avo,r;!ya;h,m; 1h0ka,las,men,rgh,ye;!a,em,h,oy;la",
  Negative: "true¦n0;ever,o0;n,t",
  QuestionWord: "true¦how3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
  Reflexive: "true¦h4it5my5o1the0your2;ir1m1;ne3ur0;sel0;f,ves;er0im0;self",
  Plural: "true¦dick0gre0ones,records;ens",
  "Unit|Noun": "true¦cEfDgChBinchAk9lb,m6newt5oz,p4qt,t1y0;ardEd;able1b0ea1sp;!l,sp;spo1;a,t,x;on9;!b,g,i1l,m,p0;h,s;!les;!b,elvin,g,m;!es;g,z;al,b;eet,oot,t;m,up0;!s",
  Value: "true¦a few",
  Imperative: "true¦bewa0come he0;re",
  "Plural|Verb": "true¦leaves",
  Demonym: "true¦0:15;1:12;a0Vb0Oc0Dd0Ce08f07g04h02iYjVkTlPmLnIomHpEqatari,rCs7t5u4v3welAz2;am0Gimbabwe0;enezuel0ietnam0I;gAkrai1;aiwTex0hai,rinida0Ju2;ni0Prkmen;a5cotti4e3ingapoOlovak,oma0Spaniard,udRw2y0W;ede,iss;negal0Cr09;sh;mo0uT;o5us0Jw2;and0;a2eru0Fhilippi0Nortugu07uerto r0S;kist3lesti1na2raguay0;ma1;ani;ami00i2orweP;caragu0geri2;an,en;a3ex0Lo2;ngo0Drocc0;cedo1la2;gasy,y07;a4eb9i2;b2thua1;e0Cy0;o,t01;azakh,eny0o2uwaiI;re0;a2orda1;ma0Ap2;anO;celandic,nd4r2sraeli,ta01vo05;a2iB;ni0qi;i0oneU;aiAin2ondur0unO;di;amEe2hanai0reek,uatemal0;or2rm0;gi0;ilipino,ren8;cuadoVgyp4mira3ngli2sto1thiopi0urope0;shm0;ti;ti0;aPominUut3;a9h6o4roat3ub0ze2;ch;!i0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el6o4r3ul2;gaE;azi9it;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;genti2me1;ne;ba1ge2;ri0;ni0;gh0r2;ic0;an",
  Organization: "true¦0:4Q;a3Tb3Bc2Od2He2Df27g1Zh1Ti1Pj1Nk1Ll1Gm12n0Po0Mp0Cqu0Br02sTtHuCv9w3xiaomi,y1;amaha,m1Bou1w1B;gov,tu3C;a4e2iki1orld trade organizati33;leaRped0O;lls fargo,st1;fie2Hinghou2R;l1rner br3U;gree3Jl street journ2Im1E;an halOeriz2Xisa,o1;dafo2Yl1;kswagMvo;b4kip,n2ps,s1;a tod3Aps;es3Mi1;lev3Fted natio3C;er,s; mobi32aco beRd bOe9gi frida3Lh3im horto3Amz,o1witt3D;shi49y1;ota,s r 05;e 1in lizzy;b3carpen3Jdaily ma3Dguess w2holli0s1w2;mashing pumpki35uprem0;ho;ea1lack eyed pe3Xyr0Q;ch bo3Dtl0;l2n3Qs1xas instrumen1U;co,la m1F;efoni0Kus;a8cientology,e5ieme2Ymirnoff,np,o3pice gir6quare0Ata1ubaru;rbuc1to34;ks;ny,undgard1;en;a2x pisto1;ls;g1Wrs;few2Minsbur31lesfor03msu2E;adiohead,b8e4o1yana3C;man empi1Xyal 1;b1dutch she4;ank;a3d 1max,vl20;bu1c2Ahot chili peppe2Ylobst2N;ll;ders dige1Ll madrid;c,s;ant3Aizn2Q;a8bs,e5fiz2Ihilip4i3r1;emier 1udenti1D;leagTo2K;nk floyd,zza hut; morrBs;psi2tro1uge0E;br33chi0Tn33;!co;lant2Un1yp16; 2ason27da2P;ld navy,pec,range juli2xf1;am;us;aAb9e6fl,h5i4o1sa,vid3wa;k2tre dame,vart1;is;ia;ke,ntendo,ss0QvZ;l,s;c,st1Otflix,w1; 1sweek;kids on the block,york0D;a,c;nd22s2t1;ional aca2Po,we0U;a,c02d0S;aDcdonalCe9i6lb,o3tv,y1;spa1;ce;b1Tnsanto,ody blu0t1;ley cr1or0T;ue;c2t1;as,subisO;helin,rosoft;dica2rcedes benz,talli1;ca;id,re;ds;cs milk,tt19z24;a3e1g,ittle caesa1P; ore09novo,x1;is,mark,us; 1bour party;pres0Dz boy;atv,fc,kk,lm,m1od1O;art;iffy lu0Roy divisi0Jpmorgan1sa;! cha09;bm,hop,k3n1tv;g,te1;l,rpol;ea;a5ewlett pack1Vi3o1sbc,yundai;me dep1n1P;ot;tac1zbollah;hi;lliburt08sbro;eneral 6hq,ithub,l5mb,o2reen d0Ou1;cci,ns n ros0;ldman sachs,o1;dye1g0H;ar;axo smith kli04encoW;electr0Nm1;oto0Z;a5bi,c barcelo4da,edex,i2leetwood m03o1rito l0G;rd,xcY;at,fa,nancial1restoZ; tim0;na;cebook,nnie mae;b0Asa,u3xxon1; m1m1;ob0J;!rosceptics;aiml0De5isney,o4u1;nkin donu2po0Zran dur1;an;ts;j,w jon0;a,f lepp12ll,peche mode,r spieg02stiny's chi1;ld;aJbc,hFiDloudflaCnn,o3r1;aigsli5eedence clearwater reviv1ossra09;al;c7inba6l4m1o0Est09;ca2p1;aq;st;dplSg1;ate;se;a c1o chanQ;ola;re;a,sco1tigroup;! systems;ev2i1;ck fil a,na daily;r1y;on;d2pital o1rls jr;ne;bury,ill1;ac;aEbc,eBf9l5mw,ni,o1p,rexiteeU;ei3mbardiIston 1;glo1pizza;be;ng;o2ue c1;roV;ckbuster video,omingda1;le; g1g1;oodriL;cht2e ge0rkshire hathaw1;ay;el;cardi,idu,nana republ3s1xt5y5;f,kin robbi1;ns;ic;bYcTdidSerosmith,iRlKmEnheuser busDol,ppleAr6s4u3v2y1;er;is,on;di,todesk;hland o1sociated E;il;b3g2m1;co;os;ys; compu1be0;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 5catel2ta1;ir;! lu1;ce1;nt;jazeera,qae1;da;g,rbnb;as;/dc,a3er,tivision1;! blizz1;ard;demy of scienc0;es;ba",
  Possessive: "true¦its,my,our0thy;!s",
  "Noun|Verb": "true¦0:9W;1:AA;2:96;3:A3;4:9R;5:A2;6:9K;7:8N;8:7L;9:A8;A:93;B:8D;C:8X;a9Ob8Qc7Id6Re6Gf5Sg5Hh55i4Xj4Uk4Rl4Em40n3Vo3Sp2Squ2Rr21s0Jt02u00vVwGyFzD;ip,oD;ne,om;awn,e6Fie68;aOeMhJiHoErD;ap,e9Oink2;nd0rDuC;kDry,sh5Hth;!shop;ck,nDpe,re,sh;!d,g;e86iD;p,sD;k,p0t2;aDed,lco8W;r,th0;it,lk,rEsDt4ve,x;h,te;!ehou1ra9;aGen5FiFoD;iDmAte,w;ce,d;be,ew,sA;cuum,l4B;pDr7;da5gra6Elo6A;aReQhrPiOoMrGuEwiDy5Z;n,st;nDrn;e,n7O;aGeFiEoDu6;t,ub2;bu5ck4Jgg0m,p;at,k,nd;ck,de,in,nsDp,v7J;f0i8R;ll,ne,p,r4Yss,t94uD;ch,r;ck,de,e,le,me,p,re;e5Wow,u6;ar,e,ll,mp0st,xt;g,lDng2rg7Ps5x;k,ly;a0Sc0Ne0Kh0Fi0Dk0Cl0Am08n06o05pXquaBtKuFwD;ea88iD;ng,pe,t4;bGit,m,ppErD;fa3ge,pri1v2U;lDo6S;e6Py;!je8;aMeLiKoHrEuDy2;dy,ff,mb2;a85eEiDo5Pugg2;ke,ng;am,ss,t4;ckEop,p,rD;e,m;ing,pi2;ck,nk,t4;er,m,p;ck,ff,ge,in,ke,lEmp,nd,p2rDte,y;!e,t;k,l;aJeIiHlGoFrDur,y;ay,e56inDu3;g,k2;ns8Bt;a5Qit;ll,n,r87te;ed,ll;m,n,rk;b,uC;aDee1Tow;ke,p;a5Je4FiDo53;le,rk;eep,iDou4;ce,p,t;ateboa7Ii;de,gnDl2Vnk,p,ze;!al;aGeFiEoDuff2;ck,p,re,w;ft,p,v0;d,i3Ylt0;ck,de,pe,re,ve;aEed,nDrv1It;se,t2N;l,r4t;aGhedu2oBrD;aEeDibb2o3Z;en,w;pe,t4;le,n,r2M;cDfegua72il,mp2;k,rifi3;aZeHhy6LiGoEuD;b,in,le,n,s5X;a6ck,ll,oDpe,u5;f,t;de,ng,ot,p,s1W;aTcSdo,el,fQgPje8lOmMnLo17pJque6sFturn,vDwa6V;eDi27;al,r1;er74oFpe8tEuD;lt,me;!a55;l71rt;air,eaDly,o53;l,t;dezvo2Zt;aDedy;ke,rk;ea1i4G;a6Iist0r5N;act6Yer1Vo71uD;nd,se;a38o6F;ch,s6G;c1Dge,iEke,lly,nDp1Wt1W;ge,k,t;n,se;es6Biv0;a04e00hYiXlToNrEsy4uD;mp,n4rcha1sh;aKeIiHoDu4O;be,ceFdu3fi2grDje8mi1p,te6;amDe6W;!me;ed,ss;ce,de,nt;sDy;er6Cs;cti3i1;iHlFoEp,re,sDuCw0;e,i5Yt;l,p;iDl;ce,sh;nt,s5V;aEce,e32uD;g,mp,n7;ce,nDy;!t;ck,le,n17pe,tNvot;a1oD;ne,tograph;ak,eFnErDt;fu55mA;!c32;!l,r;ckJiInHrFsEtDu1y;ch,e9;s,te;k,tD;!y;!ic;nt,r,se;!a7;bje8ff0il,oErDutli3Qver4B;bAd0ie9;ze;a4ReFoDur1;d,tD;e,i3;ed,gle8tD;!work;aMeKiIoEuD;rd0;ck,d3Rld,nEp,uDve;nt,th;it5EkD;ey;lk,n4Brr5CsDx;s,ta2B;asuBn4UrDss;ge,it;il,nFp,rk3WsEtD;ch,t0;h,k,t0;da5n0oeuvB;aLeJiHoEuD;mp,st;aEbby,ck,g,oDve;k,t;d,n;cDe,ft,mAnIst;en1k;aDc0Pe4vK;ch,d,k,p,se;bFcEnd,p,t4uD;gh,n4;e,k;el,o2U;eEiDno4E;ck,d,ll,ss;el,y;aEo1OuD;i3mp;m,zz;mpJnEr46ssD;ue;c1Rdex,fluGha2k,se2HteDvoi3;nt,rD;e6fa3viD;ew;en3;a8le2A;aJeHiGoEuD;g,nt;l3Ano2Dok,pDr1u1;!e;ghli1Fke,nt,re,t;aDd7lp;d,t;ck,mGndFrEsh,tDu9;ch,e;bo3Xm,ne4Eve6;!le;!m0;aMear,ift,lKossJrFuD;arDe4Alp,n;antee,d;aFiEoDumb2;uCwth;ll,nd,p;de,sp;ip;aBoDue;ss,w;g,in,me,ng,s,te,ze;aZeWiRlNoJrFuD;ck,el,nDss,zz;c38d;aEoDy;st,wn;cDgme,me,nchi1;tuB;cFg,il,ld,rD;ce,e29mDwa31;!at;us;aFe0Vip,oDy;at,ck,od,wD;!er;g,ke,me,re,sh,vo1E;eGgFlEnDre,sh,t,x;an3i0Q;e,m,t0;ht,uB;ld;aEeDn3;d,l;r,tuB;ce,il,ll,rm,vo2W;cho,d7ffe8nMsKxFyeD;!baD;ll;cGerci1hFpDtra8;eriDo0W;en3me9;au6ibA;el,han7u1;caDtima5;pe;count0d,vy;a01eSiMoJrEuDye;b,el,mp,pli2X;aGeFiEoD;ne,p;ft,ll,nk,p,ve;am,ss;ft,g,in;cEd7ubt,wnloD;ad;k,u0E;ge6p,sFt4vD;e,iDor3;de;char7gui1h,liEpD;at4lay,u5;ke;al,bKcJfeIlGmaCposAsEtaD;il;e07iD;gn,re;ay,ega5iD;ght;at,ct;li04rea1;a5ut;b,ma7n3rDte;e,t;a0Eent0Dh06irc2l03oKrFuD;be,e,rDt;b,e,l,ve;aGeFoEuDy;sh;p,ss,wd;dAep;ck,ft,sh;at,de,in,lTmMnFordina5py,re,st,uDv0;gh,nDp2rt;s01t;ceHdu8fli8glomeIsFtDveN;a8rD;a6ol;e9tru8;ct;ntDrn;ra5;bHfoGmFpD;leDouCromi1;me9;aCe9it,u5;rt;at,iD;ne;lap1oD;r,ur;aEiDoud,ub;ck,p;im,w;aEeDip;at,ck,er;iGllen7nErD;ge,m,t;ge,nD;el;n,r;er,re;ke,ll,mp,noe,pGrXsFtEuDve;se,ti0I;alog,ch;h,t;!tuB;re;a03eZiXlToPrHuEyD;pa11;bb2ck2dgEff0mp,rDst,zz;den,n;et;anJeHiFoadEuD;i1sh;ca6;be,d7;ge;aDed;ch,k;ch,d;aFg,mb,nEoDrd0tt2x,ycott;k,st,t;d,e;rd,st;aFeCiDoYur;nk,tz;nd;me;as,d,ke,nd,opsy,tD;!ch,e;aFef,lt,nDt;d,efA;it;r,t;ck,il,lan3nIrFsEtt2;le;e,h;!gDk;aDe;in;!d,g,k;bu1c05dZge,iYlVnTppQrLsIttGucEwaD;rd;tiD;on;aDempt;ck;k,sD;i6ocia5;st;chFmD;!oD;ur;!iD;ve;eEroa4;ch;al;chDg0sw0;or;aEt0;er;rm;d,m,r;dreHvD;an3oD;ca5;te;ce;ss;cDe,he,t;eFoD;rd,u9;nt;nt,ss;se",
  Actor: "true¦0:7B;1:7G;2:6A;3:7F;4:7O;5:7K;a6Nb62c4Ud4Be41f3Sg3Bh30i2Uj2Qkin2Pl2Km26n1Zo1Sp0Vqu0Tr0JsQtJuHvEw8yo6;gi,ut6;h,ub0;aAe9i8o7r6;estl0it0;m2rk0;fe,nn0t2Bza2H;atherm2ld0;ge earn0it0nder0rri1;eter7i6oyF;ll5Qp,s3Z;an,ina2U;n6s0;c6Uder03;aoisea23e9herapi5iktok0o8r6ut1yco6S;a6endseLo43;d0mp,nscri0Bvel0;ddl0u1G;a0Qchn7en6na4st0;ag0;i3Oo0D;aiXcUeRhPiMki0mu26oJpGquaFtBu7wee6;p0theart;lt2per7r6;f0ge6Iviv1;h6inten0Ist5Ivis1;ero,um2;a8ep7r6;ang0eam0;bro2Nc2Ofa2Nmo2Nsi20;ff0tesm2;tt0;ec7ir2Do6;kesp59u0M;ia5Jt3;l7me6An,rcere6ul;r,ss;di0oi5;n7s6;sy,t0;g0n0;am2ephe1Iow6;girl,m2r2Q;cretInior cit3Fr6;gea4v6;a4it1;hol4Xi7reen6ulpt1;wr2C;e01on;l1nt;aEe9o8u6;l0nn6;er up,ingE;g40le mod3Zof0;a4Zc8fug2Ppo32searQv6;ere4Uolution6;ary;e6luYru22;ptio3T;bbi,dic5Vpp0;arter6e2Z;back;aYeWhSiRlOoKr8sycho7u6;nk,p31;logi5;aGeDiBo6;d9fess1g7ph47s6;pe2Ktitu51;en6ramm0;it1y;igy,uc0;est4Nme mini0Unce6s3E;!ss;a7si6;de4;ch0;ctiti39nk0P;dca0Oet,li6pula50rnst42;c2Itic6;al scie6i2;nti5;a6umb0;nn0y6;er,ma4Lwright;lgrim,one0;a8iloso7otogra7ra6ysi1V;se;ph0;ntom,rmaci5;r6ssi1T;form0s4O;i3El,nel3Yr8st1tr6wn;i6on;arWot;ent4Wi42tn0;ccupa4ffBp8r7ut6;ca5l0B;ac4Iganiz0ig2Fph2;er3t6;i1Jomet6;ri5;ic0spring;aBe9ie4Xo7u6;n,rser3J;b6mad,vi4V;le2Vo4D;i6mesis,phew;ce,ghb1;nny,rr3t1X;aEeDiAo7u6yst1Y;m8si16;der3gul,m7n6th0;arDk;!my;ni7s6;f02s0Jt0;on,st0;chan1Qnt1rcha4;gi9k0n8rtyr,t6y1;e,riar6;ch;ag0iac;ci2stra3I;a7e2Aieutena4o6;rd,s0v0;bor0d7ndlo6ss,urea3Fwy0ym2;rd;!y;!s28;e8o7u6;ggl0;gg0urna2U;st0;c3Hdol,llu3Ummigra4n6; l9c1Qfa4habi42nov3s7ve6;nt1stig3;pe0Nt6;a1Fig3ru0M;aw;airFeBistoAo8u6ygie1K;man6sba2H;!ita8;bo,st6usekN;age,e3P;ri2;ir,r6;m7o6;!ine;it;dress0sty2C;aLeIhostGirl26ladi3oCrand7u6;e5ru;c9daug0Jfa8m7pa6s2Y;!re4;a,o6;th0;hi1B;al7d6lf0;!de3A;ie,k6te26;eep0;!wr6;it0;isha,n6;i6tl04;us;mbl0rden0;aDella,iAo7r6;eela2Nie1P;e,re6ster pare4;be1Hm2r6st0;unn0;an2ZgZlmm17nanci0r6tt0;e6st la2H; marsh2OfigXm2;rm0th0;conoEdDlectriCm8n7x6;amin0cellency,i2A;emy,trepreneur,vironmenta1J;c8p6;er1loye6;e,r;ee;ci2;it1;mi5;aKeBi8ork,ri7u6we02;de,tche2H;ft0v0;ct3eti7plom2Hre6va;ct1;ci2ti2;aDcor3fencCi0InAput9s7tectLvel6;op0;ce1Ge6ign0;rt0;ee,y;iz6;en;em2;c1Ml0;d8nc0redev7ug6;ht0;il;!dy;a06e04fo,hXitizenWlToBr9u6;r3stomer6;! representat6;ive;e3it6;ic;lJmGnAord9rpor1Nu7w6;boy,ork0;n6ri0;ciTte1Q;in3;fidantAgressSs9t6;e0Kr6;ibut1o6;ll0;tab13ul1O;!e;edi2m6pos0rade;a0EeQissi6;on0;leag8on7um6;ni5;el;ue;e6own;an0r6;ic,k;!s;a9e7i6um;ld;erle6f;ad0;ir7nce6plFract0;ll1;m2wI;lebri6o;ty;dBptAr6shi0;e7pe6;nt0;r,t6;ak0;ain;et;aMeLiJlogg0oErBu6;dd0Fild0rgl9siness6;m2p7w6;om2;ers05;ar;i7o6;!k0th0;cklay0de,gadi0;hemi2oge8y6;!frie6;nd;ym2;an;cyc6sR;li5;atbox0ings;by,nk0r6;b0on7te6;nd0;!e07;c04dWge4nQpLrHsFtAu7yatull6;ah;nt7t6;h1oG;!ie;h8t6;e6orney;nda4;ie5le6;te;sis00tron6;aut,om0;chbis8isto7tis6;an,t;crU;hop;ost9p6;ari6rentiS;ti6;on;le;a9cest1im3nou8y6;bo6;dy;nc0;ly5rc6;hi5;mi8v6;entur0is1;er;ni7r6;al;str3;at1;or;counBquaintanArob9t6;ivi5or,re6;ss;st;at;ce;ta4;nt",
  "Adj|Noun": "true¦0:16;a1Db17c0Ud0Re0Mf0Dg0Ah08i06ju05l02mWnUoSpNrIsBt7u4v1watershed;a1ision0Z;gabo4nilla,ria1;b0Vnt;ndergr1pstairs;adua14ou1;nd;a3e1oken,ri0;en,r1;min0rori13;boo,n;age,e5ilv0Flack,o3quat,ta2u1well;bordina0Xper5;b0Lndard;ciali0Yl1vereign;e,ve16;cret,n1ri0;ior;a4e2ou1ubbiL;nd,tiY;ar,bBl0Wnt0p1side11;resent0Vublican;ci0Qsh;a4eriodic0last0Zotenti0r1;emi2incip0o1;!fession0;er,um;rall4st,tie0U;ff1pposi0Hv0;ens0Oi0C;agg01ov1uts;el;a5e3iniatJo1;bi01der07r1;al,t0;di1tr0N;an,um;le,riG;attOi2u1;sh;ber0ght,qC;stice,veniT;de0mpressioYn1;cumbe0Edividu0no0Dsta0Eterim;alf,o1umdrum;bby,melF;en2old,ra1;ph0Bve;er0ious;a7e5i4l3u1;git03t1;ure;uid;ne;llow,m1;aFiL;ir,t,vo1;riOuriO;l3p00x1;c1ecutUpeV;ess;d1iK;er;ar2e1;mographUrivO;k,l2;hiGlassSo2rude,unn1;ing;m5n1operK;creCstitueOte2vertab1;le;mpor1nt;ary;ic,m2p1;anion,lex;er2u1;ni8;ci0;al;e5lank,o4r1;i2u1;te;ef;ttom,urgeois;st;cadem9d6l2ntarct9r1;ab,ct8;e3tern1;at1;ive;rt;oles1ult;ce1;nt;ic",
  "Adj|Past": "true¦0:4Q;1:4C;2:4H;3:4E;a44b3Tc36d2Je29f20g1Wh1Si1Jj1Gkno1Fl1Am15n12o0Xp0Mqu0Kr08sLtEuAv9w4yellow0;a7ea6o4rinkl0;r4u3Y;n,ri0;k31th3;rp0sh0tZ;ari0e1O;n5p4s0;d1li1Rset;cov3derstood,i4;fi0t0;a8e3Rhr7i6ouTr4urn0wi4C;a4imm0ou2G;ck0in0pp0;ed,r0;eat2Qi37;m0nn0r4;get0ni2T;aOcKeIhGimFm0Hoak0pDt7u4;bsid3Ogge44s4;pe4ta2Y;ct0nd0;a8e7i2Eok0r5u4;ff0mp0nn0;ength2Hip4;ed,p0;am0reotyp0;in0t0;eci4ik0oH;al3Efi0;pRul1;a4ock0ut;d0r0;a4c1Jle2t31;l0s3Ut0;a6or5r4;at4e25;ch0;r0tt3;t4ut0;is2Mur1;aEe5o4;tt0;cAdJf2Bg9je2l8m0Knew0p7qu6s4;eTpe2t4;or0ri2;e3Dir0;e1lac0;at0e2Q;i0Rul1;eiv0o4ycl0;mme2Lrd0v3;in0lli0ti2A;a4ot0;li28;aCer30iBlAo9r5u4;mp0zzl0;e6i2Oo4;ce2Fd4lo1Anou30pos0te2v0;uc0;fe1CocCp0Iss0;i2Kli1L;ann0e2CuS;ck0erc0ss0;ck0i2Hr4st0;allLk0;bse7c6pp13rgan2Dver4;lo4whelm0;ok0;cupi0;rv0;aJe5o4;t0uri1A;ed0gle2;a6e5ix0o4ut0ys1N;di1Nt15u26;as0Clt0;n4rk0;ag0ufact0A;e6i5o4;ad0ck0st,v0;cens0m04st0;ft,v4;el0;tt0wn;a5o15u4;dg0s1B;gg0;llumSmpAn4sol1;br0cre1Ldebt0f8jZspir0t5v4;it0olv0;e4ox0Y;gr1n4re23;d0si15;e2l1o1Wuri1;li0o01r4;ov0;a6e1o4um03;ok0r4;ri0Z;mm3rm0;i6r5u4;a1Bid0;a0Ui0Rown;ft0;aAe9i8l6oc0Ir4;a4i0oz0Y;ctHg19m0;avo0Ju4;st3;ni08tt0x0;ar0;d0il0sc4;in1;dCl1mBn9quipp0s8x4;agger1c6p4te0T;a0Se4os0;ct0rie1D;it0;cap0tabliZ;cha0XgFha1As4;ur0;a0Zbarra0N;i0Buc1;aMeDi5r4;a01i0;gni08miniSre2s4;a9c6grun0Ft4;o4re0Hu17;rt0;iplWou4;nt0r4;ag0;bl0;cBdRf9l8p7ra6t5v4;elop0ot0;ail0ermQ;ng0;re07;ay0ight0;e4in0o0M;rr0;ay0enTor1;m5t0z4;ed,zl0;ag0p4;en0;aPeLhIlHo9r6u4;lt4r0stom03;iv1;a5owd0u4;sh0;ck0mp0;d0loAm7n4ok0v3;centr1f5s4troC;id3olid1;us0;b5pl4;ic1;in0;r0ur0;assi9os0utt3;ar5i4;ll0;g0m0;lebr1n6r4;ti4;fi0;tralJ;g0lcul1;aDewild3iCl9o7r5urn4;ed,t;ok4uis0;en;il0r0t4und;tl0;e5i4;nd0;ss0;as0;ffl0k0laMs0tt3;bPcNdKfIg0lFmaz0nDppBrm0ss9u5wa4;rd0;g5thor4;iz0;me4;nt0;o6u4;m0r0;li0re4;ci1;im1ticip1;at0;a5leg0t3;er0;rm0;fe2;ct0;ju5o7va4;nc0;st0;ce4knowledg0;pt0;and5so4;rb0;on0;ed",
  Singular: "true¦0:5J;1:5H;2:4W;3:4S;4:52;5:57;6:5L;7:56;8:5B;a52b4Lc3Nd35e2Xf2Og2Jh28in24j23k22l1Um1Ln1Ho1Bp0Rqu0Qr0FsZtMuHvCw9x r58yo yo;a9ha3Po3Q;f3i4Rt0Gy9;! arou39;arCeAideo ga2Qo9;cabu4Jl5C;gOr9t;di4Zt1Y;iety,ni4P;nBp30rAs 9;do43s5E;bani1in0;coordinat3Ader9;estima1to24we41; rex,aKeJhHiFoErBuAv9;! show;m2On2rntLto1D;agedy,ib9o4E;e,u9;n0ta46;ni1p2rq3L;c,er,m9;etF;ing9ree26;!y;am,mp3F;ct2le6x return;aNcMeKhor4QiJkHoGpin off,tDuBy9;ll9ner7st4T;ab2X;b9i1n28per bowl,rro1X;st3Ltot0;atAipe2Go1Lrate7udent9;! lo0I;i39u1;ft ser4Lmeo1I;elet5i9;ll,r3V;b38gn2Tte;ab2Jc9min3B;t,urity gua2N;e6ho2Y;bbatic0la3Jndwi0Qpi5;av5eDhetor2iAo9;de6om,w;tAv9;erb2C;e,u0;bDcBf9publ2r10spi1;er9orm3;e6r0;i9ord label;p2Ht0;a1u46;estion mark,ot2F;aPeMhoLiIlGoErAu9yram1F;ddi3HpErpo1Js3J;eBo9;bl3Zs9;pe3Jta1;dic1Rmi1Fp1Qroga8ss relea1F;p9rt0;py;a9ebisci1;q2Dte;cn2eAg9;!gy;!r;ne call,tocoK;anut,dAr9t0yo1;cen3Jsp3K;al,est0;nop4rAt9;e,hog5;adi11i2V;atme0bj3FcBpia1rde0thers,utspok5ve9wn3;n,r9;ti0Pview;cuAe9;an;pi3;arBitAot9umb3;a2Fhi2R;e,ra1;cot2ra8;aFeCiAo9ur0;nopo4p18rni2Nsq1Rti36uld;c,li11n0As9tt5;chief,si34;dAnu,t9;al,i3;al,ic;gna1mm0nd15rsupi0te9yf4;ri0;aDegCiBu9;ddi1n9;ch;me,p09; Be0M;bor14y9; 9er;up;eyno1itt5;el4ourn0;cBdices,itia8ni25sAtel0Lvert9;eb1J;e28titu1;en8i2T;aIeEighDoAu9;man right,s22;me9rmoFsp1Ftb0K;! r9;un; scho0YriY;a9i1N;d9v5; start,pho9;ne;ndful,sh brown,v5ze;aBelat0Ilaci3r9ul4yp1S;an9enadi3id;a1Cd slam,ny;df4r9;l2ni1I;aGeti1HiFlu1oCrAun9;er0;ee market,i9onti3;ga1;l4ur9;so9;me;ePref4;br2mi4;conoFffi7gg,lecto0Rmbas1EnCpidem2s1Zth2venBxAyel9;id;ampZempl0Nte6;i19t;er7terp9;ri9;se;my;eLiEoBr9ump tru0U;agonf4i9;er,ve thru;cAg7i4or,ssi3wn9;side;to0EumenE;aEgniDnn3sAvide9;nd;conte6incen8p9tri11;osi9;ti0C;ta0H;le0X;athBcAf9ni0terre6;ault 05err0;al,im0;!b9;ed;aWeThMiLlJoDr9;edit caBuc9;ib9;le;rd;efficDke,lCmmuniqLnsApi3rr0t0Xus9yo1;in;erv9uI;ato02;ic,lQ;ie6;er7i9oth;e6n2;ty,vil wM;aDeqCick5ocoBr9;istmas car9ysanthemum;ol;la1;ue;ndeli3racteri9;st2;iAllEr9;e0tifica1;liZ;hi3nFpErCt9ucus;erpi9hedr0;ll9;ar;!bohyd9ri3;ra1;it0;aAe,nib0t9;on;l,ry;aMeLiop2leJoHrDu9;nny,r9tterf4;g9i0;la9;ry;eakAi9;ck;fa9throB;st;dy,ro9wl;ugh;mi9;sh;an,l4;nkiArri3;er;ng;cSdMlInFppeti1rDsBtt2utop9;sy;ic;ce6pe9;ct;r9sen0;ay;ecAoma4tiA;ly;do1;i5l9;er7y;gy;en; hominDjAvan9;tage;ec8;ti9;ve;em;cCeAqui9;tt0;ta1;te;iAru0;al;de6;nt",
  "Person|Noun": "true¦a0Eb07c03dWeUfQgOhLjHkiGlFmCnBolive,p7r4s3trini06v1wa0;ng,rd,tts;an,enus,iol0;a,et;ky,onPumm09;ay,e1o0uby;bin,d,se;ed,x;a2e1o0;l,tt04;aLnJ;dYge,tR;at,orm;a0eloW;t0x,ya;!s;a9eo,iH;ng,tP;a2e1o0;lGy;an,w3;de,smi4y;a0erb,iOolBuntR;ll,z0;el;ail,e0iLuy;ne;a1ern,i0lo;elds,nn;ith,n0;ny;a0dEmir,ula,ve;rl;a4e3i1j,ol0;ly;ck,x0;ie;an,ja;i0wn;sy;am,h0liff,rystal;a0in,ristian;mbers,ri0;ty;a4e3i2o,r0ud;an0ook;dy;ll;nedict,rg;k0nks;er;l0rt;fredo,ma",
  "Actor|Verb": "true¦aCb8c5doctor,engineAfool,g3host,judge,m2nerd,p1recruit,scout,ushAvolunteAwi0;mp,tneA;arent,ilot;an,ime;eek,oof,r0uide;adu8oom;ha1o0;ach,nscript,ok;mpion,uffeur;o2u0;lly,tch0;er;ss;ddi1ffili0rchite1;ate;ct",
  MaleName: "true¦0:H6;1:FZ;2:DS;3:GQ;4:CZ;5:FV;6:GM;7:FP;8:GW;9:ET;A:C2;B:GD;aF8bE1cCQdBMeASfA1g8Yh88i7Uj6Sk6Bl5Mm48n3So3Ip33qu31r26s1Et0Ru0Ov0CwTxSyHzC;aCor0;cChC1karia,nAT;!hDkC;!aF6;!ar7CeF5;aJevgenBSoEuC;en,rFVsCu3FvEF;if,uf;nDs6OusC;ouf,s6N;aCg;s,tC;an,h0;hli,nCrosE1ss09;is,nC;!iBU;avi2ho5;aPeNiDoCyaEL;jcieBJlfgang,odrFutR;lFnC;f8TsC;lCt1;ow;bGey,frEhe4QlC;aE5iCy;am,e,s;ed8iC;d,ed;eAur;i,ndeD2rn2sC;!l9t1;lDyC;l1ne;lDtC;!er;aCHy;aKernDAiFladDoC;jteB0lodymyr;!iC;mFQsDB;cFha0ktBZnceDrgCOvC;a0ek;!nC;t,zo;!e4StBV;lCnC7sily;!entC;in9J;ghE2lCm70nax,ri,sm0;riCyss87;ch,k;aWeRhNiLoGrEuDyC;!l2roEDs1;n6r6E;avD0eCist0oy,um0;ntCRvBKy;bFdAWmCny;!asDmCoharu;aFFie,y;!z;iA6y;mCt4;!my,othy;adEeoDia0SomC;!as;!dor91;!de4;dFrC;enBKrC;anBJeCy;ll,nBI;!dy;dgh,ha,iCnn2req,tsu5V;cDAka;aYcotWeThPiMlobod0oKpenc2tEurDvenAEyCzym1;ed,lvest2;aj,e9V;anFeDuC;!aA;fan17phEQvCwaA;e77ie;!islaCl9;v,w;lom1rBuC;leymaDHta;dDgmu9UlCm1yabonga;as,v8B;!dhart8Yn9;aEeClo75;lCrm0;d1t1;h9Jne,qu1Jun,wn,yne;aDbastiEDk2Yl5Mpp,rgCth,ymoCU;e1Dio;m4n;!tC;!ie,y;eDPlFmEnCq67tosCMul;dCj2UtiA5;e01ro;!iATkeB6mC4u5;!ik,vato9K;aZeUheC8iRoGuDyC;an,ou;b99dDf4peAssC;!elEG;ol00y;an,bLc7MdJel,geIh0lHmGnEry,sDyC;!ce;ar7Ocoe,s;!aCnBU;ld,n;an,eo;a7Ef;l7Jr;e3Eg2n9olfo,riC;go;bBNeDH;cCl9;ar87c86h54kCo;!ey,ie,y;cFeA3gDid,ubByCza;an8Ln06;g85iC;naC6s;ep;ch8Kfa5hHin2je8HlGmFndEoHpha5sDul,wi36yC;an,mo8O;h9Im4;alDSol3O;iD0on;f,ph;ul;e9CinC;cy,t1;aOeLhilJiFrCyoG;aDeC;m,st1;ka85v2O;eDoC;tr;r8GtC;er,ro;!ipCl6H;!p6U;dCLrcy,tC;ar,e9JrC;!o7;b9Udra8So9UscAHtri62ulCv8I;!ie,o7;ctav6Ji2lImHndrBRrGsDtCum6wB;is,to;aDc6k6m0vCwaBE;al79;ma;i,vR;ar,er;aDeksandr,ivC;er,i2;f,v;aNeLguyBiFoCu3O;aDel,j4l0ma0rC;beAm0;h,m;cFels,g5i9EkDlC;es,s;!au,h96l78olaC;!i,y;hCkCol76;ol75;al,d,il,ls1vC;ilAF;hom,tC;e,hC;anCy;!a5i5;aYeViLoGuDyC;l4Nr1;hamDr84staC;fa,p6E;ed,mG;di10e,hamEis4JntDritz,sCussa;es,he;e,y;ad,ed,mC;ad,ed;cGgu5hai,kFlEnDtchC;!e8O;a9Pik;house,o7t1;ae73eC3ha8Iolaj;ah,hDkC;!ey,y;aDeC;al,l;el,l;hDlv3rC;le,ri8Ev4T;di,met;ay0c00gn4hWjd,ks2NlTmadZnSrKsXtDuric7VxC;imilBKwe8B;eHhEi69tCus,y69;!eo,hCia7;ew,i67;eDiC;as,eu,s;us,w;j,o;cHiGkFlEqu8Qsha83tCv3;iCy;!m,n;in,on;el,o7us;a6Yo7us;!elCin,o7us;!l8o;frAEi5Zny,u5;achDcoCik;lm;ai,y;amDdi,e5VmC;oud;adCm6W;ou;aulCi9P;ay;aWeOiMloyd,oJuDyC;le,nd1;cFdEiDkCth2uk;a7e;gi,s,z;ov7Cv6Hw6H;!as,iC;a6Een;g0nn52renDuCvA4we7D;!iS;!zo;am,n4oC;n5r;a9Yevi,la5KnHoFst2thaEvC;eCi;nte;bo;nCpo8V;!a82el,id;!nC;aAy;mEnd1rDsz73urenCwr6K;ce,t;ry,s;ar,beAont;aOeIhalHiFla4onr63rDu5SylC;e,s;istCzysztof;i0oph2;er0ngsl9p,rC;ilA9k,ollos;ed,id;en0iGnDrmCv4Z;it;!dDnCt1;e2Ny;ri4Z;r,th;cp2j4mEna8BrDsp6them,uC;ri;im,l;al,il;a03eXiVoFuC;an,lCst3;en,iC;an,en,o,us;aQeOhKkub4AnIrGsDzC;ef;eDhCi9Wue;!ua;!f,ph;dCge;i,on;!aCny;h,s,th6J;anDnC;!ath6Hie,n72;!nC;!es;!l,sCy;ph;o,qu3;an,mC;!i,m6V;d,ffFns,rCs4;a7JemDmai7QoCry;me,ni1H;i9Dy;!e73rC;ey,y;cKdBkImHrEsDvi2yC;dBs1;on,p2;ed,oDrCv67;e6Qod;d,s61;al,es5Wis1;a,e,oCub;b,v;ob,qu13;aTbNchiMgLke53lija,nuKonut,rIsEtCv0;ai,suC;ki;aDha0i8XmaCsac;el,il;ac,iaC;h,s;a,vinCw3;!g;k,nngu6X;nac1Xor;ka;ai,rahC;im;aReLoIuCyd6;beAgGmFsC;eyDsC;a3e3;in,n;ber5W;h,o;m2raDsse3wC;a5Pie;c49t1K;a0Qct3XiGnDrC;beAman08;dr7VrC;iCy2N;!k,q1R;n0Tt3S;bKlJmza,nIo,rEsDyC;a5KdB;an,s0;lEo67r2IuCv9;hi5Hki,tC;a,o;an,ey;k,s;!im;ib;a08e00iUlenToQrMuCyorgy;iHnFsC;!taC;f,vC;!e,o;n6tC;er,h2;do,lC;herDlC;auCerQ;me;aEegCov2;!g,orC;!io,y;dy,h7C;dfr9nza3XrDttfC;ri6C;an,d47;!n;acoGlEno,oCuseppe;rgiCvan6O;!o,s;be6Ies,lC;es;mo;oFrC;aDha4HrC;it,y;ld,rd8;ffErgC;!e7iCy;!os;!r9;bElBrCv3;eCla1Nr4Hth,y;th;e,rC;e3YielC;!i4;aXeSiQlOorrest,rCyod2E;aHedFiC;edDtC;s,z;ri18;!d42eri11riC;ck,k;nCs2;cEkC;ie,lC;in,yn;esLisC;!co,z3M;etch2oC;ri0yd;d5lConn;ip;deriFliEng,rC;dinaCg4nan0B;nd8;pe,x;co;bCdi,hd;iEriC;ce,zC;io;an,en,o;benez2dZfrYit0lTmMnJo3rFsteb0th0ugenEvCymBzra;an,eCge4D;ns,re3K;!e;gi,iDnCrol,v3w3;est8ie,st;cCk;!h,k;o0DriCzo;co,qC;ue;aHerGiDmC;aGe3A;lCrh0;!iC;a10o,s;s1y;nu5;beAd1iEliDm2t1viCwood;n,s;ot28s;!as,j5Hot,sC;ha;a3en;!dGg6mFoDua2QwC;a2Pin;arC;do;oZuZ;ie;a04eTiOmitrNoFrag0uEwDylC;an,l0;ay3Hig4D;a3Gdl9nc0st3;minFnDri0ugCvydGy2S;!lF;!a36nCov0;e1Eie,y;go,iDykC;as;cCk;!k;i,y;armuFetDll1mitri7neCon,rk;sh;er,m6riC;ch;id;andLepak,j0lbeAmetri4nIon,rGsEvDwCxt2;ay30ey;en,in;hawn,moC;nd;ek,riC;ck;is,nC;is,y;rt;re;an,le,mKnIrEvC;e,iC;!d;en,iEne0PrCyl;eCin,yl;l45n;n,o,us;!iCny;el,lo;iCon;an,en,on;a0Fe0Ch03iar0lRoJrFuDyrC;il,us;rtC;!is;aEistC;iaCob12;no;ig;dy,lInErC;ey,neliCy;s,us;nEor,rDstaC;nt3;ad;or;by,e,in,l3t1;aHeEiCyde;fCnt,ve;fo0Xt1;menDt4;us;s,t;rFuDyC;!t1;dCs;e,io;enC;ce;aHeGrisC;!toC;phCs;!eC;!r;st2t;d,rCs;b5leC;s,y;cDdrCs6;ic;il;lHmFrC;ey,lDroCy;ll;!o7t1;er1iC;lo;!eb,v3;a09eZiVjorn,laUoSrEuCyr1;ddy,rtKst2;er;aKeFiEuDyC;an,ce,on;ce,no;an,ce;nDtC;!t;dDtC;!on;an,on;dFnC;dDisC;lav;en,on;!foOl9y;bby,gd0rCyd;is;i0Lke;bElDshC;al;al,lL;ek;nIrCshoi;at,nEtC;!raC;m,nd;aDhaCie;rd;rd8;!iDjam3nCs1;ie,y;to;kaMlazs,nHrC;n9rDtC;!holomew;eCy;tt;ey;dCeD;ar,iC;le;ar1Nb1Dd16fon15gust3hm12i0Zja0Yl0Bm07nTputsiSrGsaFugustEveDyCziz;a0kh0;ry;o,us;hi;aMchiKiJjun,mHnEon,tCy0;em,hCie,ur8;ur;aDoC;!ld;ud,v;aCin;an,nd8;!el,ki;baCe;ld;ta;aq;aMdHgel8tCw6;hoFoC;iDnC;!i8y;ne;ny;er7rCy;eDzC;ej;!as,i,j,s,w;!s;s,tolC;iCy;!y;ar,iEmaCos;nu5r;el;ne,r,t;aVbSdBeJfHiGl01onFphonsEt1vC;aPin;on;e,o;so,zo;!sR;!onZrC;ed;c,jaHksFssaHxC;!andC;er,rC;e,os,u;andCei;ar,er,r;ndC;ro;en;eDrecC;ht;rt8;dd3in,n,sC;taC;ir;ni;dDm6;ar;an,en;ad,eC;d,t;in;so;aGi,olErDvC;ik;ian8;f8ph;!o;mCn;!a;dGeFraDuC;!bakr,lfazl;hCm;am;!l;allFel,oulaye,ulC;!lDrahm0;an;ah,o;ah;av,on",
  Uncountable: "true¦0:2E;1:2L;2:33;a2Ub2Lc29d22e1Rf1Ng1Eh16i11j0Yk0Wl0Rm0Hn0Do0Cp03rZsLt9uran2Jv7w3you gu0E;a5his17i4oo3;d,l;ldlife,ne;rm8t1;apor,ernacul29i3;neg28ol1Otae;eDhBiAo8r4un3yranny;a,gst1B;aff2Oea1Ko4ue nor3;th;o08u3;bleshoot2Ose1Tt;night,othpas1Vwn3;foEsfoE;me off,n;er3und1;e,mod2S;a,nnis;aDcCeBhAi9ki8o7p6t4u3weepstak0;g1Unshi2Hshi;ati08e3;am,el;ace2Keci0;ap,cc1meth2C;n,ttl0;lk;eep,ingl0or1C;lf,na1Gri0;ene1Kisso1C;d0Wfe2l4nd,t3;i0Iurn;m1Ut;abi0e4ic3;e,ke15;c3i01laxa11search;ogni10rea10;a9e8hys7luto,o5re3ut2;amble,mis0s3ten20;en1Zs0L;l3rk;i28l0EyH; 16i28;a24tr0F;nt3ti0M;i0s;bstetri24vercrowd1Qxyg09;a5e4owada3utella;ys;ptu1Ows;il poliZtional securi2;aAe8o5u3;m3s1H;ps;n3o1K;ey,o3;gamy;a3cha0Elancholy,rchandi1Htallurgy;sl0t;chine3g1Aj1Hrs,thema1Q; learn1Cry;aught1e6i5ogi4u3;ck,g12;c,s1M;ce,ghtn18nguis1LteratWv1;ath1isVss;ara0EindergartPn3;icke0Aowled0Y;e3upit1;a3llyfiGwel0G;ns;ce,gnor6mp5n3;forma00ter3;net,sta07;atiSort3rov;an18;a7e6isto09o3ung1;ckey,mework,ne4o3rseradi8spitali2use arrest;ky;s2y;adquarteXre;ir,libut,ppiHs3;hi3te;sh;ene8l6o5r3um,ymnas11;a3eZ;niUss;lf,re;ut3yce0F;en; 3ti0W;edit0Hpo3;ol;aNicFlour,o4urnit3;ure;od,rgive3uri1wl;ness;arCcono0LducaBlectr9n7quip8thi0Pvery6x3;ist4per3;ti0B;en0J;body,o08th07;joy3tertain3;ment;ici2o3;ni0H;tiS;nings,th;emi02i6o4raugh3ynas2;ts;pe,wnstai3;rs;abet0ce,s3;honZrepu3;te;aDelciChAivi07l8o3urrency;al,ld w6mmenta5n3ral,ttIuscoB;fusiHt 3;ed;ry;ar;assi01oth0;es;aos,e3;eMwK;us;d,rO;a8i6lood,owlHread5u3;ntGtt1;er;!th;lliarJs3;on;g3ss;ga3;ge;cKdviJeroGirFmBn6ppeal court,r4spi3thleL;rin;ithmet3sen3;ic;i6y3;o4th3;ing;ne;se;en5n3;es2;ty;ds;craft;bi8d3nau7;yna3;mi6;ce;id,ous3;ti3;cs",
  Infinitive: "true¦0:9G;1:9T;2:AD;3:90;4:9Z;5:84;6:AH;7:A9;8:92;9:A0;A:AG;B:AI;C:9V;D:8R;E:8O;F:97;G:6H;H:7D;a94b8Hc7Jd68e4Zf4Mg4Gh4Ai3Qj3Nk3Kl3Bm34nou48o2Vp2Equ2Dr1Es0CtZuTvRwI;aOeNiLors5rI;eJiI;ng,te;ak,st3;d5e8TthI;draw,er;a2d,ep;i2ke,nIrn;d1t;aIie;liADniAry;nJpI;ho8Llift;cov1dJear8Hfound8DlIplug,rav82tie,ve94;eaAo3X;erIo;cut,go,staAFvalA3w2G;aSeQhNoMrIu73;aIe72;ffi3Smp3nsI;aBfo7CpI;i8oD;pp3ugh5;aJiJrIwaD;eat5i2;nk;aImA0;ch,se;ck3ilor,keImp1r8L;! paD;a0Ic0He0Fh0Bi0Al08mugg3n07o05p02qu01tUuLwI;aJeeIim;p,t5;ll7Wy;bNccMffLggeCmmKppJrI;mouFpa6Zvi2;o0re6Y;ari0on;er,i4;e7Numb;li9KmJsiIveD;de,st;er9it;aMe8MiKrI;ang3eIi2;ng27w;fIng;f5le;b,gg1rI;t3ve;a4AiA;a4UeJit,l7DoI;il,of;ak,nd;lIot7Kw;icEve;atGeak,i0O;aIi6;m,y;ft,ng,t;aKi6CoJriIun;nk,v6Q;ot,rt5;ke,rp5tt1;eIll,nd,que8Gv1w;!k,m;aven9ul8W;dd5tis1Iy;a0FeKiJoI;am,t,ut;d,p5;a0Ab08c06d05f01group,hea00iZjoi4lXmWnVpTq3MsOtMup,vI;amp,eJiIo3B;sEve;l,rI;e,t;i8rI;ie2ofE;eLiKpo8PtIurfa4;o24rI;aHiBuctu8;de,gn,st;mb3nt;el,hra0lIreseF;a4e71;d1ew,o07;aHe3Fo2;a7eFiIo6Jy;e2nq41ve;mbur0nf38;r0t;inKleBocus,rJuI;el,rbiA;aBeA;an4e;aBu4;ei2k8Bla43oIyc3;gni39nci3up,v1;oot,uI;ff;ct,d,liIp;se,ze;tt3viA;aAenGit,o7;aWerUinpoiFlumm1LoTrLuI;b47ke,niArIt;poDsuI;aFe;eMoI;cKd,fe4XhibEmo7noJpo0sp1tru6vI;e,i6o5L;un4;la3Nu8;aGclu6dJf1occupy,sup0JvI;a6BeF;etermi4TiB;aGllu7rtr5Ksse4Q;cei2fo4NiAmea7plex,sIva6;eve8iCua6;mp1rItrol,ve;a6It6E;bOccuNmEpMutLverIwe;l07sJtu6Yu0wI;helm;ee,h1F;gr5Cnu2Cpa4;era7i4Ipo0;py,r;ey,seItaH;r2ss;aMe0ViJoIultiply;leCu6Pw;micJnIspla4;ce,g3us;!k;iIke,na9;m,ntaH;aPeLiIo0u3N;ke,ng1quIv5;eIi6S;fy;aKnIss5;d,gI;th5;rn,ve;ng2Gu1N;eep,idnJnI;e4Cow;ap;oHuI;gg3xtaI;po0;gno8mVnIrk;cTdRfQgeChPitia7ju8q1CsNtKun6EvI;a6eIo11;nt,rt,st;erJimi6BoxiPrI;odu4u6;aBn,pr03ru6C;iCpi8tIu8;all,il,ruB;abEibE;eCo3Eu0;iIul9;ca7;i7lu6;b5Xmer0pI;aLer4Uin9ly,oJrI;e3Ais6Bo2;rt,se,veI;riA;le,rt;aLeKiIoiCuD;de,jaInd1;ck;ar,iT;mp1ng,pp5raIve;ng5Mss;ath1et,iMle27oLrI;aJeIow;et;b,pp3ze;!ve5A;gg3ve;aTer45i5RlSorMrJuI;lf4Cndrai0r48;eJiIolic;ght5;e0Qsh5;b3XeLfeEgJsI;a3Dee;eIi2;!t;clo0go,shIwa4Z;ad3F;att1ee,i36;lt1st5;a0OdEl0Mm0FnXquip,rWsVtGvTxI;aRcPeDhOiNpJtIu6;ing0Yol;eKi8lIo0un9;aHoI;it,re;ct,di7l;st,t;a3oDu3B;e30lI;a10u6;lt,mi28;alua7oI;ke,l2;chew,pou0tab19;a0u4U;aYcVdTfSgQhan4joy,lPqOrNsuMtKvI;e0YisI;a9i50;er,i4rI;aHenGuC;e,re;iGol0F;ui8;ar9iC;a9eIra2ulf;nd1;or4;ang1oIu8;r0w;irc3lo0ou0ErJuI;mb1;oaGy4D;b3ct;bKer9pI;hasiIow1;ze;aKody,rI;a4oiI;d1l;lm,rk;ap0eBuI;ci40de;rIt;ma0Rn;a0Re04iKo,rIwind3;aw,ed9oI;wn;agno0e,ff1g,mi2Kne,sLvI;eIul9;rIst;ge,t;aWbVcQlod9mant3pNru3TsMtI;iIoDu37;lJngI;uiA;!l;ol2ua6;eJlIo0ro2;a4ea0;n0r0;a2Xe36lKoIu0S;uIv1;ra9;aIo0;im;a3Kur0;b3rm;af5b01cVduBep5fUliTmQnOpMrLsiCtaGvI;eIol2;lop;ch;a20i2;aDiBloIoD;re,y;oIy;te,un4;eJoI;liA;an;mEv1;a4i0Ao06raud,y;ei2iMla8oKrI;ee,yI;!pt;de,mIup3;missi34po0;de,ma7ph1;aJrief,uI;g,nk;rk;mp5rk5uF;a0Dea0h0Ai09l08oKrIurta1G;a2ea7ipp3uI;mb3;ales4e04habEinci6ll03m00nIrro6;cXdUfQju8no7qu1sLtKvI;eIin4;ne,r9y;aHin2Bribu7;er2iLoli2Epi8tJuI;lt,me;itu7raH;in;d1st;eKiJoIroFu0;rm;de,gu8rm;ss;eJoI;ne;mn,n0;eIlu6ur;al,i2;buCe,men4pI;eIi3ly;l,te;eBi6u6;r4xiC;ean0iT;rcumveFte;eJirp,oI;o0p;riAw;ncIre5t1ulk;el;a02eSi6lQoPrKuI;iXrIy;st,y;aLeaKiJoad5;en;ng;stfeLtX;ke;il,l11mba0WrrMth1;eIow;ed;!coQfrie1LgPhMliLqueaKstJtrIwild1;ay;ow;th;e2tt3;a2eJoI;ld;ad;!in,ui3;me;bysEckfi8ff3tI;he;b15c0Rd0Iff0Ggree,l0Cm09n03ppZrXsQttOuMvJwaE;it;eDoI;id;rt;gIto0X;meF;aIeCraB;ch,in;pi8sJtoI;niA;aKeIi04u8;mb3rt,ss;le;il;re;g0Hi0ou0rI;an9i2;eaKly,oiFrI;ai0o2;nt;r,se;aMi0GnJtI;icipa7;eJoIul;un4y;al;ly0;aJu0;se;lga08ze;iKlI;e9oIu6;t,w;gn;ix,oI;rd;a03jNmiKoJsoI;rb;pt,rn;niIt;st1;er;ouJuC;st;rn;cLhie2knowled9quiItiva7;es4re;ce;ge;eQliOoKrJusI;e,tom;ue;mIst;moJpI;any,liA;da7;ma7;te;pt;andPduBet,i6oKsI;coKol2;ve;liArt,uI;nd;sh;de;ct;on",
  Person: "true¦0:1Q;a29b1Zc1Md1Ee18f15g13h0Ri0Qj0Nk0Jl0Gm09n06o05p00rPsItCusain bolt,v9w4xzibit,y1;anni,oko on2uji,v1;an,es;en,o;a3ednesday adams,i2o1;lfram,o0Q;ll ferrell,z khalifa;lt disn1Qr1;hol,r0G;a2i1oltai06;n dies0Zrginia wo17;lentino rossi,n goG;a4h3i2ripp,u1yra banks;lZpac shakur;ger woods,mba07;eresa may,or;kashi,t1ylor;um,ya1B;a5carlett johanss0h4i3lobodan milosevic,no2ocr1Lpider1uperm0Fwami; m0Em0E;op dogg,w whi1H;egfried,nbad;akespeaTerlock holm1Sia labeouf;ddam hussa16nt1;a cla11ig9;aAe6i5o3u1za;mi,n dmc,paul,sh limbau1;gh;bin hood,d stew16nald1thko;in0Mo;han0Yngo starr,valdo;ese witherspo0i1mbrandt;ll2nh1;old;ey,y;chmaninoff,ffi,iJshid,y roma1H;a4e3i2la16o1uff daddy;cahont0Ie;lar,p19;le,rZ;lm17ris hilt0;leg,prah winfr0Sra;a2e1iles cra1Bostradam0J; yo,l5tt06wmQ;pole0s;a5e4i2o1ubar03;by,lie5net,rriss0N;randa ju1tt romn0M;ly;rl0GssiaB;cklemo1rkov,s0ta hari,ya angelou;re;ady gaga,e1ibera0Pu;bron jam0Xch wale1e;sa;anye west,e3i1obe bryant;d cudi,efer suther1;la0P;ats,sha;a2effers0fk,k rowling,rr tolki1;en;ck the ripp0Mwaharlal nehru,y z;liTnez,ron m7;a7e5i3u1;lk hog5mphrey1sa01;! bog05;l1tl0H;de; m1dwig,nry 4;an;ile selassFlle ber4m3rrison1;! 1;ford;id,mo09;ry;ast0iannis,o1;odwPtye;ergus0lorence nightinga08r1;an1ederic chopN;s,z;ff5m2nya,ustaXzeki1;el;eril lagasse,i1;le zatop1nem;ek;ie;a6e4i2octor w1rake;ho;ck w1ego maradoC;olf;g1mi lovaOnzel washingt0;as;l1nHrth vadR;ai lNt0;a8h5lint0o1thulhu;n1olio;an,fuci1;us;on;aucKop2ristian baMy1;na;in;millo,ptain beefhe4r1;dinal wols2son1;! palmF;ey;art;a8e5hatt,i3oHro1;ck,n1;te;ll g1ng crosby;atB;ck,nazir bhut2rtil,yon1;ce;to;nksy,rack ob1;ama;l 6r3shton kutch2vril lavig8yn ra1;nd;er;chimed2istot1;le;es;capo2paci1;no;ne",
  Adjective: "true¦0:AI;1:BS;2:BI;3:BA;4:A8;5:84;6:AV;7:AN;8:AF;9:7H;A:BQ;B:AY;C:BC;D:BH;E:9Y;aA2b9Ec8Fd7We79f6Ng6Eh61i4Xj4Wk4Tl4Im41n3Po36p2Oquart7Pr2Ds1Dt14uSvOwFye29;aMeKhIiHoF;man5oFrth7G;dADzy;despreB1n w97s86;acked1UoleF;!sa6;ather1PeFll o70ste1D;!k5;nt1Ist6Ate4;aHeGiFola5T;bBUce versa,gi3Lle;ng67rsa5R;ca1gBSluAV;lt0PnLpHrGsFttermoBL;ef9Ku3;b96ge1; Hb32pGsFtiAH;ca6ide d4R;er,i85;f52to da2;a0Fbeco0Hc0Bd04e02f01gu1XheaBGiXkn4OmUnTopp06pRrNsJtHus0wF;aFiel3K;nt0rra0P;app0eXoF;ld,uS;eHi37o5ApGuF;perv06spec39;e1ok9O;en,ttl0;eFu5;cogn06gul2RlGqu84sF;erv0olv0;at0en33;aFrecede0E;id,rallel0;am0otic0;aFet;rri0tF;ch0;nFq26vers3;sur0terFv7U;eFrupt0;st0;air,inish0orese98;mploy0n7Ov97xpF;ect0lain0;eHisFocume01ue;clFput0;os0;cid0rF;!a8Scov9ha8Jlyi8nea8Gprivileg0sMwF;aFei9I;t9y;hGircumcFonvin2U;is0;aFeck0;lleng0rt0;b20ppea85ssuGttend0uthorF;iz0;mi8;i4Ara;aLeIhoHip 25oGrF;anspare1encha1i2;geth9leADp notch,rpB;rny,ugh6H;ena8DmpGrFs6U;r49tia4;eCo8P;leFst4M;nt0;a0Dc09e07h06i04ki03l01mug,nobbi4XoVpRqueami4XtKuFymb94;bHccinAi generis,pFr5;erFre7N;! dup9b,vi70;du0li7Lp6IsFurb7J;eq9Atanda9X;aKeJi16o2QrGubboFy4Q;rn;aightFin5GungS; fFfF;or7V;adfa9Pri6;lwa6Ftu82;arHeGir6NlendBot Fry;on;c3Qe1S;k5se; call0lImb9phistic16rHuFviV;ndFth1B;proof;dBry;dFub6; o2A;e60ipF;pe4shod;ll0n d7R;g2HnF;ceEg6ist9;am3Se9;co1Zem5lfFn6Are7; suf4Xi43;aGholFient3A;ar5;rlFt4A;et;cr0me,tisfac7F;aOeIheumatoBiGoF;bu8Ztt7Gy3;ghtFv3; 1Sf6X;cJdu8PlInown0pro69sGtF;ard0;is47oF;lu2na1;e1Suc45;alcit8Xe1ondi2;bBci3mpa1;aSePicayu7laOoNrGuF;bl7Tnjabi;eKiIoF;b7VfGmi49pFxi2M;er,ort81;a7uD;maFor,sti7va2;!ry;ciDexis0Ima2CpaB;in55puli8G;cBid;ac2Ynt 3IrFti2;ma40tFv7W;!i3Z;i2YrFss7R;anoBtF; 5XiF;al,s5V;bSffQkPld OnMrLth9utKverF;!aIbMdHhGni75seas,t,wF;ei74rou74;a63e7A;ue;ll;do1Ger,si6A;d3Qg2Aotu5Z; bFbFe on o7g3Uli7;oa80;fashion0school;!ay; gua7XbFha5Uli7;eat;eHligGsF;ce7er0So1C;at0;diFse;a1e1;aOeNiMoGuF;anc0de; moEnHrthFt6V;!eFwe7L;a7Krn;chaGdescri7Iprof30sF;top;la1;ght5;arby,cessa4ighbor5wlyw0xt;k0usiaFv3;ti8;aQeNiLoHuF;dIltiF;facet0p6;deHlGnFot,rbBst;ochro4Xth5;dy;rn,st;ddle ag0nF;dbloZi,or;ag9diocEga,naGrFtropolit4Q;e,ry;ci8;cIgenta,inHj0Fkeshift,mmGnFri4Oscu61ver18;da5Dy;ali4Lo4U;!stream;abEho;aOeLiIoFumberi8;ngFuti1R;stan3RtF;erm,i4H;ghtGteraF;l,ry,te;heart0wei5O;ft JgFss9th3;al,eFi0M;nda4;nguBps0te5;apGind5noF;wi8;ut;ad0itte4uniW;ce co0Hgno6Mll0Cm04nHpso 2UrF;a2releF;va1; ZaYcoWdReQfOgrNhibi4Ri05nMoLsHtFvalu5M;aAeF;nDrdepe2K;a7iGolFuboI;ub6ve1;de,gF;nifica1;rdi5N;a2er;own;eriIiLluenVrF;ar0eq5H;pt,rt;eHiGoFul1O;or;e,reA;fiFpe26termi5E;ni2;mpFnsideCrreA;le2;ccuCdeq5Ene,ppr4J;fFsitu,vitro;ro1;mJpF;arHeGl15oFrop9;li2r11;n2LrfeA;ti3;aGeFi18;d4BnD;tuE;egGiF;c0YteC;al,iF;tiF;ma2;ld;aOelNiLoFuma7;a4meInHrrGsFur5;ti6;if4E;e58o3U; ma3GsF;ick;ghfalut2HspF;an49;li00pf33;i4llow0ndGrdFtM; 05coEworki8;sy,y;aLener44iga3Blob3oKrGuF;il1Nng ho;aFea1Fizzl0;cGtF;ef2Vis;ef2U;ld3Aod;iFuc2D;nf2R;aVeSiQlOoJrF;aGeFil5ug3;q43tf2O;gFnt3S;i6ra1;lk13oHrF; keeps,eFge0Vm9tu41;g0Ei2Ds3R;liF;sh;ag4Mowe4uF;e1or45;e4nF;al,i2;d Gmini7rF;ti6ve1;up;bl0lDmIr Fst pac0ux;oGreacF;hi8;ff;ed,ili0R;aXfVlTmQnOqu3rMthere3veryday,xF;aApIquisi2traHuF;be48lF;ta1;!va2L;edRlF;icF;it;eAstF;whi6; Famor0ough,tiE;rou2sui2;erGiF;ne1;ge1;dFe2Aoq34;er5;ficF;ie1;g9sF;t,ygF;oi8;er;aWeMiHoGrFue;ea4owY;ci6mina1ne,r31ti8ubQ;dact2Jfficult,m,sGverF;ge1se;creGePjoi1paCtF;a1inA;et,te; Nadp0WceMfiLgeneCliJmuEpeIreliAsGvoF;id,ut;pFtitu2ul1L;eCoF;nde1;ca2ghF;tf13;a1ni2;as0;facto;i5ngero0I;ar0Ce09h07i06l05oOrIuF;rmudgeon5stoma4teF;sy;ly;aIeHu1EystalF; cleFli7;ar;epy;fFv17z0;ty;erUgTloSmPnGrpoCunterclVveFy;rt;cLdJgr21jIsHtrF;aFi2;dic0Yry;eq1Yta1;oi1ug3;escenFuN;di8;a1QeFiD;it0;atoDmensuCpF;ass1SulF;so4;ni3ss3;e1niza1;ci1J;ockwiD;rcumspeAvil;eFintzy;e4wy;leGrtaF;in;ba2;diac,ef00;a00ePiLliJoGrFuck nak0;and new,isk,on22;gGldface,naF; fi05fi05;us;nd,tF;he;gGpartisFzarE;an;tiF;me;autifOhiNlLnHsFyoN;iWtselF;li8;eGiFt;gn;aFfi03;th;at0oF;v0w;nd;ul;ckwards,rF;e,rT; priori,b13c0Zd0Tf0Ng0Ihe0Hl09mp6nt06pZrTsQttracti0MuLvIwF;aGkF;wa1B;ke,re;ant garGeraF;ge;de;diIsteEtF;heFoimmu7;nt07;re;to4;hGlFtu2;eep;en;bitIchiv3roHtF;ifiFsy;ci3;ga1;ra4;ry;pFt;aHetizi8rF;oprF;ia2;llFre1;ed,i8;ng;iquFsy;at0e;ed;cohKiJkaHl,oGriFterX;ght;ne,of;li7;ne;ke,ve;olF;ic;ad;ain07gressiIi6rF;eeF;ab6;le;ve;fGraB;id;ectGlF;ue1;ioF;na2; JaIeGvF;erD;pt,qF;ua2;ma1;hoc,infinitum;cuCquiGtu3u2;al;esce1;ra2;erSjeAlPoNrKsGuF;nda1;e1olu2trF;aAuD;se;te;eaGuF;pt;st;aFve;rd;aFe;ze;ct;ra1;nt",
  Pronoun: "true¦elle,h3i2me,she,th0us,we,you;e0ou;e,m,y;!l,t;e,im",
  Preposition: "true¦aPbMcLdKexcept,fIinGmid,notwithstandiWoDpXqua,sCt7u4v2w0;/o,hereSith0;! whHin,oW;ersus,i0;a,s a vis;n1p0;!on;like,til;h1ill,oward0;!s;an,ereby,r0;ough0u;!oM;ans,ince,o that,uch G;f1n0ut;!to;!f;! 0to;effect,part;or,r0;om;espite,own,u3;hez,irca;ar1e0oBy;sides,tween;ri7;bo8cross,ft7lo6m4propos,round,s1t0;!op;! 0;a whole,long 0;as;id0ong0;!st;ng;er;ut",
  SportsTeam: "true¦0:18;1:1E;2:1D;3:14;a1Db15c0Sd0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Am01new UoRpKqueens parkJreal salt lake,sBt6utah jazz,vancouver whitecaps,w4yW;ashington 4h10;natio1Mredski2wizar0W;ampa bay 7e6o4;ronto 4ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasD;buccanee0ra0K;a8eattle 6porting kansas0Wt4; louis 4oke0V;c1Drams;marine0s4;eah13ounH;cramento Rn 4;antonio spu0diego 4francisco gJjose earthquak1;char08paB; ran07;a9h6ittsburgh 5ortland t4;imbe0rail blaze0;pirat1steele0;il4oenix su2;adelphia 4li1;eagl1philNunE;dr1;akland 4klahoma city thunder,rlando magic;athle0Lrai4;de0;england 8orleans 7york 4;g5je3knYme3red bul0Xy4;anke1;ian3;pelica2sain3;patrio3revolut4;ion;anchEeAi4ontreal impact;ami 8lwaukee b7nnesota 4;t5vi4;kings;imberwolv1wi2;rewe0uc0J;dolphi2heat,marli2;mphis grizz4ts;li1;a6eic5os angeles 4;clippe0dodFlaB;esterV; galaxy,ke0;ansas city 4nF;chiefs,roya0D; pace0polis col3;astr05dynamo,rocke3texa2;olden state warrio0reen bay pac4;ke0;allas 8e4i04od6;nver 6troit 4;lio2pisto2ti4;ge0;broncYnugge3;cowbo5maver4;icZ;ys;arEelLhAincinnati 8leveland 6ol4;orado r4umbus crew sc;api7ocki1;brow2cavalie0guar4in4;dia2;bengaVre4;ds;arlotte horAicago 4;b5cubs,fire,wh4;iteB;ea0ulQ;diff4olina panthe0; city;altimore Alackburn rove0oston 6rooklyn 4uffalo bilN;ne3;ts;cel5red4; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 4;brav1falco2h4;awA;ns;es;on villa,r4;os;c6di4;amondbac4;ks;ardi4;na4;ls",
  Unit: "true¦a07b04cXdWexVfTgRhePinYjoule0BkMlJmDnan08oCp9quart0Bsq ft,t7volts,w6y2ze3°1µ0;g,s;c,f,n;dVear1o0;ttR; 0s 0;old;att,b;erNon0;!ne02;ascals,e1i0;cXnt00;rcent,tJ;hms,unceY;/s,e4i0m²,²,³;/h,cro2l0;e0liK;!²;grLsR;gCtJ;it1u0;menQx;erPreP;b5elvins,ilo1m0notO;/h,ph,²;!byGgrEmCs;ct0rtzL;aJogrC;allonJb0ig3rB;ps;a0emtEl oz,t4;hrenheit,radG;aby9;eci3m1;aratDe1m0oulombD;²,³;lsius,nti0;gr2lit1m0;et0;er8;am7;b1y0;te5;l,ps;c2tt0;os0;econd1;re0;!s",
  "Noun|Gerund": "true¦0:3O;1:3M;2:3N;3:3D;4:32;5:2V;6:3E;7:3K;8:36;9:3J;A:3B;a3Pb37c2Jd27e23f1Vg1Sh1Mi1Ij1Gk1Dl18m13n11o0Wp0Pques0Sr0EsTtNunderMvKwFyDzB;eroi0oB;ni0o3P;aw2eB;ar2l3;aEed4hispe5i5oCrB;ap8est3i1;n0ErB;ki0r31;i1r2s9tc9;isualizi0oB;lunt1Vti0;stan4ta6;aFeDhin6iCraBy8;c6di0i2vel1M;mi0p8;aBs1;c9si0;l6n2s1;aUcReQhOiMkatKl2Wmo6nowJpeItFuCwB;ea5im37;b35f0FrB;fi0vB;e2Mi2J;aAoryt1KrCuB;d2KfS;etc9ugg3;l3n4;bCi0;ebBi0;oar4;gnBnAt1;a3i0;ip8oB;p8rte2u1;a1r27t1;hCo5reBulp1;a2Qe2;edu3oo3;i3yi0;aKeEi4oCuB;li0n2;oBwi0;fi0;aFcEhear7laxi0nDpor1sB;pon4tructB;r2Iu5;de5;or4yc3;di0so2;p8ti0;aFeacek20laEoCrBublis9;a1Teten4in1oces7;iso2siB;tio2;n2yi0;ckaAin1rB;ki0t1O;fEpeDrganiCvB;erco24ula1;si0zi0;ni0ra1;fe5;avi0QeBur7;gotia1twor6;aDeCi2oB;de3nito5;a2dita1e1ssaA;int0XnBrke1;ifUufactu5;aEeaDiBodAyi0;cen7f1mi1stB;e2i0;r2si0;n4ug9;iCnB;ea4it1;c6l3;ogAuB;dAgg3stif12;ci0llust0VmDnBro2;nova1sp0NterBven1;ac1vie02;agi2plo4;aDea1iCoBun1;l4w3;ki0ri0;nd3rB;roWvB;es1;aCene0Lli4rBui4;ee1ie0N;rde2the5;aHeGiDlCorBros1un4;e0Pmat1;ir1oo4;gh1lCnBs9;anZdi0;i0li0;e3nX;r0Zscina1;a1du01nCxB;erci7plo5;chan1di0ginB;ee5;aLeHiGoub1rCum8wB;el3;aDeCiB;bb3n6vi0;a0Qs7;wi0;rTscoDvi0;ba1coZlBvelo8;eCiB;ve5;ga1;nGti0;aVelebUhSlPoDrBur3yc3;aBos7yi0;f1w3;aLdi0lJmFnBo6pi0ve5;dDsCvinB;ci0;trBul1;uc1;muniDpB;lBo7;ai2;ca1;lBo5;ec1;c9ti0;ap8eaCimToBubT;ni0t9;ni0ri0;aBee5;n1t1;ra1;m8rCs1te5;ri0;vi0;aPeNitMlLoGrDuB;dge1il4llBr8;yi0;an4eat9oadB;cas1;di0;a1mEokB;i0kB;ee8;pi0;bi0;es7oa1;c9i0;gin2lonAt1;gi0;bysit1c6ki0tt3;li0;ki0;bando2cGdverti7gi0pproac9rgDssuCtB;trac1;mi0;ui0;hi0;si0;coun1ti0;ti0;ni0;ng",
  PhrasalVerb: "true¦0:92;1:96;2:8H;3:8V;4:8A;5:83;6:85;7:98;8:90;9:8G;A:8X;B:8R;C:8U;D:8S;E:70;F:97;G:8Y;H:81;I:7H;J:79;a9Fb7Uc6Rd6Le6Jf5Ig50h4Biron0j47k40l3Em31n2Yo2Wp2Cquiet Hr1Xs0KtZuXvacuu6QwNyammerBzK;ero Dip LonK;e0k0;by,ov9up;aQeMhLiKor0Mrit19;mp0n3Fpe0r5s5;ackAeel Di0S;aLiKn33;gh 3Wrd0;n Dr K;do1in,oJ;it 79k5lk Lrm 69sh Kt83v60;aw3do1o7up;aw3in,oC;rgeBsK;e 2herE;a00eYhViRoQrMuKypP;ckErn K;do1in,oJup;aLiKot0y 30;ckl7Zp F;ck HdK;e 5Y;n7Wp 3Es5K;ck MdLe Kghten 6me0p o0Rre0;aw3ba4do1in,up;e Iy 2;by,oG;ink Lrow K;aw3ba4in,up;ba4ov9up;aKe 77ll62;m 2r 5M;ckBke Llk K;ov9shit,u47;aKba4do1in,leave,o4Dup;ba4ft9pa69w3;a0Vc0Te0Mh0Ii0Fl09m08n07o06p01quar5GtQuOwK;earMiK;ngLtch K;aw3ba4o8K; by;cKi6Bm 2ss0;k 64;aReQiPoNrKud35;aigh2Det75iK;ke 7Sng K;al6Yup;p Krm2F;by,in,oG;c3Ln3Lr 2tc4O;p F;c3Jmp0nd LrKveAy 2O;e Ht 2L;ba4do1up;ar3GeNiMlLrKurB;ead0ingBuc5;a49it 6H;c5ll o3Cn 2;ak Fe1Xll0;a3Bber 2rt0und like;ap 5Vow Duggl5;ash 6Noke0;eep NiKow 6;cLp K;o6Dup;e 68;in,oK;ff,v9;de19gn 4NnKt 6Gz5;gKkE; al6Ale0;aMoKu5W;ot Kut0w 7M;aw3ba4f48oC;c2WdeEk6EveA;e Pll1Nnd Orv5tK; Ktl5J;do1foLin,o7upK;!on;ot,r5Z;aw3ba4do1in,o33up;oCto;al66out0rK;ap65ew 6J;ilAv5;aXeUiSoOuK;b 5Yle0n Kstl5;aLba4do1inKo2Ith4Nu5P;!to;c2Xr8w3;ll Mot LpeAuK;g3Ind17;a2Wf3Po7;ar8in,o7up;ng 68p oKs5;ff,p18;aKelAinEnt0;c6Hd K;o4Dup;c27t0;aZeYiWlToQrOsyc35uK;ll Mn5Kt K;aKba4do1in,oJto47up;pa4Dw3;a3Jdo1in,o21to45up;attleBess KiNop 2;ah2Fon;iLp Kr4Zu1Gwer 6N;do1in,o6Nup;nt0;aLuK;gEmp 6;ce u20y 6D;ck Kg0le 4An 6p5B;oJup;el 5NncilE;c53ir 39n0ss MtLy K;ba4oG; Hc2R;aw3ba4in,oJ;pKw4Y;e4Xt D;aLerd0oK;dAt53;il Hrrow H;aTeQiPoLuK;ddl5ll I;c1FnkeyMp 6uthAve K;aKdo1in,o4Lup;l4Nw3; wi4K;ss0x 2;asur5e3SlLss K;a21up;t 6;ke Ln 6rKs2Ax0;k 6ryA;do,fun,oCsure,up;a02eViQoLuK;ck0st I;aNc4Fg MoKse0;k Kse4D;aft9ba4do1forw37in56o0Zu46;in,oJ;d 6;e NghtMnLsKve 00;ten F;e 2k 2; 2e46;ar8do1in;aMt LvelK; oC;do1go,in,o7up;nEve K;in,oK;pKut;en;c5p 2sh LtchBughAy K;do1o59;in4Po7;eMick Lnock K;do1oCup;oCup;eLy K;in,up;l Ip K;aw3ba4do1f04in,oJto,up;aMoLuK;ic5mpE;ke3St H;c43zz 2;a01eWiToPuK;nLrrKsh 6;y 2;keLt K;ar8do1;r H;lKneErse3K;d Ke 2;ba4dKfast,o0Cup;ear,o1;de Lt K;ba4on,up;aw3o7;aKlp0;d Ml Ir Kt 2;fKof;rom;f11in,o03uW;cPm 2nLsh0ve Kz2P;at,it,to;d Lg KkerP;do1in,o2Tup;do1in,oK;ut,v9;k 2;aZeTive Rloss IoMrLunK; f0S;ab hold,in43ow 2U; Kof 2I;aMb1Mit,oLr8th1IuK;nd9;ff,n,v9;bo7ft9hQw3;aw3bKdo1in,oJrise,up,w3;a4ir2H;ar 6ek0t K;aLb1Fdo1in,oKr8up;ff,n,ut,v9;cLhKl2Fr8t,w3;ead;ross;d aKng 2;bo7;a0Ee07iYlUoQrMuK;ck Ke2N;ar8up;eLighten KownBy 2;aw3oG;eKshe27; 2z5;g 2lMol Krk I;aKwi20;bo7r8;d 6low 2;aLeKip0;sh0;g 6ke0mKrKtten H;e F;gRlPnNrLsKzzle0;h F;e Km 2;aw3ba4up;d0isK;h 2;e Kl 1T;aw3fPin,o7;ht ba4ure0;ePnLsK;s 2;cMd K;fKoG;or;e D;d04l 2;cNll Krm0t1G;aLbKdo1in,o09sho0Eth08victim;a4ehi2O;pa0C;e K;do1oGup;at Kdge0nd 12y5;in,o7up;aOi1HoNrK;aLess 6op KuN;aw3b03in,oC;gBwB; Ile0ubl1B;m 2;a0Ah05l02oOrLut K;aw3ba4do1oCup;ackBeep LoKy0;ss Dwd0;by,do1in,o0Uup;me NoLuntK; o2A;k 6l K;do1oG;aRbQforOin,oNtKu0O;hLoKrue;geth9;rough;ff,ut,v9;th,wK;ard;a4y;paKr8w3;rt;eaLose K;in,oCup;n 6r F;aNeLiK;ll0pE;ck Der Kw F;on,up;t 2;lRncel0rOsMtch LveE; in;o1Nup;h Dt K;doubt,oG;ry LvK;e 08;aw3oJ;l Km H;aLba4do1oJup;ff,n,ut;r8w3;a0Ve0MiteAl0Fo04rQuK;bblNckl05il0Dlk 6ndl05rLsKtMy FzzA;t 00;n 0HsK;t D;e I;ov9;anWeaUiLush K;oGup;ghQng K;aNba4do1forMin,oLuK;nd9p;n,ut;th;bo7lKr8w3;ong;teK;n 2;k K;do1in,o7up;ch0;arTg 6iRn5oPrNssMttlLunce Kx D;aw3ba4;e 6; ar8;e H;do1;k Dt 2;e 2;l 6;do1up;d 2;aPeed0oKurt0;cMw K;aw3ba4do1o7up;ck;k K;in,oC;ck0nk0stA; oQaNef 2lt0nd K;do1ov9up;er;up;r Lt K;do1in,oCup;do1o7;ff,nK;to;ck Pil0nMrgLsK;h D;ainBe D;g DkB; on;in,o7;aw3do1in,oCup;ff,ut;ay;ct FdQir0sk MuctionA; oG;ff;ar8o7;ouK;nd; o7;d K;do1oKup;ff,n;wn;o7up;ut",
  ProperNoun: "true¦aIbDc8dalhousHe7f5gosford,h4iron maiden,kirby,landsdowne,m2nis,r1s0wembF;herwood,paldiB;iel,othwe1;cgi0ercedes,issy;ll;intBudsB;airview,lorence,ra0;mpt9nco;lmo,uro;a1h0;arlt6es5risti;rl0talina;et4i0;ng;arb3e0;et1nt0rke0;ley;on;ie;bid,jax",
  "Person|Place": "true¦a8d6h4jordan,k3orlando,s1vi0;ctor9rgin9;a0ydney;lvador,mara,ntia4;ent,obe;amil0ous0;ton;arw2ie0;go;lexandr1ust0;in;ia",
  LastName: "true¦0:BR;1:BF;2:B5;3:BH;4:AX;5:9Y;6:B6;7:BK;8:B0;9:AV;A:AL;B:8Q;C:8G;D:7K;E:BM;F:AH;aBDb9Zc8Wd88e81f7Kg6Wh64i60j5Lk4Vl4Dm39n2Wo2Op25quispe,r1Ls0Pt0Ev03wTxSyKzG;aIhGimmerm6A;aGou,u;ng,o;khar5ytsE;aKeun9BiHoGun;koya32shiBU;!lG;diGmaz;rim,z;maGng;da,g52mo83sGzaC;aChiBV;iao,u;aLeJiHoGright,u;jcA5lff,ng;lGmm0nkl0sniewsC;kiB1liams33s3;bGiss,lt0;b,er,st0;a6Vgn0lHtG;anabe,s3;k0sh,tG;e2Non;aLeKiHoGukD;gt,lk5roby5;dHllalGnogr3Kr1Css0val3S;ba,ob1W;al,ov4;lasHsel8W;lJn dIrgBEsHzG;qu7;ilyEqu7siljE;en b6Aijk,yk;enzueAIverde;aPeix1VhKi2j8ka43oJrIsui,uG;om5UrG;c2n0un1;an,emblA7ynisC;dorAMlst3Km4rrAth;atch0i8UoG;mHrG;are84laci79;ps3sG;en,on;hirDkah9Mnaka,te,varA;a06ch01eYhUiRmOoMtIuHvGzabo;en9Jobod3N;ar7bot4lliv2zuC;aIeHoG;i7Bj4AyanAB;ele,in2FpheBvens25;l8rm0;kol5lovy5re7Tsa,to,uG;ng,sa;iGy72;rn5tG;!h;l71mHnGrbu;at9cla9Egh;moBo7M;aIeGimizu;hu,vchG;en8Luk;la,r1G;gu9infe5YmGoh,pulveA7rra5P;jGyG;on5;evi6iltz,miHneid0roed0uGwarz;be3Elz;dHtG;!t,z;!t;ar4Th8ito,ka4OlJnGr4saCto,unde19v4;ch7dHtGz;a5Le,os;b53e16;as,ihDm4Po0Y;aVeSiPoJuHyG;a6oo,u;bio,iz,sG;so,u;bKc8Fdrigue67ge10j9YmJosevelt,sItHux,wG;e,li6;a9Ch;enb4Usi;a54e4L;erts15i93;bei4JcHes,vGzzo;as,e9;ci,hards12;ag2es,iHut0yG;es,nol5N;s,t0;dImHnGsmu97v6C;tan1;ir7os;ic,u;aUeOhMiJoHrGut8;asad,if6Zochazk27;lishc2GpGrti72u10we76;e3Aov51;cHe45nG;as,to;as70hl0;aGillips;k,m,n6I;a3Hde3Wete0Bna,rJtG;ersHrovGters54;!a,ic;!en,on;eGic,kiBss3;i9ra,tz,z;h86k,padopoulIrk0tHvG;ic,l4N;el,te39;os;bMconn2Ag2TlJnei6PrHsbor6XweBzG;dem7Rturk;ella4DtGwe6N;ega,iz;iGof7Hs8I;vGyn1R;ei9;aSri1;aPeNiJoGune50ym2;rHvGwak;ak4Qik5otn66;odahl,r4S;cholsZeHkolGls4Jx3;ic,ov84;ls1miG;!n1;ils3mG;co4Xec;gy,kaGray2sh,var38;jiGmu9shiG;ma;a07c04eZiWoMuHyeG;rs;lJnIrGssoli6S;atGp03r7C;i,ov4;oz,te58;d0l0;h2lOnNo0RrHsGza1A;er,s;aKeJiIoz5risHtG;e56on;!on;!n7K;au,i9no,t5J;!lA;r1Btgome59;i3El0;cracFhhail5kkeHlG;l0os64;ls1;hmeJiIj30lHn3Krci0ssiGyer2N;!er;n0Po;er,j0;dDti;cartHlG;aughl8e2;hy;dQe7Egnu68i0jer3TkPmNnMrItHyG;er,r;ei,ic,su21thews;iHkDquAroqu8tinG;ez,s;a5Xc,nG;!o;ci5Vn;a5UmG;ad5;ar5e6Kin1;rig77s1;aVeOiLoJuHyG;!nch;k4nGo;d,gu;mbarGpe3Fvr4we;di;!nGu,yana2B;coln,dG;b21holm,strom;bedEfeKhIitn0kaHn8rGw35;oy;!j;m11tG;in1on1;bvGvG;re;iGmmy,ng,rs2Qu,voie,ws3;ne,t1F;aZeYh2iWlUnez50oNrJuHvar2woG;k,n;cerGmar68znets5;a,o34;aHem0isGyeziu;h23t3O;m0sni4Fus3KvG;ch4O;bay57ch,rh0Usk16vaIwalGzl5;czGsC;yk;cIlG;!cGen4K;huk;!ev4ic,s;e8uiveG;rt;eff0kGl4mu9nnun1;ucF;ll0nnedy;hn,llKminsCne,pIrHstra3Qto,ur,yGzl5;a,s0;j0Rls22;l2oG;or;oe;aPenOha6im14oHuG;ng,r4;e32hInHrge32u6vG;anD;es,ss3;anHnsG;en,on,t3;nesGs1R;en,s1;kiBnings,s1;cJkob4EnGrv0E;kDsG;en,sG;en0Ion;ks3obs2A;brahimDglesi5Nke5Fl0Qno07oneIshikHto,vanoG;u,v54;awa;scu;aVeOiNjaltal8oIrist50uG;!aGb0ghAynh;m2ng;a6dz4fIjgaa3Hk,lHpUrGwe,x3X;ak1Gvat;mAt;er,fm3WmG;ann;ggiBtchcock;iJmingw4BnHrGss;nand7re9;deGriks1;rs3;kkiHnG;on1;la,n1;dz4g1lvoQmOns0ZqNrMsJuIwHyG;asFes;kiB;g1ng;anHhiG;mo14;i,ov0J;di6p0r10t;ue;alaG;in1;rs1;aVeorgUheorghe,iSjonRoLrJuGw3;errGnnar3Co,staf3Ctierr7zm2;a,eG;ro;ayli6ee2Lg4iffithGub0;!s;lIme0UnHodGrbachE;e,m2;calvAzale0S;dGubE;bGs0E;erg;aj,i;bs3l,mGordaO;en7;iev3U;gnMlJmaIndFo,rGsFuthi0;cGdn0za;ia;ge;eaHlG;agh0i,o;no;e,on;aVerQiLjeldsted,lKoIrHuG;chs,entAji41ll0;eem2iedm2;ntaGrt8urni0wl0;na;emi6orA;lipIsHtzgeraG;ld;ch0h0;ovG;!ic;hatDnanIrG;arGei9;a,i;deY;ov4;b0rre1D;dKinsJriksIsGvaB;cob3GpGtra3D;inoza,osiQ;en,s3;te8;er,is3warG;ds;aXePiNjurhuMoKrisco15uHvorakG;!oT;arte,boHmitru,nn,rGt3C;and,ic;is;g2he0Omingu7nErd1ItG;to;us;aGcki2Hmitr2Ossanayake,x3;s,z; JbnaIlHmirGrvisFvi,w2;!ov4;gado,ic;th;bo0groot,jo6lHsilGvriA;va;a cruz,e3uG;ca;hl,mcevsCnIt2WviG;dGes,s;ov,s3;ielsGku22;!en;ki;a0Be06hRiobQlarkPoIrGunningh1H;awfo0RivGuz;elli;h1lKntJoIrGs2Nx;byn,reG;a,ia;ke,p0;i,rer2K;em2liB;ns;!e;anu;aOeMiu,oIristGu6we;eGiaG;ns1;i,ng,p9uHwGy;!dH;dGng;huJ;!n,onGu6;!g;kJnIpm2ttHudhGv7;ry;erjee,o14;!d,g;ma,raboG;rty;bJl0Cng4rG;eghetHnG;a,y;ti;an,ota1C;cerAlder3mpbeLrIstGvadi0B;iGro;llo;doHl0Er,t0uGvalho;so;so,zo;ll;a0Fe01hYiXlUoNrKuIyG;rLtyG;qi;chan2rG;ke,ns;ank5iem,oGyant;oks,wG;ne;gdan5nIruya,su,uchaHyKziG;c,n5;rd;darGik;enG;ko;ov;aGond15;nco,zG;ev4;ancFshw16;a08oGuiy2;umGwmG;ik;ckRethov1gu,ktPnNrG;gJisInG;ascoGds1;ni;ha;er,mG;anG;!n;gtGit7nP;ss3;asF;hi;er,hG;am;b4ch,ez,hRiley,kk0ldw8nMrIshHtAu0;es;ir;bInHtlGua;ett;es,i0;ieYosa;dGik;a9yoG;padhyG;ay;ra;k,ng;ic;bb0Acos09d07g04kht05lZnPrLsl2tJyG;aHd8;in;la;chis3kiG;ns3;aImstro6sl2;an;ng;ujo,ya;dJgelHsaG;ri;ovG;!a;ersJov,reG;aGjEws;ss1;en;en,on,s3;on;eksejEiyEmeiIvG;ar7es;ez;da;ev;arwHuilG;ar;al;ams,l0;er;ta;as",
  Ordinal: "true¦eBf7nin5s3t0zeroE;enDhir1we0;lfCn7;d,t3;e0ixt8;cond,vent7;et0th;e6ie7;i2o0;r0urt3;tie4;ft1rst;ight0lev1;e0h,ie1;en0;th",
  Cardinal: "true¦bEeBf5mEnine7one,s4t0zero;en,h2rDw0;e0o;lve,n5;irt6ousands,ree;even2ix2;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illions",
  Multiple: "true¦b3hundred,m3qu2se1t0;housand,r2;pt1xt1;adr0int0;illion",
  City: "true¦0:74;1:61;2:6G;3:6J;4:5S;a68b53c4Id48e44f3Wg3Hh39i31j2Wk2Fl23m1Mn1Co19p0Wq0Ur0Os05tRuQvLwDxiBy9z5;a7h5i4Muri4O;a5e5ongsh0;ng3H;greb,nzib5G;ang2e5okoha3Sunfu;katerin3Hrev0;a5n0Q;m5Hn;arsBeAi6roclBu5;h0xi,zh5P;c7n5;d5nipeg,terth4;hoek,s1L;hi5Zkl3A;l63xford;aw;a8e6i5ladivost5Molgogr6L;en3lni6S;ni22r5;o3saill4N;lenc4Wncouv3Sr3ughn;lan bat1Crumqi,trecht;aFbilisi,eEheDiBo9r7u5;l21n63r5;in,ku;i5ondh62;es51poli;kyo,m2Zron1Pulo5;n,uS;an5jua3l2Tmisoa6Bra3;j4Tshui; hag62ssaloni2H;gucigal26hr0l av1U;briz,i6llinn,mpe56ng5rtu,shk2R;i3Esh0;an,chu1n0p2Eyu0;aEeDh8kopje,owe1Gt7u5;ra5zh4X;ba0Ht;aten is55ockholm,rasbou67uttga2V;an8e6i5;jiazhua1llo1m5Xy0;f50n5;ya1zh4H;gh3Kt4Q;att45o1Vv44;cramen16int ClBn5o paulo,ppo3Rrajevo; 7aa,t5;a 5o domin3E;a3fe,m1M;antonio,die3Cfrancisco,j5ped3Nsalvad0J;o5u0;se;em,t lake ci5Fz25;lou58peters24;a9e8i6o5;me,t59;ga,o5yadh;! de janei3F;cife,ims,nn3Jykjavik;b4Sip4lei2Inc2Pwalpindi;ingdao,u5;ez2i0Q;aFeEhDiCo9r7u6yong5;ya1;eb59ya1;a5etor3M;g52to;rt5zn0; 5la4Co;au prin0Melizabe24sa03;ls3Prae5Atts26;iladelph3Gnom pe1Aoenix;ki1tah tik3E;dua,lerYnaji,r4Ot5;na,r32;ak44des0Km1Mr6s5ttawa;a3Vlo;an,d06;a7ew5ing2Fovosibir1Jyc; 5cast36;del24orlea44taip14;g8iro4Wn5pl2Wshv33v0;ch6ji1t5;es,o1;a1o1;a6o5p4;ya;no,sa0W;aEeCi9o6u5;mb2Ani26sc3Y;gadishu,nt6s5;c13ul;evideo,pelli1Rre2Z;ami,l6n14s5;kolc,sissauga;an,waukee;cca,d5lbour2Mmph41ndo1Cssi3;an,ell2Xi3;cau,drAkass2Sl9n8r5shh4A;aca6ib5rakesh,se2L;or;i1Sy;a4EchFdal0Zi47;mo;id;aDeAi8o6u5vSy2;anMckn0Odhia3;n5s angel26;d2g bea1N;brev2Be3Lma5nz,sb2verpo28;!ss27; ma39i5;c5pzig;est16; p6g5ho2Wn0Cusan24;os;az,la33;aHharFiClaipeBo9rak0Du7y5;iv,o5;to;ala lump4n5;mi1sh0;hi0Hlka2Xpavog4si5wlo2;ce;da;ev,n5rkuk;gst2sha5;sa;k5toum;iv;bHdu3llakuric0Qmpa3Fn6ohsiu1ra5un1Iwaguc0Q;c0Pj;d5o,p4;ah1Ty;a7e6i5ohannesV;l1Vn0;dd36rusalem;ip4k5;ar2H;bad0mph1OnArkutUs7taXz5;mir,tapala5;pa;fah0l6tanb5;ul;am2Zi2H;che2d5;ianap2Mo20;aAe7o5yder2W; chi mi5ms,nolulu;nh;f6lsin5rakli2;ki;ei;ifa,lifax,mCn5rb1Dva3;g8nov01oi;aFdanEenDhCiPlasgBo9raz,u5;a5jr23;dal6ng5yaquil;zh1J;aja2Oupe;ld coa1Bthen5;bu2S;ow;ent;e0Uoa;sk;lw7n5za;dhi5gt1E;nag0U;ay;aisal29es,o8r6ukuya5;ma;ankfu5esno;rt;rt5sh0; wor6ale5;za;th;d5indhov0Pl paso;in5mont2;bur5;gh;aBe8ha0Xisp4o7resd0Lu5;b5esseldorf,nkirk,rb0shanbe;ai,l0I;ha,nggu0rtmu13;hradSl6nv5troit;er;hi;donghIe6k09l5masc1Zr es sala1KugavpiY;i0lU;gu,je2;aJebu,hAleve0Vo5raio02uriti1Q;lo7n6penhag0Ar5;do1Ok;akKst0V;gUm5;bo;aBen8i6ongqi1ristchur5;ch;ang m7ca5ttago1;go;g6n5;ai;du,zho1;ng5ttogr14;ch8sha,zh07;gliari,i9lga8mayenJn6pe town,r5tanO;acCdiff;ber1Ac5;un;ry;ro;aWeNhKirmingh0WoJr9u5;chareTdapeTenos air7r5s0tu0;g5sa;as;es;a9is6usse5;ls;ba6t5;ol;ne;sil8tisla7zzav5;il5;le;va;ia;goZst2;op6ubaneshw5;ar;al;iCl9ng8r5;g6l5n;in;en;aluru,hazi;fa6grade,o horizon5;te;st;ji1rut;ghd0BkFn9ot8r7s6yan n4;ur;el,r07;celo3i,ranquil09;ou;du1g6ja lu5;ka;alo6k5;ok;re;ng;ers5u;field;a05b02cc01ddis aba00gartaZhmedXizawl,lSmPnHqa00rEsBt7uck5;la5;nd;he7l5;an5;ta;ns;h5unci2;dod,gab5;at;li5;ngt2;on;a8c5kaOtwerp;hora6o3;na;ge;h7p5;ol5;is;eim;aravati,m0s5;terd5;am; 7buquerq6eppo,giers,ma5;ty;ue;basrah al qadim5mawsil al jadid5;ah;ab5;ad;la;ba;ra;idj0u dha5;bi;an;lbo6rh5;us;rg",
  Region: "true¦0:2O;1:2L;2:2U;3:2F;a2Sb2Fc21d1Wes1Vf1Tg1Oh1Ki1Fj1Bk16l13m0Sn09o07pYqVrSsJtEuBverAw6y4zacatec2W;akut0o0Fu4;cat1k09;a5est 4isconsin,yomi1O;bengal,virgin0;rwick3shington4;! dc;acruz,mont;dmurt0t4;ah,tar4; 2Pa12;a6e5laxca1Vripu21u4;scaEva;langa2nnessee,x2J;bas10m4smQtar29;aulip2Hil nadu;a9elang07i7o5taf16u4ylh1J;ff02rr09s1E;me1Gno1Uuth 4;cZdY;ber0c4kkim,naloa;hu1ily;n5rawak,skatchew1xo4;ny; luis potosi,ta catari2;a4hodeA;j4ngp0C;asth1shahi;ingh29u4;e4intana roo;bec,en6retaro;aAe6rince edward4unjab; i4;sl0G;i,n5r4;ak,nambu0F;a0Rnsylv4;an0;ha0Pra4;!na;axa0Zdisha,h4klaho21ntar4reg7ss0Dx0I;io;aLeEo6u4;evo le4nav0X;on;r4tt18va scot0;f9mandy,th4; 4ampton3;c6d5yo4;rk3;ako1O;aroli2;olk;bras1Nva0Dw4; 6foundland4;! and labrad4;or;brunswick,hamp3jers5mexiTyork4;! state;ey;galPyarit;aAeghala0Mi6o4;nta2r4;dov0elos;ch6dlanDn5ss4zor11;issippi,ouri;as geraPneso18;ig1oac1;dhy12harasht0Gine,lac07ni5r4ssachusetts;anhao,i el,ylG;p4toba;ur;anca3e4incoln3ouisI;e4iR;ds;a6e5h4omi;aka06ul2;dah,lant1ntucky,ra01;bardino,lmyk0ns0Qr4;achay,el0nata0X;alis6har4iangxi;kh4;and;co;daho,llino7n4owa;d5gush4;et0;ia2;is;a6ert5i4un1;dalFm0D;ford3;mp3rya2waii;ansu,eorg0lou7oa,u4;an4izhou,jarat;ajuato,gdo4;ng;cester3;lori4uji1;da;sex;ageUe7o5uran4;go;rs4;et;lawaMrby3;aFeaEh9o4rim08umbr0;ahui7l6nnectic5rsi4ventry;ca;ut;i03orado;la;e5hattisgarh,i4uvash0;apRhuahua;chn5rke4;ss0;ya;ra;lGm4;bridge3peche;a9ihar,r8u4;ck4ryat0;ingham3;shi4;re;emen,itish columb0;h0ja cal8lk7s4v7;hkorto4que;st1;an;ar0;iforn0;ia;dygHguascalientes,lBndhr9r5ss4;am;izo2kans5un4;achal 7;as;na;a 4;pradesh;a6ber5t4;ai;ta;ba5s4;ka;ma;ea",
  Place: "true¦0:4T;1:4V;2:44;3:4B;4:3I;a4Eb3Gc2Td2Ge26f25g1Vh1Ji1Fk1Cl14m0Vn0No0Jp08r04sTtNuLvJw7y5;a5o0Syz;kut1Bngtze;aDeChitBi9o5upatki,ycom2P;ki26o5;d5l1B;b3Ps5;i4to3Y;c0SllowbroCn5;c2Qgh2;by,chur1P;ed0ntw3Gs22;ke6r3St5;erf1f1; is0Gf3V;auxha3Mirgin is0Jost5;ok;laanbaatar,pto5xb3E;n,wn;a9eotihuac43h7ive49o6ru2Nsarskoe selo,u5;l2Dzigo47;nto,rquay,tt2J;am3e 5orn3E;bronx,hamptons;hiti,j mah0Iu1N;aEcotts bluff,eCfo,herbroQoApring9t7u5yd2F;dbu1Wn5;der03set3B;aff1ock2Nr5;atf1oud;hi37w24;ho,uth5; 1Iam1Zwo3E;a5i2O;f2Tt0;int lawrence riv3Pkhal2D;ayleigh,ed7i5oc1Z;chmo1Eo gran4ver5;be1Dfr09si4; s39cliffe,hi2Y;aCe9h8i5ompeii,utn2;c6ne5tcai2T; 2Pc0G;keri13t0;l,x;k,lh2mbr6n5r2J;n1Hzance;oke;cif38pahanaumokuak30r5;k5then0;si4w1K;ak7r6x5;f1l2X;ange county,d,f1inoco;mTw1G;e8i1Uo5;r5tt2N;th5wi0E; 0Sam19;uschwanste1Pw5; eng6a5h2market,po36;rk;la0P;a8co,e6i5uc;dt1Yll0Z;adow5ko0H;lands;chu picchu,gad2Ridsto1Ql8n7ple6r5;kh2; g1Cw11;hatt2Osf2B;ibu,t0ve1Z;a8e7gw,hr,in5owlOynd02;coln memori5dl2C;al;asi4w3;kefr7mbe1On5s,x;ca2Ig5si05;f1l27t0;ont;azan kreml14e6itchen2Gosrae,rasnoyar5ul;sk;ns0Hs1U;ax,cn,lf1n6ps5st;wiN;d5glew0Lverness;ian27ochina;aDeBi6kg,nd,ov5unti2H;d,enweep;gh6llc5;reL;bu03l5;and5;!s;r5yw0C;ef1tf1;libu24mp6r5stings;f1lem,row;stead,t0;aDodavari,r5uelph;avenAe5imsS;at 8en5; 6f1Fwi5;ch;acr3vall1H;brita0Flak3;hur5;st;ng3y villa0W;airhavHco,ra;aAgli9nf17ppi8u7ver6x5;et1Lf1;glad3t0;rope,st0;ng;nt0;rls1Ls5;t 5;e5si4;nd;aCe9fw,ig8o7ryd6u5xb;mfri3nstab00rh2tt0;en;nca18rcKv19wnt0B;by;n6r5vonpo1D;ry;!h2;nu8r5;l6t5;f1moor;ingt0;be;aLdg,eIgk,hClBo5royd0;l6m5rnwa0B;pt0;c7lingw6osse5;um;ood;he0S;earwat0St;a8el6i5uuk;chen itza,mney ro07natSricahua;m0Zt5;enh2;mor5rlottetPth2;ro;dar 5ntervilA;breaks,faZg5;rove;ld9m8r5versh2;lis6rizo pla5;in;le;bLpbellf1;weQ;aZcn,eNingl01kk,lackLolt0r5uckV;aGiAo5;ckt0ok5wns cany0;lyn,s5;i4to5;ne;de;dge6gh5;am,t0;n6t5;own;or5;th;ceb6m5;lNpt0;rid5;ge;bu5pool,wa8;rn;aconsfEdf1lBr9verly7x5;hi5;ll; hi5;lls;wi5;ck; air,l5;ingh2;am;ie5;ld;ltimore,rnsl6tters5;ea;ey;bLct0driadic,frica,ginJlGmFn9rc8s7tl6yleOzor3;es;!ant8;hcroft,ia; de triomphe,t6;adyr,ca8dov9tarct5;ic5; oce5;an;st5;er;ericas,s;be6dersh5hambra,list0;ot;rt0;cou5;rt;bot7i5;ngd0;on;sf1;ord",
  Country: "true¦0:38;1:2L;2:3B;a2Xb2Ec22d1Ye1Sf1Mg1Ch1Ai14j12k0Zl0Um0Gn05om2pZqat1KrXsKtCu7v5wal4yemTz3;a25imbabwe;es,lis and futu2Y;a3enezue32ietnam;nuatu,tican city;gTk6nited 4ruXs3zbeE; 2Ca,sr;arab emirat0Kkingdom,states3;! of am2Y;!raiV;a8haCimor les0Co7rinidad 5u3;nis0rk3valu;ey,me2Zs and caic1V;and t3t3;oba1L;go,kel10nga;iw2ji3nz2T;ki2V;aDcotl1eCi9lov8o6pa2Dri lanka,u5w3yr0;az3edAitzerl1;il1;d2riname;lomon1Xmal0uth 3;afr2KkMsud2;ak0en0;erra leoFn3;gapo1Yt maart3;en;negLrb0ychellZ;int 3moa,n marino,udi arab0;hele26luc0mart21;epublic of ir0Eom2Euss0w3;an27;a4eIhilippinUitcairn1Mo3uerto riN;l1rtugF;ki2Dl4nama,pua new0Vra3;gu7;au,esti3;ne;aBe9i7or3;folk1Ith4w3;ay; k3ern mariana1D;or0O;caragua,ger3ue;!ia;p3ther1Aw zeal1;al;mib0u3;ru;a7exi6icro0Bo3yanm06;ldova,n3roc5zambA;a4gol0t3;enegro,serrat;co;cAdagasc01l7r5urit4yot3;te;an0i16;shall0Xtin3;ique;a4div3i,ta;es;wi,ys0;ao,ed02;a6e5i3uxembourg;b3echtenste12thu1G;er0ya;ban0Isotho;os,tv0;azakh1Fe4iriba04o3uwait,yrgyz1F;rXsovo;eling0Knya;a3erG;ma16p2;c7nd6r4s3taly,vory coast;le of m2rael;a3el1;n,q;ia,oJ;el1;aiTon3ungary;dur0Ng kong;aBermany,ha0QibraltAre8u3;a6ern5inea3ya0P;! biss3;au;sey;deloupe,m,tema0Q;e3na0N;ce,nl1;ar;bUmb0;a7i6r3;ance,ench 3;guia0Epoly3;nes0;ji,nl1;lklandUroeU;ast tim7cu6gypt,l salv6ngl1quatorial4ritr5st3thiop0;on0; guin3;ea;ad3;or;enmark,jibou5ominica4r con3;go;!n C;ti;aBentral african Ah8o5roat0u4yprRzech3; 9ia;ba,racao;c4lo3morQngo brazzaville,okGsta r04te de ivoiL;mb0;osE;i3ristmasG;le,na;republic;m3naUpe verde,ymanA;bod0ero3;on;aGeDhut2o9r5u3;lgar0r3;kina faso,ma,undi;azil,itish 3unei;virgin3; is3;lands;liv0nai5snia and herzegoviHtswaHuvet3; isl1;and;re;l3n8rmuG;ar3gium,ize;us;h4ngladesh,rbad3;os;am4ra3;in;as;fghaGlDmBn6r4ustr3zerbaij2;al0ia;genti3men0uba;na;dorra,g5t3;arct7igua and barbu3;da;o3uil3;la;er3;ica;b3ger0;an0;ia;ni3;st2;an",
  FirstName: "true¦aTblair,cQdOfrancoZgabMhinaLilya,jHkClBm6ni4quinn,re3s0;h0umit,yd;ay,e0iloh;a,lby;g9ne;co,ko0;!s;a1el0ina,org6;!okuhF;ds,naia,r1tt0xiB;i,y;ion,lo;ashawn,eif,uca;a3e1ir0rM;an;lsFn0rry;dall,yat5;i,sD;a0essIie,ude;i1m0;ie,mG;me;ta;rie0y;le;arcy,ev0;an,on;as1h0;arl8eyenne;ey,sidy;drien,kira,l4nd1ubr0vi;ey;i,r0;a,e0;a,y;ex2f1o0;is;ie;ei,is",
  WeekDay: "true¦fri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
  Month: "true¦dec0february,july,nov0octo1sept0;em0;ber",
  Date: "true¦ago,on4som4t1week0yesterd5; end,ends;mr1o0;d2morrow;!w;ed0;ay",
  Duration: "true¦centurAd8h7m5q4se3w1y0;ear8r8;eek0k7;!end,s;ason,c5;tr,uarter;i0onth3;llisecond2nute2;our1r1;ay0ecade0;!s;ies,y",
  FemaleName: "true¦0:J7;1:JB;2:IJ;3:IK;4:J1;5:IO;6:JS;7:JO;8:HB;9:JK;A:H4;B:I2;C:IT;D:JH;E:IX;F:BA;G:I4;aGTbFLcDRdD0eBMfB4gADh9Ti9Gj8Dk7Cl5Wm48n3Lo3Hp33qu32r29s15t0Eu0Cv02wVxiTyOzH;aLeIineb,oHsof3;e3Sf3la,ra;h2iKlIna,ynH;ab,ep;da,ma;da,h2iHra;nab;aKeJi0FolB7uIvH;et8onDP;i0na;le0sen3;el,gm3Hn,rGLs8W;aoHme0nyi;m5XyAD;aMendDZhiDGiH;dele9lJnH;if48niHo0;e,f47;a,helmi0lHma;a,ow;ka0nB;aNeKiHusa5;ck84kIl8oleAviH;anFenJ4;ky,toriBK;da,lA8rHs0;a,nHoniH9;a,iFR;leHnesH9;nILrH;i1y;g9rHs6xHA;su5te;aYeUhRiNoLrIuHy2;i,la;acJ3iHu0J;c3na,sH;hFta;nHr0F;iFya;aJffaEOnHs6;a,gtiH;ng;!nFSra;aIeHomasi0;a,l9Oo8Ares1;l3ndolwethu;g9Fo88rIssH;!a,ie;eHi,ri7;sa,za;bOlMmKnIrHs6tia0wa0;a60yn;iHya;a,ka,s6;arFe2iHm77ra;!ka;a,iH;a,t6;at6it6;a0Ecarlett,e0AhWiSkye,neza0oQri,tNuIyH;bIGlvi1;ha,mayIJniAsIzH;an3Net8ie,y;anHi7;!a,e,nH;aCe;aIeH;fan4l5Dphan6E;cI5r5;b3fiAAm0LnHphi1;d2ia,ja,ya;er2lJmon1nIobh8QtH;a,i;dy;lETv3;aMeIirHo0risFDy5;a,lDM;ba,e0i5lJrH;iHr6Jyl;!d8Ifa;ia,lDZ;hd,iMki2nJrIu0w0yH;la,ma,na;i,le9on,ron,yn;aIda,ia,nHon;a,on;!ya;k6mH;!aa;lJrItaye82vH;da,inj;e0ife;en1i0ma;anA9bLd5Oh1SiBkKlJmInd2rHs6vannaC;aCi0;ant6i2;lDOma,ome;ee0in8Tu2;in1ri0;a05eZhXiUoHuthDM;bScRghQl8LnPsJwIxH;anB3ie,y;an,e0;aIeHie,lD;ann7ll1marDGtA;!lHnn1;iHyn;e,nH;a,dF;da,i,na;ayy8G;hel67io;bDRerAyn;a,cIkHmas,nFta,ya;ki,o;h8Xki;ea,iannGMoH;da,n1P;an0bJemFgi0iInHta,y0;a8Bee;han86na;a,eH;cHkaC;a,ca;bi0chIe,i0mo0nHquETy0;di,ia;aERelHiB;!e,le;een4ia0;aPeOhMiLoJrHute6A;iHudenCV;scil3LyamvaB;lHrt3;i0ly;a,paluk;ilome0oebe,ylH;is,lis;ggy,nelope,r5t2;ige,m0VnKo5rvaDMtIulH;a,et8in1;ricHt4T;a,e,ia;do2i07;ctav3dIfD3is6ksa0lHphD3umC5yunbileg;a,ga,iv3;eHvAF;l3t8;aWeUiMoIurHy5;!ay,ul;a,eJor,rIuH;f,r;aCeEma;ll1mi;aNcLhariBQkKlaJna,sHta,vi;anHha;ur;!y;a,iDZki;hoGk9YolH;a,e4P;!mh;hir,lHna,risDEsreE;!a,lBV;asuMdLh3i6Dl5nKomi7rgEVtH;aHhal4;lHs6;i1ya;cy,et8;e9iF0ya;nngu2X;a0Ackenz4e02iMoJrignayani,uriDJyH;a,rH;a,iOlNna,tG;bi0i2llBJnH;a,iH;ca,ka,qD9;a,cUdo4ZkaTlOmi,nMrItzi,yH;ar;aJiIlH;anET;am;!l,nB;dy,eHh,n4;nhGrva;aKdJe0iCUlH;iHy;cent,e;red;!gros;!e5;ae5hH;ae5el3Z;ag5DgNi,lKrH;edi7AiIjem,on,yH;em,l;em,sCG;an4iHliCF;nHsCJ;a,da;!an,han;b09cASd07e,g05ha,i04ja,l02n00rLsoum5YtKuIv84xBKyHz4;bell,ra,soBB;d7rH;a,eE;h8Gild1t4;a,cUgQiKjor4l7Un4s6tJwa,yH;!aHbe6Xja9lAE;m,nBL;a,ha,in1;!aJbCGeIja,lDna,sHt63;!a,ol,sa;!l1D;!h,mInH;!a,e,n1;!awit,i;arJeIie,oHr48ueri8;!t;!ry;et46i3B;el4Xi7Cy;dHon,ue5;akranAy;ak,en,iHlo3S;a,ka,nB;a,re,s4te;daHg4;!l3E;alDd4elHge,isDJon0;ei9in1yn;el,le;a0Ne0CiXoQuLyH;d3la,nH;!a,dIe2OnHsCT;!a,e2N;a,sCR;aD4cJel0Pis1lIna,pHz;e,iA;a,u,wa;iHy;a0Se,ja,l2NnB;is,l1UrItt1LuHvel4;el5is1;aKeIi7na,rH;aADi7;lHn1tA;ei;!in1;aTbb9HdSepa,lNnKsJvIzH;!a,be5Ret8z4;!ia;a,et8;!a,dH;a,sHy;ay,ey,i,y;a,iJja,lH;iHy;aA8e;!aH;!nF;ia,ya;!nH;!a,ne;aPda,e0iNjYla,nMoKsJtHx93y5;iHt4;c3t3;e2PlCO;la,nHra;a,ie,o2;a,or1;a,gh,laH;!ni;!h,nH;a,d2e,n5V;cOdon9DiNkes6mi9Gna,rMtJurIvHxmi,y5;ern1in3;a,e5Aie,yn;as6iIoH;nya,ya;fa,s6;a,isA9;a,la;ey,ie,y;a04eZhXiOlASoNrJyH;lHra;a,ee,ie;istHy6I;a,en,iIyH;!na;!e,n5F;nul,ri,urtnB8;aOerNlB7mJrHzzy;a,stH;en,in;!berlImernH;aq;eHi,y;e,y;a,stE;!na,ra;aHei2ongordzol;dij1w5;el7UiKjsi,lJnIrH;a,i,ri;d2na,za;ey,i,lBLs4y;ra,s6;biAcARdiat7MeBAiSlQmPnyakuma1DrNss6NtKviAyH;!e,lH;a,eH;e,i8T;!a6HeIhHi4TlDri0y;ar8Her8Hie,leErBAy;!lyn8Ori0;a,en,iHl5Xoli0yn;!ma,nFs95;a5il1;ei8Mi,lH;e,ie;a,tl6O;a0AeZiWoOuH;anMdLlHst88;es,iH;a8NeHs8X;!n9tH;!a,te;e5Mi3My;a,iA;!anNcelDdMelGhan7VleLni,sIva0yH;a,ce;eHie;fHlDph7Y;a,in1;en,n1;i7y;!a,e,n45;lHng;!i1DlH;!i1C;anNle0nKrJsH;i8JsH;!e,i8I;i,ri;!a,elGif2CnH;a,et8iHy;!e,f2A;a,eJiInH;a,eIiH;e,n1;!t8;cMda,mi,nIque4YsminFvie2y9zH;min7;a7eIiH;ce,e,n1s;!lHs82t0F;e,le;inIk6HlDquelH;in1yn;da,ta;da,lRmPnOo0rNsIvaHwo0zaro;!a0lu,na;aJiIlaHob89;!n9R;do2;belHdo2;!a,e,l3B;a7Ben1i0ma;di2es,gr72ji;a9elBogH;en1;a,e9iHo0se;a0na;aSeOiJoHus7Kyacin2C;da,ll4rten24snH;a,i9U;lImaH;ri;aIdHlaI;a,egard;ry;ath1BiJlInrietArmi9sH;sa,t1A;en2Uga,mi;di;bi2Fil8MlNnMrJsItHwa,yl8M;i5Tt4;n60ti;iHmo51ri53;etH;!te;aCnaC;a,ey,l4;a02eWiRlPoNrKunJwH;enHyne1R;!dolD;ay,el;acieIetHiselB;a,chE;!la;ld1CogooH;sh;adys,enHor3yn2K;a,da,na;aKgi,lIna,ov8EselHta;a,e,le;da,liH;an;!n0;mLnJorgIrH;ald5Si,m3Etrud7;et8i4X;a,eHna;s29vieve;ma;bIle,mHrnet,yG;al5Si5;iIrielH;a,l1;!ja;aTeQiPlorOoz3rH;anJeIiH;da,eB;da,ja;!cH;esIiHoi0P;n1s66;!ca;a,enc3;en,o0;lIn0rnH;anB;ec3ic3;jr,nArKtHy7;emIiHma,oumaA;ha,ma,n;eh;ah,iBrah,za0;cr4Rd0Re0Qi0Pk0Ol07mXn54rUsOtNuMvHwa;aKelIiH;!e,ta;inFyn;!a;!ngel4V;geni1ni47;h5Yien9ta;mLperanKtH;eIhHrel5;er;l31r7;za;a,eralB;iHma,ne4Lyn;cHka,n;a,ka;aPeNiKmH;aHe21ie,y;!li9nuH;elG;lHn1;e7iHy;a,e,ja;lHrald;da,y;!nue5;aWeUiNlMma,no2oKsJvH;a,iH;na,ra;a,ie;iHuiH;se;a,en,ie,y;a0c3da,e,f,nMsJzaH;!betHveA;e,h;aHe,ka;!beH;th;!a,or;anor,nH;!a,i;!in1na;ate1Rta;leEs6;vi;eIiHna,wi0;e,th;l,n;aYeMh3iLjeneKoH;lor5Vminiq4Ln3FrHtt4;a,eEis,la,othHthy;ea,y;ba;an09naCon9ya;anQbPde,eOiMlJmetr3nHsir5M;a,iH;ce,se;a,iIla,orHphi9;es,is;a,l6F;dHrdH;re;!d5Ena;!b2ForaCraC;a,d2nH;!a,e;hl3i0l0GmNnLphn1rIvi1WyH;le,na;a,by,cIia,lH;a,en1;ey,ie;a,et8iH;!ca,el1Aka,z;arHia;is;a0Re0Nh04i02lUoJristIynH;di,th3;al,i0;lPnMrIurH;tn1D;aJd2OiHn2Ori9;!nH;a,e,n1;!l4;cepci5Cn4sH;tanHuelo;ce,za;eHleE;en,t8;aJeoIotH;il54;!pat2;ir7rJudH;et8iH;a,ne;a,e,iH;ce,sZ;a2er2ndH;i,y;aReNloe,rH;isJyH;stH;al;sy,tH;a1Sen,iHy;an1e,n1;deJlseIrH;!i7yl;a,y;li9;nMrH;isKlImH;ai9;a,eHot8;n1t8;!sa;d2elGtH;al,elG;cIlH;es8i47;el3ilH;e,ia,y;itlYlXmilWndVrMsKtHy5;aIeIhHri0;er1IleErDy;ri0;a38sH;a37ie;a,iOlLmeJolIrH;ie,ol;!e,in1yn;lHn;!a,la;a,eIie,otHy;a,ta;ne,y;na,s1X;a0Ii0I;a,e,l1;isAl4;in,yn;a0Ke02iZlXoUrH;andi7eRiJoIyH;an0nn;nwDoke;an3HdgMgiLtH;n31tH;!aInH;ey,i,y;ny;d,t8;etH;!t7;an0e,nH;da,na;bbi7glarIlo07nH;iAn4;ka;ancHythe;a,he;an1Clja0nHsm3M;iAtH;ou;aWcVlinUniArPssOtJulaCvH;!erlH;ey,y;hJsy,tH;e,iHy7;e,na;!anH;ie,y;!ie;nItHyl;ha,ie;adIiH;ce;et8i9;ay,da;ca,ky;!triH;ce,z;rbJyaH;rmH;aa;a2o2ra;a2Ub2Od25g21i1Sj5l18m0Zn0Boi,r06sWtVuPvOwa,yIzH;ra,u0;aKes6gJlIn,seH;!l;in;un;!nH;a,na;a,i2K;drLguJrIsteH;ja;el3;stH;in1;a,ey,i,y;aahua,he0;hIi2Gja,miAs2DtrH;id;aMlIraqHt21;at;eIi7yH;!n;e,iHy;gh;!nH;ti;iJleIo6piA;ta;en,n1t8;aHelG;!n1J;a01dje5eZgViTjRnKohito,toHya;inet8nH;el5ia;te;!aKeIiHmJ;e,ka;!mHtt7;ar4;!belIliHmU;sa;!l1;a,eliH;ca;ka,sHta;a,sa;elHie;a,iH;a,ca,n1qH;ue;!tH;a,te;!bImHstasiMya;ar3;el;aLberKeliJiHy;e,l3naH;!ta;a,ja;!ly;hGiIl3nB;da;a,ra;le;aWba,ePiMlKthJyH;a,c3sH;a,on,sa;ea;iHys0N;e,s0M;a,cIn1sHza;a,e,ha,on,sa;e,ia,ja;c3is6jaKksaKna,sJxH;aHia;!nd2;ia,saH;nd2;ra;ia;i0nIyH;ah,na;a,is,naCoud;la;c6da,leEmNnLsH;haClH;inHyY;g,n;!h;a,o,slH;ey;ee;en;at6g4nIusH;ti0;es;ie;aWdiTelMrH;eJiH;anMenH;a,e,ne;an0;na;!aLeKiIyH;nn;a,n1;a,e;!ne;!iH;de;e,lDsH;on;yn;!lH;i9yn;ne;aKbIiHrL;!e,gaK;ey,i7y;!e;gaH;il;dKliyJradhIs6;ha;ya;ah;a,ya",
  Honorific: "true¦director1field marsh2lieutenant1rear0sergeant major,vice0; admir1; gener0;al",
  "Adj|Gerund": "true¦0:3F;1:3H;2:31;3:2X;4:35;5:33;6:3C;7:2Z;8:36;9:29;a33b2Tc2Bd1Te1If19g12h0Zi0Rl0Nm0Gnu0Fo0Ap04rYsKtEuBvAw1Ayiel3;ar6e08;nBpA;l1Rs0B;fol3n1Zsett2;aEeDhrBi4ouc7rAwis0;e0Bif2oub2us0yi1;ea1SiA;l2vi1;l2mp0rr1J;nt1Vxi1;aMcreec7enten2NhLkyrocke0lo0Vmi2oJpHtDuBweA;e0Ul2;pp2ArA;gi1pri5roun3;aBea8iAri2Hun9;mula0r4;gge4rA;t2vi1;ark2eAraw2;e3llb2F;aAot7;ki1ri1;i9oc29;dYtisf6;aEeBive0oAus7;a4l2;assu4defi9fres7ig9juve07mai9s0vAwar3;ea2italiAol1G;si1zi1;gi1ll6mb2vi1;a6eDier23lun1VrAun2C;eBoA;mi5vo1Z;ce3s5vai2;n3rpleA;xi1;ffCpWutBverAwi1;arc7lap04p0Pri3whel8;goi1l6st1J;en3sA;et0;m2Jrtu4;aEeDiCoBuAyst0L;mb2;t1Jvi1;s5tiga0;an1Rl0n3smeri26;dAtu4;de9;aCeaBiAo0U;fesa0Tvi1;di1ni1;c1Fg19s0;llumiGmFnArri0R;cDfurHsCtBviA;go23ti1;e1Oimi21oxica0rig0V;pi4ul0;orpo20r0K;po5;na0;eaBorr02umilA;ia0;li1rtwar8;lFrA;atiDipCoBuelA;i1li1;undbrea10wi1;pi1;f6ng;a4ea8;a3etc7it0lEoCrBulfA;il2;ee1FighXust1L;rAun3;ebo3thco8;aCoA;a0wA;e4i1;mi1tte4;lectrJmHnExA;aCci0hBis0pA;an3lo3;aOila1B;c0spe1A;ab2coura0CdBergi13ga0Clive9ric7s02tA;hral2i0J;ea4u4;barras5er09pA;owe4;if6;aQeIiBrA;if0;sAzz6;aEgDhearCsen0tA;rAur11;ac0es5;te9;us0;ppoin0r8;biliGcDfi9gra3ligh0mBpres5sAvasG;erE;an3ea9orA;ali0L;a6eiBli9rA;ea5;vi1;ta0;maPri1s7un0zz2;aPhMlo5oAripp2ut0;mGnArrespon3;cer9fDspi4tA;inBrA;as0ibu0ol2;ui1;lic0u5;ni1;fDmCpA;eAromi5;l2ti1;an3;or0;aAil2;llenAnAr8;gi1;l8ptAri1;iva0;aff2eGin3lFoDrBuA;d3st2;eathtaAui5;ki1;gg2i2o8ri1unA;ci1;in3;co8wiA;lAtc7;de4;bsorVcOgonMlJmHnno6ppea2rFsA;pi4su4toA;nBun3;di1;is7;hi1;res0;li1;aFu5;si1;ar8lu4;ri1;mi1;iAzi1;zi1;cAhi1;eleDomA;moBpan6;yi1;da0;ra0;ti1;bi1;ng",
  Comparable: "true¦0:3C;1:3Q;2:3F;a3Tb3Cc33d2Te2Mf2Ag1Wh1Li1Fj1Ek1Bl13m0Xn0So0Rp0Iqu0Gr07sHtCug0vAw4y3za0Q;el10ouN;ary,e6hi5i3ry;ck0Cde,l3n1ry,se;d,y;ny,te;a3i3R;k,ry;a3erda2ulgar;gue,in,st;a6en2Xhi5i4ouZr3;anqu2Cen1ue;dy,g36me0ny;ck,rs28;ll,me,rt,wd3I;aRcaPeOhMiLkin0BlImGoEpDt6u4w3;eet,ift;b3dd0Wperfi21rre28;sta26t21;a8e7iff,r4u3;pUr1;a4ict,o3;ng;ig2Vn0N;a1ep,rn;le,rk,te0;e1Si2Vright0;ci1Yft,l3on,re;emn,id;a3el0;ll,rt;e4i3y;g2Mm0Z;ek,nd2T;ck24l0mp1L;a3iRrill,y;dy,l01rp;ve0Jxy;n1Jr3;ce,y;d,fe,int0l1Hv0V;a8e6i5o3ude;mantic,o19sy,u3;gh;pe,t1P;a3d,mo0A;dy,l;gg4iFndom,p3re,w;id;ed;ai2i3;ck,et;hoAi1Fl9o8r5u3;ny,r3;e,p11;egna2ic4o3;fouSud;ey,k0;liXor;ain,easa2;ny;dd,i0ld,ranL;aive,e5i4o3u14;b0Sisy,rm0Ysy;bb0ce,mb0R;a3r1w;r,t;ad,e5ild,o4u3;nda12te;ist,o1;a4ek,l3;low;s0ty;a8e7i6o3ucky;f0Jn4o15u3ve0w10y0N;d,sy;e0g;ke0l,mp,tt0Eve0;e1Qwd;me,r3te;ge;e4i3;nd;en;ol0ui19;cy,ll,n3;secu6t3;e3ima4;llege2rmedia3;te;re;aAe7i6o5u3;ge,m3ng1C;bYid;me0t;gh,l0;a3fXsita2;dy,rWv3;en0y;nd13ppy,r3;d3sh;!y;aFenEhCiBlAoofy,r3;a8e6i5o3ue0Z;o3ss;vy;m,s0;at,e3y;dy,n;nd,y;ad,ib,ooD;a2d1;a3o3;st0;tDuiS;u1y;aCeebBi9l8o6r5u3;ll,n3r0N;!ny;aCesh,iend0;a3nd,rmD;my;at,ir7;erce,nan3;ci9;le;r,ul3;ty;a6erie,sse4v3xtre0B;il;nti3;al;r4s3;tern,y;ly,th0;appZe9i5ru4u3;mb;nk;r5vi4z3;zy;ne;e,ty;a3ep,n9;d3f,r;!ly;agey,h8l7o5r4u3;dd0r0te;isp,uel;ar3ld,mmon,st0ward0zy;se;evKou1;e3il0;ap,e3;sy;aHiFlCoAr5u3;ff,r0sy;ly;a6i3oad;g4llia2;nt;ht;sh,ve;ld,un3;cy;a4o3ue;nd,o1;ck,nd;g,tt3;er;d,ld,w1;dy;bsu6ng5we3;so3;me;ry;rd",
  Adverb: "true¦a08b05d00eYfSheQinPjustOkinda,likewiZmMnJoEpCquite,r9s5t2u0very,well;ltima01p0; to,wards5;h1iny bit,o0wiO;o,t6;en,us;eldom,o0uch;!me1rt0; of;how,times,w0C;a1e0;alS;ndomRth05;ar excellenEer0oint blank; Lhaps;f3n0utright;ce0ly;! 0;ag05moX; courGten;ewJo0; longWt 0;onHwithstand9;aybe,eanwhiNore0;!ovT;! aboX;deed,steY;lla,n0;ce;or3u0;ck1l9rther0;!moK;ing; 0evK;exampCgood,suH;n mas0vI;se;e0irect2; 2fini0;te0;ly;juAtrop;ackward,y 0;far,no0; means,w; GbroFd nauseam,gEl7ny5part,s4t 2w0;ay,hi0;le;be7l0mo7wor7;arge,ea6; soon,i4;mo0way;re;l 3mo2ongsi1ready,so,togeth0ways;er;de;st;b1t0;hat;ut;ain;ad;lot,posteriori",
  Conjunction: "true¦aXbTcReNhowMiEjust00noBo9p8supposing,t5wh0yet;e1il0o3;e,st;n1re0thN; if,by,vM;evL;h0il,o;erefOo0;!uU;lus,rovided th9;r0therwiM;! not; mattEr,w0;! 0;since,th4w7;f4n0; 0asmuch;as mIcaForder t0;h0o;at;! 0;only,t0w0;hen;!ev3;ith2ven0;! 0;if,tB;er;o0uz;s,z;e0ut,y the time;cau1f0;ore;se;lt3nd,s 0;far1if,m0soon1t2;uch0; as;hou0;gh",
  Currency: "true¦$,aud,bQcOdJeurIfHgbp,hkd,iGjpy,kElDp8r7s3usd,x2y1z0¢,£,¥,ден,лв,руб,฿,₡,₨,€,₭,﷼;lotyQł;en,uanP;af,of;h0t5;e0il5;k0q0;elK;oubleJp,upeeJ;e2ound st0;er0;lingG;n0soF;ceEnies;empi7i7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!os;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;e0ny;nt1;aht,itcoin0;!s",
  Determiner: "true¦aBboth,d9e6few,le5mu8neiDplenty,s4th2various,wh0;at0ich0;evC;a0e4is,ose;!t;everal,ome;!ast,s;a1l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er",
  "Adj|Present": "true¦a07b04cVdQeNfJhollIidRlEmCnarrIoBp9qua8r7s3t2uttFw0;aKet,ro0;ng,u08;endChin;e2hort,l1mooth,our,pa9tray,u0;re,speU;i2ow;cu6da02leSpaN;eplica01i02;ck;aHerfePr0;eseUime,omV;bscu1pen,wn;atu0e3odeH;re;a2e1ive,ow0;er;an;st,y;ow;a2i1oul,r0;ee,inge;rm;iIke,ncy,st;l1mpty,x0;emHpress;abo4ic7;amp,e2i1oub0ry,ull;le;ffu9re6;fu8libe0;raE;alm,l5o0;mpleCn3ol,rr1unterfe0;it;e0u7;ct;juga8sum7;ea1o0;se;n,r;ankru1lu0;nt;pt;li2pproxi0rticula1;ma0;te;ght",
  "Person|Adj": "true¦b3du2earnest,frank,mi2r0san1woo1;an0ich,u1;dy;sty;ella,rown",
  Modal: "true¦c5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ight,ust;an,o0;uld",
  Verb: "true¦born,cannot,gonna,has,keep tabs,msg",
  "Person|Verb": "true¦b8ch7dr6foster,gra5ja9lan4ma2ni9ollie,p1rob,s0wade;kip,pike,t5ue;at,eg,ier2;ck,r0;k,shal;ce;ce,nt;ew;ase,u1;iff,l1ob,u0;ck;aze,ossom",
  "Person|Date": "true¦a2j0sep;an0une;!uary;p0ugust,v0;ril"
}, br = 36, uu = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", gh = uu.split("").reduce(function(e, n, t) {
  return e[n] = t, e;
}, {}), MI = function(e) {
  if (uu[e] !== void 0)
    return uu[e];
  let n = 1, t = br, r = "";
  for (; e >= t; e -= t, n++, t *= br)
    ;
  for (; n--; ) {
    const a = e % br;
    r = String.fromCharCode((a < 10 ? 48 : 55) + a) + r, e = (e - a) / br;
  }
  return r;
}, _I = function(e) {
  if (gh[e] !== void 0)
    return gh[e];
  let n = 0, t = 1, r = br, a = 1;
  for (; t < e.length; n += r, t++, r *= br)
    ;
  for (let o = e.length - 1; o >= 0; o--, a *= br) {
    let i = e.charCodeAt(o) - 48;
    i > 10 && (i -= 7), n += i * a;
  }
  return n;
}, lu = {
  toAlphaCode: MI,
  fromAlphaCode: _I
}, BI = function(e) {
  const n = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
  for (let t = 0; t < e.nodes.length; t++) {
    const r = n.exec(e.nodes[t]);
    if (!r) {
      e.symCount = t;
      break;
    }
    e.syms[lu.fromAlphaCode(r[1])] = lu.fromAlphaCode(r[2]);
  }
  e.nodes = e.nodes.slice(e.symCount, e.nodes.length);
}, jI = function(e, n, t) {
  const r = lu.fromAlphaCode(n);
  return r < e.symCount ? e.syms[r] : t + r + 1 - e.symCount;
}, VI = function(e) {
  const n = [], t = (r, a) => {
    let o = e.nodes[r];
    o[0] === "!" && (n.push(a), o = o.slice(1));
    const i = o.split(/([A-Z0-9,]+)/g);
    for (let s = 0; s < i.length; s += 2) {
      const u = i[s], l = i[s + 1];
      if (!u)
        continue;
      const c = a + u;
      if (l === "," || l === void 0) {
        n.push(c);
        continue;
      }
      const h = jI(e, l, r);
      t(h, c);
    }
  };
  return t(0, ""), n;
}, LI = function(e) {
  const n = {
    nodes: e.split(";"),
    syms: [],
    symCount: 0
  };
  return e.match(":") && BI(n), VI(n);
}, zI = function(e) {
  if (!e)
    return {};
  const n = e.split("|").reduce((r, a) => {
    const o = a.split("¦");
    return r[o[0]] = o[1], r;
  }, {}), t = {};
  return Object.keys(n).forEach(function(r) {
    const a = LI(n[r]);
    r === "true" && (r = !0);
    for (let o = 0; o < a.length; o++) {
      const i = a[o];
      t.hasOwnProperty(i) === !0 ? Array.isArray(t[i]) === !1 ? t[i] = [t[i], r] : t[i].push(r) : t[i] = r;
    }
  }), t;
}, Ht = ["Possessive", "Pronoun"];
let GI = {
  // numbers
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  g8: "Organization",
  vh1: "Organization",
  "76ers": "SportsTeam",
  "49ers": "SportsTeam",
  q1: "Date",
  q2: "Date",
  q3: "Date",
  q4: "Date",
  km2: "Unit",
  m2: "Unit",
  dm2: "Unit",
  cm2: "Unit",
  mm2: "Unit",
  mile2: "Unit",
  in2: "Unit",
  yd2: "Unit",
  ft2: "Unit",
  m3: "Unit",
  dm3: "Unit",
  cm3: "Unit",
  in3: "Unit",
  ft3: "Unit",
  yd3: "Unit",
  // ampersands
  "at&t": "Organization",
  "black & decker": "Organization",
  "h & m": "Organization",
  "johnson & johnson": "Organization",
  "procter & gamble": "Organization",
  "ben & jerry's": "Organization",
  "&": "Conjunction",
  //pronouns
  i: ["Pronoun", "Singular"],
  he: ["Pronoun", "Singular"],
  she: ["Pronoun", "Singular"],
  it: ["Pronoun", "Singular"],
  they: ["Pronoun", "Plural"],
  we: ["Pronoun", "Plural"],
  was: ["Copula", "PastTense"],
  is: ["Copula", "PresentTense"],
  are: ["Copula", "PresentTense"],
  am: ["Copula", "PresentTense"],
  were: ["Copula", "PastTense"],
  // possessive pronouns
  her: Ht,
  his: Ht,
  hers: Ht,
  their: Ht,
  theirs: Ht,
  themselves: Ht,
  your: Ht,
  our: Ht,
  ours: Ht,
  my: Ht,
  its: Ht,
  // misc
  vs: ["Conjunction", "Abbreviation"],
  if: ["Condition", "Preposition"],
  closer: "Comparative",
  closest: "Superlative",
  much: "Adverb",
  may: "Modal",
  // irregular conjugations with two forms
  babysat: "PastTense",
  blew: "PastTense",
  drank: "PastTense",
  drove: "PastTense",
  forgave: "PastTense",
  skiied: "PastTense",
  spilt: "PastTense",
  stung: "PastTense",
  swam: "PastTense",
  swung: "PastTense",
  guaranteed: "PastTense",
  shrunk: "PastTense",
  // support 'near', 'nears', 'nearing'
  nears: "PresentTense",
  nearing: "Gerund",
  neared: "PastTense",
  no: ["Negative", "Expression"]
  // '-': 'Preposition', //june - july
  // there: 'There'
};
const HI = {
  "20th century fox": "Organization",
  "7 eleven": "Organization",
  "motel 6": "Organization",
  "excuse me": "Expression",
  "financial times": "Organization",
  "guns n roses": "Organization",
  "la z boy": "Organization",
  "labour party": "Organization",
  "new kids on the block": "Organization",
  "new york times": "Organization",
  "the guess who": "Organization",
  "thin lizzy": "Organization",
  "prime minister": "Actor",
  "free market": "Singular",
  "lay up": "Singular",
  "living room": "Singular",
  "living rooms": "Plural",
  "spin off": "Singular",
  "appeal court": "Uncountable",
  "cold war": "Uncountable",
  "gene pool": "Uncountable",
  "machine learning": "Uncountable",
  "nail polish": "Uncountable",
  "time off": "Uncountable",
  "take part": "Infinitive",
  "bill gates": "Person",
  "doctor who": "Person",
  "dr who": "Person",
  "he man": "Person",
  "iron man": "Person",
  "kid cudi": "Person",
  "run dmc": "Person",
  "rush limbaugh": "Person",
  "snow white": "Person",
  "tiger woods": "Person",
  "brand new": "Adjective",
  "en route": "Adjective",
  "left wing": "Adjective",
  "off guard": "Adjective",
  "on board": "Adjective",
  "part time": "Adjective",
  "right wing": "Adjective",
  "so called": "Adjective",
  "spot on": "Adjective",
  "straight forward": "Adjective",
  "super duper": "Adjective",
  "tip top": "Adjective",
  "top notch": "Adjective",
  "up to date": "Adjective",
  "win win": "Adjective",
  "brooklyn nets": "SportsTeam",
  "chicago bears": "SportsTeam",
  "houston astros": "SportsTeam",
  "houston dynamo": "SportsTeam",
  "houston rockets": "SportsTeam",
  "houston texans": "SportsTeam",
  "minnesota twins": "SportsTeam",
  "orlando magic": "SportsTeam",
  "san antonio spurs": "SportsTeam",
  "san diego chargers": "SportsTeam",
  "san diego padres": "SportsTeam",
  "iron maiden": "ProperNoun",
  "isle of man": "Country",
  "united states": "Country",
  "united states of america": "Country",
  "prince edward island": "Region",
  "cedar breaks": "Place",
  "cedar falls": "Place",
  "point blank": "Adverb",
  "tiny bit": "Adverb",
  "by the time": "Conjunction",
  "no matter": "Conjunction",
  "civil wars": "Plural",
  "credit cards": "Plural",
  "default rates": "Plural",
  "free markets": "Plural",
  "head starts": "Plural",
  "home runs": "Plural",
  "lay ups": "Plural",
  "phone calls": "Plural",
  "press releases": "Plural",
  "record labels": "Plural",
  "soft serves": "Plural",
  "student loans": "Plural",
  "tax returns": "Plural",
  "tv shows": "Plural",
  "video games": "Plural",
  "took part": "PastTense",
  "takes part": "PresentTense",
  "taking part": "Gerund",
  "taken part": "Participle",
  "light bulb": "Noun",
  "rush hour": "Noun",
  "fluid ounce": "Unit",
  "the rolling stones": "Organization"
}, WI = [
  ":(",
  ":)",
  ":P",
  ":p",
  ":O",
  ";(",
  ";)",
  ";P",
  ";p",
  ";O",
  ":3",
  ":|",
  ":/",
  ":\\",
  ":$",
  ":*",
  ":@",
  ":-(",
  ":-)",
  ":-P",
  ":-p",
  ":-O",
  ":-3",
  ":-|",
  ":-/",
  ":-\\",
  ":-$",
  ":-*",
  ":-@",
  ":^(",
  ":^)",
  ":^P",
  ":^p",
  ":^O",
  ":^3",
  ":^|",
  ":^/",
  ":^\\",
  ":^$",
  ":^*",
  ":^@",
  "):",
  "(:",
  "$:",
  "*:",
  ")-:",
  "(-:",
  "$-:",
  "*-:",
  ")^:",
  "(^:",
  "$^:",
  "*^:",
  "<3",
  "</3",
  "<\\3",
  "=("
], mo = {
  a: [
    [/(antenn|formul|nebul|vertebr|vit)a$/i, "$1ae"],
    [/ia$/i, "ia"]
  ],
  e: [
    [/(kn|l|w)ife$/i, "$1ives"],
    [/(hive)$/i, "$1s"],
    [/([m|l])ouse$/i, "$1ice"],
    [/([m|l])ice$/i, "$1ice"]
  ],
  f: [
    [/^(dwar|handkerchie|hoo|scar|whar)f$/i, "$1ves"],
    [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i, "$1ves"]
  ],
  i: [[/(octop|vir)i$/i, "$1i"]],
  m: [[/([ti])um$/i, "$1a"]],
  n: [[/^(oxen)$/i, "$1"]],
  o: [[/(al|ad|at|er|et|ed)o$/i, "$1oes"]],
  s: [
    [/(ax|test)is$/i, "$1es"],
    [/(alias|status)$/i, "$1es"],
    [/sis$/i, "ses"],
    [/(bu)s$/i, "$1ses"],
    [/(sis)$/i, "ses"],
    [/^(?!talis|.*hu)(.*)man$/i, "$1men"],
    [/(octop|vir|radi|nucle|fung|cact|stimul)us$/i, "$1i"]
  ],
  x: [
    [/(matr|vert|ind|cort)(ix|ex)$/i, "$1ices"],
    [/^(ox)$/i, "$1en"]
  ],
  y: [[/([^aeiouy]|qu)y$/i, "$1ies"]],
  z: [[/(quiz)$/i, "$1zes"]]
}, $I = /([xsz]|ch|sh)$/, UI = function(e) {
  let n = e[e.length - 1];
  if (mo.hasOwnProperty(n) === !0)
    for (let t = 0; t < mo[n].length; t += 1) {
      let r = mo[n][t][0];
      if (r.test(e) === !0)
        return e.replace(r, mo[n][t][1]);
    }
  return null;
}, Ei = function(e = "", n) {
  let { irregularPlurals: t, uncountable: r } = n.two;
  if (r.hasOwnProperty(e))
    return e;
  if (t.hasOwnProperty(e))
    return t[e];
  let a = UI(e);
  return a !== null ? a : $I.test(e) ? e + "es" : e + "s";
}, KI = /\|/;
let va = GI, cu = {};
const qI = { two: { irregularPlurals: Zm, uncountable: {} } };
Object.keys(mh).forEach((e) => {
  let n = zI(mh[e]);
  if (!KI.test(e)) {
    Object.keys(n).forEach((t) => {
      va[t] = e;
    });
    return;
  }
  Object.keys(n).forEach((t) => {
    if (cu[t] = e, e === "Noun|Verb") {
      let r = Ei(t, qI);
      cu[r] = "Plural|Verb";
    }
  });
});
WI.forEach((e) => va[e] = "Emoticon");
delete va[""];
delete va[null];
delete va[" "];
const V = "Singular", Fe = {
  beforeTags: {
    Determiner: V,
    //the date
    Possessive: V,
    //his date
    Acronym: V,
    //u.s. state
    // ProperNoun:n,
    Noun: V,
    //nasa funding
    Adjective: V,
    //whole bottles
    // Verb:true, //save storm victims
    PresentTense: V,
    //loves hiking
    Gerund: V,
    //uplifting victims
    PastTense: V,
    //saved storm victims
    Infinitive: V,
    //profess love
    Date: V,
    //9pm show
    Ordinal: V,
    //first date
    Demonym: V
    //dutch map
  },
  afterTags: {
    Value: V,
    //date nine  -?
    Modal: V,
    //date would
    Copula: V,
    //fear is
    PresentTense: V,
    //babysitting sucks
    PastTense: V,
    //babysitting sucked
    // Noun:n, //talking therapy, planning process
    Demonym: V,
    //american touch
    Actor: V
    //dance therapist
  },
  // ownTags: { ProperNoun: n },
  beforeWords: {
    the: V,
    //the brands
    with: V,
    //with cakes
    without: V,
    //
    // was:n, //was time  -- was working
    // is:n, //
    of: V,
    //of power
    for: V,
    //for rats
    any: V,
    //any rats
    all: V,
    //all tips
    on: V,
    //on time
    // thing-ish verbs
    cut: V,
    //cut spending
    cuts: V,
    //cut spending
    increase: V,
    // increase funding
    decrease: V,
    //
    raise: V,
    //
    drop: V,
    //
    // give: n,//give parents
    save: V,
    //
    saved: V,
    //
    saves: V,
    //
    make: V,
    //
    makes: V,
    //
    made: V,
    //
    minus: V,
    //minus laughing
    plus: V,
    //
    than: V,
    //more than age
    another: V,
    //
    versus: V,
    //
    neither: V,
    //
    about: V,
    //about claims
    // strong adjectives
    favorite: V,
    //
    best: V,
    //
    daily: V,
    //
    weekly: V,
    //
    linear: V,
    //
    binary: V,
    //
    mobile: V,
    //
    lexical: V,
    //
    technical: V,
    //
    computer: V,
    //
    scientific: V,
    //
    security: V,
    //
    government: V,
    //
    popular: V,
    //
    formal: V,
    no: V,
    //no worries
    more: V,
    //more details
    one: V,
    //one flood
    let: V,
    //let fear
    her: V,
    //her boots
    his: V,
    //
    their: V,
    //
    our: V,
    //
    us: V,
    //served us drinks
    sheer: V,
    monthly: V,
    yearly: V,
    current: V,
    previous: V,
    upcoming: V,
    last: V,
    next: V,
    main: V,
    initial: V,
    final: V,
    beginning: V,
    end: V,
    top: V,
    bottom: V,
    future: V,
    past: V,
    major: V,
    minor: V,
    side: V,
    central: V,
    peripheral: V,
    public: V,
    private: V
  },
  afterWords: {
    of: V,
    //date of birth (preposition)
    system: V,
    aid: V,
    method: V,
    utility: V,
    tool: V,
    reform: V,
    therapy: V,
    philosophy: V,
    room: V,
    authority: V,
    says: V,
    said: V,
    wants: V,
    wanted: V,
    is: V,
    did: V,
    do: V,
    can: V,
    //parents can
    wise: V
    //service-wise
    // they: n,//snakes they
  }
}, U = "Infinitive", pt = {
  beforeTags: {
    Modal: U,
    //would date
    Adverb: U,
    //quickly date
    Negative: U,
    //not date
    Plural: U
    //characters drink
    // ProperNoun: vb,//google thought
  },
  afterTags: {
    Determiner: U,
    //flash the
    Adverb: U,
    //date quickly
    Possessive: U,
    //date his
    Reflexive: U,
    //resolve yourself
    // Noun:true, //date spencer
    Preposition: U,
    //date around, dump onto, grumble about
    // Conjunction: v, // dip to, dip through
    Cardinal: U,
    //cut 3 squares
    Comparative: U,
    //feel greater
    Superlative: U
    //feel greatest
  },
  beforeWords: {
    i: U,
    //i date
    we: U,
    //we date
    you: U,
    //you date
    they: U,
    //they date
    to: U,
    //to date
    please: U,
    //please check
    will: U,
    //will check
    have: U,
    had: U,
    would: U,
    could: U,
    should: U,
    do: U,
    did: U,
    does: U,
    can: U,
    must: U,
    us: U,
    me: U,
    let: U,
    even: U,
    when: U,
    help: U,
    //help combat
    // them: v,
    he: U,
    she: U,
    it: U,
    being: U,
    // prefixes
    bi: U,
    co: U,
    contra: U,
    de: U,
    inter: U,
    intra: U,
    mis: U,
    pre: U,
    out: U,
    counter: U,
    nobody: U,
    somebody: U,
    anybody: U,
    everybody: U
    // un: v,
    // over: v,
    // under: v,
  },
  afterWords: {
    the: U,
    //echo the
    me: U,
    //date me
    you: U,
    //date you
    him: U,
    //loves him
    us: U,
    //cost us
    her: U,
    //
    his: U,
    //
    them: U,
    //
    they: U,
    //
    it: U,
    //hope it
    himself: U,
    herself: U,
    itself: U,
    myself: U,
    ourselves: U,
    themselves: U,
    something: U,
    anything: U,
    a: U,
    //covers a
    an: U,
    //covers an
    // from: v, //ranges from
    up: U,
    //serves up
    down: U,
    //serves up
    by: U,
    // in: v, //bob in
    out: U,
    // on: v,
    off: U,
    under: U,
    what: U,
    //look what
    // when: v,//starts when
    // for:true, //settled for
    all: U,
    //shiver all night
    // conjunctions
    to: U,
    //dip to
    because: U,
    //
    although: U,
    //
    // after: v,
    // before: v,//
    how: U,
    //
    otherwise: U,
    //
    together: U,
    //fit together
    though: U,
    //
    into: U,
    //
    yet: U,
    //
    more: U,
    //kill more
    here: U,
    // look here
    there: U,
    //
    away: U
    //float away
  }
}, JI = {
  beforeTags: Object.assign({}, pt.beforeTags, Fe.beforeTags, {}),
  afterTags: Object.assign({}, pt.afterTags, Fe.afterTags, {}),
  beforeWords: Object.assign({}, pt.beforeWords, Fe.beforeWords, {}),
  afterWords: Object.assign({}, pt.afterWords, Fe.afterWords, {})
}, q = "Adjective", qe = {
  beforeTags: {
    Determiner: q,
    //the detailed
    // Copula: jj, //is detailed
    Possessive: q,
    //spencer's detailed
    Hyphenated: q
    //rapidly-changing
  },
  afterTags: {
    // Noun: jj, //detailed plan, overwhelming evidence
    Adjective: q
    //intoxicated little
  },
  beforeWords: {
    seem: q,
    //seem prepared
    seemed: q,
    seems: q,
    feel: q,
    //feel prepared
    feels: q,
    felt: q,
    stay: q,
    appear: q,
    appears: q,
    appeared: q,
    also: q,
    over: q,
    //over cooked
    under: q,
    too: q,
    //too insulting
    it: q,
    //find it insulting
    but: q,
    //nothing but frustrating
    still: q,
    //still scared
    // adverbs that are adjective-ish
    really: q,
    //really damaged
    quite: q,
    well: q,
    very: q,
    truly: q,
    how: q,
    //how slow
    deeply: q,
    hella: q,
    // always: jj,
    // never: jj,
    profoundly: q,
    extremely: q,
    so: q,
    badly: q,
    mostly: q,
    totally: q,
    awfully: q,
    rather: q,
    nothing: q,
    //nothing secret,
    something: q,
    //something wrong
    anything: q,
    not: q,
    //not swell
    me: q,
    //called me swell
    is: q,
    face: q,
    //faces shocking revelations
    faces: q,
    faced: q,
    look: q,
    looks: q,
    looked: q,
    reveal: q,
    reveals: q,
    revealed: q,
    sound: q,
    sounded: q,
    sounds: q,
    remains: q,
    remained: q,
    prove: q,
    //would prove shocking
    proves: q,
    proved: q,
    becomes: q,
    stays: q,
    tastes: q,
    taste: q,
    smells: q,
    smell: q,
    gets: q,
    //gets shocking snowfall
    grows: q,
    as: q,
    rings: q,
    radiates: q,
    conveys: q,
    convey: q,
    conveyed: q,
    of: q
    // 'smacks of': jj,
    // 'reeks of': jj,
  },
  afterWords: {
    too: q,
    //insulting too
    also: q,
    //insulting too
    or: q,
    //insulting or
    enough: q,
    //cool enough
    as: q
    //as shocking as
    //about: jj, //cool about
  }
}, re = "Gerund", Xn = {
  beforeTags: {
    // Verb: g, // loves shocking
    Adverb: re,
    //quickly shocking
    Preposition: re,
    //by insulting
    Conjunction: re
    //to insulting
  },
  afterTags: {
    Adverb: re,
    //shocking quickly
    Possessive: re,
    //shocking spencer's
    Person: re,
    //telling spencer
    Pronoun: re,
    //shocking him
    Determiner: re,
    //shocking the
    Copula: re,
    //shocking is
    Preposition: re,
    //dashing by, swimming in
    Conjunction: re,
    //insulting to
    Comparative: re
    //growing shorter
  },
  beforeWords: {
    been: re,
    keep: re,
    //keep going
    continue: re,
    //
    stop: re,
    //
    am: re,
    //am watching
    be: re,
    //be timing
    me: re,
    //got me thinking
    // action-words
    began: re,
    start: re,
    starts: re,
    started: re,
    stops: re,
    stopped: re,
    help: re,
    helps: re,
    avoid: re,
    avoids: re,
    love: re,
    //love painting
    loves: re,
    loved: re,
    hate: re,
    hates: re,
    hated: re
    // was:g,//was working
    // is:g,
    // be:g,
  },
  afterWords: {
    you: re,
    //telling you
    me: re,
    //
    her: re,
    //
    him: re,
    //
    his: re,
    //
    them: re,
    //
    their: re,
    // fighting their
    it: re,
    //dumping it
    this: re,
    //running this
    there: re,
    // swimming there
    on: re,
    // landing on
    about: re,
    // talking about
    for: re,
    // paying for
    up: re,
    //speeding up
    down: re
    //
  }
}, we = "Gerund", Gn = "Adjective", XI = {
  beforeTags: Object.assign({}, qe.beforeTags, Xn.beforeTags, {
    // Copula: jj,
    Imperative: we,
    //recommend living in
    Infinitive: Gn,
    //say charming things
    // PresentTense: g,
    Plural: we
    //kids cutting
  }),
  afterTags: Object.assign({}, qe.afterTags, Xn.afterTags, {
    Noun: Gn
    //shocking ignorance
    // Plural: jj, //shocking lies
  }),
  beforeWords: Object.assign({}, qe.beforeWords, Xn.beforeWords, {
    is: Gn,
    are: we,
    //is overflowing: JJ, are overflowing : VB ??
    was: Gn,
    of: Gn,
    //of varying
    suggest: we,
    suggests: we,
    suggested: we,
    recommend: we,
    recommends: we,
    recommended: we,
    imagine: we,
    imagines: we,
    imagined: we,
    consider: we,
    considered: we,
    considering: we,
    resist: we,
    resists: we,
    resisted: we,
    avoid: we,
    avoided: we,
    avoiding: we,
    except: Gn,
    accept: Gn,
    assess: we,
    explore: we,
    fear: we,
    fears: we,
    appreciate: we,
    question: we,
    help: we,
    embrace: we,
    with: Gn
    //filled with daring
  }),
  afterWords: Object.assign({}, qe.afterWords, Xn.afterWords, {
    to: we,
    not: we,
    //trying not to car
    the: we
    //sweeping the country
  })
}, vh = {
  beforeTags: {
    Determiner: void 0,
    //the premier university
    Cardinal: "Noun",
    //1950 convertable
    PhrasalVerb: "Adjective"
    //starts out fine
  },
  afterTags: {
    // Pronoun: 'Noun'//as an adult i
  }
}, QI = {
  beforeTags: Object.assign({}, qe.beforeTags, Fe.beforeTags, vh.beforeTags),
  afterTags: Object.assign({}, qe.afterTags, Fe.afterTags, vh.afterTags),
  beforeWords: Object.assign({}, qe.beforeWords, Fe.beforeWords, {
    // are representative
    are: "Adjective",
    is: "Adjective",
    was: "Adjective",
    be: "Adjective",
    // phrasals
    off: "Adjective",
    //start off fine
    out: "Adjective"
    //comes out fine
  }),
  afterWords: Object.assign({}, qe.afterWords, Fe.afterWords)
};
let ie = "PastTense", Ia = "Adjective";
const go = {
  beforeTags: {
    Adverb: ie,
    //quickly detailed
    Pronoun: ie,
    //he detailed
    ProperNoun: ie,
    //toronto closed
    Auxiliary: ie,
    Noun: ie
    //eye closed  -- i guess.
  },
  afterTags: {
    Possessive: ie,
    //hooked him
    Pronoun: ie,
    //hooked me
    Determiner: ie,
    //hooked the
    Adverb: ie,
    //cooked perfectly
    Comparative: ie,
    //closed higher
    Date: ie,
    // alleged thursday
    Gerund: ie
    //left dancing
  },
  beforeWords: {
    be: ie,
    //be hooked vs be embarrassed
    who: ie,
    //who lost
    get: Ia,
    //get charged
    had: ie,
    has: ie,
    have: ie,
    been: ie,
    it: ie,
    //it intoxicated him
    as: ie,
    //as requested
    for: Ia,
    //for discounted items
    more: Ia,
    //more broken promises
    always: Ia
  },
  afterWords: {
    by: ie,
    //damaged by
    back: ie,
    //charged back
    out: ie,
    //charged out
    in: ie,
    //crowded in
    up: ie,
    //heated up
    down: ie,
    //hammered down
    before: ie,
    //
    after: ie,
    //
    for: ie,
    //settled for
    the: ie,
    //settled the
    with: ie,
    //obsessed with
    as: ie,
    //known as
    on: ie,
    //focused on
    at: ie,
    //recorded at
    between: ie,
    //settled between
    to: ie,
    //dedicated to
    into: ie,
    //pumped into
    us: ie,
    //charged us
    them: ie,
    //charged us
    his: ie,
    //shared his
    her: ie,
    //
    their: ie,
    //
    our: ie,
    //
    me: ie,
    //
    about: Ia
  }
}, YI = {
  beforeTags: Object.assign({}, qe.beforeTags, go.beforeTags),
  afterTags: Object.assign({}, qe.afterTags, go.afterTags),
  beforeWords: Object.assign({}, qe.beforeWords, go.beforeWords),
  afterWords: Object.assign({}, qe.afterWords, go.afterWords)
}, ZI = {
  afterTags: {
    Noun: "Adjective",
    //ruling party
    Conjunction: void 0
    //clean and excellent
  }
}, eE = {
  beforeTags: Object.assign({}, qe.beforeTags, pt.beforeTags, {
    // always clean
    Adverb: void 0,
    Negative: void 0
  }),
  afterTags: Object.assign({}, qe.afterTags, pt.afterTags, ZI.afterTags),
  beforeWords: Object.assign({}, qe.beforeWords, pt.beforeWords, {
    // have seperate contracts
    have: void 0,
    had: void 0,
    not: void 0,
    //went wrong, got wrong
    went: "Adjective",
    goes: "Adjective",
    got: "Adjective",
    // be sure
    be: "Adjective"
  }),
  afterWords: Object.assign({}, qe.afterWords, pt.afterWords, {
    to: void 0,
    //slick to the touch
    as: "Adjective"
    //pale as
  })
}, vo = {
  beforeTags: {
    Copula: "Gerund",
    PastTense: "Gerund",
    PresentTense: "Gerund",
    Infinitive: "Gerund"
  },
  afterTags: {
    Value: "Gerund"
    //maintaining 500
  },
  beforeWords: {
    are: "Gerund",
    were: "Gerund",
    be: "Gerund",
    no: "Gerund",
    without: "Gerund",
    //are you playing
    you: "Gerund",
    we: "Gerund",
    they: "Gerund",
    he: "Gerund",
    she: "Gerund",
    //stop us playing
    us: "Gerund",
    them: "Gerund"
  },
  afterWords: {
    // offering the
    the: "Gerund",
    this: "Gerund",
    that: "Gerund",
    //got me thinking
    me: "Gerund",
    us: "Gerund",
    them: "Gerund"
  }
}, tE = {
  beforeTags: Object.assign({}, Xn.beforeTags, Fe.beforeTags, vo.beforeTags),
  afterTags: Object.assign({}, Xn.afterTags, Fe.afterTags, vo.afterTags),
  beforeWords: Object.assign({}, Xn.beforeWords, Fe.beforeWords, vo.beforeWords),
  afterWords: Object.assign({}, Xn.afterWords, Fe.afterWords, vo.afterWords)
}, Hr = "Singular", ur = "Infinitive", nE = {
  beforeTags: Object.assign({}, pt.beforeTags, Fe.beforeTags, {
    // Noun: undefined
    Adjective: Hr,
    //great name
    Particle: Hr
    //brought under control
  }),
  afterTags: Object.assign({}, pt.afterTags, Fe.afterTags, {
    ProperNoun: ur,
    Gerund: ur,
    Adjective: ur,
    Copula: Hr
  }),
  beforeWords: Object.assign({}, pt.beforeWords, Fe.beforeWords, {
    // is time
    is: Hr,
    was: Hr,
    //balance of power
    of: Hr,
    have: null
    //have cash
  }),
  afterWords: Object.assign({}, pt.afterWords, Fe.afterWords, {
    // for: vb,//work for
    instead: ur,
    // that: nn,//subject that was
    // for: vb,//work for
    about: ur,
    //talk about
    his: ur,
    //shot his
    her: ur,
    //
    to: null,
    by: null,
    in: null
  })
}, Ae = "Person", Je = {
  beforeTags: {
    Honorific: Ae,
    Person: Ae
    // Preposition: p, //with sue
  },
  afterTags: {
    Person: Ae,
    ProperNoun: Ae,
    Verb: Ae
    //bob could
    // Modal:true, //bob could
    // Copula:true, //bob is
    // PresentTense:true, //bob seems
  },
  beforeWords: {
    hi: Ae,
    hey: Ae,
    yo: Ae,
    dear: Ae,
    hello: Ae
  },
  afterWords: {
    // person-usually verbs
    said: Ae,
    says: Ae,
    told: Ae,
    tells: Ae,
    feels: Ae,
    felt: Ae,
    seems: Ae,
    thinks: Ae,
    thought: Ae,
    spends: Ae,
    spendt: Ae,
    plays: Ae,
    played: Ae,
    sing: Ae,
    sang: Ae,
    learn: Ae,
    learned: Ae,
    wants: Ae,
    wanted: Ae
    // and:true, //sue and jeff
  }
}, Oe = "Month", rE = "Person", yo = {
  beforeTags: {
    Date: Oe,
    Value: Oe
  },
  afterTags: {
    Date: Oe,
    Value: Oe
  },
  beforeWords: {
    by: Oe,
    in: Oe,
    on: Oe,
    during: Oe,
    after: Oe,
    before: Oe,
    between: Oe,
    until: Oe,
    til: Oe,
    sometime: Oe,
    of: Oe,
    //5th of april
    this: Oe,
    //this april
    next: Oe,
    last: Oe,
    previous: Oe,
    following: Oe,
    with: rE
    // for: p,
  },
  afterWords: {
    sometime: Oe,
    in: Oe,
    of: Oe,
    until: Oe,
    the: Oe
    //june the 4th
  }
}, aE = {
  beforeTags: Object.assign({}, Je.beforeTags, yo.beforeTags),
  afterTags: Object.assign({}, Je.afterTags, yo.afterTags),
  beforeWords: Object.assign({}, Je.beforeWords, yo.beforeWords),
  afterWords: Object.assign({}, Je.afterWords, yo.afterWords)
}, oE = {
  beforeTags: Object.assign({}, Fe.beforeTags, Je.beforeTags),
  afterTags: Object.assign({}, Fe.afterTags, Je.afterTags),
  beforeWords: Object.assign({}, Fe.beforeWords, Je.beforeWords, { i: "Infinitive", we: "Infinitive" }),
  afterWords: Object.assign({}, Fe.afterWords, Je.afterWords)
}, iE = {
  beforeTags: Object.assign({}, Fe.beforeTags, Je.beforeTags, pt.beforeTags),
  afterTags: Object.assign({}, Fe.afterTags, Je.afterTags, pt.afterTags),
  beforeWords: Object.assign({}, Fe.beforeWords, Je.beforeWords, pt.beforeWords),
  afterWords: Object.assign({}, Fe.afterWords, Je.afterWords, pt.afterWords)
}, ot = "Place", bo = {
  beforeTags: {
    Place: ot
  },
  afterTags: {
    Place: ot,
    Abbreviation: ot
  },
  beforeWords: {
    in: ot,
    by: ot,
    near: ot,
    from: ot,
    to: ot
  },
  afterWords: {
    in: ot,
    by: ot,
    near: ot,
    from: ot,
    to: ot,
    government: ot,
    council: ot,
    region: ot,
    city: ot
  }
}, sE = {
  beforeTags: Object.assign({}, bo.beforeTags, Je.beforeTags),
  afterTags: Object.assign({}, bo.afterTags, Je.afterTags),
  beforeWords: Object.assign({}, bo.beforeWords, Je.beforeWords),
  afterWords: Object.assign({}, bo.afterWords, Je.afterWords)
}, uE = {
  beforeTags: Object.assign({}, Je.beforeTags, qe.beforeTags),
  afterTags: Object.assign({}, Je.afterTags, qe.afterTags),
  beforeWords: Object.assign({}, Je.beforeWords, qe.beforeWords),
  afterWords: Object.assign({}, Je.afterWords, qe.afterWords)
};
let Bt = "Unit";
const lE = {
  beforeTags: { Value: Bt },
  afterTags: {},
  beforeWords: {
    per: Bt,
    every: Bt,
    each: Bt,
    square: Bt,
    //square km
    cubic: Bt,
    sq: Bt,
    metric: Bt
    //metric ton
  },
  afterWords: {
    per: Bt,
    squared: Bt,
    cubed: Bt,
    long: Bt
    //foot long
  }
}, ta = {
  "Actor|Verb": JI,
  "Adj|Gerund": XI,
  "Adj|Noun": QI,
  "Adj|Past": YI,
  "Adj|Present": eE,
  "Noun|Verb": nE,
  "Noun|Gerund": tE,
  "Person|Noun": oE,
  "Person|Date": aE,
  "Person|Verb": iE,
  "Person|Place": sE,
  "Person|Adj": uE,
  "Unit|Noun": lE
}, xo = (e, n) => {
  let t = Object.keys(e).reduce((r, a) => (r[a] = e[a] === "Infinitive" ? "PresentTense" : "Plural", r), {});
  return Object.assign(t, n);
};
ta["Plural|Verb"] = {
  beforeWords: xo(ta["Noun|Verb"].beforeWords, {
    had: "Plural",
    //had tears
    have: "Plural"
  }),
  afterWords: xo(ta["Noun|Verb"].afterWords, {
    his: "PresentTense",
    her: "PresentTense",
    its: "PresentTense",
    in: null,
    to: null,
    is: "PresentTense",
    //the way it works is
    by: "PresentTense"
    //it works by
  }),
  beforeTags: xo(ta["Noun|Verb"].beforeTags, {
    Conjunction: "PresentTense",
    //and changes
    Noun: void 0,
    //the century demands
    ProperNoun: "PresentTense"
    //john plays
  }),
  afterTags: xo(ta["Noun|Verb"].afterTags, {
    Gerund: "Plural",
    //ice caps disappearing
    Noun: "PresentTense",
    //changes gears
    Value: "PresentTense"
    //changes seven gears
  })
};
const Ne = "Adjective", Ze = "Infinitive", lr = "PresentTense", ue = "Singular", et = "PastTense", Wr = "Adverb", At = "Plural", Be = "Actor", wo = "Verb", ut = "Noun", cE = "ProperNoun", Wt = "LastName", yh = "Modal", Ee = "Place", ds = "Participle", hE = [
  null,
  null,
  {
    //2-letter
    ea: ue,
    ia: ut,
    ic: Ne,
    ly: Wr,
    "'n": wo,
    "'t": wo
  },
  {
    //3-letter
    oed: et,
    ued: et,
    xed: et,
    " so": Wr,
    "'ll": yh,
    "'re": "Copula",
    azy: Ne,
    eer: ut,
    end: wo,
    ped: et,
    ffy: Ne,
    ify: Ze,
    ing: "Gerund",
    ize: Ze,
    ibe: Ze,
    lar: Ne,
    mum: Ne,
    nes: lr,
    nny: Ne,
    // oid: Adj,
    ous: Ne,
    que: Ne,
    ger: ut,
    ber: ut,
    rol: ue,
    sis: ue,
    ogy: ue,
    oid: ue,
    ian: ue,
    zes: lr,
    eld: et,
    ken: ds,
    //awoken
    ven: ds,
    //woven
    ten: ds,
    //brighten
    ect: Ze,
    ict: Ze,
    // ide: Inf,
    ign: Ze,
    oze: Ze,
    ful: Ne,
    bal: Ne,
    ton: ut,
    pur: Ee
  },
  {
    //4-letter
    amed: et,
    aped: et,
    ched: et,
    lked: et,
    rked: et,
    reed: et,
    nded: et,
    mned: Ne,
    cted: et,
    dged: et,
    ield: ue,
    akis: Wt,
    cede: Ze,
    chuk: Wt,
    czyk: Wt,
    ects: lr,
    iend: ue,
    ends: wo,
    enko: Wt,
    ette: ue,
    iary: ue,
    wner: ue,
    //owner
    fies: lr,
    fore: Wr,
    gate: Ze,
    gone: Ne,
    ices: At,
    ints: At,
    ruct: Ze,
    ines: At,
    ions: At,
    ners: At,
    pers: At,
    lers: At,
    less: Ne,
    llen: Ne,
    made: Ne,
    nsen: Wt,
    oses: lr,
    ould: yh,
    some: Ne,
    sson: Wt,
    ians: At,
    // tage: Inf,
    tion: ue,
    tage: ut,
    ique: ue,
    tive: Ne,
    tors: ut,
    vice: ue,
    lier: ue,
    fier: ue,
    wned: et,
    gent: ue,
    tist: Be,
    pist: Be,
    rist: Be,
    mist: Be,
    yist: Be,
    vist: Be,
    ists: Be,
    lite: ue,
    site: ue,
    rite: ue,
    mite: ue,
    bite: ue,
    mate: ue,
    date: ue,
    ndal: ue,
    vent: ue,
    uist: Be,
    gist: Be,
    note: ue,
    cide: ue,
    //homicide
    ence: ue,
    //absence
    wide: Ne,
    //nationwide
    // side: Adj,//alongside
    vide: Ze,
    //provide
    ract: Ze,
    duce: Ze,
    pose: Ze,
    eive: Ze,
    lyze: Ze,
    lyse: Ze,
    iant: Ne,
    nary: Ne,
    ghty: Ne,
    uent: Ne,
    erer: Be,
    //caterer
    bury: Ee,
    dorf: ut,
    esty: ut,
    wych: Ee,
    dale: Ee,
    folk: Ee,
    vale: Ee,
    abad: Ee,
    sham: Ee,
    wick: Ee,
    view: Ee
  },
  {
    //5-letter
    elist: Be,
    holic: ue,
    phite: ue,
    tized: et,
    urned: et,
    eased: et,
    ances: At,
    bound: Ne,
    ettes: At,
    fully: Wr,
    ishes: lr,
    ities: At,
    marek: Wt,
    nssen: Wt,
    ology: ut,
    osome: ue,
    tment: ue,
    ports: At,
    rough: Ne,
    tches: lr,
    tieth: "Ordinal",
    tures: At,
    wards: Wr,
    where: Wr,
    archy: ut,
    pathy: ut,
    opoly: ut,
    embly: ut,
    phate: ut,
    ndent: ue,
    scent: ue,
    onist: Be,
    anist: Be,
    alist: Be,
    olist: Be,
    icist: Be,
    ounce: Ze,
    iable: Ne,
    borne: Ne,
    gnant: Ne,
    inant: Ne,
    igent: Ne,
    atory: Ne,
    // ctory: Adj,
    rient: ue,
    dient: ue,
    maker: Be,
    burgh: Ee,
    mouth: Ee,
    ceter: Ee,
    ville: Ee,
    hurst: Ee,
    stead: Ee,
    endon: Ee,
    brook: Ee,
    shire: Ee,
    worth: ut,
    field: cE,
    ridge: Ee
  },
  {
    //6-letter
    auskas: Wt,
    parent: ue,
    cedent: ue,
    ionary: ue,
    cklist: ue,
    brooke: Ee,
    keeper: Be,
    logist: Be,
    teenth: "Value",
    worker: Be,
    master: Be,
    writer: Be,
    brough: Ee,
    cester: Ee,
    ington: Ee,
    cliffe: Ee,
    ingham: Ee
  },
  {
    //7-letter
    chester: Ee,
    logists: Be,
    opoulos: Wt,
    borough: Ee,
    sdottir: Wt
    //swedish female
  }
], It = "Adjective", Te = "Noun", Ea = "Verb", dE = [
  null,
  null,
  {
    // 2-letter
  },
  {
    // 3-letter
    neo: Te,
    bio: Te,
    // pre: Noun,
    "de-": Ea,
    "re-": Ea,
    "un-": Ea,
    "ex-": Te
  },
  {
    // 4-letter
    anti: Te,
    auto: Te,
    faux: It,
    hexa: Te,
    kilo: Te,
    mono: Te,
    nano: Te,
    octa: Te,
    poly: Te,
    semi: It,
    tele: Te,
    "pro-": It,
    "mis-": Ea,
    "dis-": Ea,
    "pre-": It
    //hmm
  },
  {
    // 5-letter
    anglo: Te,
    centi: Te,
    ethno: Te,
    ferro: Te,
    grand: Te,
    hepta: Te,
    hydro: Te,
    intro: Te,
    macro: Te,
    micro: Te,
    milli: Te,
    nitro: Te,
    penta: Te,
    quasi: It,
    radio: Te,
    tetra: Te,
    "omni-": It,
    "post-": It
  },
  {
    // 6-letter
    pseudo: It,
    "extra-": It,
    "hyper-": It,
    "inter-": It,
    "intra-": It,
    "deca-": It
    // 'trans-': Noun,
  },
  {
    // 7-letter
    electro: Te
  }
], Re = "Adjective", Co = "Infinitive", ko = "PresentTense", wn = "Singular", ft = "PastTense", bh = "Adverb", Cn = "Expression", xh = "Actor", wh = "Verb", Ch = "Noun", No = "LastName", pE = {
  a: [
    [/.[aeiou]na$/, Ch, "tuna"],
    [/.[oau][wvl]ska$/, No],
    [/.[^aeiou]ica$/, wn, "harmonica"],
    [/^([hyj]a+)+$/, Cn, "haha"]
    //hahah
  ],
  c: [[/.[^aeiou]ic$/, Re]],
  d: [
    //==-ed==
    //double-consonant
    [/[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/, ft, "popped"],
    //double-vowel
    [/.[aeo]{2}[bdgmnprvz]ed$/, ft, "rammed"],
    //-hed
    [/.[aeiou][sg]hed$/, ft, "gushed"],
    //-rd
    [/.[aeiou]red$/, ft, "hired"],
    [/.[aeiou]r?ried$/, ft, "hurried"],
    // ard
    [/[^aeiou]ard$/, wn, "steward"],
    // id
    [/[aeiou][^aeiou]id$/, Re, ""],
    [/.[vrl]id$/, Re, "livid"],
    // ===== -ed ======
    //-led
    [/..led$/, ft, "hurled"],
    //-sed
    [/.[iao]sed$/, ft, ""],
    [/[aeiou]n?[cs]ed$/, ft, ""],
    //-med
    [/[aeiou][rl]?[mnf]ed$/, ft, ""],
    //-ked
    [/[aeiou][ns]?c?ked$/, ft, "bunked"],
    //-gned
    [/[aeiou]gned$/, ft],
    //-ged
    [/[aeiou][nl]?ged$/, ft],
    //-ted
    [/.[tdbwxyz]ed$/, ft],
    [/[^aeiou][aeiou][tvx]ed$/, ft],
    //-ied
    [/.[cdflmnprstv]ied$/, ft, "emptied"]
  ],
  e: [
    [/.[lnr]ize$/, Co, "antagonize"],
    [/.[^aeiou]ise$/, Co, "antagonise"],
    [/.[aeiou]te$/, Co, "bite"],
    [/.[^aeiou][ai]ble$/, Re, "fixable"],
    [/.[^aeiou]eable$/, Re, "maleable"],
    [/.[ts]ive$/, Re, "festive"],
    [/[a-z]-like$/, Re, "woman-like"]
  ],
  h: [
    [/.[^aeiouf]ish$/, Re, "cornish"],
    [/.v[iy]ch$/, No, "..ovich"],
    [/^ug?h+$/, Cn, "ughh"],
    [/^uh[ -]?oh$/, Cn, "uhoh"],
    [/[a-z]-ish$/, Re, "cartoon-ish"]
  ],
  i: [[/.[oau][wvl]ski$/, No, "polish-male"]],
  k: [
    [/^(k){2}$/, Cn, "kkkk"]
    //kkkk
  ],
  l: [
    [/.[gl]ial$/, Re, "familial"],
    [/.[^aeiou]ful$/, Re, "fitful"],
    [/.[nrtumcd]al$/, Re, "natal"],
    [/.[^aeiou][ei]al$/, Re, "familial"]
  ],
  m: [
    [/.[^aeiou]ium$/, wn, "magnesium"],
    [/[^aeiou]ism$/, wn, "schism"],
    [/^[hu]m+$/, Cn, "hmm"],
    [/^\d+ ?[ap]m$/, "Date", "3am"]
  ],
  n: [
    [/.[lsrnpb]ian$/, Re, "republican"],
    [/[^aeiou]ician$/, xh, "musician"],
    [/[aeiou][ktrp]in'$/, "Gerund", "cookin'"]
    // 'cookin', 'hootin'
  ],
  o: [
    [/^no+$/, Cn, "noooo"],
    [/^(yo)+$/, Cn, "yoo"],
    [/^wo{2,}[pt]?$/, Cn, "woop"]
    //woo
  ],
  r: [
    [/.[bdfklmst]ler$/, "Noun"],
    [/[aeiou][pns]er$/, wn],
    [/[^i]fer$/, Co],
    [/.[^aeiou][ao]pher$/, xh],
    [/.[lk]er$/, "Noun"],
    [/.ier$/, "Comparative"]
  ],
  t: [
    [/.[di]est$/, "Superlative"],
    [/.[icldtgrv]ent$/, Re],
    [/[aeiou].*ist$/, Re],
    [/^[a-z]et$/, wh]
  ],
  s: [
    [/.[^aeiou]ises$/, ko],
    [/.[rln]ates$/, ko],
    [/.[^z]ens$/, wh],
    [/.[lstrn]us$/, wn],
    [/.[aeiou]sks$/, ko],
    [/.[aeiou]kes$/, ko],
    [/[aeiou][^aeiou]is$/, wn],
    [/[a-z]'s$/, Ch],
    [/^yes+$/, Cn]
    //yessss
  ],
  v: [
    [/.[^aeiou][ai][kln]ov$/, No]
    //east-europe
  ],
  y: [
    [/.[cts]hy$/, Re],
    [/.[st]ty$/, Re],
    [/.[tnl]ary$/, Re],
    [/.[oe]ry$/, wn],
    [/[rdntkbhs]ly$/, bh],
    [/.(gg|bb|zz)ly$/, Re],
    [/...lly$/, bh],
    [/.[gk]y$/, Re],
    [/[bszmp]{2}y$/, Re],
    [/.[ai]my$/, Re],
    [/[ea]{2}zy$/, Re],
    [/.[^aeiou]ity$/, wn]
  ]
}, lt = "Verb", Pe = "Noun", fE = {
  // looking at the previous word's tags:
  leftTags: [
    ["Adjective", Pe],
    ["Possessive", Pe],
    ["Determiner", Pe],
    ["Adverb", lt],
    ["Pronoun", lt],
    ["Value", Pe],
    ["Ordinal", Pe],
    ["Modal", lt],
    ["Superlative", Pe],
    ["Demonym", Pe],
    ["Honorific", "Person"]
    //dr. Smith
  ],
  // looking at the previous word:
  leftWords: [
    ["i", lt],
    ["first", Pe],
    ["it", lt],
    ["there", lt],
    ["not", lt],
    ["because", Pe],
    ["if", Pe],
    ["but", Pe],
    ["who", lt],
    ["this", Pe],
    ["his", Pe],
    ["when", Pe],
    ["you", lt],
    ["very", "Adjective"],
    ["old", Pe],
    ["never", lt],
    ["before", Pe],
    ["a", Pe],
    ["the", Pe],
    ["been", lt]
  ],
  // looking at the next word's tags:
  rightTags: [
    ["Copula", Pe],
    ["PastTense", Pe],
    ["Conjunction", Pe],
    ["Modal", Pe]
  ],
  // looking at the next word:
  rightWords: [
    ["there", lt],
    ["me", lt],
    ["man", "Adjective"],
    // ['only', vb],
    ["him", lt],
    ["it", lt],
    //relaunch it
    ["were", Pe],
    ["took", Pe],
    ["himself", lt],
    ["went", Pe],
    ["who", Pe],
    ["jr", "Person"]
  ]
}, Fr = {
  Comparative: {
    fwd: "3:ser,ier¦1er:h,t,f,l,n¦1r:e¦2er:ss,or,om",
    both: "3er:ver,ear,alm¦3ner:hin¦3ter:lat¦2mer:im¦2er:ng,rm,mb¦2ber:ib¦2ger:ig¦1er:w,p,k,d¦ier:y",
    rev: "1:tter,yer¦2:uer,ver,ffer,oner,eler,ller,iler,ster,cer,uler,sher,ener,gher,aner,adder,nter,eter,rter,hter,rner,fter¦3:oser,ooler,eafer,user,airer,bler,maler,tler,eater,uger,rger,ainer,urer,ealer,icher,pler,emner,icter,nser,iser¦4:arser,viner,ucher,rosser,somer,ndomer,moter,oother,uarer,hiter¦5:nuiner,esser,emier¦ar:urther",
    ex: "worse:bad¦better:good¦4er:fair,gray,poor¦1urther:far¦3ter:fat,hot,wet¦3der:mad,sad¦3er:shy,fun¦4der:glad¦:¦4r:cute,dire,fake,fine,free,lame,late,pale,rare,ripe,rude,safe,sore,tame,wide¦5r:eerie,stale"
  },
  Gerund: {
    fwd: "1:nning,tting,rring,pping,eing,mming,gging,dding,bbing,kking¦2:eking,oling,eling,eming¦3:velling,siting,uiting,fiting,loting,geting,ialing,celling¦4:graming",
    both: "1:aing,iing,fing,xing,ying,oing,hing,wing¦2:tzing,rping,izzing,bting,mning,sping,wling,rling,wding,rbing,uping,lming,wning,mping,oning,lting,mbing,lking,fting,hting,sking,gning,pting,cking,ening,nking,iling,eping,ering,rting,rming,cting,lping,ssing,nting,nding,lding,sting,rning,rding,rking¦3:belling,siping,toming,yaking,uaking,oaning,auling,ooping,aiding,naping,euring,tolling,uzzing,ganing,haning,ualing,halling,iasing,auding,ieting,ceting,ouling,voring,ralling,garing,joring,oaming,oaking,roring,nelling,ooring,uelling,eaming,ooding,eaping,eeting,ooting,ooming,xiting,keting,ooking,ulling,airing,oaring,biting,outing,oiting,earing,naling,oading,eeding,ouring,eaking,aiming,illing,oining,eaning,onging,ealing,aining,eading¦4:thoming,melling,aboring,ivoting,weating,dfilling,onoring,eriting,imiting,tialling,rgining,otoring,linging,winging,lleting,louding,spelling,mpelling,heating,feating,opelling,choring,welling,ymaking,ctoring,calling,peating,iloring,laiting,utoring,uditing,mmaking,loating,iciting,waiting,mbating,voiding,otalling,nsoring,nselling,ocusing,itoring,eloping¦5:rselling,umpeting,atrolling,treating,tselling,rpreting,pringing,ummeting,ossoming,elmaking,eselling,rediting,totyping,onmaking,rfeiting,ntrolling¦5e:chmaking,dkeeping,severing,erouting,ecreting,ephoning,uthoring,ravening,reathing,pediting,erfering,eotyping,fringing,entoring,ombining,ompeting¦4e:emaking,eething,twining,rruling,chuting,xciting,rseding,scoping,edoring,pinging,lunging,agining,craping,pleting,eleting,nciting,nfining,ncoding,tponing,ecoding,writing,esaling,nvening,gnoring,evoting,mpeding,rvening,dhering,mpiling,storing,nviting,ploring¦3e:tining,nuring,saking,miring,haling,ceding,xuding,rining,nuting,laring,caring,miling,riding,hoking,piring,lading,curing,uading,noting,taping,futing,paring,hading,loding,siring,guring,vading,voking,during,niting,laning,caping,luting,muting,ruding,ciding,juring,laming,caling,hining,uoting,liding,ciling,duling,tuting,puting,cuting,coring,uiding,tiring,turing,siding,rading,enging,haping,buting,lining,taking,anging,haring,uiring,coming,mining,moting,suring,viding,luding¦2e:tring,zling,uging,oging,gling,iging,vring,fling,lging,obing,psing,pling,ubing,cling,dling,wsing,iking,rsing,dging,kling,ysing,tling,rging,eging,nsing,uning,osing,uming,using,ibing,bling,aging,ising,asing,ating¦2ie:rlying¦1e:zing,uing,cing,ving",
    rev: "ying:ie¦1ing:se,ke,te,we,ne,re,de,pe,me,le,c,he¦2ing:ll,ng,dd,ee,ye,oe,rg,us¦2ning:un¦2ging:og,ag,ug,ig,eg¦2ming:um¦2bing:ub,ab,eb,ob¦3ning:lan,can,hin,pin,win¦3ring:cur,lur,tir,tar,pur,car¦3ing:ait,del,eel,fin,eat,oat,eem,lel,ool,ein,uin¦3ping:rop,rap,top,uip,wap,hip,hop,lap,rip,cap¦3ming:tem,wim,rim,kim,lim¦3ting:mat,cut,pot,lit,lot,hat,set,pit,put¦3ding:hed,bed,bid¦3king:rek¦3ling:cil,pel¦3bing:rib¦4ning:egin¦4ing:isit,ruit,ilot,nsit,dget,rkel,ival,rcel¦4ring:efer,nfer¦4ting:rmit,mmit,ysit,dmit,emit,bmit,tfit,gret¦4ling:evel,xcel,ivel¦4ding:hred¦5ing:arget,posit,rofit¦5ring:nsfer¦5ting:nsmit,orget,cquit¦5ling:ancel,istil",
    ex: "3:adding,eating,aiming,aiding,airing,outing,gassing,setting,getting,putting,cutting,winning,sitting,betting,mapping,tapping,letting,bidding,hitting,tanning,netting,popping,fitting,capping,lapping,barring,banning,vetting,topping,rotting,tipping,potting,wetting,pitting,dipping,budding,hemming,pinning,jetting,kidding,padding,podding,sipping,wedding,bedding,donning,warring,penning,gutting,cueing,wadding,petting,ripping,napping,matting,tinning,binning,dimming,hopping,mopping,nodding,panning,rapping,ridding,sinning¦4:selling,falling,calling,waiting,editing,telling,rolling,heating,boating,hanging,beating,coating,singing,tolling,felling,polling,discing,seating,voiding,gelling,yelling,baiting,reining,ruining,seeking,spanning,stepping,knitting,emitting,slipping,quitting,dialing,omitting,clipping,shutting,skinning,abutting,flipping,trotting,cramming,fretting,suiting¦5:bringing,treating,spelling,stalling,trolling,expelling,rivaling,wringing,deterring,singeing,befitting,refitting¦6:enrolling,distilling,scrolling,strolling,caucusing,travelling¦7:installing,redefining,stencilling,recharging,overeating,benefiting,unraveling,programing¦9:reprogramming¦is:being¦2e:using,aging,owing¦3e:making,taking,coming,noting,hiring,filing,coding,citing,doping,baking,coping,hoping,lading,caring,naming,voting,riding,mining,curing,lining,ruling,typing,boring,dining,firing,hiding,piling,taping,waning,baling,boning,faring,honing,wiping,luring,timing,wading,piping,fading,biting,zoning,daring,waking,gaming,raking,ceding,tiring,coking,wining,joking,paring,gaping,poking,pining,coring,liming,toting,roping,wiring,aching¦4e:writing,storing,eroding,framing,smoking,tasting,wasting,phoning,shaking,abiding,braking,flaking,pasting,priming,shoring,sloping,withing,hinging¦5e:defining,refining,renaming,swathing,fringing,reciting¦1ie:dying,tying,lying,vying¦7e:sunbathing"
  },
  Participle: {
    fwd: "1:mt¦2:llen¦3:iven,aken¦:ne¦y:in",
    both: "1:wn¦2:me,aten¦3:seen,bidden,isen¦4:roven,asten¦3l:pilt¦3d:uilt¦2e:itten¦1im:wum¦1eak:poken¦1ine:hone¦1ose:osen¦1in:gun¦1ake:woken¦ear:orn¦eal:olen¦eeze:ozen¦et:otten¦ink:unk¦ing:ung",
    rev: "2:un¦oken:eak¦ought:eek¦oven:eave¦1ne:o¦1own:ly¦1den:de¦1in:ay¦2t:am¦2n:ee¦3en:all¦4n:rive,sake,take¦5n:rgive",
    ex: "2:been¦3:seen,run¦4:given,taken¦5:shaken¦2eak:broken¦1ive:dove¦2y:flown¦3e:hidden,ridden¦1eek:sought¦1ake:woken¦1eave:woven"
  },
  PastTense: {
    fwd: "1:tted,wed,gged,nned,een,rred,pped,yed,bbed,oed,dded,rd,wn,mmed¦2:eed,nded,et,hted,st,oled,ut,emed,eled,lded,ken,rt,nked,apt,ant,eped,eked¦3:eared,eat,eaded,nelled,ealt,eeded,ooted,eaked,eaned,eeted,mited,bid,uit,ead,uited,ealed,geted,velled,ialed,belled¦4:ebuted,hined,comed¦y:ied¦ome:ame¦ear:ore¦ind:ound¦ing:ung,ang¦ep:pt¦ink:ank,unk¦ig:ug¦all:ell¦ee:aw¦ive:ave¦eeze:oze¦old:eld¦ave:ft¦ake:ook¦ell:old¦ite:ote¦ide:ode¦ine:one¦in:un,on¦eal:ole¦im:am¦ie:ay¦and:ood¦1ise:rose¦1eak:roke¦1ing:rought¦1ive:rove¦1el:elt¦1id:bade¦1et:got¦1y:aid¦1it:sat¦3e:lid¦3d:pent",
    both: "1:aed,fed,xed,hed¦2:sged,xted,wled,rped,lked,kied,lmed,lped,uped,bted,rbed,rked,wned,rled,mped,fted,mned,mbed,zzed,omed,ened,cked,gned,lted,sked,ued,zed,nted,ered,rted,rmed,ced,sted,rned,ssed,rded,pted,ved,cted¦3:cled,eined,siped,ooned,uked,ymed,jored,ouded,ioted,oaned,lged,asped,iged,mured,oided,eiled,yped,taled,moned,yled,lit,kled,oaked,gled,naled,fled,uined,oared,valled,koned,soned,aided,obed,ibed,meted,nicked,rored,micked,keted,vred,ooped,oaded,rited,aired,auled,filled,ouled,ooded,ceted,tolled,oited,bited,aped,tled,vored,dled,eamed,nsed,rsed,sited,owded,pled,sored,rged,osed,pelled,oured,psed,oated,loned,aimed,illed,eured,tred,ioned,celled,bled,wsed,ooked,oiled,itzed,iked,iased,onged,ased,ailed,uned,umed,ained,auded,nulled,ysed,eged,ised,aged,oined,ated,used,dged,doned¦4:ntied,efited,uaked,caded,fired,roped,halled,roked,himed,culed,tared,lared,tuted,uared,routed,pited,naked,miled,houted,helled,hared,cored,caled,tired,peated,futed,ciled,called,tined,moted,filed,sided,poned,iloted,honed,lleted,huted,ruled,cured,named,preted,vaded,sured,talled,haled,peded,gined,nited,uided,ramed,feited,laked,gured,ctored,unged,pired,cuted,voked,eloped,ralled,rined,coded,icited,vided,uaded,voted,mined,sired,noted,lined,nselled,luted,jured,fided,puted,piled,pared,olored,cided,hoked,enged,tured,geoned,cotted,lamed,uiled,waited,udited,anged,luded,mired,uired,raded¦5:modelled,izzled,eleted,umpeted,ailored,rseded,treated,eduled,ecited,rammed,eceded,atrolled,nitored,basted,twined,itialled,ncited,gnored,ploded,xcited,nrolled,namelled,plored,efeated,redited,ntrolled,nfined,pleted,llided,lcined,eathed,ibuted,lloted,dhered,cceded¦3ad:sled¦2aw:drew¦2ot:hot¦2ke:made¦2ow:hrew,grew¦2ose:hose¦2d:ilt¦2in:egan¦1un:ran¦1ink:hought¦1ick:tuck¦1ike:ruck¦1eak:poke,nuck¦1it:pat¦1o:did¦1ow:new¦1ake:woke¦go:went",
    rev: "3:rst,hed,hut,cut,set¦4:tbid¦5:dcast,eread,pread,erbid¦ought:uy,eek¦1ied:ny,ly,dy,ry,fy,py,vy,by,ty,cy¦1ung:ling,ting,wing¦1pt:eep¦1ank:rink¦1ore:bear,wear¦1ave:give¦1oze:reeze¦1ound:rind,wind¦1ook:take,hake¦1aw:see¦1old:sell¦1ote:rite¦1ole:teal¦1unk:tink¦1am:wim¦1ay:lie¦1ood:tand¦1eld:hold¦2d:he,ge,re,le,leed,ne,reed,be,ye,lee,pe,we¦2ed:dd,oy,or,ey,gg,rr,us,ew,to¦2ame:ecome,rcome¦2ped:ap¦2ged:ag,og,ug,eg¦2bed:ub,ab,ib,ob¦2lt:neel¦2id:pay¦2ang:pring¦2ove:trive¦2med:um¦2ode:rride¦2at:ysit¦3ted:mit,hat,mat,lat,pot,rot,bat¦3ed:low,end,tow,und,ond,eem,lay,cho,dow,xit,eld,ald,uld,law,lel,eat,oll,ray,ank,fin,oam,out,how,iek,tay,haw,ait,vet,say,cay,bow¦3d:ste,ede,ode,ete,ree,ude,ame,oke,ote,ime,ute,ade¦3red:lur,cur,pur,car¦3ped:hop,rop,uip,rip,lip,tep,top¦3ded:bed,rod,kid¦3ade:orbid¦3led:uel¦3ned:lan,can,kin,pan,tun¦3med:rim,lim¦4ted:quit,llot¦4ed:pear,rrow,rand,lean,mand,anel,pand,reet,link,abel,evel,imit,ceed,ruit,mind,peal,veal,hool,head,pell,well,mell,uell,band,hear,weak¦4led:nnel,qual,ebel,ivel¦4red:nfer,efer,sfer¦4n:sake,trew¦4d:ntee¦4ded:hred¦4ned:rpin¦5ed:light,nceal,right,ndear,arget,hread,eight,rtial,eboot¦5d:edite,nvite¦5ted:egret¦5led:ravel",
    ex: "2:been,upped¦3:added,aged,aided,aimed,aired,bid,died,dyed,egged,erred,eyed,fit,gassed,hit,lied,owed,pent,pied,tied,used,vied,oiled,outed,banned,barred,bet,canned,cut,dipped,donned,ended,feed,inked,jarred,let,manned,mowed,netted,padded,panned,pitted,popped,potted,put,set,sewn,sowed,tanned,tipped,topped,vowed,weed,bowed,jammed,binned,dimmed,hopped,mopped,nodded,pinned,rigged,sinned,towed,vetted¦4:ached,baked,baled,boned,bored,called,caned,cared,ceded,cited,coded,cored,cubed,cured,dared,dined,edited,exited,faked,fared,filed,fined,fired,fuelled,gamed,gelled,hired,hoped,joked,lined,mined,named,noted,piled,poked,polled,pored,pulled,reaped,roamed,rolled,ruled,seated,shed,sided,timed,tolled,toned,voted,waited,walled,waned,winged,wiped,wired,zoned,yelled,tamed,lubed,roped,faded,mired,caked,honed,banged,culled,heated,raked,welled,banded,beat,cast,cooled,cost,dealt,feared,folded,footed,handed,headed,heard,hurt,knitted,landed,leaked,leapt,linked,meant,minded,molded,neared,needed,peaked,plodded,plotted,pooled,quit,read,rooted,sealed,seeded,seeped,shipped,shunned,skimmed,slammed,sparred,stemmed,stirred,suited,thinned,twinned,swayed,winked,dialed,abutted,blotted,fretted,healed,heeded,peeled,reeled¦5:basted,cheated,equalled,eroded,exiled,focused,opined,pleated,primed,quoted,scouted,shored,sloped,smoked,sniped,spelled,spouted,routed,staked,stored,swelled,tasted,treated,wasted,smelled,dwelled,honored,prided,quelled,eloped,scared,coveted,sweated,breaded,cleared,debuted,deterred,freaked,modeled,pleaded,rebutted,speeded¦6:anchored,defined,endured,impaled,invited,refined,revered,strolled,cringed,recast,thrust,unfolded¦7:authored,combined,competed,conceded,convened,excreted,extruded,redefined,restored,secreted,rescinded,welcomed¦8:expedited,infringed¦9:interfered,intervened,persevered¦10:contravened¦eat:ate¦is:was¦go:went¦are:were¦3d:bent,lent,rent,sent¦3e:bit,fled,hid,lost¦3ed:bled,bred¦2ow:blew,grew¦1uy:bought¦2tch:caught¦1o:did¦1ive:dove,gave¦2aw:drew¦2ed:fed¦2y:flew,laid,paid,said¦1ight:fought¦1et:got¦2ve:had¦1ang:hung¦2ad:led¦2ght:lit¦2ke:made¦2et:met¦1un:ran¦1ise:rose¦1it:sat¦1eek:sought¦1each:taught¦1ake:woke,took¦1eave:wove¦2ise:arose¦1ear:bore,tore,wore¦1ind:bound,found,wound¦2eak:broke¦2ing:brought,wrung¦1ome:came¦2ive:drove¦1ig:dug¦1all:fell¦2el:felt¦4et:forgot¦1old:held¦2ave:left¦1ing:rang,sang¦1ide:rode¦1ink:sank¦1ee:saw¦2ine:shone¦4e:slid¦1ell:sold,told¦4d:spent¦2in:spun¦1in:won"
  },
  PresentTense: {
    fwd: "1:oes¦1ve:as",
    both: "1:xes¦2:zzes,ches,shes,sses¦3:iases¦2y:llies,plies¦1y:cies,bies,ties,vies,nies,pies,dies,ries,fies¦:s",
    rev: "1ies:ly¦2es:us,go,do¦3es:cho,eto",
    ex: "2:does,goes¦3:gasses¦5:focuses¦is:are¦3y:relies¦2y:flies¦2ve:has"
  },
  Superlative: {
    fwd: "1st:e¦1est:l,m,f,s¦1iest:cey¦2est:or,ir¦3est:ver",
    both: "4:east¦5:hwest¦5lest:erful¦4est:weet,lgar,tter,oung¦4most:uter¦3est:ger,der,rey,iet,ong,ear¦3test:lat¦3most:ner¦2est:pt,ft,nt,ct,rt,ht¦2test:it¦2gest:ig¦1est:b,k,n,p,h,d,w¦iest:y",
    rev: "1:ttest,nnest,yest¦2:sest,stest,rmest,cest,vest,lmest,olest,ilest,ulest,ssest,imest,uest¦3:rgest,eatest,oorest,plest,allest,urest,iefest,uelest,blest,ugest,amest,yalest,ealest,illest,tlest,itest¦4:cerest,eriest,somest,rmalest,ndomest,motest,uarest,tiffest¦5:leverest,rangest¦ar:urthest¦3ey:riciest",
    ex: "best:good¦worst:bad¦5est:great¦4est:fast,full,fair,dull¦3test:hot,wet,fat¦4nest:thin¦1urthest:far¦3est:gay,shy,ill¦4test:neat¦4st:late,wide,fine,safe,cute,fake,pale,rare,rude,sore,ripe,dire¦6st:severe"
  },
  AdjToNoun: {
    fwd: "1:tistic,eable,lful,sful,ting,tty¦2:onate,rtable,geous,ced,seful,ctful¦3:ortive,ented¦arity:ear¦y:etic¦fulness:begone¦1ity:re¦1y:tiful,gic¦2ity:ile,imous,ilous,ime¦2ion:ated¦2eness:iving¦2y:trious¦2ation:iring¦2tion:vant¦3ion:ect¦3ce:mant,mantic¦3tion:irable¦3y:est,estic¦3m:mistic,listic¦3ess:ning¦4n:utious¦4on:rative,native,vative,ective¦4ce:erant",
    both: "1:king,wing¦2:alous,ltuous,oyful,rdous¦3:gorous,ectable,werful,amatic¦4:oised,usical,agical,raceful,ocused,lined,ightful¦5ness:stful,lding,itous,nuous,ulous,otous,nable,gious,ayful,rvous,ntous,lsive,peful,entle,ciful,osive,leful,isive,ncise,reful,mious¦5ty:ivacious¦5ties:ubtle¦5ce:ilient,adiant,atient¦5cy:icient¦5sm:gmatic¦5on:sessive,dictive¦5ity:pular,sonal,eative,entic¦5sity:uminous¦5ism:conic¦5nce:mperate¦5ility:mitable¦5ment:xcited¦5n:bitious¦4cy:brant,etent,curate¦4ility:erable,acable,icable,ptable¦4ty:nacious,aive,oyal,dacious¦4n:icious¦4ce:vient,erent,stent,ndent,dient,quent,ident¦4ness:adic,ound,hing,pant,sant,oing,oist,tute¦4icity:imple¦4ment:fined,mused¦4ism:otic¦4ry:dantic¦4ity:tund,eral¦4edness:hand¦4on:uitive¦4lity:pitable¦4sm:eroic,namic¦4sity:nerous¦3th:arm¦3ility:pable,bable,dable,iable¦3cy:hant,nant,icate¦3ness:red,hin,nse,ict,iet,ite,oud,ind,ied,rce¦3ion:lute¦3ity:ual,gal,volous,ial¦3ce:sent,fensive,lant,gant,gent,lent,dant¦3on:asive¦3m:fist,sistic,iastic¦3y:terious,xurious,ronic,tastic¦3ur:amorous¦3e:tunate¦3ation:mined¦3sy:rteous¦3ty:ain¦3ry:ave¦3ment:azed¦2ness:de,on,ue,rn,ur,ft,rp,pe,om,ge,rd,od,ay,ss,er,ll,oy,ap,ht,ld,ad,rt¦2inousness:umous¦2ity:neous,ene,id,ane¦2cy:bate,late¦2ation:ized¦2ility:oble,ible¦2y:odic¦2e:oving,aring¦2s:ost¦2itude:pt¦2dom:ee¦2ance:uring¦2tion:reet¦2ion:oted¦2sion:ending¦2liness:an¦2or:rdent¦1th:ung¦1e:uable¦1ness:w,h,k,f¦1ility:mble¦1or:vent¦1ement:ging¦1tiquity:ncient¦1ment:hed¦verty:or¦ength:ong¦eat:ot¦pth:ep¦iness:y",
    rev: "",
    ex: "5:forceful,humorous¦8:charismatic¦13:understanding¦5ity:active¦11ness:adventurous,inquisitive,resourceful¦8on:aggressive,automatic,perceptive¦7ness:amorous,fatuous,furtive,ominous,serious¦5ness:ample,sweet¦12ness:apprehensive,cantankerous,contemptuous,ostentatious¦13ness:argumentative,conscientious¦9ness:assertive,facetious,imperious,inventive,oblivious,rapacious,receptive,seditious,whimsical¦10ness:attractive,expressive,impressive,loquacious,salubrious,thoughtful¦3edom:boring¦4ness:calm,fast,keen,tame¦8ness:cheerful,gracious,specious,spurious,timorous,unctuous¦5sity:curious¦9ion:deliberate¦8ion:desperate¦6e:expensive¦7ce:fragrant¦3y:furious¦9ility:ineluctable¦6ism:mystical¦8ity:physical,proactive,sensitive,vertical¦5cy:pliant¦7ity:positive¦9ity:practical¦12ism:professional¦6ce:prudent¦3ness:red¦6cy:vagrant¦3dom:wise"
  }
}, mE = function(e, n = {}) {
  return n.hasOwnProperty(e) ? n[e] : null;
}, gE = function(e, n = []) {
  for (let t = 0; t < n.length; t += 1)
    if (e.endsWith(n[t]))
      return e;
  return null;
}, vE = function(e, n, t = {}) {
  n = n || {};
  let r = e.length - 1;
  for (let a = r; a >= 1; a -= 1) {
    let o = e.length - a, i = e.substring(o, e.length);
    if (n.hasOwnProperty(i) === !0)
      return e.slice(0, o) + n[i];
    if (t.hasOwnProperty(i) === !0)
      return e.slice(0, o) + t[i];
  }
  return n.hasOwnProperty("") ? e += n[""] : t.hasOwnProperty("") ? e += t[""] : null;
}, Ft = function(e = "", n = {}) {
  let t = mE(e, n.ex);
  return t = t || gE(e, n.same), t = t || vE(e, n.fwd, n.both), t = t || e, t;
}, kh = function(e) {
  return Object.entries(e).reduce((n, t) => (n[t[1]] = t[0], n), {});
}, ya = function(e = {}) {
  return {
    reversed: !0,
    // keep these two
    both: kh(e.both),
    ex: kh(e.ex),
    // swap this one in
    fwd: e.rev || {}
  };
}, Nh = /^([0-9]+)/, yE = function(e) {
  let n = {};
  return e.split("¦").forEach((t) => {
    let [r, a] = t.split(":");
    a = (a || "").split(","), a.forEach((o) => {
      n[o] = r;
    });
  }), n;
}, bE = function(e = "", n = "") {
  n = String(n);
  let t = n.match(Nh);
  if (t === null)
    return n;
  let r = Number(t[1]) || 0;
  return e.substring(0, r) + n.replace(Nh, "");
}, Ao = function(e) {
  let n = yE(e);
  return Object.keys(n).reduce((t, r) => (t[r] = bE(r, n[r]), t), {});
}, Mr = function(e = {}) {
  return typeof e == "string" && (e = JSON.parse(e)), e.fwd = Ao(e.fwd || ""), e.both = Ao(e.both || ""), e.rev = Ao(e.rev || ""), e.ex = Ao(e.ex || ""), e;
}, eg = Mr(Fr.PastTense), tg = Mr(Fr.PresentTense), ng = Mr(Fr.Gerund), rg = Mr(Fr.Participle), xE = ya(eg), wE = ya(tg), CE = ya(ng), kE = ya(rg), ag = Mr(Fr.Comparative), og = Mr(Fr.Superlative), NE = ya(ag), AE = ya(og), IE = Mr(Fr.AdjToNoun), ig = {
  fromPast: eg,
  fromPresent: tg,
  fromGerund: ng,
  fromParticiple: rg,
  toPast: xE,
  toPresent: wE,
  toGerund: CE,
  toParticiple: kE,
  // adjectives
  toComparative: ag,
  toSuperlative: og,
  fromComparative: NE,
  fromSuperlative: AE,
  adjToNoun: IE
}, EE = [
  //web tags
  [/^[\w.]+@[\w.]+\.[a-z]{2,3}$/, "Email"],
  [/^(https?:\/\/|www\.)+\w+\.[a-z]{2,3}/, "Url", "http.."],
  [/^[a-z0-9./].+\.(com|net|gov|org|ly|edu|info|biz|dev|ru|jp|de|in|uk|br|io|ai)/, "Url", ".com"],
  // timezones
  [/^[PMCE]ST$/, "Timezone", "EST"],
  //names
  [/^ma?c'[a-z]{3}/, "LastName", "mc'neil"],
  [/^o'[a-z]{3}/, "LastName", "o'connor"],
  [/^ma?cd[aeiou][a-z]{3}/, "LastName", "mcdonald"],
  //slang things
  [/^(lol)+[sz]$/, "Expression", "lol"],
  [/^wo{2,}a*h?$/, "Expression", "wooah"],
  [/^(hee?){2,}h?$/, "Expression", "hehe"],
  [/^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/, "Verb", "un-vite"],
  // m/h
  [/^(m|k|cm|km)\/(s|h|hr)$/, "Unit", "5 k/m"],
  // μg/g
  [/^(ug|ng|mg)\/(l|m3|ft3)$/, "Unit", "ug/L"],
  // love/hate
  [new RegExp("[^:/]\\/\\p{Letter}", "u"), "SlashedTerm", "love/hate"]
], TE = [
  // #coolguy
  [new RegExp("^#[\\p{Number}_]*\\p{Letter}", "u"), "HashTag"],
  // can't be all numbers
  // @spencermountain
  [/^@\w{2,}$/, "AtMention"],
  // period-ones acronyms - f.b.i.
  [/^([A-Z]\.){2}[A-Z]?/i, ["Acronym", "Noun"], "F.B.I"],
  //ascii-only
  // ending-apostrophes
  [/.{3}[lkmnp]in['‘’‛‵′`´]$/, "Gerund", "chillin'"],
  [/.{4}s['‘’‛‵′`´]$/, "Possessive", "flanders'"],
  //from https://www.regextester.com/106421
  // [/^([\u00a9\u00ae\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, 'Emoji', 'emoji-range']
  // unicode character range
  [/^[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u, "Emoji", "emoji-class"]
], PE = [
  [/^@1?[0-9](am|pm)$/i, "Time", "3pm"],
  [/^@1?[0-9]:[0-9]{2}(am|pm)?$/i, "Time", "3:30pm"],
  [/^'[0-9]{2}$/, "Year"],
  // times
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/, "Time", "3:12:31"],
  [/^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i, "Time", "1:12pm"],
  [/^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i, "Time", "1:12:31pm"],
  //can remove?
  // iso-dates
  [/^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i, "Date", "iso-date"],
  [/^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/, "Date", "iso-dash"],
  [/^[0-9]{1,4}\/[0-9]{1,2}\/([0-9]{4}|[0-9]{2})$/, "Date", "iso-slash"],
  [/^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/, "Date", "iso-dot"],
  [/^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i, "Date", "12-dec-2019"],
  // timezones
  [/^utc ?[+-]?[0-9]+$/, "Timezone", "utc-9"],
  [/^(gmt|utc)[+-][0-9]{1,2}$/i, "Timezone", "gmt-3"],
  //phone numbers
  [/^[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "421-0029"],
  [/^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/, "PhoneNumber", "1-800-"],
  //money
  //like $5.30
  [new RegExp("^[-+]?\\p{Currency_Symbol}[-+]?[0-9]+(,[0-9]{3})*(\\.[0-9]+)?([kmb]|bn)?\\+?$", "u"), ["Money", "Value"], "$5.30"],
  //like 5.30$
  [new RegExp("^[-+]?[0-9]+(,[0-9]{3})*(\\.[0-9]+)?\\p{Currency_Symbol}\\+?$", "u"), ["Money", "Value"], "5.30£"],
  //like
  [/^[-+]?[$£]?[0-9]([0-9,.])+(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i, ["Money", "Value"], "$400usd"],
  //numbers
  // 50 | -50 | 3.23  | 5,999.0  | 10+
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/, ["Cardinal", "NumericValue"], "5,999"],
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/, ["Ordinal", "NumericValue"], "53rd"],
  // .73th
  [/^\.[0-9]+\+?$/, ["Cardinal", "NumericValue"], ".73th"],
  //percent
  [/^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/, ["Percent", "Cardinal", "NumericValue"], "-4%"],
  [/^\.[0-9]+%$/, ["Percent", "Cardinal", "NumericValue"], ".3%"],
  //fraction
  [/^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/, ["Fraction", "NumericValue"], "2/3rds"],
  //range
  [/^[0-9.]{1,3}[a-z]{0,2}[-–—][0-9]{1,3}[a-z]{0,2}$/, ["Value", "NumberRange"], "3-4"],
  //time-range
  [/^[0-9]{1,2}(:[0-9][0-9])?(am|pm)? ?[-–—] ?[0-9]{1,2}(:[0-9][0-9])?(am|pm)$/, ["Time", "NumberRange"], "3-4pm"],
  //number with unit
  [/^[0-9.]+([a-z°]{1,4})$/, "NumericValue", "9km"]
], SE = [
  "academy",
  "administration",
  "agence",
  "agences",
  "agencies",
  "agency",
  "airlines",
  "airways",
  "army",
  "assoc",
  "associates",
  "association",
  "assurance",
  "authority",
  "autorite",
  "aviation",
  "bank",
  "banque",
  "board",
  "boys",
  "brands",
  "brewery",
  "brotherhood",
  "brothers",
  "bureau",
  "cafe",
  "co",
  "caisse",
  "capital",
  "care",
  "cathedral",
  "center",
  "centre",
  "chemicals",
  "choir",
  "chronicle",
  "church",
  "circus",
  "clinic",
  "clinique",
  "club",
  "co",
  "coalition",
  "coffee",
  "collective",
  "college",
  "commission",
  "committee",
  "communications",
  "community",
  "company",
  "comprehensive",
  "computers",
  "confederation",
  "conference",
  "conseil",
  "consulting",
  "containers",
  "corporation",
  "corps",
  "corp",
  "council",
  "crew",
  "data",
  "departement",
  "department",
  "departments",
  "design",
  "development",
  "directorate",
  "division",
  "drilling",
  "education",
  "eglise",
  "electric",
  "electricity",
  "energy",
  "ensemble",
  "enterprise",
  "enterprises",
  "entertainment",
  "estate",
  "etat",
  "faculty",
  "faction",
  "federation",
  "financial",
  "fm",
  "foundation",
  "fund",
  "gas",
  "gazette",
  "girls",
  "government",
  "group",
  "guild",
  "herald",
  "holdings",
  "hospital",
  "hotel",
  "hotels",
  "inc",
  "industries",
  "institut",
  "institute",
  "institutes",
  "insurance",
  "international",
  "interstate",
  "investment",
  "investments",
  "investors",
  "journal",
  "laboratory",
  "labs",
  "llc",
  "ltd",
  "limited",
  "machines",
  "magazine",
  "management",
  "marine",
  "marketing",
  "markets",
  "media",
  "memorial",
  "ministere",
  "ministry",
  "military",
  "mobile",
  "motor",
  "motors",
  "musee",
  "museum",
  "news",
  "observatory",
  "office",
  "oil",
  "optical",
  "orchestra",
  "organization",
  "partners",
  "partnership",
  "petrol",
  "petroleum",
  "pharmacare",
  "pharmaceutical",
  "pharmaceuticals",
  "pizza",
  "plc",
  "police",
  "politburo",
  "polytechnic",
  "post",
  "power",
  "press",
  "productions",
  "quartet",
  "radio",
  "reserve",
  "resources",
  "restaurant",
  "restaurants",
  "savings",
  "school",
  "securities",
  "service",
  "services",
  "societe",
  "subsidiary",
  "society",
  "sons",
  // 'standard',
  "subcommittee",
  "syndicat",
  "systems",
  "telecommunications",
  "telegraph",
  "television",
  "times",
  "tribunal",
  "tv",
  "union",
  "university",
  "utilities",
  "workers"
].reduce((e, n) => (e[n] = !0, e), {}), DE = [
  // geology
  "atoll",
  "basin",
  "bay",
  "beach",
  "bluff",
  "bog",
  "camp",
  "canyon",
  "canyons",
  "cape",
  "cave",
  "caves",
  // 'cliff',
  "cliffs",
  "coast",
  "cove",
  "coves",
  "crater",
  "crossing",
  "creek",
  "desert",
  "dune",
  "dunes",
  "downs",
  "estates",
  "escarpment",
  "estuary",
  "falls",
  "fjord",
  "fjords",
  "forest",
  "forests",
  "glacier",
  "gorge",
  "gorges",
  "grove",
  "gulf",
  "gully",
  "highland",
  "heights",
  "hollow",
  "hill",
  "hills",
  "inlet",
  "island",
  "islands",
  "isthmus",
  "junction",
  "knoll",
  "lagoon",
  "lake",
  "lakeshore",
  "marsh",
  "marshes",
  "mount",
  "mountain",
  "mountains",
  "narrows",
  "peninsula",
  "plains",
  "plateau",
  "pond",
  "rapids",
  "ravine",
  "reef",
  "reefs",
  "ridge",
  // 'river delta',
  "river",
  "rivers",
  "sandhill",
  "shoal",
  "shore",
  "shoreline",
  "shores",
  "strait",
  "straits",
  "springs",
  "stream",
  "swamp",
  "tombolo",
  "trail",
  "trails",
  "trench",
  "valley",
  "vallies",
  "village",
  "volcano",
  "waterfall",
  "watershed",
  "wetland",
  "woods",
  "acres",
  // districts
  "burough",
  "county",
  "district",
  "municipality",
  "prefecture",
  "province",
  "region",
  "reservation",
  "state",
  "territory",
  "borough",
  "metropolis",
  "downtown",
  "uptown",
  "midtown",
  "city",
  "town",
  "township",
  "hamlet",
  "country",
  "kingdom",
  "enclave",
  "neighbourhood",
  "neighborhood",
  "kingdom",
  "ward",
  "zone",
  // 'range',
  //building/ complex
  "airport",
  "amphitheater",
  "arch",
  "arena",
  "auditorium",
  "bar",
  "barn",
  "basilica",
  "battlefield",
  "bridge",
  "building",
  "castle",
  "centre",
  "coliseum",
  "cineplex",
  "complex",
  "dam",
  "farm",
  "field",
  "fort",
  "garden",
  "gardens",
  // 'grounds',
  "gymnasium",
  "hall",
  "house",
  "levee",
  "library",
  "manor",
  "memorial",
  "monument",
  "museum",
  "gallery",
  "palace",
  "pillar",
  "pits",
  // 'pit',
  // 'place',
  // 'point',
  // 'room',
  "plantation",
  "playhouse",
  "quarry",
  // 'ruins',
  "sportsfield",
  "sportsplex",
  "stadium",
  // 'statue',
  "terrace",
  "terraces",
  "theater",
  "tower",
  "park",
  "parks",
  "site",
  "ranch",
  "raceway",
  "sportsplex",
  // 'sports centre',
  // 'sports field',
  // 'soccer complex',
  // 'soccer centre',
  // 'sports complex',
  // 'civic centre',
  // roads
  "ave",
  "st",
  "street",
  "rd",
  "road",
  "lane",
  "landing",
  "crescent",
  "cr",
  "way",
  "tr",
  "terrace",
  "avenue"
].reduce((e, n) => (e[n] = !0, e), {}), Io = [
  [/([^v])ies$/i, "$1y"],
  [/(ise)s$/i, "$1"],
  //promises
  [/(kn|[^o]l|w)ives$/i, "$1ife"],
  [/^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i, "$1f"],
  [/^(dwar|handkerchie|hoo|scar|whar)ves$/i, "$1f"],
  [/(antenn|formul|nebul|vertebr|vit)ae$/i, "$1a"],
  [/(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i, "$1us"],
  [/(buffal|tomat|tornad)(oes)$/i, "$1o"],
  [/(ause)s$/i, "$1"],
  //causes
  [/(ease)s$/i, "$1"],
  //diseases
  [/(ious)es$/i, "$1"],
  //geniouses
  [/(ouse)s$/i, "$1"],
  //houses
  [/(ose)s$/i, "$1"],
  //roses
  [/(..ase)s$/i, "$1"],
  [/(..[aeiu]s)es$/i, "$1"],
  [/(vert|ind|cort)(ices)$/i, "$1ex"],
  [/(matr|append)(ices)$/i, "$1ix"],
  [/([xo]|ch|ss|sh)es$/i, "$1"],
  [/men$/i, "man"],
  [/(n)ews$/i, "$1ews"],
  [/([ti])a$/i, "$1um"],
  [/([^aeiouy]|qu)ies$/i, "$1y"],
  [/(s)eries$/i, "$1eries"],
  [/(m)ovies$/i, "$1ovie"],
  [/(cris|ax|test)es$/i, "$1is"],
  [/(alias|status)es$/i, "$1"],
  [/(ss)$/i, "$1"],
  [/(ic)s$/i, "$1"],
  [/s$/i, ""]
], OE = function(e) {
  return Object.keys(e).reduce((n, t) => (n[e[t]] = t, n), {});
}, sg = function(e, n) {
  const { irregularPlurals: t } = n.two;
  let r = OE(t);
  if (r.hasOwnProperty(e))
    return r[e];
  for (let a = 0; a < Io.length; a++)
    if (Io[a][0].test(e) === !0)
      return e = e.replace(Io[a][0], Io[a][1]), e;
  return e;
}, RE = function(e, n) {
  let t = [e], r = Ei(e, n);
  r !== e && t.push(r);
  let a = sg(e, n);
  return a !== e && t.push(a), t;
}, FE = { toPlural: Ei, toSingular: sg, all: RE };
let xr = {
  Gerund: ["ing"],
  Actor: ["erer"],
  Infinitive: [
    "ate",
    "ize",
    "tion",
    "rify",
    "then",
    "ress",
    "ify",
    "age",
    "nce",
    "ect",
    "ise",
    "ine",
    "ish",
    "ace",
    "ash",
    "ure",
    "tch",
    "end",
    "ack",
    "and",
    "ute",
    "ade",
    "ock",
    "ite",
    "ase",
    "ose",
    "use",
    "ive",
    "int",
    "nge",
    "lay",
    "est",
    "ain",
    "ant",
    "ent",
    "eed",
    "er",
    "le",
    "unk",
    "ung",
    "upt",
    "en"
  ],
  PastTense: ["ept", "ed", "lt", "nt", "ew", "ld"],
  PresentTense: [
    "rks",
    "cks",
    "nks",
    "ngs",
    "mps",
    "tes",
    "zes",
    "ers",
    "les",
    "acks",
    "ends",
    "ands",
    "ocks",
    "lays",
    "eads",
    "lls",
    "els",
    "ils",
    "ows",
    "nds",
    "ays",
    "ams",
    "ars",
    "ops",
    "ffs",
    "als",
    "urs",
    "lds",
    "ews",
    "ips",
    "es",
    "ts",
    "ns"
  ],
  Participle: ["ken", "wn"]
};
xr = Object.keys(xr).reduce((e, n) => (xr[n].forEach((t) => e[t] = n), e), {});
const ug = function(e) {
  let n = e.substring(e.length - 3);
  if (xr.hasOwnProperty(n) === !0)
    return xr[n];
  let t = e.substring(e.length - 2);
  return xr.hasOwnProperty(t) === !0 ? xr[t] : e.substring(e.length - 1) === "s" ? "PresentTense" : null;
}, ME = function(e, n) {
  let t = "", r = {};
  n.one && n.one.prefixes && (r = n.one.prefixes);
  let [a, o] = e.split(/ /);
  return o && r[a] === !0 && (t = a, a = o, o = ""), {
    prefix: t,
    verb: a,
    particle: o
  };
}, Ah = {
  are: "be",
  were: "be",
  been: "be",
  is: "be",
  am: "be",
  was: "be",
  be: "be",
  being: "be"
}, hu = function(e, n, t) {
  const { fromPast: r, fromPresent: a, fromGerund: o, fromParticiple: i } = n.two.models;
  let { prefix: s, verb: u, particle: l } = ME(e, n), c = "";
  if (t || (t = ug(e)), Ah.hasOwnProperty(e))
    c = Ah[e];
  else if (t === "Participle")
    c = Ft(u, i);
  else if (t === "PastTense")
    c = Ft(u, r);
  else if (t === "PresentTense")
    c = Ft(u, a);
  else if (t === "Gerund")
    c = Ft(u, o);
  else
    return e;
  return l && (c += " " + l), s && (c = s + " " + c), c;
}, _E = (e) => / /.test(e) ? e.split(/ /) : [e, ""], Cl = function(e, n) {
  const { toPast: t, toPresent: r, toGerund: a, toParticiple: o } = n.two.models;
  if (e === "be")
    return {
      Infinitive: e,
      Gerund: "being",
      PastTense: "was",
      PresentTense: "is"
    };
  let [i, s] = _E(e), u = {
    Infinitive: i,
    PastTense: Ft(i, t),
    PresentTense: Ft(i, r),
    Gerund: Ft(i, a),
    FutureTense: "will " + i
  }, l = Ft(i, o);
  if (l !== e && l !== u.PastTense) {
    let c = n.one.lexicon || {};
    (c[l] === "Participle" || c[l] === "Adjective") && (e === "play" && (l = "played"), u.Participle = l);
  }
  return s && Object.keys(u).forEach((c) => {
    u[c] += " " + s;
  }), u;
}, BE = function(e, n) {
  let t = Cl(e, n);
  return delete t.FutureTense, Object.values(t).filter((r) => r);
}, jE = {
  toInfinitive: hu,
  conjugate: Cl,
  all: BE
}, kl = function(e, n) {
  const t = n.two.models.toSuperlative;
  return Ft(e, t);
}, Nl = function(e, n) {
  const t = n.two.models.toComparative;
  return Ft(e, t);
}, VE = function(e, n) {
  const t = n.two.models.fromComparative;
  return Ft(e, t);
}, LE = function(e, n) {
  const t = n.two.models.fromSuperlative;
  return Ft(e, t);
}, zE = function(e, n) {
  const t = n.two.models.adjToNoun;
  return Ft(e, t);
}, lg = function(e = "", n = []) {
  const t = e.length;
  let r = t <= 6 ? t - 1 : 6;
  for (let a = r; a >= 1; a -= 1) {
    let o = e.substring(t - a, e.length);
    if (n[o.length].hasOwnProperty(o) === !0) {
      let i = e.slice(0, t - a), s = n[o.length][o];
      return i + s;
    }
  }
  return null;
}, xe = "ically", GE = /* @__PURE__ */ new Set([
  "analyt" + xe,
  //analytical
  "chem" + xe,
  // chemical
  "class" + xe,
  //classical
  "clin" + xe,
  // clinical
  "crit" + xe,
  // critical
  "ecolog" + xe,
  // ecological
  "electr" + xe,
  // electrical
  "empir" + xe,
  // empirical
  "frant" + xe,
  // frantical
  "grammat" + xe,
  // grammatical
  "ident" + xe,
  // identical
  "ideolog" + xe,
  // ideological
  "log" + xe,
  // logical
  "mag" + xe,
  //magical
  "mathemat" + xe,
  // mathematical
  "mechan" + xe,
  // mechanical
  "med" + xe,
  // medical
  "method" + xe,
  // methodical
  "method" + xe,
  // methodical
  "mus" + xe,
  // musical
  "phys" + xe,
  // physical
  "phys" + xe,
  // physical
  "polit" + xe,
  // political
  "pract" + xe,
  // practical
  "rad" + xe,
  //radical
  "satir" + xe,
  // satirical
  "statist" + xe,
  // statistical
  "techn" + xe,
  // technical
  "technolog" + xe,
  // technological
  "theoret" + xe,
  // theoretical
  "typ" + xe,
  // typical
  "vert" + xe,
  // vertical
  "whims" + xe
  // whimsical
]), HE = [
  null,
  {},
  { ly: "" },
  {
    ily: "y",
    bly: "ble",
    ply: "ple"
  },
  {
    ally: "al",
    rply: "rp"
  },
  {
    ually: "ual",
    ially: "ial",
    cally: "cal",
    eally: "eal",
    rally: "ral",
    nally: "nal",
    mally: "mal",
    eeply: "eep",
    eaply: "eap"
  },
  {
    ically: "ic"
  }
], WE = /* @__PURE__ */ new Set([
  "early",
  "only",
  "hourly",
  "daily",
  "weekly",
  "monthly",
  "yearly",
  "mostly",
  "duly",
  "unduly",
  "especially",
  "undoubtedly",
  "conversely",
  "namely",
  "exceedingly",
  "presumably",
  "accordingly",
  "overly",
  "best",
  "latter",
  "little",
  "long",
  "low"
]), Ih = {
  wholly: "whole",
  fully: "full",
  truly: "true",
  gently: "gentle",
  singly: "single",
  customarily: "customary",
  idly: "idle",
  publically: "public",
  quickly: "quick",
  superbly: "superb",
  cynically: "cynical",
  well: "good"
  // -?
}, $E = function(e) {
  return e.endsWith("ly") ? GE.has(e) ? e.replace(/ically/, "ical") : WE.has(e) ? null : Ih.hasOwnProperty(e) ? Ih[e] : lg(e, HE) || e : null;
}, UE = [
  null,
  {
    y: "ily"
  },
  {
    ly: "ly",
    //unchanged
    ic: "ically"
  },
  {
    ial: "ially",
    ual: "ually",
    tle: "tly",
    ble: "bly",
    ple: "ply",
    ary: "arily"
  },
  {},
  {},
  {}
], Eh = {
  cool: "cooly",
  whole: "wholly",
  full: "fully",
  good: "well",
  idle: "idly",
  public: "publicly",
  single: "singly",
  special: "especially"
}, cg = function(e) {
  if (Eh.hasOwnProperty(e))
    return Eh[e];
  let n = lg(e, UE);
  return n || (n = e + "ly"), n;
}, KE = function(e, n) {
  let t = [e];
  return t.push(kl(e, n)), t.push(Nl(e, n)), t.push(cg(e)), t = t.filter((r) => r), t = new Set(t), Array.from(t);
}, qE = {
  toSuperlative: kl,
  toComparative: Nl,
  toAdverb: cg,
  toNoun: zE,
  fromAdverb: $E,
  fromSuperlative: LE,
  fromComparative: VE,
  all: KE
}, JE = {
  noun: FE,
  verb: jE,
  adjective: qE
}, Th = {
  // add plural forms of singular nouns
  Singular: (e, n, t, r) => {
    let a = r.one.lexicon, o = t.two.transform.noun.toPlural(e, r);
    a[o] || (n[o] = n[o] || "Plural");
  },
  // 'lawyer', 'manager' plural forms
  Actor: (e, n, t, r) => {
    let a = r.one.lexicon, o = t.two.transform.noun.toPlural(e, r);
    a[o] || (n[o] = n[o] || ["Plural", "Actor"]);
  },
  // superlative/ comparative forms for adjectives
  Comparable: (e, n, t, r) => {
    let a = r.one.lexicon, { toSuperlative: o, toComparative: i } = t.two.transform.adjective, s = o(e, r);
    a[s] || (n[s] = n[s] || "Superlative");
    let u = i(e, r);
    a[u] || (n[u] = n[u] || "Comparative"), n[e] = "Adjective";
  },
  // 'german' -> 'germans'
  Demonym: (e, n, t, r) => {
    let a = t.two.transform.noun.toPlural(e, r);
    n[a] = n[a] || ["Demonym", "Plural"];
  },
  // conjugate all forms of these verbs
  Infinitive: (e, n, t, r) => {
    let a = r.one.lexicon, o = t.two.transform.verb.conjugate(e, r);
    Object.entries(o).forEach((i) => {
      !a[i[1]] && !n[i[1]] && i[0] !== "FutureTense" && (n[i[1]] = i[0]);
    });
  },
  // 'walk up' should conjugate, too
  PhrasalVerb: (e, n, t, r) => {
    let a = r.one.lexicon;
    n[e] = ["PhrasalVerb", "Infinitive"];
    let o = r.one._multiCache, [i, s] = e.split(" ");
    a[i] || (n[i] = n[i] || "Infinitive");
    let u = t.two.transform.verb.conjugate(i, r);
    delete u.FutureTense, Object.entries(u).forEach((l) => {
      if (l[0] === "Actor" || l[1] === "")
        return;
      !n[l[1]] && !a[l[1]] && (n[l[1]] = l[0]), o[l[1]] = 2;
      let c = l[1] + " " + s;
      n[c] = n[c] || [l[0], "PhrasalVerb"];
    });
  },
  // expand 'million'
  Multiple: (e, n) => {
    n[e] = ["Multiple", "Cardinal"], n[e + "th"] = ["Multiple", "Ordinal"], n[e + "ths"] = ["Multiple", "Fraction"];
  },
  // expand number-words
  Cardinal: (e, n) => {
    n[e] = ["TextValue", "Cardinal"];
  },
  // 'millionth'
  Ordinal: (e, n) => {
    n[e] = ["TextValue", "Ordinal"], n[e + "s"] = ["TextValue", "Fraction"];
  },
  // 'thames'
  Place: (e, n) => {
    n[e] = ["Place", "ProperNoun"];
  },
  // 'ontario'
  Region: (e, n) => {
    n[e] = ["Region", "ProperNoun"];
  }
}, XE = function(e, n) {
  const { methods: t, model: r } = n;
  let a = {}, o = {};
  return Object.keys(e).forEach((i) => {
    let s = e[i];
    i = i.toLowerCase().trim(), i = i.replace(/'s\b/, "");
    let u = i.split(/ /);
    u.length > 1 && (o[u[0]] === void 0 || u.length > o[u[0]]) && (o[u[0]] = u.length), Th.hasOwnProperty(s) === !0 && Th[s](i, a, t, r), a[i] = a[i] || s;
  }), delete a[""], delete a[null], delete a[" "], { lex: a, _multi: o };
}, QE = function(e, n) {
  const t = /^[0-9]+$/;
  let r = e[n];
  if (!r)
    return !1;
  const a = /* @__PURE__ */ new Set(["may", "april", "august", "jan"]);
  if (r.normal === "like" || a.has(r.normal) || r.tags.has("Place") || r.tags.has("Date"))
    return !1;
  if (e[n - 1]) {
    let i = e[n - 1];
    if (i.tags.has("Date") || a.has(i.normal) || i.tags.has("Adjective") || r.tags.has("Adjective"))
      return !1;
  }
  let o = r.normal;
  return !((o.length === 1 || o.length === 2 || o.length === 4) && t.test(o));
}, YE = function(e) {
  const n = /[,:;]/;
  let t = [];
  return e.forEach((r) => {
    let a = 0;
    r.forEach((o, i) => {
      n.test(o.post) && QE(r, i + 1) && (t.push(r.slice(a, i + 1)), a = i + 1);
    }), a < r.length && t.push(r.slice(a, r.length));
  }), t;
}, Ph = {
  e: ["mice", "louse", "antennae", "formulae", "nebulae", "vertebrae", "vitae"],
  i: ["tia", "octopi", "viri", "radii", "nuclei", "fungi", "cacti", "stimuli"],
  n: ["men"],
  t: ["feet"]
}, ZE = /* @__PURE__ */ new Set([
  // 'formulas',
  // 'umbrellas',
  // 'gorillas',
  // 'koalas',
  "israelis",
  "menus",
  "logos"
]), e3 = [
  "bus",
  "mas",
  //christmas
  "was",
  // 'las',
  "ias",
  //alias
  "xas",
  "vas",
  "cis",
  //probocis
  "lis",
  "nis",
  //tennis
  "ois",
  "ris",
  "sis",
  //thesis
  "tis",
  //mantis, testis
  "xis",
  "aus",
  "cus",
  "eus",
  //nucleus
  "fus",
  //doofus
  "gus",
  //fungus
  "ius",
  //radius
  "lus",
  //stimulus
  "nus",
  "das",
  "ous",
  "pus",
  //octopus
  "rus",
  //virus
  "sus",
  //census
  "tus",
  //status,cactus
  "xus",
  "aos",
  //chaos
  "igos",
  "ados",
  //barbados
  "ogos",
  "'s",
  "ss"
], hg = function(e) {
  if (!e || e.length <= 3)
    return !1;
  if (ZE.has(e))
    return !0;
  let n = e[e.length - 1];
  return Ph.hasOwnProperty(n) ? Ph[n].find((t) => e.endsWith(t)) : !(n !== "s" || e3.find((t) => e.endsWith(t)));
}, du = {
  two: {
    quickSplit: YE,
    expandLexicon: XE,
    transform: JE,
    looksPlural: hg
  }
}, t3 = function(e) {
  const { irregularPlurals: n } = e.two, { lexicon: t } = e.one;
  return Object.entries(n).forEach((r) => {
    t[r[0]] = t[r[0]] || "Singular", t[r[1]] = t[r[1]] || "Plural";
  }), e;
};
let pu = {
  one: { lexicon: {} },
  two: { models: ig }
};
const n3 = {
  // 'pilot'
  "Actor|Verb": "Actor",
  //
  // 'amusing'
  "Adj|Gerund": "Adjective",
  //+conjugations
  // 'standard'
  "Adj|Noun": "Adjective",
  // 'boiled'
  "Adj|Past": "Adjective",
  //+conjugations
  // 'smooth'
  "Adj|Present": "Adjective",
  //+conjugations
  // 'box'
  "Noun|Verb": "Singular",
  //+conjugations (no-present)
  //'singing'
  "Noun|Gerund": "Gerund",
  //+conjugations
  // 'hope'
  "Person|Noun": "Noun",
  // 'April'
  "Person|Date": "Month",
  // 'rob'
  "Person|Verb": "FirstName",
  //+conjugations
  // 'victoria'
  "Person|Place": "Person",
  // 'rusty'
  "Person|Adj": "Comparative",
  // 'boxes'
  "Plural|Verb": "Plural",
  //(these are already derivative)
  // 'miles'
  "Unit|Noun": "Noun"
}, dg = function(e, n) {
  const t = { model: n, methods: du };
  let { lex: r, _multi: a } = du.two.expandLexicon(e, t);
  return Object.assign(n.one.lexicon, r), Object.assign(n.one._multiCache, a), n;
}, r3 = function(e, n) {
  return Object.keys(e).forEach((t) => {
    e[t] === "Uncountable" && (n.two.uncountable[t] = !0, e[t] = "Uncountable");
  }), n;
}, Sh = function(e, n, t) {
  let r = Cl(e, pu);
  n[r.PastTense] = n[r.PastTense] || "PastTense", n[r.Gerund] = n[r.Gerund] || "Gerund", t === !0 && (n[r.PresentTense] = n[r.PresentTense] || "PresentTense");
}, Dh = function(e, n, t) {
  let r = kl(e, t);
  n[r] = n[r] || "Superlative";
  let a = Nl(e, t);
  n[a] = n[a] || "Comparative";
}, a3 = function(e, n, t) {
  let r = Ei(e, t);
  n[r] = n[r] || "Plural";
}, o3 = function(e, n) {
  let t = {};
  const r = n.one.lexicon;
  return Object.keys(e).forEach((a) => {
    const o = e[a];
    if (t[a] = n3[o], (o === "Noun|Verb" || o === "Person|Verb" || o === "Actor|Verb") && Sh(a, r, !1), o === "Adj|Present" && (Sh(a, r, !0), Dh(a, r, n)), o === "Person|Adj" && Dh(a, r, n), o === "Adj|Gerund" || o === "Noun|Gerund") {
      let i = hu(a, pu, "Gerund");
      r[i] || (t[i] = "Infinitive");
    }
    if ((o === "Noun|Gerund" || o === "Adj|Noun" || o === "Person|Noun") && a3(a, r, n), o === "Adj|Past") {
      let i = hu(a, pu, "PastTense");
      r[i] || (t[i] = "Infinitive");
    }
  }), n = dg(t, n), n;
}, i3 = function(e) {
  return e = dg(e.one.lexicon, e), e = r3(e.one.lexicon, e), e = o3(e.two.switches, e), e = t3(e), e;
};
let fu = {
  one: {
    _multiCache: {},
    lexicon: va,
    frozenLex: HI
  },
  two: {
    irregularPlurals: Zm,
    models: ig,
    suffixPatterns: hE,
    prefixPatterns: dE,
    endsWith: pE,
    neighbours: fE,
    regexNormal: EE,
    regexText: TE,
    regexNumbers: PE,
    switches: cu,
    clues: ta,
    uncountable: {},
    orgWords: SE,
    placeWords: DE
  }
};
fu = i3(fu);
const s3 = function(e, n, t, r) {
  const a = r.methods.one.setTag;
  if (e.length >= 3) {
    const o = /:/;
    if (e[0].post.match(o)) {
      let s = e[1];
      if (s.tags.has("Value") || s.tags.has("Email") || s.tags.has("PhoneNumber"))
        return;
      a([e[0]], "Expression", r, null, "2-punct-colon''");
    }
  }
}, u3 = function(e, n, t, r) {
  const a = r.methods.one.setTag;
  e[n].post === "-" && e[n + 1] && a([e[n], e[n + 1]], "Hyphenated", r, null, "1-punct-hyphen''");
}, Oh = /^(under|over|mis|re|un|dis|semi)-?/, l3 = function(e, n, t) {
  const r = t.two.switches;
  let a = e[n];
  if (r.hasOwnProperty(a.normal)) {
    a.switch = r[a.normal];
    return;
  }
  if (Oh.test(a.normal)) {
    let o = a.normal.replace(Oh, "");
    o.length > 3 && r.hasOwnProperty(o) && (a.switch = r[o]);
  }
}, c3 = (e, n, t = "") => {
  const r = (i) => "\x1B[33m\x1B[3m" + i + "\x1B[0m", a = (i) => "\x1B[3m" + i + "\x1B[0m";
  let o = e.text || "[" + e.implicit + "]";
  typeof n != "string" && n.length > 2 && (n = n.slice(0, 2).join(", #") + " +"), n = typeof n != "string" ? n.join(", #") : n, console.log(` ${r(o).padEnd(24)} \x1B[32m→\x1B[0m #${n.padEnd(22)}  ${a(t)}`);
}, Ue = function(e, n, t) {
  if (!n || n.length === 0 || e.frozen === !0)
    return;
  const r = typeof process > "u" || !process.env ? self.env || {} : process.env;
  r && r.DEBUG_TAGS && c3(e, n, t), e.tags = e.tags || /* @__PURE__ */ new Set(), typeof n == "string" ? e.tags.add(n) : n.forEach((a) => e.tags.add(a));
}, h3 = [
  "Acronym",
  "Abbreviation",
  "ProperNoun",
  "Uncountable",
  "Possessive",
  "Pronoun",
  "Activity",
  "Honorific",
  "Month"
], d3 = function(e) {
  !e.tags.has("Noun") || e.tags.has("Plural") || e.tags.has("Singular") || h3.find((n) => e.tags.has(n)) || (hg(e.normal) ? Ue(e, "Plural", "3-plural-guess") : Ue(e, "Singular", "3-singular-guess"));
}, p3 = function(e) {
  let n = e.tags;
  if (n.has("Verb") && n.size === 1) {
    let t = ug(e.normal);
    t && Ue(e, t, "3-verb-tense-guess");
  }
}, no = function(e, n, t) {
  let r = e[n], a = Array.from(r.tags);
  for (let o = 0; o < a.length; o += 1)
    if (t.one.tagSet[a[o]]) {
      let i = t.one.tagSet[a[o]].parents;
      Ue(r, i, ` -inferred by #${a[o]}`);
    }
  d3(r), p3(r);
}, f3 = new RegExp("^\\p{Lu}[\\p{Ll}'’]", "u"), m3 = /[0-9]/, g3 = ["Date", "Month", "WeekDay", "Unit", "Expression"], v3 = /[IVX]/, y3 = /^[IVXLCDM]{2,}$/, b3 = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/, x3 = {
  li: !0,
  dc: !0,
  md: !0,
  dm: !0,
  ml: !0
}, w3 = function(e, n, t) {
  let r = e[n];
  r.index = r.index || [0, 0];
  let a = r.index[1], o = r.text || "";
  return a !== 0 && f3.test(o) === !0 && m3.test(o) === !1 ? g3.find((i) => r.tags.has(i)) || r.pre.match(/["']$/) || r.normal === "the" ? null : (no(e, n, t), !r.tags.has("Noun") && !r.frozen && r.tags.clear(), Ue(r, "ProperNoun", "2-titlecase"), !0) : o.length >= 2 && y3.test(o) && v3.test(o) && b3.test(o) && !x3[r.normal] ? (Ue(r, "RomanNumeral", "2-xvii"), !0) : null;
}, Rh = function(e = "", n = []) {
  const t = e.length;
  let r = 7;
  t <= r && (r = t - 1);
  for (let a = r; a > 1; a -= 1) {
    let o = e.substring(t - a, t);
    if (n[o.length].hasOwnProperty(o) === !0)
      return n[o.length][o];
  }
  return null;
}, C3 = function(e, n, t) {
  let r = e[n];
  if (r.tags.size === 0) {
    let a = Rh(r.normal, t.two.suffixPatterns);
    if (a !== null)
      return Ue(r, a, "2-suffix"), r.confidence = 0.7, !0;
    if (r.implicit && (a = Rh(r.implicit, t.two.suffixPatterns), a !== null))
      return Ue(r, a, "2-implicit-suffix"), r.confidence = 0.7, !0;
  }
  return null;
}, Fh = /['‘’‛‵′`´]/, ps = function(e, n) {
  for (let t = 0; t < n.length; t += 1)
    if (n[t][0].test(e) === !0)
      return n[t];
  return null;
}, k3 = function(e = "", n) {
  let t = e[e.length - 1];
  if (n.hasOwnProperty(t) === !0) {
    let r = n[t] || [];
    for (let a = 0; a < r.length; a += 1)
      if (r[a][0].test(e) === !0)
        return r[a];
  }
  return null;
}, N3 = function(e, n, t, r) {
  const a = r.methods.one.setTag;
  let { regexText: o, regexNormal: i, regexNumbers: s, endsWith: u } = t.two, l = e[n], c = l.machine || l.normal, h = l.text;
  Fh.test(l.post) && !Fh.test(l.pre) && (h += l.post.trim());
  let d = ps(h, o) || ps(c, i);
  return !d && /[0-9]/.test(c) && (d = ps(c, s)), !d && l.tags.size === 0 && (d = k3(c, u)), d ? (a([l], d[1], r, null, `2-regex-'${d[2] || d[0]}'`), l.confidence = 0.6, !0) : null;
}, A3 = function(e = "", n = []) {
  const t = e.length;
  let r = 7;
  r > t - 3 && (r = t - 3);
  for (let a = r; a > 2; a -= 1) {
    let o = e.substring(0, a);
    if (n[o.length].hasOwnProperty(o) === !0)
      return n[o.length][o];
  }
  return null;
}, I3 = function(e, n, t) {
  let r = e[n];
  if (r.tags.size === 0) {
    let a = A3(r.normal, t.two.prefixPatterns);
    if (a !== null)
      return Ue(r, a, "2-prefix"), r.confidence = 0.5, !0;
  }
  return null;
}, E3 = 1400, T3 = 2100, P3 = /* @__PURE__ */ new Set([
  "in",
  "on",
  "by",
  "until",
  "for",
  "to",
  "during",
  "throughout",
  "through",
  "within",
  "before",
  "after",
  "of",
  "this",
  "next",
  "last",
  "circa",
  "around",
  "post",
  "pre",
  "budget",
  "classic",
  "plan",
  "may"
]), Mh = function(e) {
  if (!e)
    return !1;
  let n = e.normal || e.implicit;
  return !!(P3.has(n) || e.tags.has("Date") || e.tags.has("Month") || e.tags.has("WeekDay") || e.tags.has("Year") || e.tags.has("ProperNoun"));
}, _h = function(e) {
  return e ? !!(e.tags.has("Ordinal") || e.tags.has("Cardinal") && e.normal.length < 3 || e.normal === "is" || e.normal === "was") : !1;
}, Bh = function(e) {
  return e && (e.tags.has("Date") || e.tags.has("Month") || e.tags.has("WeekDay") || e.tags.has("Year"));
}, S3 = function(e, n) {
  const t = e[n];
  if (t.tags.has("NumericValue") && t.tags.has("Cardinal") && t.normal.length === 4) {
    let r = Number(t.normal);
    if (r && !isNaN(r) && r > E3 && r < T3) {
      let a = e[n - 1], o = e[n + 1];
      if (Mh(a) || Mh(o))
        return Ue(t, "Year", "2-tagYear");
      if (r >= 1920 && r < 2025) {
        if (_h(a) || _h(o))
          return Ue(t, "Year", "2-tagYear-close");
        if (Bh(e[n - 2]) || Bh(e[n + 2]))
          return Ue(t, "Year", "2-tagYear-far");
        if (a && (a.tags.has("Determiner") || a.tags.has("Possessive")) && o && o.tags.has("Noun") && !o.tags.has("Plural"))
          return Ue(t, "Year", "2-tagYear-noun");
      }
    }
  }
  return null;
}, D3 = function(e, n, t, r) {
  const a = r.methods.one.setTag, o = e[n], i = ["PastTense", "PresentTense", "Auxiliary", "Modal", "Particle"];
  o.tags.has("Verb") && (i.find((u) => o.tags.has(u)) || a([o], "Infinitive", r, null, "2-verb-type''"));
}, pg = /^[A-Z]('s|,)?$/, fg = /^[A-Z-]+$/, mg = /^[A-Z]+s$/, O3 = /([A-Z]\.)+[A-Z]?,?$/, R3 = /[A-Z]{2,}('s|,)?$/, F3 = /([a-z]\.)+[a-z]\.?$/, gg = {
  I: !0,
  A: !0
}, M3 = {
  la: !0,
  ny: !0,
  us: !0,
  dc: !0,
  gb: !0
}, _3 = function(e, n) {
  let t = e.text;
  if (fg.test(t) === !1)
    if (t.length > 3 && mg.test(t) === !0)
      t = t.replace(/s$/, "");
    else
      return !1;
  return t.length > 5 || gg.hasOwnProperty(t) || n.one.lexicon.hasOwnProperty(e.normal) ? !1 : O3.test(t) === !0 || F3.test(t) === !0 || pg.test(t) === !0 || R3.test(t) === !0;
}, B3 = function(e, n, t) {
  let r = e[n];
  return r.tags.has("RomanNumeral") || r.tags.has("Acronym") || r.frozen ? null : _3(r, t) ? (r.tags.clear(), Ue(r, ["Acronym", "Noun"], "3-no-period-acronym"), M3[r.normal] === !0 && Ue(r, "Place", "3-place-acronym"), mg.test(r.text) === !0 && Ue(r, "Plural", "3-plural-acronym"), !0) : !gg.hasOwnProperty(r.text) && pg.test(r.text) ? (r.tags.clear(), Ue(r, ["Acronym", "Noun"], "3-one-letter-acronym"), !0) : r.tags.has("Organization") && r.text.length <= 3 ? (Ue(r, "Acronym", "3-org-acronym"), !0) : r.tags.has("Organization") && fg.test(r.text) && r.text.length <= 6 ? (Ue(r, "Acronym", "3-titlecase-acronym"), !0) : null;
}, jh = function(e, n) {
  if (!e)
    return null;
  let t = n.find((r) => e.normal === r[0]);
  return t ? t[1] : null;
}, Vh = function(e, n) {
  if (!e)
    return null;
  let t = n.find((r) => e.tags.has(r[0]));
  return t ? t[1] : null;
}, j3 = function(e, n, t) {
  const { leftTags: r, leftWords: a, rightWords: o, rightTags: i } = t.two.neighbours;
  let s = e[n];
  if (s.tags.size === 0) {
    let u = null;
    if (u = u || jh(e[n - 1], a), u = u || jh(e[n + 1], o), u = u || Vh(e[n - 1], r), u = u || Vh(e[n + 1], i), u)
      return Ue(s, u, "3-[neighbour]"), no(e, n, t), e[n].confidence = 0.2, !0;
  }
  return null;
}, V3 = (e) => new RegExp("^\\p{Lu}[\\p{Ll}'’]", "u").test(e), Lh = function(e, n, t) {
  return !e || e.tags.has("FirstName") || e.tags.has("Place") ? !1 : e.tags.has("ProperNoun") || e.tags.has("Organization") || e.tags.has("Acronym") ? !0 : !t && V3(e.text) ? n === 0 ? e.tags.has("Singular") : !0 : !1;
}, L3 = function(e, n, t, r) {
  const a = t.model.two.orgWords, o = t.methods.one.setTag;
  let i = e[n], s = i.machine || i.normal;
  if (a[s] === !0 && Lh(e[n - 1], n - 1, r)) {
    o([e[n]], "Organization", t, null, "3-[org-word]");
    for (let u = n; u >= 0 && Lh(e[u], u, r); u -= 1)
      o([e[u]], "Organization", t, null, "3-[org-word]");
  }
  return null;
}, z3 = (e) => new RegExp("^\\p{Lu}[\\p{Ll}'’]", "u").test(e), G3 = /'s$/, zh = /* @__PURE__ */ new Set([
  "athletic",
  "city",
  "community",
  "eastern",
  "federal",
  "financial",
  "great",
  "historic",
  "historical",
  "local",
  "memorial",
  "municipal",
  "national",
  "northern",
  "provincial",
  "southern",
  "state",
  "western",
  "spring",
  "pine",
  "sunset",
  "view",
  "oak",
  "maple",
  "spruce",
  "cedar",
  "willow"
]), H3 = /* @__PURE__ */ new Set(["center", "centre", "way", "range", "bar", "bridge", "field", "pit"]), Gh = function(e, n, t) {
  if (!e)
    return !1;
  let r = e.tags;
  return r.has("Organization") || r.has("Possessive") || G3.test(e.normal) ? !1 : r.has("ProperNoun") || r.has("Place") ? !0 : !t && z3(e.text) ? n === 0 ? r.has("Singular") : !0 : !1;
}, W3 = function(e, n, t, r) {
  const a = t.model.two.placeWords, o = t.methods.one.setTag;
  let i = e[n], s = i.machine || i.normal;
  if (a[s] === !0) {
    for (let u = n - 1; u >= 0; u -= 1)
      if (!zh.has(e[u].normal)) {
        if (Gh(e[u], u, r)) {
          o(e.slice(u, n + 1), "Place", t, null, "3-[place-of-foo]");
          continue;
        }
        break;
      }
    if (H3.has(s))
      return !1;
    for (let u = n + 1; u < e.length; u += 1) {
      if (Gh(e[u], u, r))
        return o(e.slice(n, u + 1), "Place", t, null, "3-[foo-place]"), !0;
      if (!(e[u].normal === "of" || zh.has(e[u].normal)))
        break;
    }
  }
  return null;
}, $3 = function(e, n, t) {
  let r = !1, a = e[n].tags;
  (a.size === 0 || a.size === 1 && (a.has("Hyphenated") || a.has("HashTag") || a.has("Prefix") || a.has("SlashedTerm"))) && (r = !0), r && (Ue(e[n], "Noun", "3-[fallback]"), no(e, n, t), e[n].confidence = 0.1);
}, U3 = /^[A-Z][a-z]/, $t = (e, n) => e[n].tags.has("ProperNoun") && U3.test(e[n].text) ? "Noun" : null, Hh = (e, n, t) => n === 0 && !e[1] ? t : null, K3 = function(e, n) {
  return !e[n + 1] && e[n - 1] && e[n - 1].tags.has("Determiner") ? "Noun" : null;
}, q3 = function(e, n, t) {
  return n === 0 && e.length > 3 ? t : null;
}, Wh = {
  "Adj|Gerund": (e, n) => $t(e, n),
  "Adj|Noun": (e, n) => $t(e, n) || K3(e, n),
  "Actor|Verb": (e, n) => $t(e, n),
  "Adj|Past": (e, n) => $t(e, n),
  "Adj|Present": (e, n) => $t(e, n),
  "Noun|Gerund": (e, n) => $t(e, n),
  "Noun|Verb": (e, n) => n > 0 && $t(e, n) || Hh(e, n, "Infinitive"),
  "Plural|Verb": (e, n) => $t(e, n) || Hh(e, n, "PresentTense") || q3(e, n, "Plural"),
  "Person|Noun": (e, n) => $t(e, n),
  "Person|Verb": (e, n) => n !== 0 ? $t(e, n) : null,
  "Person|Adj": (e, n) => n === 0 && e.length > 1 || $t(e, n) ? "Person" : null
}, Al = typeof process > "u" || !process.env ? self.env || {} : process.env, $h = /^(under|over|mis|re|un|dis|semi)-?/, Uh = (e, n) => {
  if (!e || !n)
    return null;
  let t = e.normal || e.implicit, r = null;
  return n.hasOwnProperty(t) && (r = n[t]), r && Al.DEBUG_TAGS && console.log(`
  \x1B[2m\x1B[3m     ↓ - '${t}' \x1B[0m`), r;
}, Kh = (e, n = {}, t) => {
  if (!e || !n)
    return null;
  let a = Array.from(e.tags).sort((o, i) => {
    let s = t[o] ? t[o].parents.length : 0, u = t[i] ? t[i].parents.length : 0;
    return s > u ? -1 : 1;
  }).find((o) => n[o]);
  return a && Al.DEBUG_TAGS && console.log(`  \x1B[2m\x1B[3m      ↓ - '${e.normal || e.implicit}' (#${a})  \x1B[0m`), a = n[a], a;
}, J3 = function(e, n, t, r) {
  var s;
  if (!t)
    return null;
  const a = ((s = e[n - 1]) == null ? void 0 : s.text) !== "also" ? n - 1 : Math.max(0, n - 2), o = r.one.tagSet;
  let i = Uh(e[n + 1], t.afterWords);
  return i = i || Uh(e[a], t.beforeWords), i = i || Kh(e[a], t.beforeTags, o), i = i || Kh(e[n + 1], t.afterTags, o), i;
}, X3 = function(e, n, t) {
  const r = t.model, a = t.methods.one.setTag, { switches: o, clues: i } = r.two, s = e[n];
  let u = s.normal || s.implicit || "";
  if ($h.test(u) && !o[u] && (u = u.replace($h, "")), s.switch) {
    let l = s.switch;
    if (s.tags.has("Acronym") || s.tags.has("PhrasalVerb"))
      return;
    let c = J3(e, n, i[l], r);
    Wh[l] && (c = Wh[l](e, n) || c), c ? (a([s], c, t, null, `3-[switch] (${l})`), no(e, n, r)) : Al.DEBUG_TAGS && console.log(`
 -> X  - '${u}'  : (${l})  `);
  }
}, Q3 = {
  there: !0,
  //go there
  this: !0,
  //try this
  it: !0,
  //do it
  him: !0,
  her: !0,
  us: !0
  //tell us
}, Y3 = function(e, n) {
  const t = n.methods.one.setTag, r = n.model.one._multiCache || {};
  let a = e[0];
  if ((a.switch === "Noun|Verb" || a.tags.has("Infinitive")) && e.length >= 2) {
    if (e.length < 4 && !Q3[e[1].normal] || !a.tags.has("PhrasalVerb") && r.hasOwnProperty(a.normal))
      return;
    (e[1].tags.has("Noun") || e[1].tags.has("Determiner")) && (!e.slice(1, 3).some((u) => u.tags.has("Verb")) || a.tags.has("#PhrasalVerb")) && t([a], "Imperative", n, null, "3-[imperative]");
  }
}, Z3 = function(e) {
  if (e.filter((t) => !t.tags.has("ProperNoun")).length <= 3)
    return !1;
  const n = /^[a-z]/;
  return e.every((t) => !n.test(t.text));
}, eT = function(e, n, t) {
  e.forEach((r) => {
    s3(r, 0, n, t);
  });
}, tT = function(e, n, t, r) {
  for (let a = 0; a < e.length; a += 1)
    e[a].frozen !== !0 && (l3(e, a, n), r === !1 && w3(e, a, n), C3(e, a, n), N3(e, a, n, t), I3(e, a, n), S3(e, a));
}, nT = function(e, n, t, r) {
  for (let a = 0; a < e.length; a += 1) {
    let o = B3(e, a, n);
    no(e, a, n), o = o || j3(e, a, n), o = o || $3(e, a, n);
  }
  for (let a = 0; a < e.length; a += 1)
    e[a].frozen !== !0 && (L3(e, a, t, r), W3(e, a, t, r), X3(e, a, t), D3(e, a, n, t), u3(e, a, n, t));
  Y3(e, t);
}, rT = function(e) {
  const { methods: n, model: t, world: r } = e;
  let a = e.docs;
  eT(a, t, r);
  let o = n.two.quickSplit(a);
  for (let i = 0; i < o.length; i += 1) {
    let s = o[i];
    const u = Z3(s);
    tT(s, t, r, u), nT(s, t, r, u);
  }
  return o;
}, qh = {
  // 'spencer's' -> 'spencer'
  Possessive: (e) => {
    let n = e.machine || e.normal || e.text;
    return n = n.replace(/'s$/, ""), n;
  },
  // 'drinks' -> 'drink'
  Plural: (e, n) => {
    let t = e.machine || e.normal || e.text;
    return n.methods.two.transform.noun.toSingular(t, n.model);
  },
  // ''
  Copula: () => "is",
  // 'walked' -> 'walk'
  PastTense: (e, n) => {
    let t = e.machine || e.normal || e.text;
    return n.methods.two.transform.verb.toInfinitive(t, n.model, "PastTense");
  },
  // 'walking' -> 'walk'
  Gerund: (e, n) => {
    let t = e.machine || e.normal || e.text;
    return n.methods.two.transform.verb.toInfinitive(t, n.model, "Gerund");
  },
  // 'walks' -> 'walk'
  PresentTense: (e, n) => {
    let t = e.machine || e.normal || e.text;
    return e.tags.has("Infinitive") ? t : n.methods.two.transform.verb.toInfinitive(t, n.model, "PresentTense");
  },
  // 'quieter' -> 'quiet'
  Comparative: (e, n) => {
    let t = e.machine || e.normal || e.text;
    return n.methods.two.transform.adjective.fromComparative(t, n.model);
  },
  // 'quietest' -> 'quiet'
  Superlative: (e, n) => {
    let t = e.machine || e.normal || e.text;
    return n.methods.two.transform.adjective.fromSuperlative(t, n.model);
  },
  // 'suddenly' -> 'sudden'
  Adverb: (e, n) => {
    const { fromAdverb: t } = n.methods.two.transform.adjective;
    let r = e.machine || e.normal || e.text;
    return t(r);
  }
}, aT = function(e) {
  const n = e.world, t = Object.keys(qh);
  e.docs.forEach((r) => {
    for (let a = 0; a < r.length; a += 1) {
      const o = r[a];
      for (let i = 0; i < t.length; i += 1)
        if (o.tags.has(t[i])) {
          const s = qh[t[i]];
          let u = s(o, n);
          o.normal !== u && (o.root = u);
          break;
        }
    }
  });
}, Jh = {
  // adverbs
  // 'Comparative': 'RBR',
  // 'Superlative': 'RBS',
  Adverb: "RB",
  // adjectives
  Comparative: "JJR",
  Superlative: "JJS",
  Adjective: "JJ",
  TO: "Conjunction",
  // verbs
  Modal: "MD",
  Auxiliary: "MD",
  Gerund: "VBG",
  //throwing
  PastTense: "VBD",
  //threw
  Participle: "VBN",
  //thrown
  PresentTense: "VBZ",
  //throws
  Infinitive: "VB",
  //throw
  Particle: "RP",
  //phrasal particle
  Verb: "VB",
  // throw
  // pronouns
  Pronoun: "PRP",
  // misc
  Cardinal: "CD",
  Conjunction: "CC",
  Determiner: "DT",
  Preposition: "IN",
  // 'Determiner': 'WDT',
  // 'Expression': 'FW',
  QuestionWord: "WP",
  Expression: "UH",
  //nouns
  Possessive: "POS",
  ProperNoun: "NNP",
  Person: "NNP",
  Place: "NNP",
  Organization: "NNP",
  Singular: "NN",
  Plural: "NNS",
  Noun: "NN",
  There: "EX"
  //'there'
  // 'Adverb':'WRB',
  // 'Noun':'PDT', //predeterminer
  // 'Noun':'SYM', //symbol
  // 'Noun':'NFP', //
  //  WDT 	Wh-determiner
  // 	WP 	Wh-pronoun
  // 	WP$ 	Possessive wh-pronoun
  // 	WRB 	Wh-adverb
}, oT = function(e) {
  if (e.tags.has("ProperNoun") && e.tags.has("Plural"))
    return "NNPS";
  if (e.tags.has("Possessive") && e.tags.has("Pronoun"))
    return "PRP$";
  if (e.normal === "there")
    return "EX";
  if (e.normal === "to")
    return "TO";
  let n = e.tagRank || [];
  for (let t = 0; t < n.length; t += 1)
    if (Jh.hasOwnProperty(n[t]))
      return Jh[n[t]];
  return null;
}, iT = function(e) {
  e.compute("tagRank"), e.docs.forEach((n) => {
    n.forEach((t) => {
      t.penn = oT(t);
    });
  });
}, sT = { preTagger: rT, root: aT, penn: iT }, fs = ["Person", "Place", "Organization"], uT = {
  Noun: {
    not: ["Verb", "Adjective", "Adverb", "Value", "Determiner"]
  },
  Singular: {
    is: "Noun",
    not: ["Plural", "Uncountable"]
  },
  // 'Canada'
  ProperNoun: {
    is: "Noun"
  },
  Person: {
    is: "Singular",
    also: ["ProperNoun"],
    not: ["Place", "Organization", "Date"]
  },
  FirstName: {
    is: "Person"
  },
  MaleName: {
    is: "FirstName",
    not: ["FemaleName", "LastName"]
  },
  FemaleName: {
    is: "FirstName",
    not: ["MaleName", "LastName"]
  },
  LastName: {
    is: "Person",
    not: ["FirstName"]
  },
  // 'dr.'
  Honorific: {
    is: "Person",
    not: ["FirstName", "LastName", "Value"]
  },
  Place: {
    is: "Singular",
    not: ["Person", "Organization"]
  },
  Country: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["City"]
  },
  City: {
    is: "Place",
    also: ["ProperNoun"],
    not: ["Country"]
  },
  // 'california'
  Region: {
    is: "Place",
    also: ["ProperNoun"]
  },
  Address: {
    // is: 'Place',
  },
  Organization: {
    is: "ProperNoun",
    not: ["Person", "Place"]
  },
  SportsTeam: {
    is: "Organization"
  },
  School: {
    is: "Organization"
  },
  Company: {
    is: "Organization"
  },
  Plural: {
    is: "Noun",
    not: ["Singular", "Uncountable"]
  },
  // 'gravity'
  Uncountable: {
    is: "Noun"
  },
  // 'it'
  Pronoun: {
    is: "Noun",
    not: fs
  },
  // 'swimmer'
  Actor: {
    is: "Noun",
    not: ["Place", "Organization"]
  },
  // walking
  Activity: {
    is: "Noun",
    not: ["Person", "Place"]
  },
  // kilometres
  Unit: {
    is: "Noun",
    not: fs
  },
  // canadian
  Demonym: {
    is: "Noun",
    also: ["ProperNoun"],
    not: fs
  },
  // [spencer's] hat
  Possessive: {
    is: "Noun"
  },
  // 'yourself'
  Reflexive: {
    is: "Pronoun"
  }
}, lT = {
  Verb: {
    not: ["Noun", "Adjective", "Adverb", "Value", "Expression"]
  },
  // 'he [walks]'
  PresentTense: {
    is: "Verb",
    not: ["PastTense", "FutureTense"]
  },
  // 'will [walk]'
  Infinitive: {
    is: "PresentTense",
    not: ["Gerund"]
  },
  // '[walk] now!'
  Imperative: {
    is: "Verb",
    not: ["PastTense", "Gerund", "Copula"]
  },
  // walking
  Gerund: {
    is: "PresentTense",
    not: ["Copula"]
  },
  // walked
  PastTense: {
    is: "Verb",
    not: ["PresentTense", "Gerund", "FutureTense"]
  },
  // will walk
  FutureTense: {
    is: "Verb",
    not: ["PresentTense", "PastTense"]
  },
  // is/was
  Copula: {
    is: "Verb"
  },
  // '[could] walk'
  Modal: {
    is: "Verb",
    not: ["Infinitive"]
  },
  // 'awaken'
  Participle: {
    is: "PastTense"
  },
  // '[will have had] walked'
  Auxiliary: {
    is: "Verb",
    not: ["PastTense", "PresentTense", "Gerund", "Conjunction"]
  },
  // 'walk out'
  PhrasalVerb: {
    is: "Verb"
  },
  // 'walk [out]'
  Particle: {
    is: "PhrasalVerb",
    not: ["PastTense", "PresentTense", "Copula", "Gerund"]
  },
  // 'walked by'
  Passive: {
    is: "Verb"
  }
}, cT = {
  Value: {
    not: ["Verb", "Adjective", "Adverb"]
  },
  Ordinal: {
    is: "Value",
    not: ["Cardinal"]
  },
  Cardinal: {
    is: "Value",
    not: ["Ordinal"]
  },
  Fraction: {
    is: "Value",
    not: ["Noun"]
  },
  Multiple: {
    is: "TextValue"
  },
  RomanNumeral: {
    is: "Cardinal",
    not: ["TextValue"]
  },
  TextValue: {
    is: "Value",
    not: ["NumericValue"]
  },
  NumericValue: {
    is: "Value",
    not: ["TextValue"]
  },
  Money: {
    is: "Cardinal"
  },
  Percent: {
    is: "Value"
  }
}, hT = {
  Date: {
    not: ["Verb", "Adverb", "Adjective"]
  },
  Month: {
    is: "Date",
    also: ["Noun"],
    not: ["Year", "WeekDay", "Time"]
  },
  WeekDay: {
    is: "Date",
    also: ["Noun"]
  },
  Year: {
    is: "Date",
    not: ["RomanNumeral"]
  },
  FinancialQuarter: {
    is: "Date",
    not: "Fraction"
  },
  // 'easter'
  Holiday: {
    is: "Date",
    also: ["Noun"]
  },
  // 'summer'
  Season: {
    is: "Date"
  },
  Timezone: {
    is: "Date",
    also: ["Noun"],
    not: ["ProperNoun"]
  },
  Time: {
    is: "Date",
    not: ["AtMention"]
  },
  // 'months'
  Duration: {
    is: "Date",
    also: ["Noun"]
  }
}, dT = ["Noun", "Verb", "Adjective", "Adverb", "Value", "QuestionWord"], pT = {
  Adjective: {
    not: ["Noun", "Verb", "Adverb", "Value"]
  },
  Comparable: {
    is: "Adjective"
  },
  Comparative: {
    is: "Adjective"
  },
  Superlative: {
    is: "Adjective",
    not: ["Comparative"]
  },
  NumberRange: {},
  Adverb: {
    not: ["Noun", "Verb", "Adjective", "Value"]
  },
  Determiner: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Conjunction"]
    //allow 'a' to be a Determiner/Value
  },
  Conjunction: {
    not: dT
  },
  Preposition: {
    not: ["Noun", "Verb", "Adjective", "Adverb", "QuestionWord", "Determiner"]
  },
  QuestionWord: {
    not: ["Determiner"]
  },
  Currency: {
    is: "Noun"
  },
  Expression: {
    not: ["Noun", "Adjective", "Verb", "Adverb"]
  },
  Abbreviation: {},
  Url: {
    not: ["HashTag", "PhoneNumber", "Verb", "Adjective", "Value", "AtMention", "Email", "SlashedTerm"]
  },
  PhoneNumber: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "Email"]
  },
  HashTag: {},
  AtMention: {
    is: "Noun",
    not: ["HashTag", "Email"]
  },
  Emoji: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Emoticon: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention", "SlashedTerm"]
  },
  SlashedTerm: {
    not: ["Emoticon", "Url", "Value"]
  },
  Email: {
    not: ["HashTag", "Verb", "Adjective", "Value", "AtMention"]
  },
  Acronym: {
    not: ["Plural", "RomanNumeral", "Pronoun", "Date"]
  },
  Negative: {
    not: ["Noun", "Adjective", "Value", "Expression"]
  },
  Condition: {
    not: ["Verb", "Adjective", "Noun", "Value"]
  },
  // existential 'there'
  There: {
    not: ["Verb", "Adjective", "Noun", "Value", "Conjunction", "Preposition"]
  },
  // 'co-wrote'
  Prefix: {
    not: ["Abbreviation", "Acronym", "ProperNoun"]
  },
  // hard-nosed, bone-headed
  Hyphenated: {}
};
let fT = Object.assign({}, uT, lT, cT, hT, pT);
const mT = {
  compute: sT,
  methods: du,
  model: fu,
  tags: fT,
  hooks: ["preTagger"]
}, gT = /[,)"';:\-–—.…]/, kn = function(e, n) {
  if (!e.found)
    return;
  let t = e.termList();
  for (let r = 0; r < t.length - 1; r++) {
    const a = t[r];
    if (gT.test(a.post))
      return;
  }
  t[0].implicit = t[0].normal, t[0].text += n, t[0].normal += n, t.slice(1).forEach((r) => {
    r.implicit = r.normal, r.text = "", r.normal = "";
  });
  for (let r = 0; r < t.length - 1; r++)
    t[r].post = t[r].post.replace(/ /, "");
}, vT = function() {
  let e = this.not("@hasContraction"), n = e.match("(we|they|you) are");
  return kn(n, "'re"), n = e.match("(he|she|they|it|we|you) will"), kn(n, "'ll"), n = e.match("(he|she|they|it|we) is"), kn(n, "'s"), n = e.match("#Person is"), kn(n, "'s"), n = e.match("#Person would"), kn(n, "'d"), n = e.match("(is|was|had|would|should|could|do|does|have|has|can) not"), kn(n, "n't"), n = e.match("(i|we|they) have"), kn(n, "'ve"), n = e.match("(would|should|could) have"), kn(n, "'ve"), n = e.match("i am"), kn(n, "'m"), n = e.match("going to"), this;
}, yT = new RegExp("^\\p{Lu}[\\p{Ll}'’]", "u"), bT = function(e = "") {
  return e = e.replace(/^ *[a-z\u00C0-\u00FF]/, (n) => n.toUpperCase()), e;
}, xT = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Contraction";
    }
    /** i've -> 'i have' */
    expand() {
      return this.docs.forEach((r) => {
        let a = yT.test(r[0].text);
        r.forEach((o, i) => {
          o.text = o.implicit || "", delete o.implicit, i < r.length - 1 && o.post === "" && (o.post += " "), o.dirty = !0;
        }), a && (r[0].text = bT(r[0].text));
      }), this.compute("normal"), this;
    }
  }
  e.prototype.contractions = function() {
    let t = this.match("@hasContraction+");
    return new n(this.document, t.pointer);
  }, e.prototype.contract = vT;
}, wT = function(e, n, t) {
  let [r, a] = n;
  !t || t.length === 0 || (t = t.map((o, i) => (o.implicit = o.text, o.machine = o.text, o.pre = "", o.post = "", o.text = "", o.normal = "", o.index = [r, a + i], o)), t[0] && (t[0].pre = e[r][a].pre, t[t.length - 1].post = e[r][a].post, t[0].text = e[r][a].text, t[0].normal = e[r][a].normal), e[r].splice(a, 1, ...t));
}, CT = /'/, kT = /* @__PURE__ */ new Set([
  "been",
  //the meeting's been ..
  "become"
  //my son's become
]), NT = /* @__PURE__ */ new Set([
  "what",
  //it's what
  "how",
  //it's how
  "when",
  "if",
  //it's if
  "too"
]);
let AT = /* @__PURE__ */ new Set(["too", "also", "enough"]);
const IT = (e, n) => {
  for (let t = n + 1; t < e.length; t += 1) {
    let r = e[t];
    if (kT.has(r.normal))
      return "has";
    if (NT.has(r.normal) || r.tags.has("Gerund") || r.tags.has("Determiner") || r.tags.has("Adjective") || r.switch === "Adj|Past" && e[t + 1] && (AT.has(e[t + 1].normal) || e[t + 1].tags.has("Preposition")))
      return "is";
    if (r.tags.has("PastTense"))
      return e[t + 1] && e[t + 1].normal === "for" ? "is" : "has";
  }
  return "is";
}, ET = function(e, n) {
  let t = e[n].normal.split(CT)[0];
  if (t === "let")
    return [t, "us"];
  if (t === "there") {
    let r = e[n + 1];
    if (r && r.tags.has("Plural"))
      return [t, "are"];
  }
  return IT(e, n) === "has" ? [t, "has"] : [t, "is"];
}, TT = /'/, PT = /* @__PURE__ */ new Set([
  "better",
  //had better
  "done",
  //had done
  "before",
  // he'd _ before
  "it",
  // he'd _ it
  "had"
  //she'd had -> she would have..
]), ST = /* @__PURE__ */ new Set([
  "have",
  // 'i'd have' -> i would have..
  "be"
  //' she'd be'
]), DT = (e, n) => {
  for (let t = n + 1; t < e.length; t += 1) {
    let r = e[t];
    if (PT.has(r.normal))
      return "had";
    if (ST.has(r.normal))
      return "would";
    if (r.tags.has("PastTense") || r.switch === "Adj|Past")
      return "had";
    if (r.tags.has("PresentTense") || r.tags.has("Infinitive"))
      return "would";
    if (r.tags.has("#Determiner"))
      return "had";
    if (r.tags.has("Adjective"))
      return "would";
  }
  return !1;
}, OT = function(e, n) {
  let t = e[n].normal.split(TT)[0];
  return t === "how" || t === "what" ? [t, "did"] : DT(e, n) === "had" ? [t, "had"] : [t, "would"];
}, RT = function(e, n) {
  for (let t = n - 1; t >= 0; t -= 1)
    if (e[t].tags.has("Noun") || e[t].tags.has("Pronoun") || e[t].tags.has("Plural") || e[t].tags.has("Singular"))
      return e[t];
  return null;
}, FT = function(e, n) {
  if (e[n].normal === "ain't" || e[n].normal === "aint") {
    if (e[n + 1] && e[n + 1].normal === "never")
      return ["have"];
    let r = RT(e, n);
    if (r) {
      if (r.normal === "we" || r.normal === "they")
        return ["are", "not"];
      if (r.normal === "i")
        return ["am", "not"];
      if (r.tags && r.tags.has("Plural"))
        return ["are", "not"];
    }
    return ["is", "not"];
  }
  return [e[n].normal.replace(/n't/, ""), "not"];
}, MT = {
  that: !0,
  there: !0,
  let: !0,
  here: !0,
  everywhere: !0
}, _T = {
  in: !0,
  //in sunday's
  by: !0,
  //by sunday's
  for: !0
  //for sunday's
};
let BT = /* @__PURE__ */ new Set(["too", "also", "enough", "about"]), jT = /* @__PURE__ */ new Set(["is", "are", "did", "were", "could", "should", "must", "had", "have"]);
const VT = (e, n) => {
  let t = e[n];
  if (MT.hasOwnProperty(t.machine || t.normal))
    return !1;
  if (t.tags.has("Possessive"))
    return !0;
  if (t.tags.has("QuestionWord") || t.normal === "he's" || t.normal === "she's")
    return !1;
  let r = e[n + 1];
  if (!r)
    return !0;
  if (t.normal === "it's")
    return !!r.tags.has("#Noun");
  if (r.switch == "Noun|Gerund") {
    let a = e[n + 2];
    return a ? a.tags.has("Copula") ? !0 : (a.normal === "on" || a.normal === "in", !1) : !!(t.tags.has("Actor") || t.tags.has("ProperNoun"));
  }
  if (r.tags.has("Verb"))
    return r.tags.has("Infinitive") ? !0 : r.tags.has("Gerund") ? !1 : !!r.tags.has("PresentTense");
  if (r.switch === "Adj|Noun") {
    let a = e[n + 2];
    if (!a)
      return !1;
    if (jT.has(a.normal))
      return !0;
    if (BT.has(a.normal))
      return !1;
  }
  if (r.tags.has("Noun")) {
    let a = r.machine || r.normal;
    return !(a === "here" || a === "there" || a === "everywhere" || r.tags.has("Possessive") || r.tags.has("ProperNoun") && !t.tags.has("ProperNoun"));
  }
  if (e[n - 1] && _T[e[n - 1].normal] === !0)
    return !0;
  if (r.tags.has("Adjective")) {
    let a = e[n + 2];
    if (!a)
      return !1;
    if (a.tags.has("Noun") && !a.tags.has("Pronoun")) {
      let o = r.normal;
      return !(o === "above" || o === "below" || o === "behind");
    }
    return a.switch === "Noun|Verb";
  }
  return !!r.tags.has("Value");
}, Xh = /'/, LT = function(e) {
  e.forEach((n, t) => {
    n.index && (n.index[1] = t);
  });
}, zT = function(e, n, t, r) {
  let a = n.update();
  a.document = [e];
  let o = t + r;
  t > 0 && (t -= 1), e[o] && (o += 1), a.ptrs = [[0, t, o]], a.compute(["freeze", "lexicon", "preTagger", "unfreeze"]), LT(e);
}, Qh = {
  // how'd
  d: (e, n) => OT(e, n),
  // we ain't
  t: (e, n) => FT(e, n),
  // bob's
  s: (e, n, t) => VT(e, n) ? t.methods.one.setTag([e[n]], "Possessive", t, null, "2-contraction") : ET(e, n)
}, GT = function(e, n) {
  let t = n.fromText(e.join(" "));
  return t.compute("id"), t.docs[0];
}, HT = (e) => {
  let { world: n, document: t } = e;
  t.forEach((r, a) => {
    for (let o = r.length - 1; o >= 0; o -= 1) {
      if (r[o].implicit)
        continue;
      let i = null;
      Xh.test(r[o].normal) === !0 && (i = r[o].normal.split(Xh)[1]);
      let s = null;
      if (Qh.hasOwnProperty(i) && (s = Qh[i](r, o, n)), s) {
        s = GT(s, e), wT(t, [a, o], s), zT(t[a], e, o, s.length);
        continue;
      }
    }
  });
}, WT = { contractionTwo: HT }, $T = {
  compute: WT,
  api: xT,
  hooks: ["contractionTwo"]
}, UT = [
  // all fell apart
  { match: "[(all|both)] #Determiner #Noun", group: 0, tag: "Noun", reason: "all-noun" },
  //sometimes not-adverbs
  { match: "#Copula [(just|alone)]$", group: 0, tag: "Adjective", reason: "not-adverb" },
  //jack is guarded
  { match: "#Singular is #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "is-filled" },
  // smoked poutine is
  { match: "[#PastTense] #Singular is", group: 0, tag: "Adjective", reason: "smoked-poutine" },
  // baked onions are
  { match: "[#PastTense] #Plural are", group: 0, tag: "Adjective", reason: "baked-onions" },
  // well made
  { match: "well [#PastTense]", group: 0, tag: "Adjective", reason: "well-made" },
  // is f*ed up
  { match: "#Copula [fucked up?]", group: 0, tag: "Adjective", reason: "swears-adjective" },
  //jack seems guarded
  { match: "#Singular (seems|appears) #Adverb? [#PastTense$]", group: 0, tag: "Adjective", reason: "seems-filled" },
  // jury is out - preposition ➔ adjective
  { match: "#Copula #Adjective? [(out|in|through)]$", group: 0, tag: "Adjective", reason: "still-out" },
  // shut the door
  { match: "^[#Adjective] (the|your) #Noun", group: 0, notIf: "(all|even)", tag: "Infinitive", reason: "shut-the" },
  // the said card
  { match: "the [said] #Noun", group: 0, tag: "Adjective", reason: "the-said-card" },
  // faith-based, much-appreciated, soft-boiled
  { match: "[#Hyphenated (#Hyphenated && #PastTense)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "faith-based" },
  //self-driving
  { match: "[#Hyphenated (#Hyphenated && #Gerund)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", notIf: "#Adverb", reason: "self-driving" },
  //dammed-up
  { match: "[#PastTense (#Hyphenated && #PhrasalVerb)] (#Noun|#Conjunction)", group: 0, tag: "Adjective", reason: "dammed-up" },
  //two-fold
  { match: "(#Hyphenated && #Value) fold", tag: "Adjective", reason: "two-fold" },
  //must-win
  { match: "must (#Hyphenated && #Infinitive)", tag: "Adjective", reason: "must-win" },
  // vacuum-sealed
  { match: "(#Hyphenated && #Infinitive) #Hyphenated", tag: "Adjective", notIf: "#PhrasalVerb", reason: "vacuum-sealed" },
  { match: "too much", tag: "Adverb Adjective", reason: "bit-4" },
  { match: "a bit much", tag: "Determiner Adverb Adjective", reason: "bit-3" },
  // adjective-prefixes - 'un skilled'
  { match: "[(un|contra|extra|inter|intra|macro|micro|mid|mis|mono|multi|pre|sub|tri|ex)] #Adjective", group: 0, tag: ["Adjective", "Prefix"], reason: "un-skilled" }
], KT = "(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)", Yh = "(hard|fast|late|early|high|right|deep|close|direct)", qT = [
  // kinda sparkly
  { match: "#Adverb [#Adverb] (and|or|then)", group: 0, tag: "Adjective", reason: "kinda-sparkly-and" },
  // dark green
  { match: `[${KT}] #Adjective`, group: 0, tag: "Adverb", reason: "dark-green" },
  // far too
  { match: "#Copula [far too] #Adjective", group: 0, tag: "Adverb", reason: "far-too" },
  // was still in
  { match: "#Copula [still] (in|#Gerund|#Adjective)", group: 0, tag: "Adverb", reason: "was-still-walking" },
  // studies hard
  { match: `#Plural ${Yh}`, tag: "#PresentTense #Adverb", reason: "studies-hard" },
  // shops direct
  {
    match: `#Verb [${Yh}] !#Noun?`,
    group: 0,
    notIf: "(#Copula|get|got|getting|become|became|becoming|feel|feels|feeling|#Determiner|#Preposition)",
    tag: "Adverb",
    reason: "shops-direct"
  },
  // studies a lot
  { match: "[#Plural] a lot", tag: "PresentTense", reason: "studies-a-lot" }
], JT = [
  //a staggering cost
  // { match: '(a|an) [#Gerund]', group: 0, tag: 'Adjective', reason: 'a|an' },
  //as amusing as
  { match: "as [#Gerund] as", group: 0, tag: "Adjective", reason: "as-gerund-as" },
  // more amusing than
  { match: "more [#Gerund] than", group: 0, tag: "Adjective", reason: "more-gerund-than" },
  // very amusing
  { match: "(so|very|extremely) [#Gerund]", group: 0, tag: "Adjective", reason: "so-gerund" },
  // found it amusing
  { match: "(found|found) it #Adverb? [#Gerund]", group: 0, tag: "Adjective", reason: "found-it-gerund" },
  // a bit amusing
  { match: "a (little|bit|wee) bit? [#Gerund]", group: 0, tag: "Adjective", reason: "a-bit-gerund" },
  // looking annoying
  {
    match: "#Gerund [#Gerund]",
    group: 0,
    tag: "Adjective",
    notIf: "(impersonating|practicing|considering|assuming)",
    reason: "looking-annoying"
  },
  // looked amazing
  {
    match: "(looked|look|looks) #Adverb? [%Adj|Gerund%]",
    group: 0,
    tag: "Adjective",
    notIf: "(impersonating|practicing|considering|assuming)",
    reason: "looked-amazing"
  },
  // were really amazing
  // { match: '(looked|look|looks) #Adverb [%Adj|Gerund%]', group: 0, tag: 'Adjective', notIf: '(impersonating|practicing|considering|assuming)', reason: 'looked-amazing' },
  // developing a
  { match: "[%Adj|Gerund%] #Determiner", group: 0, tag: "Gerund", reason: "developing-a" },
  // world's leading manufacturer
  { match: "#Possessive [%Adj|Gerund%] #Noun", group: 0, tag: "Adjective", reason: "leading-manufacturer" },
  // meaning alluring
  { match: "%Noun|Gerund% %Adj|Gerund%", tag: "Gerund #Adjective", reason: "meaning-alluring" },
  // face shocking revelations
  {
    match: "(face|embrace|reveal|stop|start|resume) %Adj|Gerund%",
    tag: "#PresentTense #Adjective",
    reason: "face-shocking"
  },
  // are enduring symbols
  { match: "(are|were) [%Adj|Gerund%] #Plural", group: 0, tag: "Adjective", reason: "are-enduring-symbols" }
], XT = [
  //the above is clear
  { match: "#Determiner [#Adjective] #Copula", group: 0, tag: "Noun", reason: "the-adj-is" },
  //real evil is
  { match: "#Adjective [#Adjective] #Copula", group: 0, tag: "Noun", reason: "adj-adj-is" },
  //his fine
  { match: "(his|its) [%Adj|Noun%]", group: 0, tag: "Noun", notIf: "#Hyphenated", reason: "his-fine" },
  //is all
  { match: "#Copula #Adverb? [all]", group: 0, tag: "Noun", reason: "is-all" },
  // have fun
  { match: "(have|had) [#Adjective] #Preposition .", group: 0, tag: "Noun", reason: "have-fun" },
  // brewing giant
  { match: "#Gerund (giant|capital|center|zone|application)", tag: "Noun", reason: "brewing-giant" },
  // in an instant
  { match: "#Preposition (a|an) [#Adjective]$", group: 0, tag: "Noun", reason: "an-instant" },
  // no golden would
  { match: "no [#Adjective] #Modal", group: 0, tag: "Noun", reason: "no-golden" },
  // brand new
  { match: "[brand #Gerund?] new", group: 0, tag: "Adverb", reason: "brand-new" },
  // some kind
  { match: "(#Determiner|#Comparative|new|different) [kind]", group: 0, tag: "Noun", reason: "some-kind" },
  // her favourite sport
  { match: "#Possessive [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", reason: "her-favourite" },
  // must-win
  { match: "must && #Hyphenated .", tag: "Adjective", reason: "must-win" },
  // the present
  {
    match: "#Determiner [#Adjective]$",
    tag: "Noun",
    notIf: "(this|that|#Comparative|#Superlative)",
    reason: "the-south"
  },
  //are that crazy.
  // company-wide
  {
    match: "(#Noun && #Hyphenated) (#Adjective && #Hyphenated)",
    tag: "Adjective",
    notIf: "(this|that|#Comparative|#Superlative)",
    reason: "company-wide"
  },
  // the poor were
  {
    match: "#Determiner [#Adjective] (#Copula|#Determiner)",
    notIf: "(#Comparative|#Superlative)",
    group: 0,
    tag: "Noun",
    reason: "the-poor"
  },
  // professional bodybuilder
  {
    match: "[%Adj|Noun%] #Noun",
    notIf: "(#Pronoun|#ProperNoun)",
    group: 0,
    tag: "Adjective",
    reason: "stable-foundations"
  }
], QT = [
  // amusing his aunt
  // { match: '[#Adjective] #Possessive #Noun', group: 0, tag: 'Verb', reason: 'gerund-his-noun' },
  // loving you
  // { match: '[#Adjective] (us|you)', group: 0, tag: 'Gerund', reason: 'loving-you' },
  // slowly stunning
  { match: "(slowly|quickly) [#Adjective]", group: 0, tag: "Verb", reason: "slowly-adj" },
  // does mean
  { match: "does (#Adverb|not)? [#Adjective]", group: 0, tag: "PresentTense", reason: "does-mean" },
  // okay by me
  { match: "[(fine|okay|cool|ok)] by me", group: 0, tag: "Adjective", reason: "okay-by-me" },
  // i mean
  { match: "i (#Adverb|do)? not? [mean]", group: 0, tag: "PresentTense", reason: "i-mean" },
  //will secure our
  { match: "will #Adjective", tag: "Auxiliary Infinitive", reason: "will-adj" },
  //he disguised the thing
  { match: "#Pronoun [#Adjective] #Determiner #Adjective? #Noun", group: 0, tag: "Verb", reason: "he-adj-the" },
  //is eager to go
  { match: "#Copula [%Adj|Present%] to #Verb", group: 0, tag: "Verb", reason: "adj-to" },
  //is done well
  { match: "#Copula [#Adjective] (well|badly|quickly|slowly)", group: 0, tag: "Verb", reason: "done-well" },
  // rude and insulting
  { match: "#Adjective and [#Gerund] !#Preposition?", group: 0, tag: "Adjective", reason: "rude-and-x" },
  // were over cooked
  { match: "#Copula #Adverb? (over|under) [#PastTense]", group: 0, tag: "Adjective", reason: "over-cooked" },
  // was bland and overcooked
  { match: "#Copula #Adjective+ (and|or) [#PastTense]$", group: 0, tag: "Adjective", reason: "bland-and-overcooked" },
  // got tired of
  { match: "got #Adverb? [#PastTense] of", group: 0, tag: "Adjective", reason: "got-tired-of" },
  //felt loved
  {
    match: "(seem|seems|seemed|appear|appeared|appears|feel|feels|felt|sound|sounds|sounded) (#Adverb|#Adjective)? [#PastTense]",
    group: 0,
    tag: "Adjective",
    reason: "felt-loved"
  },
  // seem confused
  { match: "(seem|feel|seemed|felt) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "seem-confused" },
  // a bit confused
  { match: "a (bit|little|tad) [#PastTense #Particle?]", group: 0, tag: "Adjective", reason: "a-bit-confused" },
  // do not be embarrassed
  { match: "not be [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "do-not-be-confused" },
  // is just right
  { match: "#Copula just [%Adj|Past% #Particle?]", group: 0, tag: "Adjective", reason: "is-just-right" },
  // as pale as
  { match: "as [#Infinitive] as", group: 0, tag: "Adjective", reason: "as-pale-as" },
  //failed and oppressive
  { match: "[%Adj|Past%] and #Adjective", group: 0, tag: "Adjective", reason: "faled-and-oppressive" },
  // or heightened emotion
  {
    match: "or [#PastTense] #Noun",
    group: 0,
    tag: "Adjective",
    notIf: "(#Copula|#Pronoun)",
    reason: "or-heightened-emotion"
  },
  // became involved
  { match: "(become|became|becoming|becomes) [#Verb]", group: 0, tag: "Adjective", reason: "become-verb" },
  // their declared intentions
  { match: "#Possessive [#PastTense] #Noun", group: 0, tag: "Adjective", reason: "declared-intentions" },
  // is he cool
  { match: "#Copula #Pronoun [%Adj|Present%]", group: 0, tag: "Adjective", reason: "is-he-cool" },
  // is crowded with
  {
    match: "#Copula [%Adj|Past%] with",
    group: 0,
    tag: "Adjective",
    notIf: "(associated|worn|baked|aged|armed|bound|fried|loaded|mixed|packed|pumped|filled|sealed)",
    reason: "is-crowded-with"
  },
  // is empty$
  { match: "#Copula #Adverb? [%Adj|Present%]$", group: 0, tag: "Adjective", reason: "was-empty$" }
], YT = [
  //still good
  { match: "[still] #Adjective", group: 0, tag: "Adverb", reason: "still-advb" },
  //still make
  { match: "[still] #Verb", group: 0, tag: "Adverb", reason: "still-verb" },
  // so hot
  { match: "[so] #Adjective", group: 0, tag: "Adverb", reason: "so-adv" },
  // way hotter
  { match: "[way] #Comparative", group: 0, tag: "Adverb", reason: "way-adj" },
  // way too hot
  { match: "[way] #Adverb #Adjective", group: 0, tag: "Adverb", reason: "way-too-adj" },
  // all singing
  { match: "[all] #Verb", group: 0, tag: "Adverb", reason: "all-verb" },
  // sing like an angel
  { match: "#Verb  [like]", group: 0, notIf: "(#Modal|#PhrasalVerb)", tag: "Adverb", reason: "verb-like" },
  //barely even walk
  { match: "(barely|hardly) even", tag: "Adverb", reason: "barely-even" },
  //even held
  { match: "[even] #Verb", group: 0, tag: "Adverb", reason: "even-walk" },
  //even worse
  { match: "[even] #Comparative", group: 0, tag: "Adverb", reason: "even-worse" },
  // even the greatest
  { match: "[even] (#Determiner|#Possessive)", group: 0, tag: "#Adverb", reason: "even-the" },
  // even left
  { match: "even left", tag: "#Adverb #Verb", reason: "even-left" },
  // way over
  { match: "[way] #Adjective", group: 0, tag: "#Adverb", reason: "way-over" },
  //cheering hard - dropped -ly's
  {
    match: "#PresentTense [(hard|quick|bright|slow|fast|backwards|forwards)]",
    notIf: "#Copula",
    group: 0,
    tag: "Adverb",
    reason: "lazy-ly"
  },
  // much appreciated
  { match: "[much] #Adjective", group: 0, tag: "Adverb", reason: "bit-1" },
  // is well
  { match: "#Copula [#Adverb]$", group: 0, tag: "Adjective", reason: "is-well" },
  // a bit cold
  { match: "a [(little|bit|wee) bit?] #Adjective", group: 0, tag: "Adverb", reason: "a-bit-cold" },
  // super strong
  { match: "[(super|pretty)] #Adjective", group: 0, tag: "Adverb", reason: "super-strong" },
  // become overly weakened
  { match: "(become|fall|grow) #Adverb? [#PastTense]", group: 0, tag: "Adjective", reason: "overly-weakened" },
  // a completely beaten man
  { match: "(a|an) #Adverb [#Participle] #Noun", group: 0, tag: "Adjective", reason: "completely-beaten" },
  //a close
  { match: "#Determiner #Adverb? [close]", group: 0, tag: "Adjective", reason: "a-close" },
  //walking close
  { match: "#Gerund #Adverb? [close]", group: 0, tag: "Adverb", notIf: "(getting|becoming|feeling)", reason: "being-close" },
  // a blown motor
  { match: "(the|those|these|a|an) [#Participle] #Noun", group: 0, tag: "Adjective", reason: "blown-motor" },
  // charged back
  { match: "(#PresentTense|#PastTense) [back]", group: 0, tag: "Adverb", notIf: "(#PhrasalVerb|#Copula)", reason: "charge-back" },
  // send around
  { match: "#Verb [around]", group: 0, tag: "Adverb", notIf: "#PhrasalVerb", reason: "send-around" },
  // later say
  { match: "[later] #PresentTense", group: 0, tag: "Adverb", reason: "later-say" },
  // the well
  { match: "#Determiner [well] !#PastTense?", group: 0, tag: "Noun", reason: "the-well" },
  // high enough
  { match: "#Adjective [enough]", group: 0, tag: "Adverb", reason: "high-enough" }
], ZT = [
  // ==== Holiday ====
  { match: "#Holiday (day|eve)", tag: "Holiday", reason: "holiday-day" },
  //5th of March
  { match: "#Value of #Month", tag: "Date", reason: "value-of-month" },
  //5 March
  { match: "#Cardinal #Month", tag: "Date", reason: "cardinal-month" },
  //march 5 to 7
  { match: "#Month #Value to #Value", tag: "Date", reason: "value-to-value" },
  //march the 12th
  { match: "#Month the #Value", tag: "Date", reason: "month-the-value" },
  //june 7
  { match: "(#WeekDay|#Month) #Value", tag: "Date", reason: "date-value" },
  //7 june
  { match: "#Value (#WeekDay|#Month)", tag: "Date", reason: "value-date" },
  //may twenty five
  { match: "(#TextValue && #Date) #TextValue", tag: "Date", reason: "textvalue-date" },
  // 'aug 20-21'
  { match: "#Month #NumberRange", tag: "Date", reason: "aug 20-21" },
  // wed march 5th
  { match: "#WeekDay #Month #Ordinal", tag: "Date", reason: "week mm-dd" },
  // aug 5th 2021
  { match: "#Month #Ordinal #Cardinal", tag: "Date", reason: "mm-dd-yyy" },
  // === timezones ===
  // china standard time
  { match: "(#Place|#Demonmym|#Time) (standard|daylight|central|mountain)? time", tag: "Timezone", reason: "std-time" },
  // eastern time
  {
    match: "(eastern|mountain|pacific|central|atlantic) (standard|daylight|summer)? time",
    tag: "Timezone",
    reason: "eastern-time"
  },
  // 5pm central
  { match: "#Time [(eastern|mountain|pacific|central|est|pst|gmt)]", group: 0, tag: "Timezone", reason: "5pm-central" },
  // central european time
  { match: "(central|western|eastern) european time", tag: "Timezone", reason: "cet" }
], eP = [
  // ==== WeekDay ====
  // sun the 5th
  { match: "[sun] the #Ordinal", tag: "WeekDay", reason: "sun-the-5th" },
  //sun feb 2
  { match: "[sun] #Date", group: 0, tag: "WeekDay", reason: "sun-feb" },
  //1pm next sun
  { match: "#Date (on|this|next|last|during)? [sun]", group: 0, tag: "WeekDay", reason: "1pm-sun" },
  //this sat
  { match: "(in|by|before|during|on|until|after|of|within|all) [sat]", group: 0, tag: "WeekDay", reason: "sat" },
  { match: "(in|by|before|during|on|until|after|of|within|all) [wed]", group: 0, tag: "WeekDay", reason: "wed" },
  { match: "(in|by|before|during|on|until|after|of|within|all) [march]", group: 0, tag: "Month", reason: "march" },
  //sat november
  { match: "[sat] #Date", group: 0, tag: "WeekDay", reason: "sat-feb" },
  // ==== Month ====
  //all march
  { match: "#Preposition [(march|may)]", group: 0, tag: "Month", reason: "in-month" },
  //this march
  { match: "(this|next|last) (march|may) !#Infinitive?", tag: "#Date #Month", reason: "this-month" },
  // march 5th
  { match: "(march|may) the? #Value", tag: "#Month #Date #Date", reason: "march-5th" },
  // 5th of march
  { match: "#Value of? (march|may)", tag: "#Date #Date #Month", reason: "5th-of-march" },
  // march and feb
  { match: "[(march|may)] .? #Date", group: 0, tag: "Month", reason: "march-and-feb" },
  // feb to march
  { match: "#Date .? [(march|may)]", group: 0, tag: "Month", reason: "feb-and-march" },
  //quickly march
  { match: "#Adverb [(march|may)]", group: 0, tag: "Verb", reason: "quickly-march" },
  //march quickly
  { match: "[(march|may)] #Adverb", group: 0, tag: "Verb", reason: "march-quickly" },
  //12 am
  { match: "#Value (am|pm)", tag: "Time", reason: "2-am" }
], tP = "(feel|sense|process|rush|side|bomb|bully|challenge|cover|crush|dump|exchange|flow|function|issue|lecture|limit|march|process)", nP = [
  //'more' is not always an adverb
  // any more
  { match: "(the|any) [more]", group: 0, tag: "Singular", reason: "more-noun" },
  // more players
  { match: "[more] #Noun", group: 0, tag: "Adjective", reason: "more-noun" },
  // rights of man
  { match: "(right|rights) of .", tag: "Noun", reason: "right-of" },
  // a bit
  { match: "a [bit]", group: 0, tag: "Singular", reason: "bit-2" },
  // a must
  { match: "a [must]", group: 0, tag: "Singular", reason: "must-2" },
  // we all
  { match: "(we|us) [all]", group: 0, tag: "Noun", reason: "we all" },
  // due to weather
  { match: "due to [#Verb]", group: 0, tag: "Noun", reason: "due-to" },
  //some pressing issues
  { match: "some [#Verb] #Plural", group: 0, tag: "Noun", reason: "determiner6" },
  // my first thought
  { match: "#Possessive #Ordinal [#PastTense]", group: 0, tag: "Noun", reason: "first-thought" },
  //the nice swim
  {
    match: "(the|this|those|these) #Adjective [%Verb|Noun%]",
    group: 0,
    tag: "Noun",
    notIf: "#Copula",
    reason: "the-adj-verb"
  },
  // the truly nice swim
  { match: "(the|this|those|these) #Adverb #Adjective [#Verb]", group: 0, tag: "Noun", reason: "determiner4" },
  //the wait to vote
  { match: "the [#Verb] #Preposition .", group: 0, tag: "Noun", reason: "determiner1" },
  //a sense of
  { match: "(a|an|the) [#Verb] of", group: 0, tag: "Noun", reason: "the-verb-of" },
  //the threat of force
  { match: "#Determiner #Noun of [#Verb]", group: 0, tag: "Noun", notIf: "#Gerund", reason: "noun-of-noun" },
  // ended in ruins
  {
    match: "#PastTense #Preposition [#PresentTense]",
    group: 0,
    notIf: "#Gerund",
    tag: "Noun",
    reason: "ended-in-ruins"
  },
  //'u' as pronoun
  { match: "#Conjunction [u]", group: 0, tag: "Pronoun", reason: "u-pronoun-2" },
  { match: "[u] #Verb", group: 0, tag: "Pronoun", reason: "u-pronoun-1" },
  //the western line
  {
    match: "#Determiner [(western|eastern|northern|southern|central)] #Noun",
    group: 0,
    tag: "Noun",
    reason: "western-line"
  },
  //air-flow
  { match: "(#Singular && @hasHyphen) #PresentTense", tag: "Noun", reason: "hyphen-verb" },
  //is no walk
  { match: "is no [#Verb]", group: 0, tag: "Noun", reason: "is-no-verb" },
  //do so
  { match: "do [so]", group: 0, tag: "Noun", reason: "so-noun" },
  // what the hell
  { match: "#Determiner [(shit|damn|hell)]", group: 0, tag: "Noun", reason: "swears-noun" },
  // go to shit
  { match: "to [(shit|hell)]", group: 0, tag: "Noun", reason: "to-swears" },
  // the staff were
  { match: "(the|these) [#Singular] (were|are)", group: 0, tag: "Plural", reason: "singular-were" },
  // a comdominium, or simply condo
  { match: "a #Noun+ or #Adverb+? [#Verb]", group: 0, tag: "Noun", reason: "noun-or-noun" },
  // walk the walk
  {
    match: "(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]",
    group: 0,
    tag: "Noun",
    notIf: "(seem|appear|include|#Gerund|#Copula)",
    reason: "det-inf"
  },
  // { match: '(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]', group: 0, tag: 'Noun', notIf: '(#Gerund|#Copula)', reason: 'det-pres' },
  // ==== Actor ====
  //Aircraft designer
  { match: "#Noun #Actor", tag: "Actor", notIf: "(#Person|#Pronoun)", reason: "thing-doer" },
  //lighting designer
  { match: "#Gerund #Actor", tag: "Actor", reason: "gerund-doer" },
  // captain sanders
  // { match: '[#Actor+] #ProperNoun', group: 0, tag: 'Honorific', reason: 'sgt-kelly' },
  // co-founder
  { match: "co #Singular", tag: "Actor", reason: "co-noun" },
  // co-founder
  {
    match: "[#Noun+] #Actor",
    group: 0,
    tag: "Actor",
    notIf: "(#Honorific|#Pronoun|#Possessive)",
    reason: "air-traffic-controller"
  },
  // fine-artist
  {
    match: "(urban|cardiac|cardiovascular|respiratory|medical|clinical|visual|graphic|creative|dental|exotic|fine|certified|registered|technical|virtual|professional|amateur|junior|senior|special|pharmaceutical|theoretical)+ #Noun? #Actor",
    tag: "Actor",
    reason: "fine-artist"
  },
  // dance coach
  {
    match: "#Noun+ (coach|chef|king|engineer|fellow|personality|boy|girl|man|woman|master)",
    tag: "Actor",
    reason: "dance-coach"
  },
  // chief design officer
  { match: "chief . officer", tag: "Actor", reason: "chief-x-officer" },
  // chief of police
  { match: "chief of #Noun+", tag: "Actor", reason: "chief-of-police" },
  // president of marketing
  { match: "senior? vice? president of #Noun+", tag: "Actor", reason: "president-of" },
  // ==== Singular ====
  //the sun
  { match: "#Determiner [sun]", group: 0, tag: "Singular", reason: "the-sun" },
  //did a 900, paid a 20
  { match: "#Verb (a|an) [#Value]$", group: 0, tag: "Singular", reason: "did-a-value" },
  //'the can'
  { match: "the [(can|will|may)]", group: 0, tag: "Singular", reason: "the can" },
  // ==== Possessive ====
  //spencer kelly's
  { match: "#FirstName #Acronym? (#Possessive && #LastName)", tag: "Possessive", reason: "name-poss" },
  //Super Corp's fundraiser
  { match: "#Organization+ #Possessive", tag: "Possessive", reason: "org-possessive" },
  //Los Angeles's fundraiser
  { match: "#Place+ #Possessive", tag: "Possessive", reason: "place-possessive" },
  // Ptolemy's experiments
  { match: "#Possessive #PresentTense #Particle?", notIf: "(#Gerund|her)", tag: "Noun", reason: "possessive-verb" },
  // anna's eating vs anna's eating lunch
  // my presidents house
  { match: "(my|our|their|her|his|its) [(#Plural && #Actor)] #Noun", tag: "Possessive", reason: "my-dads" },
  // 10th of a second
  { match: "#Value of a [second]", group: 0, unTag: "Value", tag: "Singular", reason: "10th-of-a-second" },
  // 10 seconds
  { match: "#Value [seconds]", group: 0, unTag: "Value", tag: "Plural", reason: "10-seconds" },
  // in time
  { match: "in [#Infinitive]", group: 0, tag: "Singular", reason: "in-age" },
  // a minor in
  { match: "a [#Adjective] #Preposition", group: 0, tag: "Noun", reason: "a-minor-in" },
  //the repairer said
  { match: "#Determiner [#Singular] said", group: 0, tag: "Actor", reason: "the-actor-said" },
  //the euro sense
  {
    match: `#Determiner #Noun [${tP}] !(#Preposition|to|#Adverb)?`,
    group: 0,
    tag: "Noun",
    reason: "the-noun-sense"
  },
  // photographs of a computer are
  { match: "[#PresentTense] (of|by|for) (a|an|the) #Noun #Copula", group: 0, tag: "Plural", reason: "photographs-of" },
  // fight and win
  { match: "#Infinitive and [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "fight and win" },
  // peace and flowers and love
  { match: "#Noun and [#Verb] and #Noun", group: 0, tag: "Noun", reason: "peace-and-flowers" },
  // the 1992 classic
  { match: "the #Cardinal [%Adj|Noun%]", group: 0, tag: "Noun", reason: "the-1992-classic" },
  // the premier university
  { match: "#Copula the [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", reason: "the-premier-university" },
  // scottish - i ate me sandwich
  { match: "i #Verb [me] #Noun", group: 0, tag: "Possessive", reason: "scottish-me" },
  // dance music
  {
    match: "[#PresentTense] (music|class|lesson|night|party|festival|league|ceremony)",
    group: 0,
    tag: "Noun",
    reason: "dance-music"
  },
  // wit it
  { match: "[wit] (me|it)", group: 0, tag: "Presposition", reason: "wit-me" },
  //left-her-boots, shoved her hand
  { match: "#PastTense #Possessive [#Verb]", group: 0, tag: "Noun", notIf: "(saw|made)", reason: "left-her-boots" },
  //35 signs
  { match: "#Value [%Plural|Verb%]", group: 0, tag: "Plural", notIf: "(one|1|a|an)", reason: "35-signs" },
  //had time
  { match: "had [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|come|become)", reason: "had-time" },
  //instant access
  { match: "%Adj|Noun% %Noun|Verb%", tag: "#Adjective #Noun", notIf: "#ProperNoun #Noun", reason: "instant-access" },
  // a representative to
  { match: "#Determiner [%Adj|Noun%] #Conjunction", group: 0, tag: "Noun", reason: "a-rep-to" },
  // near death experiences, ambitious sales targets
  {
    match: "#Adjective #Noun [%Plural|Verb%]$",
    group: 0,
    tag: "Plural",
    notIf: "#Pronoun",
    reason: "near-death-experiences"
  },
  // your guild colors
  { match: "#Possessive #Noun [%Plural|Verb%]$", group: 0, tag: "Plural", reason: "your-guild-colors" }
], rP = [
  // the planning processes
  { match: "(this|that|the|a|an) [#Gerund #Infinitive]", group: 0, tag: "Singular", reason: "the-planning-process" },
  // the paving stones
  { match: "(that|the) [#Gerund #PresentTense]", group: 0, ifNo: "#Copula", tag: "Plural", reason: "the-paving-stones" },
  // this swimming
  // { match: '(this|that|the) [#Gerund]', group: 0, tag: 'Noun', reason: 'this-gerund' },
  // the remaining claims
  { match: "#Determiner [#Gerund] #Noun", group: 0, tag: "Adjective", reason: "the-gerund-noun" },
  // i think tipping sucks
  { match: "#Pronoun #Infinitive [#Gerund] #PresentTense", group: 0, tag: "Noun", reason: "tipping-sucks" },
  // early warning
  { match: "#Adjective [#Gerund]", group: 0, tag: "Noun", notIf: "(still|even|just)", reason: "early-warning" },
  //walking is cool
  { match: "[#Gerund] #Adverb? not? #Copula", group: 0, tag: "Activity", reason: "gerund-copula" },
  //are doing is
  { match: "#Copula [(#Gerund|#Activity)] #Copula", group: 0, tag: "Gerund", reason: "are-doing-is" },
  //walking should be fun
  { match: "[#Gerund] #Modal", group: 0, tag: "Activity", reason: "gerund-modal" },
  // finish listening
  // { match: '#Infinitive [#Gerund]', group: 0, tag: 'Activity', reason: 'finish-listening' },
  // the ruling party
  // responsibility for setting
  { match: "#Singular for [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "noun-for-gerund" },
  // better for training
  { match: "#Comparative (for|at) [%Noun|Gerund%]", group: 0, tag: "Gerund", reason: "better-for-gerund" },
  // keep the touching
  { match: "#PresentTense the [#Gerund]", group: 0, tag: "Noun", reason: "keep-the-touching" }
], aP = [
  // do the dance
  { match: "#Infinitive (this|that|the) [#Infinitive]", group: 0, tag: "Noun", reason: "do-this-dance" },
  //running-a-show
  { match: "#Gerund #Determiner [#Infinitive]", group: 0, tag: "Noun", reason: "running-a-show" },
  //the-only-reason
  { match: "#Determiner (only|further|just|more|backward) [#Infinitive]", group: 0, tag: "Noun", reason: "the-only-reason" },
  // a stream runs
  { match: "(the|this|a|an) [#Infinitive] #Adverb? #Verb", group: 0, tag: "Noun", reason: "determiner5" },
  //a nice deal
  { match: "#Determiner #Adjective #Adjective? [#Infinitive]", group: 0, tag: "Noun", reason: "a-nice-inf" },
  // the mexican train
  { match: "#Determiner #Demonym [#PresentTense]", group: 0, tag: "Noun", reason: "mexican-train" },
  //next career move
  { match: "#Adjective #Noun+ [#Infinitive] #Copula", group: 0, tag: "Noun", reason: "career-move" },
  // at some point
  { match: "at some [#Infinitive]", group: 0, tag: "Noun", reason: "at-some-inf" },
  // goes to sleep
  { match: "(go|goes|went) to [#Infinitive]", group: 0, tag: "Noun", reason: "goes-to-verb" },
  //a close watch on
  { match: "(a|an) #Adjective? #Noun [#Infinitive] (#Preposition|#Noun)", group: 0, notIf: "from", tag: "Noun", reason: "a-noun-inf" },
  //a tv show
  { match: "(a|an) #Noun [#Infinitive]$", group: 0, tag: "Noun", reason: "a-noun-inf2" },
  //is mark hughes
  // { match: '#Copula [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'is-pres-noun' },
  // good wait staff
  // { match: '#Adjective [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'good-wait-staff' },
  // running for congress
  { match: "#Gerund #Adjective? for [#Infinitive]", group: 0, tag: "Noun", reason: "running-for" },
  // running to work
  // { match: '#Gerund #Adjective to [#Infinitive]', group: 0, tag: 'Noun', reason: 'running-to' },
  // about love
  { match: "about [#Infinitive]", group: 0, tag: "Singular", reason: "about-love" },
  // singers on stage
  { match: "#Plural on [#Infinitive]", group: 0, tag: "Noun", reason: "on-stage" },
  // any charge
  { match: "any [#Infinitive]", group: 0, tag: "Noun", reason: "any-charge" },
  // no doubt
  { match: "no [#Infinitive]", group: 0, tag: "Noun", reason: "no-doubt" },
  // number of seats
  { match: "number of [#PresentTense]", group: 0, tag: "Noun", reason: "number-of-x" },
  // teaches/taught
  { match: "(taught|teaches|learns|learned) [#PresentTense]", group: 0, tag: "Noun", reason: "teaches-x" },
  // use reverse
  { match: "(try|use|attempt|build|make) [#Verb #Particle?]", notIf: "(#Copula|#Noun|sure|fun|up)", group: 0, tag: "Noun", reason: "do-verb" },
  //make sure of
  // checkmate is
  { match: "^[#Infinitive] (is|was)", group: 0, tag: "Noun", reason: "checkmate-is" },
  // get much sleep
  { match: "#Infinitive much [#Infinitive]", group: 0, tag: "Noun", reason: "get-much" },
  // cause i gotta
  { match: "[cause] #Pronoun #Verb", group: 0, tag: "Conjunction", reason: "cause-cuz" },
  // the cardio dance party
  { match: "the #Singular [#Infinitive] #Noun", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "cardio-dance" },
  // that should smoke
  { match: "#Determiner #Modal [#Noun]", group: 0, tag: "PresentTense", reason: "should-smoke" },
  //this rocks
  { match: "this [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Date)", reason: "this-verbs" },
  //voice that rocks
  { match: "#Noun that [#Plural]", group: 0, tag: "PresentTense", notIf: "(#Preposition|#Pronoun|way)", reason: "voice-that-rocks" },
  //that leads to
  { match: "that [#Plural] to", group: 0, tag: "PresentTense", notIf: "#Preposition", reason: "that-leads-to" },
  //let him glue
  {
    match: "(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)",
    group: 0,
    tag: "Infinitive",
    reason: "let-him-glue"
  },
  // assign all tasks
  { match: "#Verb (all|every|each|most|some|no) [#PresentTense]", notIf: "#Modal", group: 0, tag: "Noun", reason: "all-presentTense" },
  // PresentTense/Noun ambiguities
  // big dreams, critical thinking
  // have big dreams
  { match: "(had|have|#PastTense) #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "better", reason: "adj-presentTense" },
  // excellent answer spencer
  // { match: '^#Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'start adj-presentTense' },
  // one big reason
  { match: "#Value #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "one-big-reason" },
  // won widespread support
  { match: "#PastTense #Adjective+ [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Copula|better)", reason: "won-wide-support" },
  // many poses
  { match: "(many|few|several|couple) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "many-poses" },
  // very big dreams
  { match: "#Determiner #Adverb #Adjective [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Copula", reason: "very-big-dream" },
  // from start to finish
  { match: "from #Noun to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "start-to-finish" },
  // for comparison or contrast
  { match: "(for|with|of) #Noun (and|or|not) [%Noun|Verb%]", group: 0, tag: "Noun", notIf: "#Pronoun", reason: "for-food-and-gas" },
  // adorable little store
  { match: "#Adjective #Adjective [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "adorable-little-store" },
  // of basic training
  // { match: '#Preposition #Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'of-basic-training' },
  // justifiying higher costs
  { match: "#Gerund #Adverb? #Comparative [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "higher-costs" },
  { match: "(#Noun && @hasComma) #Noun (and|or) [#PresentTense]", group: 0, tag: "Noun", notIf: "#Copula", reason: "noun-list" },
  // any questions for
  { match: "(many|any|some|several) [#PresentTense] for", group: 0, tag: "Noun", reason: "any-verbs-for" },
  // to facilitate gas exchange with
  { match: "to #PresentTense #Noun [#PresentTense] #Preposition", group: 0, tag: "Noun", reason: "gas-exchange" },
  // waited until release
  { match: "#PastTense (until|as|through|without) [#PresentTense]", group: 0, tag: "Noun", reason: "waited-until-release" },
  // selling like hot cakes
  { match: "#Gerund like #Adjective? [#PresentTense]", group: 0, tag: "Plural", reason: "like-hot-cakes" },
  // some valid reason
  { match: "some #Adjective [#PresentTense]", group: 0, tag: "Noun", reason: "some-reason" },
  // for some reason
  { match: "for some [#PresentTense]", group: 0, tag: "Noun", reason: "for-some-reason" },
  // same kind of shouts
  { match: "(same|some|the|that|a) kind of [#PresentTense]", group: 0, tag: "Noun", reason: "some-kind-of" },
  // a type of shout
  { match: "(same|some|the|that|a) type of [#PresentTense]", group: 0, tag: "Noun", reason: "some-type-of" },
  // doing better for fights
  { match: "#Gerund #Adjective #Preposition [#PresentTense]", group: 0, tag: "Noun", reason: "doing-better-for-x" },
  // get better aim
  { match: "(get|got|have) #Comparative [#PresentTense]", group: 0, tag: "Noun", reason: "got-better-aim" },
  // whose name was
  { match: "whose [#PresentTense] #Copula", group: 0, tag: "Noun", reason: "whos-name-was" },
  // give up on reason
  { match: "#PhrasalVerb #Particle #Preposition [#PresentTense]", group: 0, tag: "Noun", reason: "given-up-on-x" },
  //there are reasons
  { match: "there (are|were) #Adjective? [#PresentTense]", group: 0, tag: "Plural", reason: "there-are" },
  // 30 trains
  { match: "#Value [#PresentTense] of", group: 0, notIf: "(one|1|#Copula|#Infinitive)", tag: "Plural", reason: "2-trains" },
  // compromises are possible
  { match: "[#PresentTense] (are|were) #Adjective", group: 0, tag: "Plural", reason: "compromises-are-possible" },
  // hope i helped
  { match: "^[(hope|guess|thought|think)] #Pronoun #Verb", group: 0, tag: "Infinitive", reason: "suppose-i" },
  //pursue its dreams
  // { match: '#PresentTense #Possessive [#PresentTense]', notIf: '#Gerund', group: 0, tag: 'Plural', reason: 'pursue-its-dreams' },
  // our unyielding support
  { match: "#Possessive #Adjective [#Verb]", group: 0, tag: "Noun", notIf: "#Copula", reason: "our-full-support" },
  // tastes good
  { match: "[(tastes|smells)] #Adverb? #Adjective", group: 0, tag: "PresentTense", reason: "tastes-good" },
  // are you playing golf
  // { match: '^are #Pronoun [#Noun]', group: 0, notIf: '(here|there)', tag: 'Verb', reason: 'are-you-x' },
  // ignoring commute
  { match: "#Copula #Gerund [#PresentTense] !by?", group: 0, tag: "Noun", notIf: "going", reason: "ignoring-commute" },
  // noun-pastTense variables
  { match: "#Determiner #Adjective? [(shed|thought|rose|bid|saw|spelt)]", group: 0, tag: "Noun", reason: "noun-past" },
  // 'verb-to'
  // how to watch
  { match: "how to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "how-to-noun" },
  // which boost it
  { match: "which [%Noun|Verb%] #Noun", group: 0, tag: "Infinitive", reason: "which-boost-it" },
  // asking questions
  { match: "#Gerund [%Plural|Verb%]", group: 0, tag: "Plural", reason: "asking-questions" },
  // ready to stream
  { match: "(ready|available|difficult|hard|easy|made|attempt|try) to [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "ready-to-noun" },
  // bring to market
  { match: "(bring|went|go|drive|run|bike) to [%Noun|Verb%]", group: 0, tag: "Noun", reason: "bring-to-noun" },
  // can i sleep, would you look
  { match: "#Modal #Noun [%Noun|Verb%]", group: 0, tag: "Infinitive", reason: "would-you-look" },
  // is just spam
  { match: "#Copula just [#Infinitive]", group: 0, tag: "Noun", reason: "is-just-spam" },
  // request copies
  { match: "^%Noun|Verb% %Plural|Verb%", tag: "Imperative #Plural", reason: "request-copies" },
  // homemade pickles and drinks
  { match: "#Adjective #Plural and [%Plural|Verb%]", group: 0, tag: "#Plural", reason: "pickles-and-drinks" },
  // the 1968 film
  { match: "#Determiner #Year [#Verb]", group: 0, tag: "Noun", reason: "the-1968-film" },
  // the break up
  { match: "#Determiner [#PhrasalVerb #Particle]", group: 0, tag: "Noun", reason: "the-break-up" },
  // the individual goals
  { match: "#Determiner [%Adj|Noun%] #Noun", group: 0, tag: "Adjective", notIf: "(#Pronoun|#Possessive|#ProperNoun)", reason: "the-individual-goals" },
  // work or prepare
  { match: "[%Noun|Verb%] or #Infinitive", group: 0, tag: "Infinitive", reason: "work-or-prepare" },
  // to give thanks
  { match: "to #Infinitive [#PresentTense]", group: 0, tag: "Noun", notIf: "(#Gerund|#Copula|help)", reason: "to-give-thanks" },
  // kills me
  { match: "[#Noun] me", group: 0, tag: "Verb", reason: "kills-me" },
  // removes wrinkles
  { match: "%Plural|Verb% %Plural|Verb%", tag: "#PresentTense #Plural", reason: "removes-wrinkles" }
], oP = [
  { match: "#Money and #Money #Currency?", tag: "Money", reason: "money-and-money" },
  // 6 dollars and 5 cents
  { match: "#Value #Currency [and] #Value (cents|ore|centavos|sens)", group: 0, tag: "money", reason: "and-5-cents" },
  // maybe currencies
  { match: "#Value (mark|rand|won|rub|ore)", tag: "#Money #Currency", reason: "4-mark" },
  // 3 pounds
  { match: "a pound", tag: "#Money #Unit", reason: "a-pound" },
  { match: "#Value (pound|pounds)", tag: "#Money #Unit", reason: "4-pounds" }
], iP = [
  // half a penny
  { match: "[(half|quarter)] of? (a|an)", group: 0, tag: "Fraction", reason: "millionth" },
  // nearly half
  { match: "#Adverb [half]", group: 0, tag: "Fraction", reason: "nearly-half" },
  // half the
  { match: "[half] the", group: 0, tag: "Fraction", reason: "half-the" },
  // and a half
  { match: "#Cardinal and a half", tag: "Fraction", reason: "and-a-half" },
  // two-halves
  { match: "#Value (halves|halfs|quarters)", tag: "Fraction", reason: "two-halves" },
  // ---ordinals as fractions---
  // a fifth
  { match: "a #Ordinal", tag: "Fraction", reason: "a-quarter" },
  // seven fifths
  { match: "[#Cardinal+] (#Fraction && /s$/)", tag: "Fraction", reason: "seven-fifths" },
  // doc.match('(#Fraction && /s$/)').lookBefore('#Cardinal+$').tag('Fraction')
  // one third of ..
  { match: "[#Cardinal+ #Ordinal] of .", group: 0, tag: "Fraction", reason: "ordinal-of" },
  // 100th of
  { match: "[(#NumericValue && #Ordinal)] of .", group: 0, tag: "Fraction", reason: "num-ordinal-of" },
  // a twenty fifth
  { match: "(a|one) #Cardinal?+ #Ordinal", tag: "Fraction", reason: "a-ordinal" },
  // //  '3 out of 5'
  { match: "#Cardinal+ out? of every? #Cardinal", tag: "Fraction", reason: "out-of" }
], sP = [
  // ==== Ambiguous numbers ====
  // 'second'
  { match: "#Cardinal [second]", tag: "Unit", reason: "one-second" },
  //'a/an' can mean 1 - "a hour"
  {
    match: "!once? [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)",
    group: 0,
    tag: "Value",
    reason: "a-is-one"
  },
  // ==== PhoneNumber ====
  //1 800 ...
  { match: "1 #Value #PhoneNumber", tag: "PhoneNumber", reason: "1-800-Value" },
  //(454) 232-9873
  { match: "#NumericValue #PhoneNumber", tag: "PhoneNumber", reason: "(800) PhoneNumber" },
  // ==== Currency ====
  // chinese yuan
  { match: "#Demonym #Currency", tag: "Currency", reason: "demonym-currency" },
  // ten bucks
  { match: "#Value [(buck|bucks|grand)]", group: 0, tag: "Currency", reason: "value-bucks" },
  // ==== Money ====
  { match: "[#Value+] #Currency", group: 0, tag: "Money", reason: "15 usd" },
  // ==== Ordinal ====
  { match: "[second] #Noun", group: 0, tag: "Ordinal", reason: "second-noun" },
  // ==== Units ====
  //5 yan
  { match: "#Value+ [#Currency]", group: 0, tag: "Unit", reason: "5-yan" },
  { match: "#Value [(foot|feet)]", group: 0, tag: "Unit", reason: "foot-unit" },
  //5 kg.
  { match: "#Value [#Abbreviation]", group: 0, tag: "Unit", reason: "value-abbr" },
  { match: "#Value [k]", group: 0, tag: "Unit", reason: "value-k" },
  { match: "#Unit an hour", tag: "Unit", reason: "unit-an-hour" },
  // ==== Magnitudes ====
  //minus 7
  { match: "(minus|negative) #Value", tag: "Value", reason: "minus-value" },
  //seven point five
  { match: "#Value (point|decimal) #Value", tag: "Value", reason: "value-point-value" },
  //quarter million
  { match: "#Determiner [(half|quarter)] #Ordinal", group: 0, tag: "Value", reason: "half-ordinal" },
  // thousand and two
  { match: "#Multiple+ and #Value", tag: "Value", reason: "magnitude-and-value" },
  // ambiguous units like 'gb'
  // { match: '#Value square? [(kb|mb|gb|tb|ml|pt|qt|tbl|tbsp|km|cm|mm|mi|ft|yd|kg|hg|mg|oz|lb|mph|pa|miles|yard|yards|pound|pounds)]', group: 0, tag: 'Unit', reason: '12-gb' },
  // 5 miles per hour
  { match: "#Value #Unit [(per|an) (hr|hour|sec|second|min|minute)]", group: 0, tag: "Unit", reason: "12-miles-per-second" },
  // 5 square miles
  { match: "#Value [(square|cubic)] #Unit", group: 0, tag: "Unit", reason: "square-miles" }
  // 5) The expenses
  // { match: '^[#Value] (#Determiner|#Gerund)', group: 0, tag: 'Expression', unTag: 'Value', reason: 'numbered-list' },
], uP = [
  // ==== FirstNames ====
  //is foo Smith
  { match: "#Copula [(#Noun|#PresentTense)] #LastName", group: 0, tag: "FirstName", reason: "copula-noun-lastname" },
  //pope francis
  {
    match: "(sister|pope|brother|father|aunt|uncle|grandpa|grandfather|grandma) #ProperNoun",
    tag: "Person",
    reason: "lady-titlecase",
    safe: !0
  },
  // ==== Nickname ====
  // Dwayne 'the rock' Johnson
  { match: "#FirstName [#Determiner #Noun] #LastName", group: 0, tag: "Person", reason: "first-noun-last" },
  {
    match: "#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun",
    tag: "Person",
    reason: "titlecase-acronym-titlecase",
    safe: !0
  },
  { match: "#Acronym #LastName", tag: "Person", reason: "acronym-lastname", safe: !0 },
  { match: "#Person (jr|sr|md)", tag: "Person", reason: "person-honorific" },
  //remove single 'mr'
  { match: "#Honorific #Acronym", tag: "Person", reason: "Honorific-TitleCase" },
  { match: "#Person #Person the? #RomanNumeral", tag: "Person", reason: "roman-numeral" },
  { match: "#FirstName [/^[^aiurck]$/]", group: 0, tag: ["Acronym", "Person"], reason: "john-e" },
  //j.k Rowling
  { match: "#Noun van der? #Noun", tag: "Person", reason: "van der noun", safe: !0 },
  //king of spain
  { match: "(king|queen|prince|saint|lady) of #Noun", tag: "Person", reason: "king-of-noun", safe: !0 },
  //lady Florence
  { match: "(prince|lady) #Place", tag: "Person", reason: "lady-place" },
  //saint Foo
  { match: "(king|queen|prince|saint) #ProperNoun", tag: "Person", notIf: "#Place", reason: "saint-foo" },
  // al sharpton
  { match: "al (#Person|#ProperNoun)", tag: "Person", reason: "al-borlen", safe: !0 },
  //ferdinand de almar
  { match: "#FirstName de #Noun", tag: "Person", reason: "bill-de-noun" },
  //Osama bin Laden
  { match: "#FirstName (bin|al) #Noun", tag: "Person", reason: "bill-al-noun" },
  //John L. Foo
  { match: "#FirstName #Acronym #ProperNoun", tag: "Person", reason: "bill-acronym-title" },
  //Andrew Lloyd Webber
  { match: "#FirstName #FirstName #ProperNoun", tag: "Person", reason: "bill-firstname-title" },
  //Mr Foo
  { match: "#Honorific #FirstName? #ProperNoun", tag: "Person", reason: "dr-john-Title" },
  //peter the great
  { match: "#FirstName the #Adjective", tag: "Person", reason: "name-the-great" },
  // dick van dyke
  { match: "#ProperNoun (van|al|bin) #ProperNoun", tag: "Person", reason: "title-van-title", safe: !0 },
  //jose de Sucre
  { match: "#ProperNoun (de|du) la? #ProperNoun", tag: "Person", notIf: "#Place", reason: "title-de-title" },
  //Jani K. Smith
  { match: "#Singular #Acronym #LastName", tag: "#FirstName #Person .", reason: "title-acro-noun", safe: !0 },
  //Foo Ford
  { match: "[#ProperNoun] #Person", group: 0, tag: "Person", reason: "proper-person", safe: !0 },
  // john keith jones
  {
    match: "#Person [#ProperNoun #ProperNoun]",
    group: 0,
    tag: "Person",
    notIf: "#Possessive",
    reason: "three-name-person",
    safe: !0
  },
  //John Foo
  {
    match: "#FirstName #Acronym? [#ProperNoun]",
    group: 0,
    tag: "LastName",
    notIf: "#Possessive",
    reason: "firstname-titlecase"
  },
  // john stewart
  { match: "#FirstName [#FirstName]", group: 0, tag: "LastName", reason: "firstname-firstname" },
  //Joe K. Sombrero
  { match: "#FirstName #Acronym #Noun", tag: "Person", reason: "n-acro-noun", safe: !0 },
  //Anthony de Marco
  { match: "#FirstName [(de|di|du|van|von)] #Person", group: 0, tag: "LastName", reason: "de-firstname" },
  // baker jenna smith
  // { match: '[#Actor+] #Person', group: 0, tag: 'Person', reason: 'baker-sam-smith' },
  // sergeant major Harold
  {
    match: "[(lieutenant|corporal|sergeant|captain|qeen|king|admiral|major|colonel|marshal|president|queen|king)+] #ProperNoun",
    group: 0,
    tag: "Honorific",
    reason: "seargeant-john"
  },
  // ==== Honorics ====
  {
    match: "[(private|general|major|rear|prime|field|count|miss)] #Honorific? #Person",
    group: 0,
    tag: ["Honorific", "Person"],
    reason: "ambg-honorifics"
  },
  // dr john foobar
  {
    match: "#Honorific #FirstName [#Singular]",
    group: 0,
    tag: "LastName",
    notIf: "#Possessive",
    reason: "dr-john-foo",
    safe: !0
  },
  //his-excellency
  {
    match: "[(his|her) (majesty|honour|worship|excellency|honorable)] #Person",
    group: 0,
    tag: "Honorific",
    reason: "his-excellency"
  },
  // Lieutenant colonel
  { match: "#Honorific #Actor", tag: "Honorific", reason: "Lieutenant colonel" },
  // first lady, second admiral
  { match: "(first|second|third|1st|2nd|3rd) #Actor", tag: "Honorific", reason: "first lady" },
  // Louis IV
  { match: "#Person #RomanNumeral", tag: "Person", reason: "louis-IV" }
], lP = [
  // ebenezer scrooge
  {
    match: "#FirstName #Noun$",
    tag: ". #LastName",
    notIf: "(#Possessive|#Organization|#Place|#Pronoun|@hasTitleCase)",
    reason: "firstname-noun"
  },
  // ===person-date===
  { match: "%Person|Date% #Acronym? #ProperNoun", tag: "Person", reason: "jan-thierson" },
  // ===person-noun===
  //Cliff Clavin
  { match: "%Person|Noun% #Acronym? #ProperNoun", tag: "Person", reason: "switch-person", safe: !0 },
  // olive garden
  { match: "%Person|Noun% #Organization", tag: "Organization", reason: "olive-garden" },
  // ===person-verb===
  // ollie faroo
  { match: "%Person|Verb% #Acronym? #ProperNoun", tag: "Person", reason: "verb-propernoun", ifNo: "#Actor" },
  // chuck will ...
  {
    match: "[%Person|Verb%] (will|had|has|said|says|told|did|learned|wants|wanted)",
    group: 0,
    tag: "Person",
    reason: "person-said"
  },
  // ===person-place===
  //sydney harbour
  {
    match: "[%Person|Place%] (harbor|harbour|pier|town|city|place|dump|landfill)",
    group: 0,
    tag: "Place",
    reason: "sydney-harbour"
  },
  // east sydney
  { match: "(west|east|north|south) [%Person|Place%]", group: 0, tag: "Place", reason: "east-sydney" },
  // ===person-adjective===
  // rusty smith
  // { match: `${personAdj} #Person`, tag: 'Person', reason: 'randy-smith' },
  // rusty a. smith
  // { match: `${personAdj} #Acronym? #ProperNoun`, tag: 'Person', reason: 'rusty-smith' },
  // very rusty
  // { match: `#Adverb [${personAdj}]`, group: 0, tag: 'Adjective', reason: 'really-rich' },
  // ===person-verb===
  // would wade
  { match: "#Modal [%Person|Verb%]", group: 0, tag: "Verb", reason: "would-mark" },
  // really wade
  { match: "#Adverb [%Person|Verb%]", group: 0, tag: "Verb", reason: "really-mark" },
  // drew closer
  { match: "[%Person|Verb%] (#Adverb|#Comparative)", group: 0, tag: "Verb", reason: "drew-closer" },
  // wade smith
  { match: "%Person|Verb% #Person", tag: "Person", reason: "rob-smith" },
  // wade m. Cooper
  { match: "%Person|Verb% #Acronym #ProperNoun", tag: "Person", reason: "rob-a-smith" },
  // will go
  { match: "[will] #Verb", group: 0, tag: "Modal", reason: "will-verb" },
  // will Pharell
  { match: "(will && @isTitleCase) #ProperNoun", tag: "Person", reason: "will-name" },
  // jack layton won
  {
    match: "(#FirstName && !#Possessive) [#Singular] #Verb",
    group: 0,
    safe: !0,
    tag: "LastName",
    reason: "jack-layton"
  },
  // sherwood anderson told
  { match: "^[#Singular] #Person #Verb", group: 0, safe: !0, tag: "Person", reason: "sherwood-anderson" },
  // bought a warhol
  { match: "(a|an) [#Person]$", group: 0, unTag: "Person", reason: "a-warhol" }
], cP = [
  //sometimes adverbs - 'pretty good','well above'
  {
    match: "#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)",
    tag: "#Copula #Adverb #Adjective",
    reason: "sometimes-adverb"
  },
  //i better ..
  { match: "(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense", group: 0, tag: "Modal", reason: "i-better" },
  // adj -> gerund
  // like
  { match: "(#Modal|i|they|we|do) not? [like]", group: 0, tag: "PresentTense", reason: "modal-like" },
  // ==== Tense ====
  //he left
  { match: "#Noun #Adverb? [left]", group: 0, tag: "PastTense", reason: "left-verb" },
  // ==== Copula ====
  //will be running (not copula)
  { match: "will #Adverb? not? #Adverb? [be] #Gerund", group: 0, tag: "Copula", reason: "will-be-copula" },
  //for more complex forms, just tag 'be'
  { match: "will #Adverb? not? #Adverb? [be] #Adjective", group: 0, tag: "Copula", reason: "be-copula" },
  // ==== Infinitive ====
  //march to
  { match: "[march] (up|down|back|toward)", notIf: "#Date", group: 0, tag: "Infinitive", reason: "march-to" },
  //must march
  { match: "#Modal [march]", group: 0, tag: "Infinitive", reason: "must-march" },
  // may be
  { match: "[may] be", group: 0, tag: "Verb", reason: "may-be" },
  // subject to
  { match: "[(subject|subjects|subjected)] to", group: 0, tag: "Verb", reason: "subject to" },
  // subject to
  { match: "[home] to", group: 0, tag: "PresentTense", reason: "home to" },
  // === misc==
  // side with
  // { match: '[(side|fool|monkey)] with', group: 0, tag: 'Infinitive', reason: 'fool-with' },
  // open the door
  { match: "[open] #Determiner", group: 0, tag: "Infinitive", reason: "open-the" },
  //were being run
  { match: "(were|was) being [#PresentTense]", group: 0, tag: "PastTense", reason: "was-being" },
  //had been broken
  { match: "(had|has|have) [been /en$/]", group: 0, tag: "Auxiliary Participle", reason: "had-been-broken" },
  //had been smoked
  { match: "(had|has|have) [been /ed$/]", group: 0, tag: "Auxiliary PastTense", reason: "had-been-smoked" },
  //were being run
  { match: "(had|has) #Adverb? [been] #Adverb? #PastTense", group: 0, tag: "Auxiliary", reason: "had-been-adj" },
  //had to walk
  { match: "(had|has) to [#Noun] (#Determiner|#Possessive)", group: 0, tag: "Infinitive", reason: "had-to-noun" },
  // have read
  { match: "have [#PresentTense]", group: 0, tag: "PastTense", notIf: "(come|gotten)", reason: "have-read" },
  // does that work
  { match: "(does|will|#Modal) that [work]", group: 0, tag: "PastTense", reason: "does-that-work" },
  // sounds fun
  { match: "[(sound|sounds)] #Adjective", group: 0, tag: "PresentTense", reason: "sounds-fun" },
  // look good
  { match: "[(look|looks)] #Adjective", group: 0, tag: "PresentTense", reason: "looks-good" },
  // stops thinking
  { match: "[(start|starts|stop|stops|begin|begins)] #Gerund", group: 0, tag: "Verb", reason: "starts-thinking" },
  // have read
  { match: "(have|had) read", tag: "Modal #PastTense", reason: "read-read" },
  //were under cooked
  {
    match: "(is|was|were) [(under|over) #PastTense]",
    group: 0,
    tag: "Adverb Adjective",
    reason: "was-under-cooked"
  },
  // damn them
  { match: "[shit] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear1-verb" },
  { match: "[damn] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear2-verb" },
  { match: "[fuck] (#Determiner|#Possessive|them)", group: 0, tag: "Verb", reason: "swear3-verb" },
  // jobs that fit
  { match: "#Plural that %Noun|Verb%", tag: ". #Preposition #Infinitive", reason: "jobs-that-work" },
  // works for me
  { match: "[works] for me", group: 0, tag: "PresentTense", reason: "works-for-me" },
  // as we please
  { match: "as #Pronoun [please]", group: 0, tag: "Infinitive", reason: "as-we-please" },
  // verb-prefixes - 'co write'
  { match: "[(co|mis|de|inter|intra|pre|re|un|out|under|over|counter)] #Verb", group: 0, tag: ["Verb", "Prefix"], notIf: "(#Copula|#PhrasalVerb)", reason: "co-write" },
  // dressed and left
  { match: "#PastTense and [%Adj|Past%]", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // melted and fallen
  { match: "[%Adj|Past%] and #PastTense", group: 0, tag: "PastTense", reason: "dressed-and-left" },
  // is he stoked
  { match: "#Copula #Pronoun [%Adj|Past%]", group: 0, tag: "Adjective", reason: "is-he-stoked" },
  // to dream of
  { match: "to [%Noun|Verb%] #Preposition", group: 0, tag: "Infinitive", reason: "to-dream-of" }
], hP = [
  // ==== Auxiliary ====
  // have been
  { match: "will (#Adverb|not)+? [have] (#Adverb|not)+? #Verb", group: 0, tag: "Auxiliary", reason: "will-have-vb" },
  //was walking
  { match: "[#Copula] (#Adverb|not)+? (#Gerund|#PastTense)", group: 0, tag: "Auxiliary", reason: "copula-walking" },
  //would walk
  { match: "[(#Modal|did)+] (#Adverb|not)+? #Verb", group: 0, tag: "Auxiliary", reason: "modal-verb" },
  //would have had
  { match: "#Modal (#Adverb|not)+? [have] (#Adverb|not)+? [had] (#Adverb|not)+? #Verb", group: 0, tag: "Auxiliary", reason: "would-have" },
  //support a splattering of auxillaries before a verb
  { match: "[(has|had)] (#Adverb|not)+? #PastTense", group: 0, tag: "Auxiliary", reason: "had-walked" },
  // will walk
  { match: "[(do|does|did|will|have|had|has|got)] (not|#Adverb)+? #Verb", group: 0, tag: "Auxiliary", reason: "have-had" },
  // about to go
  { match: "[about to] #Adverb? #Verb", group: 0, tag: ["Auxiliary", "Verb"], reason: "about-to" },
  //would be walking
  { match: "#Modal (#Adverb|not)+? [be] (#Adverb|not)+? #Verb", group: 0, tag: "Auxiliary", reason: "would-be" },
  //had been walking
  { match: "[(#Modal|had|has)] (#Adverb|not)+? [been] (#Adverb|not)+? #Verb", group: 0, tag: "Auxiliary", reason: "had-been" },
  // was being driven
  { match: "[(be|being|been)] #Participle", group: 0, tag: "Auxiliary", reason: "being-driven" },
  // may want
  { match: "[may] #Adverb? #Infinitive", group: 0, tag: "Auxiliary", reason: "may-want" },
  // was being walked
  { match: "#Copula (#Adverb|not)+? [(be|being|been)] #Adverb+? #PastTense", group: 0, tag: "Auxiliary", reason: "being-walked" },
  // will be walked
  { match: "will [be] #PastTense", group: 0, tag: "Auxiliary", reason: "will-be-x" },
  // been walking
  { match: "[(be|been)] (#Adverb|not)+? #Gerund", group: 0, tag: "Auxiliary", reason: "been-walking" },
  // used to walk
  { match: "[used to] #PresentTense", group: 0, tag: "Auxiliary", reason: "used-to-walk" },
  // was going to walk
  { match: "#Copula (#Adverb|not)+? [going to] #Adverb+? #PresentTense", group: 0, tag: "Auxiliary", reason: "going-to-walk" },
  // tell me
  { match: "#Imperative [(me|him|her)]", group: 0, tag: "Reflexive", reason: "tell-him" },
  // there is no x
  { match: "(is|was) #Adverb? [no]", group: 0, tag: "Negative", reason: "is-no" },
  // been told
  { match: "[(been|had|became|came)] #PastTense", group: 0, notIf: "#PhrasalVerb", tag: "Auxiliary", reason: "been-told" },
  // being born
  { match: "[(being|having|getting)] #Verb", group: 0, tag: "Auxiliary", reason: "being-born" },
  // be walking
  { match: "[be] #Gerund", group: 0, tag: "Auxiliary", reason: "be-walking" },
  // better go
  { match: "[better] #PresentTense", group: 0, tag: "Modal", notIf: "(#Copula|#Gerund)", reason: "better-go" },
  // even better
  { match: "even better", tag: "Adverb #Comparative", reason: "even-better" }
], dP = [
  // ==== Phrasal ====
  //'foo-up'
  { match: "(#Verb && @hasHyphen) up", tag: "PhrasalVerb", reason: "foo-up" },
  { match: "(#Verb && @hasHyphen) off", tag: "PhrasalVerb", reason: "foo-off" },
  { match: "(#Verb && @hasHyphen) over", tag: "PhrasalVerb", reason: "foo-over" },
  { match: "(#Verb && @hasHyphen) out", tag: "PhrasalVerb", reason: "foo-out" },
  // walk in on
  {
    match: "[#Verb (in|out|up|down|off|back)] (on|in)",
    notIf: "#Copula",
    tag: "PhrasalVerb Particle",
    reason: "walk-in-on"
  },
  // went on for
  { match: "(lived|went|crept|go) [on] for", group: 0, tag: "PhrasalVerb", reason: "went-on" },
  // the curtains come down
  { match: "#Verb (up|down|in|on|for)$", tag: "PhrasalVerb #Particle", notIf: "#PhrasalVerb", reason: "come-down$" },
  // got me thinking
  // { match: '(got|had) me [#Noun]', group: 0, tag: 'Verb', reason: 'got-me-gerund' },
  // help stop
  { match: "help [(stop|end|make|start)]", group: 0, tag: "Infinitive", reason: "help-stop" },
  // work in the office
  { match: "#PhrasalVerb (in && #Particle) #Determiner", tag: "#Verb #Preposition #Determiner", unTag: "PhrasalVerb", reason: "work-in-the" },
  // start listening
  { match: "[(stop|start|finish|help)] #Gerund", group: 0, tag: "Infinitive", reason: "start-listening" },
  // mis-fired
  // { match: '[(mis)] #Verb', group: 0, tag: 'Verb', reason: 'mis-firedsa' },
  //back it up
  {
    match: "#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]",
    group: 0,
    tag: "Adverb",
    reason: "phrasal-pronoun-advb"
  }
], ms = "(i|we|they)", pP = [
  // do not go
  { match: "^do not? [#Infinitive #Particle?]", notIf: ms, group: 0, tag: "Imperative", reason: "do-eat" },
  // please go
  { match: "^please do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "please-go" },
  // just go
  { match: "^just do? not? [#Infinitive #Particle?]", group: 0, tag: "Imperative", reason: "just-go" },
  // do it better
  { match: "^[#Infinitive] it #Comparative", notIf: ms, group: 0, tag: "Imperative", reason: "do-it-better" },
  // do it again
  { match: "^[#Infinitive] it (please|now|again|plz)", notIf: ms, group: 0, tag: "Imperative", reason: "do-it-please" },
  // go quickly.
  { match: "^[#Infinitive] (#Adjective|#Adverb)$", group: 0, tag: "Imperative", notIf: "(so|such|rather|enough)", reason: "go-quickly" },
  // turn down the noise
  { match: "^[#Infinitive] (up|down|over) #Determiner", group: 0, tag: "Imperative", reason: "turn-down" },
  // eat my shorts
  { match: "^[#Infinitive] (your|my|the|a|an|any|each|every|some|more|with|on)", group: 0, notIf: "like", tag: "Imperative", reason: "eat-my-shorts" },
  // tell him the story
  { match: "^[#Infinitive] (him|her|it|us|me|there)", group: 0, tag: "Imperative", reason: "tell-him" },
  // avoid loud noises
  { match: "^[#Infinitive] #Adjective #Noun$", group: 0, tag: "Imperative", reason: "avoid-loud-noises" },
  // call and reserve
  { match: "^[#Infinitive] (#Adjective|#Adverb)? and #Infinitive", group: 0, tag: "Imperative", reason: "call-and-reserve" },
  // one-word imperatives
  { match: "^(go|stop|wait|hurry) please?$", tag: "Imperative", reason: "go" },
  // somebody call
  { match: "^(somebody|everybody) [#Infinitive]", group: 0, tag: "Imperative", reason: "somebody-call" },
  // let's leave
  { match: "^let (us|me) [#Infinitive]", group: 0, tag: "Imperative", reason: "lets-leave" },
  // shut the door
  { match: "^[(shut|close|open|start|stop|end|keep)] #Determiner #Noun", group: 0, tag: "Imperative", reason: "shut-the-door" },
  // turn off the light
  { match: "^[#PhrasalVerb #Particle] #Determiner #Noun", group: 0, tag: "Imperative", reason: "turn-off-the-light" },
  // go to toronto
  { match: "^[go] to .", group: 0, tag: "Imperative", reason: "go-to-toronto" },
  // would you recommend
  { match: "^#Modal you [#Infinitive]", group: 0, tag: "Imperative", reason: "would-you-" },
  // never say
  { match: "^never [#Infinitive]", group: 0, tag: "Imperative", reason: "never-stop" },
  // come have a drink
  { match: "^come #Infinitive", tag: "Imperative", notIf: "on", reason: "come-have" },
  // come and have a drink
  { match: "^come and? #Infinitive", tag: "Imperative . Imperative", notIf: "#PhrasalVerb", reason: "come-and-have" },
  // stay away
  { match: "^stay (out|away|back)", tag: "Imperative", reason: "stay-away" },
  // stay cool
  { match: "^[(stay|be|keep)] #Adjective", group: 0, tag: "Imperative", reason: "stay-cool" },
  // keep it silent
  { match: "^[keep it] #Adjective", group: 0, tag: "Imperative", reason: "keep-it-cool" },
  // don't be late
  { match: "^do not [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-be" },
  // allow yourself
  { match: "[#Infinitive] (yourself|yourselves)", group: 0, tag: "Imperative", reason: "allow-yourself" },
  // look what
  { match: "[#Infinitive] what .", group: 0, tag: "Imperative", reason: "look-what" },
  // continue playing
  { match: "^[#Infinitive] #Gerund", group: 0, tag: "Imperative", reason: "keep-playing" },
  // go to it
  { match: "^[#Infinitive] (to|for|into|toward|here|there)", group: 0, tag: "Imperative", reason: "go-to" },
  // relax and unwind
  { match: "^[#Infinitive] (and|or) #Infinitive", group: 0, tag: "Imperative", reason: "inf-and-inf" },
  // commit to
  { match: "^[%Noun|Verb%] to", group: 0, tag: "Imperative", reason: "commit-to" },
  // maintain eye contact
  { match: "^[#Infinitive] #Adjective? #Singular #Singular", group: 0, tag: "Imperative", reason: "maintain-eye-contact" },
  // don't forget to clean
  { match: "do not (forget|omit|neglect) to [#Infinitive]", group: 0, tag: "Imperative", reason: "do-not-forget" },
  // pay attention
  { match: "^[(ask|wear|pay|look|help|show|watch|act|fix|kill|stop|start|turn|try|win)] #Noun", group: 0, tag: "Imperative", reason: "pay-attention" }
], fP = [
  // that were growing
  { match: "(that|which) were [%Adj|Gerund%]", group: 0, tag: "Gerund", reason: "that-were-growing" },
  // was dissapointing
  // { match: '#Copula [%Adj|Gerund%]$', group: 0, tag: 'Adjective', reason: 'was-disappointing$' },
  // repairing crubling roads
  { match: "#Gerund [#Gerund] #Plural", group: 0, tag: "Adjective", reason: "hard-working-fam" }
  // { match: '(that|which) were [%Adj|Gerund%]', group: 0, tag: 'Gerund', reason: 'that-were-growing' },
], mP = [
  // got walked, was walked, were walked
  { match: "(got|were|was|is|are|am) (#PastTense|#Participle)", tag: "Passive", reason: "got-walked" },
  // was being walked
  { match: "(was|were|is|are|am) being (#PastTense|#Participle)", tag: "Passive", reason: "was-being" },
  // had been walked, have been eaten
  { match: "(had|have|has) been (#PastTense|#Participle)", tag: "Passive", reason: "had-been" },
  // will be cleaned
  { match: "will be being? (#PastTense|#Participle)", tag: "Passive", reason: "will-be-cleaned" },
  // suffered by the country
  { match: "#Noun [(#PastTense|#Participle)] by (the|a) #Noun", group: 0, tag: "Passive", reason: "suffered-by" }
];
let gP = [
  // u r cool
  { match: "u r", tag: "#Pronoun #Copula", reason: "u r" },
  { match: "#Noun [(who|whom)]", group: 0, tag: "Determiner", reason: "captain-who" },
  // ==== Conditions ====
  // had he survived,
  { match: "[had] #Noun+ #PastTense", group: 0, tag: "Condition", reason: "had-he" },
  // were he to survive
  { match: "[were] #Noun+ to #Infinitive", group: 0, tag: "Condition", reason: "were-he" },
  // some sort of
  { match: "some sort of", tag: "Adjective Noun Conjunction", reason: "some-sort-of" },
  // some of
  // { match: 'some of', tag: 'Noun Conjunction', reason: 'some-of' },
  // of some sort
  { match: "of some sort", tag: "Conjunction Adjective Noun", reason: "of-some-sort" },
  // such skill
  { match: "[such] (a|an|is)? #Noun", group: 0, tag: "Determiner", reason: "such-skill" },
  // another one
  // { match: '[another] (#Noun|#Value)', group: 0, tag: 'Adjective', reason: 'another-one' },
  // right after
  { match: "[right] (before|after|in|into|to|toward)", group: 0, tag: "#Adverb", reason: "right-into" },
  // at about
  { match: "#Preposition [about]", group: 0, tag: "Adjective", reason: "at-about" },
  // are ya
  { match: "(are|#Modal|see|do|for) [ya]", group: 0, tag: "Pronoun", reason: "are-ya" },
  // long live
  { match: "[long live] .", group: 0, tag: "#Adjective #Infinitive", reason: "long-live" },
  // plenty of
  { match: "[plenty] of", group: 0, tag: "#Uncountable", reason: "plenty-of" },
  // 'there' as adjective
  { match: "(always|nearly|barely|practically) [there]", group: 0, tag: "Adjective", reason: "always-there" },
  // existential 'there'
  // there she is
  { match: "[there] (#Adverb|#Pronoun)? #Copula", group: 0, tag: "There", reason: "there-is" },
  // is there food
  { match: "#Copula [there] .", group: 0, tag: "There", reason: "is-there" },
  // should there
  { match: "#Modal #Adverb? [there]", group: 0, tag: "There", reason: "should-there" },
  // do you
  { match: "^[do] (you|we|they)", group: 0, tag: "QuestionWord", reason: "do-you" },
  // does he
  { match: "^[does] (he|she|it|#ProperNoun)", group: 0, tag: "QuestionWord", reason: "does-he" },
  // the person who
  { match: "#Determiner #Noun+ [who] #Verb", group: 0, tag: "Preposition", reason: "the-x-who" },
  // the person which
  { match: "#Determiner #Noun+ [which] #Verb", group: 0, tag: "Preposition", reason: "the-x-which" },
  // a while
  { match: "a [while]", group: 0, tag: "Noun", reason: "a-while" },
  // guess who
  { match: "guess who", tag: "#Infinitive #QuestionWord", reason: "guess-who" },
  // swear words
  { match: "[fucking] !#Verb", group: 0, tag: "#Gerund", reason: "f-as-gerund" }
];
const vP = [
  // Foo University
  // { match: `#Noun ${orgMap}`, tag: 'Organization', safe: true, reason: 'foo-university' },
  // // University of Toronto
  // { match: `${orgMap} of #Place`, tag: 'Organization', safe: true, reason: 'university-of-foo' },
  // // foo regional health authority
  // { match: `${orgMap} (health|local|regional)+ authority`, tag: 'Organization', reason: 'regional-health' },
  // // foo stock exchange
  // { match: `${orgMap} (stock|mergantile)+ exchange`, tag: 'Organization', reason: 'stock-exchange' },
  // // foo news service
  // { match: `${orgMap} (daily|evening|local)+ news service?`, tag: 'Organization', reason: 'foo-news' },
  //University of Foo
  { match: "university of #Place", tag: "Organization", reason: "university-of-Foo" },
  //John & Joe's
  { match: "#Noun (&|n) #Noun", tag: "Organization", reason: "Noun-&-Noun" },
  // teachers union of Ontario
  { match: "#Organization of the? #ProperNoun", tag: "Organization", reason: "org-of-place", safe: !0 },
  //walmart USA
  { match: "#Organization #Country", tag: "Organization", reason: "org-country" },
  //organization
  { match: "#ProperNoun #Organization", tag: "Organization", notIf: "#FirstName", reason: "titlecase-org" },
  //FitBit Inc
  { match: "#ProperNoun (ltd|co|inc|dept|assn|bros)", tag: "Organization", reason: "org-abbrv" },
  // the OCED
  { match: "the [#Acronym]", group: 0, tag: "Organization", reason: "the-acronym", safe: !0 },
  // government of india
  { match: "government of the? [#Place+]", tag: "Organization", reason: "government-of-x" },
  // school board
  { match: "(health|school|commerce) board", tag: "Organization", reason: "school-board" },
  // special comittee
  {
    match: "(nominating|special|conference|executive|steering|central|congressional) committee",
    tag: "Organization",
    reason: "special-comittee"
  },
  // global trade union
  {
    match: "(world|global|international|national|#Demonym) #Organization",
    tag: "Organization",
    reason: "global-org"
  },
  // schools
  { match: "#Noun+ (public|private) school", tag: "School", reason: "noun-public-school" },
  // new york yankees
  { match: "#Place+ #SportsTeam", tag: "SportsTeam", reason: "place-sportsteam" },
  // 'manchester united'
  {
    match: "(dc|atlanta|minnesota|manchester|newcastle|sheffield) united",
    tag: "SportsTeam",
    reason: "united-sportsteam"
  },
  // 'toronto fc'
  { match: "#Place+ fc", tag: "SportsTeam", reason: "fc-sportsteam" },
  // baltimore quilting club
  {
    match: "#Place+ #Noun{0,2} (club|society|group|team|committee|commission|association|guild|crew)",
    tag: "Organization",
    reason: "place-noun-society"
  }
], yP = [
  // ==== Region ====
  // West Norforlk
  { match: "(west|north|south|east|western|northern|southern|eastern)+ #Place", tag: "Region", reason: "west-norfolk" },
  //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
  {
    match: "#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|pa|sc|tn|tx|ut|vt|pr)]",
    group: 0,
    tag: "Region",
    reason: "us-state"
  },
  // portland oregon
  { match: "portland [or]", group: 0, tag: "Region", reason: "portland-or" },
  //words removed from preTagger/placeWords
  {
    match: "#ProperNoun+ (cliff|place|range|pit|place|point|room|grounds|ruins)",
    tag: "Place",
    reason: "foo-point"
  },
  // in Foo California
  { match: "in [#ProperNoun] #Place", group: 0, tag: "Place", reason: "propernoun-place" },
  // Address
  {
    match: "#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)",
    tag: "Address",
    reason: "address-st"
  },
  // port dover
  { match: "(port|mount|mt) #ProperName", tag: "Place", reason: "port-name" }
  // generic 'oak ridge' names
  // { match: '(oak|maple|spruce|pine|cedar|willow|green|sunset|sunrise) #Place', tag: 'Place', reason: 'tree-name' },
  // generic 'sunset view' names
  // { match: '() #Place', tag: 'Place', reason: 'tree-name' },
  // Sports Arenas and Complexs
  // {
  //   match:
  //     '(#Place+|#Place|#ProperNoun) (memorial|athletic|community|financial)? (sportsplex|stadium|sports centre|sports field|soccer complex|soccer centre|sports complex|civic centre|centre|arena|gardens|complex|coliseum|auditorium|place|building)',
  //   tag: 'Place',
  //   reason: 'sport-complex',
  // },
], bP = [
  // ==== Conjunctions ====
  { match: "[so] #Noun", group: 0, tag: "Conjunction", reason: "so-conj" },
  //how he is driving
  {
    match: "[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)",
    group: 0,
    tag: "Conjunction",
    reason: "how-he-is-x"
  },
  // when he
  { match: "#Copula [(who|what|where|why|how|when)] #Noun", group: 0, tag: "Conjunction", reason: "when-he" },
  // says that he..
  { match: "#Verb [that] #Pronoun", group: 0, tag: "Conjunction", reason: "said-that-he" },
  // things that are required
  { match: "#Noun [that] #Copula", group: 0, tag: "Conjunction", reason: "that-are" },
  // things that seem cool
  { match: "#Noun [that] #Verb #Adjective", group: 0, tag: "Conjunction", reason: "that-seem" },
  // wasn't that wide..
  { match: "#Noun #Copula not? [that] #Adjective", group: 0, tag: "Adverb", reason: "that-adj" },
  // ==== Prepositions ====
  //all students
  { match: "#Verb #Adverb? #Noun [(that|which)]", group: 0, tag: "Preposition", reason: "that-prep" },
  //work, which has been done.
  { match: "@hasComma [which] (#Pronoun|#Verb)", group: 0, tag: "Preposition", reason: "which-copula" },
  //folks like her
  { match: "#Noun [like] #Noun", group: 0, tag: "Preposition", reason: "noun-like" },
  //like the time
  { match: "^[like] #Determiner", group: 0, tag: "Preposition", reason: "like-the" },
  //a day like this
  { match: "a #Noun [like] (#Noun|#Determiner)", group: 0, tag: "Preposition", reason: "a-noun-like" },
  // really like
  { match: "#Adverb [like]", group: 0, tag: "Verb", reason: "really-like" },
  // nothing like
  { match: "(not|nothing|never) [like]", group: 0, tag: "Preposition", reason: "nothing-like" },
  // treat them like
  { match: "#Infinitive #Pronoun [like]", group: 0, tag: "Preposition", reason: "treat-them-like" },
  // ==== Questions ====
  // where
  // why
  // when
  // who
  // whom
  // whose
  // what
  // which
  //the word 'how many'
  // { match: '^(how|which)', tag: 'QuestionWord', reason: 'how-question' },
  // how-he, when the
  { match: "[#QuestionWord] (#Pronoun|#Determiner)", group: 0, tag: "Preposition", reason: "how-he" },
  // when stolen
  { match: "[#QuestionWord] #Participle", group: 0, tag: "Preposition", reason: "when-stolen" },
  // how is
  { match: "[how] (#Determiner|#Copula|#Modal|#PastTense)", group: 0, tag: "QuestionWord", reason: "how-is" },
  // children who dance
  { match: "#Plural [(who|which|when)] .", group: 0, tag: "Preposition", reason: "people-who" }
], xP = [
  //swear-words as non-expression POS
  { match: "holy (shit|fuck|hell)", tag: "Expression", reason: "swears-expression" },
  // well..
  { match: "^[(well|so|okay|now)] !#Adjective?", group: 0, tag: "Expression", reason: "well-" },
  // well..
  { match: "^come on", tag: "Expression", reason: "come-on" },
  // sorry
  { match: "(say|says|said) [sorry]", group: 0, tag: "Expression", reason: "say-sorry" },
  // ok,
  { match: "^(ok|alright|shoot|hell|anyways)", tag: "Expression", reason: "ok-" },
  // c'mon marge..
  // { match: '^[come on] #Noun', group: 0, tag: 'Expression', reason: 'come-on' },
  // say,
  { match: "^(say && @hasComma)", tag: "Expression", reason: "say-" },
  { match: "^(like && @hasComma)", tag: "Expression", reason: "like-" },
  // dude we should
  { match: "^[(dude|man|girl)] #Pronoun", group: 0, tag: "Expression", reason: "dude-i" }
];
let wP = [].concat(
  // order matters top-matches can get overwritten
  mP,
  UT,
  qT,
  JT,
  XT,
  YT,
  eP,
  ZT,
  nP,
  rP,
  aP,
  oP,
  iP,
  sP,
  uP,
  lP,
  cP,
  QT,
  hP,
  dP,
  pP,
  fP,
  gP,
  vP,
  yP,
  bP,
  xP
);
const CP = {
  two: {
    matches: wP
  }
};
let gs = null;
const kP = function(e) {
  const { world: n } = e, { model: t, methods: r } = n;
  gs = gs || r.one.buildNet(t.two.matches, n);
  let o = r.two.quickSplit(e.document).map((s) => {
    let u = s[0];
    return [u.index[0], u.index[1], u.index[1] + s.length];
  }), i = e.update(o);
  return i.cache(), i.sweep(gs), e.uncache(), e.unfreeze(), e;
}, NP = (e) => e.compute(["freeze", "lexicon", "preTagger", "postTagger", "unfreeze"]), AP = { postTagger: kP, tagger: NP }, IP = (e) => Math.round(e * 100) / 100;
function EP(e) {
  e.prototype.confidence = function() {
    let n = 0, t = 0;
    return this.docs.forEach((r) => {
      r.forEach((a) => {
        t += 1, n += a.confidence || 1;
      });
    }), t === 0 ? 1 : IP(n / t);
  }, e.prototype.tagger = function() {
    return this.compute(["tagger"]);
  };
}
const TP = {
  api: EP,
  compute: AP,
  model: CP,
  hooks: ["postTagger"]
}, PP = function(e) {
  return Object.keys(e.hooks).filter((n) => !n.startsWith("#") && !n.startsWith("%"));
}, SP = function(e, n) {
  let t = PP(n);
  if (t.length === 0)
    return e;
  e._cache || e.cache();
  let r = e._cache;
  return e.filter((a, o) => t.some((i) => r[o].has(i)));
}, DP = function(e, n) {
  let t = n;
  typeof n == "string" && (t = this.buildNet([{ match: n }]));
  let r = this.tokenize(e), a = SP(r, t);
  return a.found ? (a.compute(["index", "tagger"]), a.match(n)) : r.none();
}, OP = {
  lib: {
    lazy: DP
  }
}, RP = function(e, n) {
  const t = e.methods.two.transform.verb.conjugate;
  let r = t(n, e.model);
  return e.has("#Gerund") ? r.Gerund : e.has("#PastTense") ? r.PastTense : e.has("#PresentTense") ? r.PresentTense : e.has("#Gerund") ? r.Gerund : n;
}, FP = function(e, n) {
  let t = n;
  return e.forEach((r) => {
    r.has("#Infinitive") || (t = RP(r, n)), r.replaceWith(t);
  }), e;
}, MP = function(e, n) {
  let t = n;
  if (e.has("#Plural")) {
    const r = e.methods.two.transform.noun.toPlural;
    t = r(n, e.model);
  }
  e.replaceWith(t, { possessives: !0 });
}, _P = function(e, n) {
  const { toAdverb: t } = e.methods.two.transform.adjective;
  let a = t(n);
  a && e.replaceWith(a);
}, BP = function(e, n) {
  const { toComparative: t, toSuperlative: r } = e.methods.two.transform.adjective;
  let a = n;
  e.has("#Comparative") ? a = t(a, e.model) : e.has("#Superlative") && (a = r(a, e.model)), a && e.replaceWith(a);
}, jP = function(e, n, t) {
  let r = e.split(/ /g).map((o) => o.toLowerCase().trim());
  r = r.filter((o) => o), r = r.map((o) => `{${o}}`).join(" ");
  let a = this.match(r);
  return t && (a = a.if(t)), a.has("#Verb") ? FP(a, n) : a.has("#Noun") ? MP(a, n) : a.has("#Adverb") ? _P(a, n) : a.has("#Adjective") ? BP(a, n) : this;
}, VP = function(e) {
  e.prototype.swap = jP;
}, LP = {
  api: VP
};
se.plugin(mT);
se.plugin($T);
se.plugin(TP);
se.plugin(OP);
se.plugin(LP);
const $r = function(e) {
  const { fromComparative: n, fromSuperlative: t } = e.methods.two.transform.adjective;
  let r = e.text("normal");
  return e.has("#Comparative") ? n(r, e.model) : e.has("#Superlative") ? t(r, e.model) : r;
}, zP = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Adjectives";
    }
    json(r = {}) {
      const { toAdverb: a, toNoun: o, toSuperlative: i, toComparative: s } = this.methods.two.transform.adjective;
      return r.normal = !0, this.map((u) => {
        let l = u.toView().json(r)[0] || {}, c = $r(u);
        return l.adjective = {
          adverb: a(c, this.model),
          noun: o(c, this.model),
          superlative: i(c, this.model),
          comparative: s(c, this.model)
        }, l;
      }, []);
    }
    adverbs() {
      return this.before("#Adverb+$").concat(this.after("^#Adverb+"));
    }
    conjugate(r) {
      const { toComparative: a, toSuperlative: o, toNoun: i, toAdverb: s } = this.methods.two.transform.adjective;
      return this.getNth(r).map((u) => {
        let l = $r(u);
        return {
          Adjective: l,
          Comparative: a(l, this.model),
          Superlative: o(l, this.model),
          Noun: i(l, this.model),
          Adverb: s(l, this.model)
        };
      }, []);
    }
    toComparative(r) {
      const { toComparative: a } = this.methods.two.transform.adjective;
      return this.getNth(r).map((o) => {
        let i = $r(o), s = a(i, this.model);
        return o.replaceWith(s);
      });
    }
    toSuperlative(r) {
      const { toSuperlative: a } = this.methods.two.transform.adjective;
      return this.getNth(r).map((o) => {
        let i = $r(o), s = a(i, this.model);
        return o.replaceWith(s);
      });
    }
    toAdverb(r) {
      const { toAdverb: a } = this.methods.two.transform.adjective;
      return this.getNth(r).map((o) => {
        let i = $r(o), s = a(i, this.model);
        return o.replaceWith(s);
      });
    }
    toNoun(r) {
      const { toNoun: a } = this.methods.two.transform.adjective;
      return this.getNth(r).map((o) => {
        let i = $r(o), s = a(i, this.model);
        return o.replaceWith(s);
      });
    }
  }
  e.prototype.adjectives = function(t) {
    let r = this.match("#Adjective");
    return r = r.getNth(t), new n(r.document, r.pointer);
  }, e.prototype.superlatives = function(t) {
    let r = this.match("#Superlative");
    return r = r.getNth(t), new n(r.document, r.pointer);
  }, e.prototype.comparatives = function(t) {
    let r = this.match("#Comparative");
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, GP = { api: zP }, HP = function(e) {
  return e.compute("root").text("root");
}, WP = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Adverbs";
    }
    conjugate(r) {
      return this.getNth(r).map((a) => {
        let o = HP(a);
        return {
          Adverb: a.text("normal"),
          Adjective: o
        };
      }, []);
    }
    json(r = {}) {
      const a = this.methods.two.transform.adjective.fromAdverb;
      return r.normal = !0, this.map((o) => {
        let i = o.toView().json(r)[0] || {};
        return i.adverb = {
          adjective: a(i.normal)
        }, i;
      }, []);
    }
  }
  e.prototype.adverbs = function(t) {
    let r = this.match("#Adverb");
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, $P = { api: WP }, UP = function(e) {
  let n = e.match("@hasComma");
  return n = n.filter((t) => {
    if (t.growLeft(".").wordCount() === 1 || t.growRight(". .").wordCount() === 1)
      return !1;
    let r = t.grow(".");
    return r = r.ifNo("@hasComma @hasComma"), r = r.ifNo("@hasComma (and|or) ."), r = r.ifNo("(#City && @hasComma) #Country"), r = r.ifNo("(#WeekDay && @hasComma) #Date"), r = r.ifNo("(#Date+ && @hasComma) #Value"), r = r.ifNo("(#Adjective && @hasComma) #Adjective"), r.found;
  }), e.splitAfter(n);
}, KP = function(e) {
  let n = e.parentheses();
  return n = n.filter((t) => t.wordCount() >= 3 && t.has("#Verb") && t.has("#Noun")), e.splitOn(n);
}, qP = function(e) {
  let n = e.quotations();
  return n = n.filter((t) => t.wordCount() >= 3 && t.has("#Verb") && t.has("#Noun")), e.splitOn(n);
}, JP = function(e) {
  let n = this;
  n = KP(n), n = qP(n), n = UP(n), n = n.splitAfter("(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)"), n = n.splitAfter("^#Pronoun (said|says)"), n = n.splitBefore("(said|says) #ProperNoun$"), n = n.splitBefore(". . if .{4}"), n = n.splitBefore("and while"), n = n.splitBefore("now that"), n = n.splitBefore("ever since"), n = n.splitBefore("(supposing|although)"), n = n.splitBefore("even (while|if|though)"), n = n.splitBefore("(whereas|whose)"), n = n.splitBefore("as (though|if)"), n = n.splitBefore("(til|until)");
  let t = n.match("#Verb .* [but] .* #Verb", 0);
  t.found && (n = n.splitBefore(t));
  let r = n.if("if .{2,9} then .").match("then");
  return n = n.splitBefore(r), typeof e == "number" && (n = n.get(e)), n;
}, XP = function(e) {
  let n = [], t = null;
  return e.clauses().docs.forEach((o) => {
    o.forEach((i) => {
      !i.chunk || i.chunk !== t ? (t = i.chunk, n.push([i.index[0], i.index[1], i.index[1] + 1])) : n[n.length - 1][2] = i.index[1] + 1;
    }), t = null;
  }), e.update(n);
}, QP = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Chunks";
    }
    isVerb() {
      return this.filter((r) => r.has("<Verb>"));
    }
    isNoun() {
      return this.filter((r) => r.has("<Noun>"));
    }
    isAdjective() {
      return this.filter((r) => r.has("<Adjective>"));
    }
    isPivot() {
      return this.filter((r) => r.has("<Pivot>"));
    }
    // chunk-friendly debug
    debug() {
      return this.toView().debug("chunks"), this;
    }
    // overloaded - keep Sentences class
    update(r) {
      let a = new n(this.document, r);
      return a._cache = this._cache, a;
    }
  }
  e.prototype.chunks = function(t) {
    let r = XP(this);
    return r = r.getNth(t), new n(this.document, r.pointer);
  }, e.prototype.clauses = JP;
}, Zh = {
  this: "Noun",
  then: "Pivot"
}, YP = function(e) {
  for (let n = 0; n < e.length; n += 1)
    for (let t = 0; t < e[n].length; t += 1) {
      let r = e[n][t];
      if (Zh.hasOwnProperty(r.normal) === !0) {
        r.chunk = Zh[r.normal];
        continue;
      }
      if (r.tags.has("Verb")) {
        r.chunk = "Verb";
        continue;
      }
      if (r.tags.has("Noun") || r.tags.has("Determiner")) {
        r.chunk = "Noun";
        continue;
      }
      if (r.tags.has("Value")) {
        r.chunk = "Noun";
        continue;
      }
      if (r.tags.has("QuestionWord")) {
        r.chunk = "Pivot";
        continue;
      }
    }
}, ZP = function(e) {
  for (let n = 0; n < e.length; n += 1)
    for (let t = 0; t < e[n].length; t += 1) {
      let r = e[n][t];
      if (r.chunk)
        continue;
      let a = e[n][t + 1], o = e[n][t - 1];
      if (r.tags.has("Adjective")) {
        if (o && o.tags.has("Copula")) {
          r.chunk = "Adjective";
          continue;
        }
        if (o && o.tags.has("Determiner")) {
          r.chunk = "Noun";
          continue;
        }
        if (a && a.tags.has("Noun")) {
          r.chunk = "Noun";
          continue;
        }
        continue;
      }
      if (r.tags.has("Adverb") || r.tags.has("Negative")) {
        if (o && o.tags.has("Adjective")) {
          r.chunk = "Adjective";
          continue;
        }
        if (o && o.tags.has("Verb")) {
          r.chunk = "Verb";
          continue;
        }
        if (a && a.tags.has("Adjective")) {
          r.chunk = "Adjective";
          continue;
        }
        if (a && a.tags.has("Verb")) {
          r.chunk = "Verb";
          continue;
        }
      }
    }
}, eS = [
  // === Conjunction ===
  // that the houses
  { match: "[that] #Determiner #Noun", group: 0, chunk: "Pivot" },
  // estimated that
  { match: "#PastTense [that]", group: 0, chunk: "Pivot" },
  // so the
  { match: "[so] #Determiner", group: 0, chunk: "Pivot" },
  // === Adjective ===
  // was really nice
  { match: "#Copula #Adverb+? [#Adjective]", group: 0, chunk: "Adjective" },
  // was nice
  // { match: '#Copula [#Adjective]', group: 0, chunk: 'Adjective' },
  // nice and cool
  { match: "#Adjective and #Adjective", chunk: "Adjective" },
  // really nice
  // { match: '#Adverb+ #Adjective', chunk: 'Adjective' },
  // === Verb ===
  // quickly and suddenly run
  { match: "#Adverb+ and #Adverb #Verb", chunk: "Verb" },
  // sitting near
  { match: "#Gerund #Adjective$", chunk: "Verb" },
  // going to walk
  { match: "#Gerund to #Verb", chunk: "Verb" },
  // come and have a drink
  { match: "#PresentTense and #PresentTense", chunk: "Verb" },
  // really not
  { match: "#Adverb #Negative", chunk: "Verb" },
  // want to see
  { match: "(want|wants|wanted) to #Infinitive", chunk: "Verb" },
  // walk ourselves
  { match: "#Verb #Reflexive", chunk: "Verb" },
  // tell him the story
  // { match: '#PresentTense [#Pronoun] #Determiner', group: 0, chunk: 'Verb' },
  // tries to walk
  { match: "#Verb [to] #Adverb? #Infinitive", group: 0, chunk: "Verb" },
  // upon seeing
  { match: "[#Preposition] #Gerund", group: 0, chunk: "Verb" },
  // ensure that
  { match: "#Infinitive [that] <Noun>", group: 0, chunk: "Verb" },
  // === Noun ===
  // the brown fox
  // { match: '#Determiner #Adjective+ #Noun', chunk: 'Noun' },
  // the fox
  // { match: '(the|this) <Noun>', chunk: 'Noun' },
  // brown fox
  // { match: '#Adjective+ <Noun>', chunk: 'Noun' },
  // --- of ---
  // son of a gun
  { match: "#Noun of #Determiner? #Noun", chunk: "Noun" },
  // 3 beautiful women
  { match: "#Value+ #Adverb? #Adjective", chunk: "Noun" },
  // the last russian tsar
  { match: "the [#Adjective] #Noun", chunk: "Noun" },
  // breakfast in bed
  { match: "#Singular in #Determiner? #Singular", chunk: "Noun" },
  // Some citizens in this Canadian capital
  { match: "#Plural [in] #Determiner? #Noun", group: 0, chunk: "Pivot" },
  // indoor and outdoor seating
  { match: "#Noun and #Determiner? #Noun", notIf: "(#Possessive|#Pronoun)", chunk: "Noun" }
  //  boys and girls
  // { match: '#Plural and #Determiner? #Plural', chunk: 'Noun' },
  // tomatoes and cheese
  // { match: '#Noun and #Determiner? #Noun', notIf: '#Pronoun', chunk: 'Noun' },
  // that is why
  // { match: '[that] (is|was)', group: 0, chunk: 'Noun' },
];
let vs = null;
const tS = function(e, n, t) {
  const { methods: r } = t;
  vs = vs || r.one.buildNet(eS, t), e.sweep(vs);
}, ys = function(e, n) {
  if ((typeof process > "u" || !process.env ? self.env || {} : process.env).DEBUG_CHUNKS) {
    let r = (e.normal + "'").padEnd(8);
    console.log(`  | '${r}  →  \x1B[34m${n.padEnd(12)}\x1B[0m \x1B[2m -fallback- \x1B[0m`);
  }
  e.chunk = n;
}, nS = function(e) {
  for (let n = 0; n < e.length; n += 1)
    for (let t = 0; t < e[n].length; t += 1) {
      let r = e[n][t];
      r.chunk === void 0 && (r.tags.has("Conjunction") || r.tags.has("Preposition") ? ys(r, "Pivot") : r.tags.has("Adverb") ? ys(r, "Verb") : r.chunk = "Noun");
    }
}, rS = function(e) {
  let n = [], t = null;
  e.forEach((r) => {
    for (let a = 0; a < r.length; a += 1) {
      let o = r[a];
      t && o.chunk === t ? n[n.length - 1].terms.push(o) : (n.push({ chunk: o.chunk, terms: [o] }), t = o.chunk);
    }
  }), n.forEach((r) => {
    r.chunk === "Verb" && (r.terms.find((o) => o.tags.has("Verb")) || r.terms.forEach((o) => o.chunk = null));
  });
}, aS = function(e) {
  const { document: n, world: t } = e;
  YP(n), ZP(n), tS(e, n, t), nS(n), rS(n);
}, oS = { chunks: aS }, iS = {
  compute: oS,
  api: QP,
  hooks: ["chunks"]
}, Eo = /\./g, sS = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Acronyms";
    }
    strip() {
      return this.docs.forEach((r) => {
        r.forEach((a) => {
          a.text = a.text.replace(Eo, ""), a.normal = a.normal.replace(Eo, "");
        });
      }), this;
    }
    addPeriods() {
      return this.docs.forEach((r) => {
        r.forEach((a) => {
          a.text = a.text.replace(Eo, ""), a.normal = a.normal.replace(Eo, ""), a.text = a.text.split("").join(".") + ".", a.normal = a.normal.split("").join(".") + ".";
        });
      }), this;
    }
  }
  e.prototype.acronyms = function(t) {
    let r = this.match("#Acronym");
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, vg = /\(/, yg = /\)/, uS = function(e, n) {
  for (; n < e.length; n += 1)
    if (e[n].post && yg.test(e[n].post)) {
      let [, t] = e[n].index;
      return t = t || 0, t;
    }
  return null;
}, lS = function(e) {
  let n = [];
  return e.docs.forEach((t) => {
    for (let r = 0; r < t.length; r += 1) {
      let a = t[r];
      if (a.pre && vg.test(a.pre)) {
        let o = uS(t, r);
        if (o !== null) {
          let [i, s] = t[r].index;
          n.push([i, s, o + 1, t[r].id]), r = o;
        }
      }
    }
  }), e.update(n);
}, cS = function(e) {
  return e.docs.forEach((n) => {
    n[0].pre = n[0].pre.replace(vg, "");
    let t = n[n.length - 1];
    t.post = t.post.replace(yg, "");
  }), e;
}, hS = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Possessives";
    }
    strip() {
      return cS(this);
    }
  }
  e.prototype.parentheses = function(t) {
    let r = lS(this);
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, ed = /'s$/, dS = function(e) {
  let n = e.match("#Possessive+");
  return n.has("#Person") && (n = n.growLeft("#Person+")), n.has("#Place") && (n = n.growLeft("#Place+")), n.has("#Organization") && (n = n.growLeft("#Organization+")), n;
}, pS = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Possessives";
    }
    strip() {
      return this.docs.forEach((r) => {
        r.forEach((a) => {
          a.text = a.text.replace(ed, ""), a.normal = a.normal.replace(ed, "");
        });
      }), this;
    }
  }
  e.prototype.possessives = function(t) {
    let r = dS(this);
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, ii = {
  '"': '"',
  // 'StraightDoubleQuotes'
  "＂": "＂",
  // 'StraightDoubleQuotesWide'
  "'": "'",
  // 'StraightSingleQuotes'
  "“": "”",
  // 'CommaDoubleQuotes'
  "‘": "’",
  // 'CommaSingleQuotes'
  "‟": "”",
  // 'CurlyDoubleQuotesReversed'
  "‛": "’",
  // 'CurlySingleQuotesReversed'
  "„": "”",
  // 'LowCurlyDoubleQuotes'
  "⹂": "”",
  // 'LowCurlyDoubleQuotesReversed'
  "‚": "’",
  // 'LowCurlySingleQuotes'
  "«": "»",
  // 'AngleDoubleQuotes' «, »
  "‹": "›",
  // 'AngleSingleQuotes'
  // Prime 'non quotation'
  "‵": "′",
  // 'PrimeSingleQuotes'
  "‶": "″",
  // 'PrimeDoubleQuotes'
  "‷": "‴",
  // 'PrimeTripleQuotes'
  // Prime 'quotation' variation
  "〝": "〞",
  // 'PrimeDoubleQuotes'
  "`": "´",
  // 'PrimeSingleQuotes'
  "〟": "〞"
  // 'LowPrimeDoubleQuotesReversed'
}, Il = RegExp("[" + Object.keys(ii).join("") + "]"), fS = RegExp("[" + Object.values(ii).join("") + "]"), mS = function(e, n) {
  const t = e[n].pre.match(Il)[0] || "";
  if (!t || !ii[t])
    return null;
  const r = ii[t];
  for (; n < e.length; n += 1)
    if (e[n].post && e[n].post.match(r))
      return n;
  return null;
}, gS = function(e) {
  let n = [];
  return e.docs.forEach((t) => {
    for (let r = 0; r < t.length; r += 1) {
      let a = t[r];
      if (a.pre && Il.test(a.pre)) {
        let o = mS(t, r);
        if (o !== null) {
          let [i, s] = t[r].index;
          n.push([i, s, o + 1, t[r].id]), r = o;
        }
      }
    }
  }), e.update(n);
}, vS = function(e) {
  e.docs.forEach((n) => {
    n[0].pre = n[0].pre.replace(Il, "");
    let t = n[n.length - 1];
    t.post = t.post.replace(fS, "");
  });
}, yS = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Possessives";
    }
    strip() {
      return vS(this);
    }
  }
  e.prototype.quotations = function(t) {
    let r = gS(this);
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, bS = function(e) {
  let n = this.splitAfter("@hasComma");
  return n = n.match("#PhoneNumber+"), n = n.getNth(e), n;
}, xS = [
  ["hyphenated", "@hasHyphen ."],
  ["hashTags", "#HashTag"],
  ["emails", "#Email"],
  ["emoji", "#Emoji"],
  ["emoticons", "#Emoticon"],
  ["atMentions", "#AtMention"],
  ["urls", "#Url"],
  // ['pronouns', '#Pronoun'],
  ["conjunctions", "#Conjunction"],
  ["prepositions", "#Preposition"],
  ["abbreviations", "#Abbreviation"],
  ["honorifics", "#Honorific"]
];
let wS = [
  ["emojis", "emoji"],
  ["atmentions", "atMentions"]
];
const CS = function(e) {
  xS.forEach((n) => {
    e.prototype[n[0]] = function(t) {
      let r = this.match(n[1]);
      return typeof t == "number" ? r.get(t) : r;
    };
  }), e.prototype.phoneNumbers = bS, wS.forEach((n) => {
    e.prototype[n[0]] = e.prototype[n[1]];
  });
}, kS = /\//, NS = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Slashes";
    }
    split() {
      return this.map((r) => {
        let o = r.text().split(kS);
        return r = r.replaceWith(o.join(" ")), r.growRight("(" + o.join("|") + ")+");
      });
    }
  }
  e.prototype.slashes = function(t) {
    let r = this.match("#SlashedTerm");
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, AS = {
  api: function(e) {
    sS(e), hS(e), pS(e), yS(e), CS(e), NS(e);
  }
}, To = function(e, n) {
  e.docs.forEach((t) => {
    t.forEach(n);
  });
}, td = {
  // remove titlecasing, uppercase
  case: (e) => {
    To(e, (n) => {
      n.text = n.text.toLowerCase();
    });
  },
  // visually romanize/anglicize 'Björk' into 'Bjork'.
  unicode: (e) => {
    const n = e.world, t = n.methods.one.killUnicode;
    To(e, (r) => r.text = t(r.text, n));
  },
  // remove hyphens, newlines, and force one space between words
  whitespace: (e) => {
    To(e, (n) => {
      n.post = n.post.replace(/\s+/g, " "), n.post = n.post.replace(/\s([.,?!:;])/g, "$1"), n.pre = n.pre.replace(/\s+/g, "");
    });
  },
  // remove commas, semicolons - but keep sentence-ending punctuation
  punctuation: (e) => {
    To(e, (r) => {
      r.post = r.post.replace(/[–—-]/g, " "), r.post = r.post.replace(/[,:;]/g, ""), r.post = r.post.replace(/\.{2,}/g, ""), r.post = r.post.replace(/\?{2,}/g, "?"), r.post = r.post.replace(/!{2,}/g, "!"), r.post = r.post.replace(/\?!+/g, "?");
    });
    let n = e.docs, t = n[n.length - 1];
    if (t && t.length > 0) {
      let r = t[t.length - 1];
      r.post = r.post.replace(/ /g, "");
    }
  },
  // ====== subsets ===
  // turn "isn't" to "is not"
  contractions: (e) => {
    e.contractions().expand();
  },
  //remove periods from acronyms, like 'F.B.I.'
  acronyms: (e) => {
    e.acronyms().strip();
  },
  //remove words inside brackets (like these)
  parentheses: (e) => {
    e.parentheses().strip();
  },
  // turn "Google's tax return" to "Google tax return"
  possessives: (e) => {
    e.possessives().strip();
  },
  // turn "tax return" to tax return
  quotations: (e) => {
    e.quotations().strip();
  },
  // remove them
  emoji: (e) => {
    e.emojis().remove();
  },
  //turn 'Vice Admiral John Smith' to 'John Smith'
  honorifics: (e) => {
    e.match("#Honorific+ #Person").honorifics().remove();
  },
  // remove needless adverbs
  adverbs: (e) => {
    e.adverbs().remove();
  },
  // turn "batmobiles" into "batmobile"
  nouns: (e) => {
    e.nouns().toSingular();
  },
  // turn all verbs into Infinitive form - "I walked" → "I walk"
  verbs: (e) => {
    e.verbs().toInfinitive();
  },
  // turn "fifty" into "50"
  numbers: (e) => {
    e.numbers().toNumber();
  },
  /** remove bullets from beginning of phrase */
  debullet: (e) => {
    const n = /^\s*([-–—*•])\s*$/;
    return e.docs.forEach((t) => {
      n.test(t[0].pre) && (t[0].pre = t[0].pre.replace(n, ""));
    }), e;
  }
}, bs = (e) => e.split("|").reduce((n, t) => (n[t] = !0, n), {}), xs = "unicode|punctuation|whitespace|acronyms", nd = "|case|contractions|parentheses|quotations|emoji|honorifics|debullet", IS = "|possessives|adverbs|nouns|verbs", ES = {
  light: bs(xs),
  medium: bs(xs + nd),
  heavy: bs(xs + nd + IS)
};
function TS(e) {
  e.prototype.normalize = function(n = "light") {
    return typeof n == "string" && (n = ES[n]), Object.keys(n).forEach((t) => {
      td.hasOwnProperty(t) && td[t](this, n[t]);
    }), this;
  };
}
const PS = {
  api: TS
}, SS = function(e) {
  let n = e.clauses().match("<Noun>"), t = n.match("@hasComma");
  return t = t.not("#Place"), t.found && (n = n.splitAfter(t)), n = n.splitOn("#Expression"), n = n.splitOn("(he|she|we|you|they|i)"), n = n.splitOn("(#Noun|#Adjective) [(he|him|she|it)]", 0), n = n.splitOn("[(he|him|she|it)] (#Determiner|#Value)", 0), n = n.splitBefore("#Noun [(the|a|an)] #Adjective? #Noun", 0), n = n.splitOn("[(here|there)] #Noun", 0), n = n.splitOn("[#Noun] (here|there)", 0), n = n.splitBefore("(our|my|their|your)"), n = n.splitOn("#Noun [#Determiner]", 0), n = n.if("#Noun"), n;
}, rd = [
  "after",
  "although",
  "as if",
  "as long as",
  "as",
  "because",
  "before",
  "even if",
  "even though",
  "ever since",
  "if",
  "in order that",
  "provided that",
  "since",
  "so that",
  "than",
  "that",
  "though",
  "unless",
  "until",
  "what",
  "whatever",
  "when",
  "whenever",
  "where",
  "whereas",
  "wherever",
  "whether",
  "which",
  "whichever",
  "who",
  "whoever",
  "whom",
  "whomever",
  "whose"
], DS = function(e) {
  if (e.before("#Preposition$").found)
    return !0;
  if (!e.before().found)
    return !1;
  for (let t = 0; t < rd.length; t += 1)
    if (e.has(rd[t]))
      return !0;
  return !1;
}, OS = "(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)", RS = function(e, n) {
  if (e.has("#Plural") || e.has("#Noun and #Noun") || e.has("(we|they)"))
    return !0;
  if (n.has(OS) === !0 || e.has("#Singular"))
    return !1;
  let t = n.text("normal");
  return t.length > 3 && t.endsWith("s") && !t.endsWith("ss");
}, FS = function(e) {
  let n = e.clone();
  return n = n.match("#Noun+"), n = n.remove("(#Adjective|#Preposition|#Determiner|#Value)"), n = n.not("#Possessive"), n = n.first(), n.found ? n : e;
}, $n = function(e) {
  let n = FS(e);
  return {
    determiner: e.match("#Determiner").eq(0),
    adjectives: e.match("#Adjective"),
    number: e.values(),
    isPlural: RS(e, n),
    isSubordinate: DS(e),
    root: n
  };
}, ad = (e) => e.text(), MS = (e) => e.json({ terms: !1, normal: !0 }).map((n) => n.normal), _S = function(e) {
  let n = null;
  if (!e.found)
    return n;
  let t = e.values(0);
  return t.found ? (t.parse()[0] || {}).num : n;
}, BS = function(e) {
  let n = $n(e);
  return {
    root: ad(n.root),
    number: _S(n.number),
    determiner: ad(n.determiner),
    adjectives: MS(n.adjectives),
    isPlural: n.isPlural,
    isSubordinate: n.isSubordinate
  };
}, bg = function(e) {
  return !e.has("^(#Uncountable|#ProperNoun|#Place|#Pronoun|#Acronym)+$");
}, jS = { tags: !0 }, VS = function(e, n) {
  if (n.isPlural === !0 || (n.root.has("#Possessive") && (n.root = n.root.possessives().strip()), !bg(n.root)))
    return e;
  const { methods: t, model: r } = e.world, { toPlural: a } = t.two.transform.noun;
  let o = n.root.text({ keepPunct: !1 }), i = a(o, r);
  e.match(n.root).replaceWith(i, jS).tag("Plural", "toPlural"), n.determiner.has("(a|an)") && e.remove(n.determiner);
  let s = n.root.after("not? #Adverb+? [#Copula]", 0);
  return s.found && (s.has("is") ? e.replace(s, "are") : s.has("was") && e.replace(s, "were")), e;
}, LS = { tags: !0 }, zS = function(e, n) {
  if (n.isPlural === !1)
    return e;
  const { methods: t, model: r } = e.world, { toSingular: a } = t.two.transform.noun;
  let o = n.root.text("normal"), i = a(o, r);
  return e.replace(n.root, i, LS).tag("Singular", "toPlural"), e;
}, GS = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Nouns";
    }
    parse(r) {
      return this.getNth(r).map($n);
    }
    json(r) {
      let a = typeof r == "object" ? r : {};
      return this.getNth(r).map((o) => {
        let i = o.toView().json(a)[0] || {};
        return a && a.noun !== !1 && (i.noun = BS(o)), i;
      }, []);
    }
    conjugate(r) {
      const a = this.world.methods.two.transform.noun;
      return this.getNth(r).map((o) => {
        let i = $n(o), s = i.root.compute("root").text("root"), u = {
          Singular: s
        };
        return bg(i.root) && (u.Plural = a.toPlural(s, this.model)), u.Singular === u.Plural && delete u.Plural, u;
      }, []);
    }
    isPlural(r) {
      return this.filter((o) => $n(o).isPlural).getNth(r);
    }
    isSingular(r) {
      return this.filter((o) => !$n(o).isPlural).getNth(r);
    }
    adjectives(r) {
      let a = this.update([]);
      return this.forEach((o) => {
        let i = $n(o).adjectives;
        i.found && (a = a.concat(i));
      }), a.getNth(r);
    }
    toPlural(r) {
      return this.getNth(r).map((a) => VS(a, $n(a)));
    }
    toSingular(r) {
      return this.getNth(r).map((a) => {
        let o = $n(a);
        return zS(a, o);
      });
    }
    // create a new View, from this one
    update(r) {
      let a = new n(this.document, r);
      return a._cache = this._cache, a;
    }
  }
  e.prototype.nouns = function(t) {
    let r = SS(this);
    return r = r.getNth(t), new n(this.document, r.pointer);
  };
}, HS = {
  api: GS
}, WS = function(e, n) {
  let t = e.match("#Fraction+");
  return t = t.filter((r) => !r.lookBehind("#Value and$").found), t = t.notIf("#Value seconds"), t;
}, $S = (e) => {
  const n = [
    {
      reg: /^(minus|negative)[\s-]/i,
      mult: -1
    },
    {
      reg: /^(a\s)?half[\s-](of\s)?/i,
      mult: 0.5
    }
    //  {
    //   reg: /^(a\s)?quarter[\s\-]/i,
    //   mult: 0.25
    // }
  ];
  for (let t = 0; t < n.length; t++)
    if (n[t].reg.test(e) === !0)
      return {
        amount: n[t].mult,
        str: e.replace(n[t].reg, "")
      };
  return {
    amount: 1,
    str: e
  };
}, Ke = {
  ones: {
    zeroth: 0,
    first: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eighth: 8,
    ninth: 9,
    zero: 0,
    one: 1,
    two: 2,
    three: 3,
    four: 4,
    five: 5,
    six: 6,
    seven: 7,
    eight: 8,
    nine: 9
  },
  teens: {
    tenth: 10,
    eleventh: 11,
    twelfth: 12,
    thirteenth: 13,
    fourteenth: 14,
    fifteenth: 15,
    sixteenth: 16,
    seventeenth: 17,
    eighteenth: 18,
    nineteenth: 19,
    ten: 10,
    eleven: 11,
    twelve: 12,
    thirteen: 13,
    fourteen: 14,
    fifteen: 15,
    sixteen: 16,
    seventeen: 17,
    eighteen: 18,
    nineteen: 19
  },
  tens: {
    twentieth: 20,
    thirtieth: 30,
    fortieth: 40,
    fourtieth: 40,
    fiftieth: 50,
    sixtieth: 60,
    seventieth: 70,
    eightieth: 80,
    ninetieth: 90,
    twenty: 20,
    thirty: 30,
    forty: 40,
    fourty: 40,
    fifty: 50,
    sixty: 60,
    seventy: 70,
    eighty: 80,
    ninety: 90
  },
  multiples: {
    hundredth: 100,
    thousandth: 1e3,
    millionth: 1e6,
    billionth: 1e9,
    trillionth: 1e12,
    quadrillionth: 1e15,
    quintillionth: 1e18,
    sextillionth: 1e21,
    septillionth: 1e24,
    hundred: 100,
    thousand: 1e3,
    million: 1e6,
    billion: 1e9,
    trillion: 1e12,
    quadrillion: 1e15,
    quintillion: 1e18,
    sextillion: 1e21,
    septillion: 1e24,
    grand: 1e3
  }
}, US = (e, n) => {
  if (Ke.ones.hasOwnProperty(e)) {
    if (n.ones || n.teens)
      return !1;
  } else if (Ke.teens.hasOwnProperty(e)) {
    if (n.ones || n.teens || n.tens)
      return !1;
  } else if (Ke.tens.hasOwnProperty(e) && (n.ones || n.teens || n.tens))
    return !1;
  return !0;
}, KS = function(e) {
  let n = "0.";
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    if (Ke.ones.hasOwnProperty(r) === !0)
      n += Ke.ones[r];
    else if (Ke.teens.hasOwnProperty(r) === !0)
      n += Ke.teens[r];
    else if (Ke.tens.hasOwnProperty(r) === !0)
      n += Ke.tens[r];
    else if (/^[0-9]$/.test(r) === !0)
      n += r;
    else
      return 0;
  }
  return parseFloat(n);
}, qS = (e) => (e = e.replace(/1st$/, "1"), e = e.replace(/2nd$/, "2"), e = e.replace(/3rd$/, "3"), e = e.replace(/([4567890])r?th$/, "$1"), e = e.replace(/^[$€¥£¢]/, ""), e = e.replace(/[%$€¥£¢]$/, ""), e = e.replace(/,/g, ""), e = e.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, "$1"), e), JS = /^([0-9,. ]+)\/([0-9,. ]+)$/, od = {
  "a few": 3,
  "a couple": 2,
  "a dozen": 12,
  "two dozen": 24,
  zero: 0
}, Po = (e) => Object.keys(e).reduce((n, t) => (n += e[t], n), 0), mu = function(e) {
  if (od.hasOwnProperty(e) === !0)
    return od[e];
  if (e === "a" || e === "an")
    return 1;
  const n = $S(e);
  e = n.str;
  let t = null, r = {}, a = 0, o = !1;
  const i = e.split(/[ -]/);
  for (let s = 0; s < i.length; s++) {
    let u = i[s];
    if (u = qS(u), !u || u === "and")
      continue;
    if (u === "-" || u === "negative") {
      o = !0;
      continue;
    }
    if (u.charAt(0) === "-" && (o = !0, u = u.substring(1)), u === "point")
      return a += Po(r), a += KS(i.slice(s + 1, i.length)), a *= n.amount, a;
    const l = u.match(JS);
    if (l) {
      const c = parseFloat(l[1].replace(/[, ]/g, "")), h = parseFloat(l[2].replace(/[, ]/g, ""));
      h && (a += c / h || 0);
      continue;
    }
    if (Ke.tens.hasOwnProperty(u) && r.ones && Object.keys(r).length === 1 && (a = r.ones * 100, r = {}), US(u, r) === !1)
      return null;
    if (/^[0-9.]+$/.test(u))
      r.ones = parseFloat(u);
    else if (Ke.ones.hasOwnProperty(u) === !0)
      r.ones = Ke.ones[u];
    else if (Ke.teens.hasOwnProperty(u) === !0)
      r.teens = Ke.teens[u];
    else if (Ke.tens.hasOwnProperty(u) === !0)
      r.tens = Ke.tens[u];
    else if (Ke.multiples.hasOwnProperty(u) === !0) {
      let c = Ke.multiples[u];
      if (c === t)
        return null;
      if (c === 100 && i[s + 1] !== void 0) {
        const h = i[s + 1];
        Ke.multiples[h] && (c *= Ke.multiples[h], s += 1);
      }
      t === null || c < t ? (a += (Po(r) || 1) * c, t = c, r = {}) : (a += Po(r), t = c, a = (a || 1) * c, r = {});
    }
  }
  return a += Po(r), a *= n.amount, a *= o ? -1 : 1, a === 0 && Object.keys(r).length === 0 ? null : a;
}, id = /s$/, $a = function(e) {
  let n = e.text("reduced");
  return mu(n);
};
let si = {
  half: 2,
  halve: 2,
  quarter: 4
};
const XS = function(e) {
  let t = e.text("reduced").match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);
  return t && t[1] && t[0] ? {
    numerator: Number(t[1]),
    denominator: Number(t[2])
  } : null;
}, QS = function(e) {
  let n = e.match("[<num>#Value+] out of every? [<den>#Value+]");
  if (n.found !== !0)
    return null;
  let { num: t, den: r } = n.groups();
  return !t || !r || (t = $a(t), r = $a(r), !t || !r) ? null : typeof t == "number" && typeof r == "number" ? {
    numerator: t,
    denominator: r
  } : null;
}, YS = function(e) {
  let n = e.match("[<num>(#Cardinal|a)+] [<den>#Fraction+]");
  if (n.found !== !0)
    return null;
  let { num: t, den: r } = n.groups();
  t.has("a") ? t = 1 : t = $a(t);
  let a = r.text("reduced");
  return id.test(a) && (a = a.replace(id, ""), r = r.replaceWith(a)), si.hasOwnProperty(a) ? r = si[a] : r = $a(r), typeof t == "number" && typeof r == "number" ? {
    numerator: t,
    denominator: r
  } : null;
}, ZS = function(e) {
  let n = e.match("^#Ordinal$");
  return n.found !== !0 ? null : e.lookAhead("^of .") ? {
    numerator: 1,
    denominator: $a(n)
  } : null;
}, eD = function(e) {
  let n = e.text("reduced");
  return si.hasOwnProperty(n) ? { numerator: 1, denominator: si[n] } : null;
}, tD = (e) => {
  let n = Math.round(e * 1e3) / 1e3;
  return n === 0 && e !== 0 ? e : n;
}, An = function(e) {
  e = e.clone();
  let n = eD(e) || XS(e) || QS(e) || YS(e) || ZS(e) || null;
  return n !== null && n.numerator && n.denominator && (n.decimal = n.numerator / n.denominator, n.decimal = tD(n.decimal)), n;
}, El = function(e) {
  if (e < 1e6)
    return String(e);
  let n;
  return typeof e == "number" ? n = e.toFixed(0) : n = e, n.indexOf("e+") === -1 ? n : n.replace(".", "").split("e+").reduce(function(t, r) {
    return t + Array(r - t.length + 2).join(0);
  });
}, So = [
  ["ninety", 90],
  ["eighty", 80],
  ["seventy", 70],
  ["sixty", 60],
  ["fifty", 50],
  ["forty", 40],
  ["thirty", 30],
  ["twenty", 20]
], sd = [
  "",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen"
], nD = [
  [1e24, "septillion"],
  [1e20, "hundred sextillion"],
  [1e21, "sextillion"],
  [1e20, "hundred quintillion"],
  [1e18, "quintillion"],
  [1e17, "hundred quadrillion"],
  [1e15, "quadrillion"],
  [1e14, "hundred trillion"],
  [1e12, "trillion"],
  [1e11, "hundred billion"],
  [1e9, "billion"],
  [1e8, "hundred million"],
  [1e6, "million"],
  [1e5, "hundred thousand"],
  [1e3, "thousand"],
  [100, "hundred"],
  [1, "one"]
], rD = function(e) {
  let n = e, t = [];
  return nD.forEach((r) => {
    if (e >= r[0]) {
      let a = Math.floor(n / r[0]);
      n -= a * r[0], a && t.push({
        unit: r[1],
        count: a
      });
    }
  }), t;
}, aD = function(e) {
  let n = [];
  if (e > 100)
    return n;
  for (let t = 0; t < So.length; t++)
    e >= So[t][1] && (e -= So[t][1], n.push(So[t][0]));
  return sd[e] && n.push(sd[e]), n;
}, oD = (e) => {
  const n = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];
  let t = [], a = El(e).match(/\.([0-9]+)/);
  if (!a || !a[0])
    return t;
  t.push("point");
  let o = a[0].split("");
  for (let i = 0; i < o.length; i++)
    t.push(n[o[i]]);
  return t;
}, Ua = function(e) {
  let n = e.num;
  if (n === 0 || n === "0")
    return "zero";
  n > 1e21 && (n = El(n));
  let t = [];
  n < 0 && (t.push("minus"), n = Math.abs(n));
  let r = rD(n);
  for (let a = 0; a < r.length; a++) {
    let o = r[a].unit;
    o === "one" && (o = "", t.length > 1 && t.push("and")), t = t.concat(aD(r[a].count)), t.push(o);
  }
  return t = t.concat(oD(n)), t = t.filter((a) => a), t.length === 0 && (t[0] = ""), t.join(" ");
}, iD = function(e) {
  if (!e.numerator || !e.denominator)
    return "";
  let n = Ua({ num: e.numerator }), t = Ua({ num: e.denominator });
  return `${n} out of ${t}`;
}, ud = {
  one: "first",
  two: "second",
  three: "third",
  five: "fifth",
  eight: "eighth",
  nine: "ninth",
  twelve: "twelfth",
  twenty: "twentieth",
  thirty: "thirtieth",
  forty: "fortieth",
  fourty: "fourtieth",
  fifty: "fiftieth",
  sixty: "sixtieth",
  seventy: "seventieth",
  eighty: "eightieth",
  ninety: "ninetieth"
}, xg = (e) => {
  let n = Ua(e).split(" "), t = n[n.length - 1];
  return ud.hasOwnProperty(t) ? n[n.length - 1] = ud[t] : n[n.length - 1] = t.replace(/y$/, "i") + "th", n.join(" ");
}, sD = function(e) {
  if (!e.numerator || !e.denominator)
    return "";
  let n = Ua({ num: e.numerator }), t = xg({ num: e.denominator });
  return e.denominator === 2 && (t = "half"), n && t ? (e.numerator !== 1 && (t += "s"), `${n} ${t}`) : "";
}, uD = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Fractions";
    }
    parse(r) {
      return this.getNth(r).map(An);
    }
    get(r) {
      return this.getNth(r).map(An);
    }
    json(r) {
      return this.getNth(r).map((a) => {
        let o = a.toView().json(r)[0], i = An(a);
        return o.fraction = i, o;
      }, []);
    }
    // become 0.5
    toDecimal(r) {
      return this.getNth(r).forEach((a) => {
        let { decimal: o } = An(a);
        a = a.replaceWith(String(o), !0), a.tag("NumericValue"), a.unTag("Fraction");
      }), this;
    }
    toFraction(r) {
      return this.getNth(r).forEach((a) => {
        let o = An(a);
        if (o && typeof o.numerator == "number" && typeof o.denominator == "number") {
          let i = `${o.numerator}/${o.denominator}`;
          this.replace(a, i);
        }
      }), this;
    }
    toOrdinal(r) {
      return this.getNth(r).forEach((a) => {
        let o = An(a), i = sD(o);
        a.after("^#Noun").found && (i += " of"), a.replaceWith(i);
      }), this;
    }
    toCardinal(r) {
      return this.getNth(r).forEach((a) => {
        let o = An(a), i = iD(o);
        a.replaceWith(i);
      }), this;
    }
    toPercentage(r) {
      return this.getNth(r).forEach((a) => {
        let { decimal: o } = An(a), i = o * 100;
        i = Math.round(i * 100) / 100, a.replaceWith(`${i}%`);
      }), this;
    }
  }
  e.prototype.fractions = function(t) {
    let r = WS(this);
    return r = r.getNth(t), new n(this.document, r.pointer);
  };
}, lD = "one|two|three|four|five|six|seven|eight|nine", Hn = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty", cD = "eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen", ws = function(e) {
  let n = e.match("#Value+");
  if (n.has("#NumericValue #NumericValue") && (n.has("#Value @hasComma #Value") ? n.splitAfter("@hasComma") : n.has("#NumericValue #Fraction") ? n.splitAfter("#NumericValue #Fraction") : n = n.splitAfter("#NumericValue")), n.has("#Value #Value #Value") && !n.has("#Multiple") && n.has("(" + Hn + ") #Cardinal #Cardinal") && (n = n.splitAfter("(" + Hn + ") #Cardinal")), n.has("#Value #Value")) {
    n.has("#NumericValue #NumericValue") && (n = n.splitOn("#Year")), n.has("(" + Hn + ") (" + cD + ")") && (n = n.splitAfter("(" + Hn + ")"));
    let t = n.match("#Cardinal #Cardinal");
    if (t.found && !n.has("(point|decimal|#Fraction)") && !t.has("#Cardinal (#Multiple|point|decimal)")) {
      let r = n.has(`(${lD}) (${Hn})`), a = t.has("(" + Hn + ") #Cardinal"), o = t.has("#Multiple #Value");
      !r && !a && !o && t.terms().forEach((i) => {
        n = n.splitOn(i);
      });
    }
    n.match("#Ordinal #Ordinal").match("#TextValue").found && !n.has("#Multiple") && (n.has("(" + Hn + ") #Ordinal") || (n = n.splitAfter("#Ordinal"))), n = n.splitBefore("#Ordinal [#Cardinal]", 0), n.has("#TextValue #NumericValue") && !n.has("(" + Hn + "|#Multiple)") && (n = n.splitBefore("#TextValue #NumericValue"));
  }
  return n = n.splitAfter("#NumberRange"), n = n.splitBefore("#Year"), n;
}, hD = function(e, n) {
  e = e.replace(/,/g, "");
  let t = e.split(/([0-9.,]*)/), [r, a] = t, o = t.slice(2).join("");
  return a !== "" && n.length < 2 ? (a = Number(a || e), typeof a != "number" && (a = null), o = o || "", (o === "st" || o === "nd" || o === "rd" || o === "th") && (o = ""), {
    prefix: r || "",
    num: a,
    suffix: o
  }) : null;
}, it = function(e) {
  if (typeof e == "string")
    return { num: mu(e) };
  let n = e.text("reduced"), t = e.growRight("#Unit").match("#Unit$").text("machine"), r = /[0-9],[0-9]/.test(e.text("text"));
  if (e.terms().length === 1 && !e.has("#Multiple")) {
    let s = hD(n, e);
    if (s !== null)
      return s.hasComma = r, s.unit = t, s;
  }
  let a = e.match("#Fraction{2,}$");
  a = a.found === !1 ? e.match("^#Fraction$") : a;
  let o = null;
  a.found && (a.has("#Value and #Value #Fraction") && (a = a.match("and #Value #Fraction")), o = An(a), e = e.not(a), e = e.not("and$"), n = e.text("reduced"));
  let i = 0;
  return n && (i = mu(n) || 0), o && o.decimal && (i += o.decimal), {
    hasComma: r,
    prefix: "",
    num: i,
    suffix: "",
    isOrdinal: e.has("#Ordinal"),
    isText: e.has("#TextValue"),
    isFraction: e.has("#Fraction"),
    isMoney: e.has("#Money"),
    unit: t
  };
}, dD = function(e) {
  let n = e.num;
  if (!n && n !== 0)
    return null;
  let t = n % 100;
  if (t > 10 && t < 20)
    return String(n) + "th";
  const r = {
    0: "th",
    1: "st",
    2: "nd",
    3: "rd"
  };
  let a = El(n), o = a.slice(a.length - 1, a.length);
  return r[o] ? a += r[o] : a += "th", a;
}, ld = {
  "¢": "cents",
  $: "dollars",
  "£": "pounds",
  "¥": "yen",
  "€": "euros",
  "₡": "colón",
  "฿": "baht",
  "₭": "kip",
  "₩": "won",
  "₹": "rupees",
  "₽": "ruble",
  "₺": "liras"
}, cd = {
  "%": "percent",
  // s: 'seconds',
  // cm: 'centimetres',
  // km: 'kilometres',
  // ft: 'feet',
  "°": "degrees"
}, hd = function(e) {
  let n = {
    suffix: "",
    prefix: e.prefix
  };
  return ld.hasOwnProperty(e.prefix) && (n.suffix += " " + ld[e.prefix], n.prefix = ""), cd.hasOwnProperty(e.suffix) && (n.suffix += " " + cd[e.suffix]), n.suffix && e.num === 1 && (n.suffix = n.suffix.replace(/s$/, "")), !n.suffix && e.suffix && (n.suffix += " " + e.suffix), n;
}, cr = function(e, n) {
  if (n === "TextOrdinal") {
    let { prefix: r, suffix: a } = hd(e);
    return r + xg(e) + a;
  }
  if (n === "Ordinal")
    return e.prefix + dD(e) + e.suffix;
  if (n === "TextCardinal") {
    let { prefix: r, suffix: a } = hd(e);
    return r + Ua(e) + a;
  }
  let t = e.num;
  return e.hasComma && (t = t.toLocaleString()), e.prefix + String(t) + e.suffix;
}, pD = (e) => Object.prototype.toString.call(e) === "[object Array]", fD = function(e) {
  if (typeof e == "string" || typeof e == "number") {
    let n = {};
    return n[e] = !0, n;
  }
  return pD(e) ? e.reduce((n, t) => (n[t] = !0, n), {}) : e || {};
}, mD = function(e, n = {}) {
  return n = fD(n), e.filter((t) => {
    let { unit: r } = it(t);
    return !!(r && n[r] === !0);
  });
}, gD = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Numbers";
    }
    parse(r) {
      return this.getNth(r).map(it);
    }
    get(r) {
      return this.getNth(r).map(it).map((a) => a.num);
    }
    json(r) {
      let a = typeof r == "object" ? r : {};
      return this.getNth(r).map((o) => {
        let i = o.toView().json(a)[0], s = it(o);
        return i.number = {
          prefix: s.prefix,
          num: s.num,
          suffix: s.suffix,
          hasComma: s.hasComma,
          unit: s.unit
        }, i;
      }, []);
    }
    /** any known measurement unit, for the number */
    units() {
      return this.growRight("#Unit").match("#Unit$");
    }
    /** return values that match a given unit */
    isUnit(r) {
      return mD(this, r);
    }
    /** return only ordinal numbers */
    isOrdinal() {
      return this.if("#Ordinal");
    }
    /** return only cardinal numbers*/
    isCardinal() {
      return this.if("#Cardinal");
    }
    /** convert to numeric form like '8' or '8th' */
    toNumber() {
      let r = this.map((a) => {
        if (!this.has("#TextValue"))
          return a;
        let o = it(a);
        if (o.num === null)
          return a;
        let i = a.has("#Ordinal") ? "Ordinal" : "Cardinal", s = cr(o, i);
        return a.replaceWith(s, { tags: !0 }), a.tag("NumericValue");
      });
      return new n(r.document, r.pointer);
    }
    /** add commas, or nicer formatting for numbers */
    toLocaleString() {
      return this.forEach((a) => {
        let o = it(a);
        if (o.num === null)
          return;
        let i = o.num.toLocaleString();
        if (a.has("#Ordinal")) {
          let u = cr(o, "Ordinal").match(/[a-z]+$/);
          u && (i += u[0] || "");
        }
        a.replaceWith(i, { tags: !0 });
      }), this;
    }
    /** convert to numeric form like 'eight' or 'eighth' */
    toText() {
      let a = this.map((o) => {
        if (o.has("#TextValue"))
          return o;
        let i = it(o);
        if (i.num === null)
          return o;
        let s = o.has("#Ordinal") ? "TextOrdinal" : "TextCardinal", u = cr(i, s);
        return o.replaceWith(u, { tags: !0 }), o.tag("TextValue"), o;
      });
      return new n(a.document, a.pointer);
    }
    /** convert ordinal to cardinal form, like 'eight', or '8' */
    toCardinal() {
      let a = this.map((o) => {
        if (!o.has("#Ordinal"))
          return o;
        let i = it(o);
        if (i.num === null)
          return o;
        let s = o.has("#TextValue") ? "TextCardinal" : "Cardinal", u = cr(i, s);
        return o.replaceWith(u, { tags: !0 }), o.tag("Cardinal"), o;
      });
      return new n(a.document, a.pointer);
    }
    /** convert cardinal to ordinal form, like 'eighth', or '8th' */
    toOrdinal() {
      let a = this.map((o) => {
        if (o.has("#Ordinal"))
          return o;
        let i = it(o);
        if (i.num === null)
          return o;
        let s = o.has("#TextValue") ? "TextOrdinal" : "Ordinal", u = cr(i, s);
        return o.replaceWith(u, { tags: !0 }), o.tag("Ordinal"), o;
      });
      return new n(a.document, a.pointer);
    }
    /** return only numbers that are == n */
    isEqual(r) {
      return this.filter((a) => it(a).num === r);
    }
    /** return only numbers that are > n*/
    greaterThan(r) {
      return this.filter((a) => it(a).num > r);
    }
    /** return only numbers that are < n*/
    lessThan(r) {
      return this.filter((a) => it(a).num < r);
    }
    /** return only numbers > min and < max */
    between(r, a) {
      return this.filter((o) => {
        let i = it(o).num;
        return i > r && i < a;
      });
    }
    /** set these number to n */
    set(r) {
      if (r === void 0)
        return this;
      typeof r == "string" && (r = it(r).num);
      let o = this.map((i) => {
        let s = it(i);
        if (s.num = r, s.num === null)
          return i;
        let u = i.has("#Ordinal") ? "Ordinal" : "Cardinal";
        i.has("#TextValue") && (u = i.has("#Ordinal") ? "TextOrdinal" : "TextCardinal");
        let l = cr(s, u);
        return s.hasComma && u === "Cardinal" && (l = Number(l).toLocaleString()), i = i.not("#Currency"), i.replaceWith(l, { tags: !0 }), i;
      });
      return new n(o.document, o.pointer);
    }
    add(r) {
      if (!r)
        return this;
      typeof r == "string" && (r = it(r).num);
      let o = this.map((i) => {
        let s = it(i);
        if (s.num === null)
          return i;
        s.num += r;
        let u = i.has("#Ordinal") ? "Ordinal" : "Cardinal";
        s.isText && (u = i.has("#Ordinal") ? "TextOrdinal" : "TextCardinal");
        let l = cr(s, u);
        return i.replaceWith(l, { tags: !0 }), i;
      });
      return new n(o.document, o.pointer);
    }
    /** decrease each number by n*/
    subtract(r, a) {
      return this.add(r * -1, a);
    }
    /** increase each number by 1 */
    increment(r) {
      return this.add(1, r);
    }
    /** decrease each number by 1 */
    decrement(r) {
      return this.add(-1, r);
    }
    // overloaded - keep Numbers class
    update(r) {
      let a = new n(this.document, r);
      return a._cache = this._cache, a;
    }
  }
  n.prototype.toNice = n.prototype.toLocaleString, n.prototype.isBetween = n.prototype.between, n.prototype.minus = n.prototype.subtract, n.prototype.plus = n.prototype.add, n.prototype.equals = n.prototype.isEqual, e.prototype.numbers = function(t) {
    let r = ws(this);
    return r = r.getNth(t), new n(this.document, r.pointer);
  }, e.prototype.percentages = function(t) {
    let r = ws(this);
    return r = r.filter((a) => a.has("#Percent") || a.after("^percent")), r = r.getNth(t), new n(this.document, r.pointer);
  }, e.prototype.money = function(t) {
    let r = ws(this);
    return r = r.filter((a) => a.has("#Money") || a.after("^#Currency")), r = r.getNth(t), new n(this.document, r.pointer);
  }, e.prototype.values = e.prototype.numbers;
}, vD = function(e) {
  uD(e), gD(e);
}, yD = {
  api: vD
  // add @greaterThan, @lessThan
  // mutate: world => {
  //   let termMethods = world.methods.one.termMethods
  //   termMethods.lessThan = function (term) {
  //     return false //TODO: implement
  //     // return /[aeiou]/.test(term.text)
  //   }
  // },
}, bD = {
  people: !0,
  emails: !0,
  phoneNumbers: !0,
  places: !0
}, xD = function(e = {}) {
  return e = Object.assign({}, bD, e), e.people !== !1 && this.people().replaceWith("██████████"), e.emails !== !1 && this.emails().replaceWith("██████████"), e.places !== !1 && this.places().replaceWith("██████████"), e.phoneNumbers !== !1 && this.phoneNumbers().replaceWith("███████"), this;
}, wD = {
  api: function(e) {
    e.prototype.redact = xD;
  }
}, CD = function(e) {
  let n = e.clauses();
  return /\.\.$/.test(e.out("text")) || e.has("^#QuestionWord") && e.has("@hasComma") ? !1 : !!(e.has("or not$") || e.has("^#QuestionWord") || e.has("^(do|does|did|is|was|can|could|will|would|may) #Noun") || e.has("^(have|must) you") || n.has("(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$"));
}, kD = function(e) {
  const n = /\?/, { document: t } = e;
  return e.filter((r) => {
    let a = r.docs[0] || [], o = a[a.length - 1];
    return !o || t[o.index[0]].length !== a.length ? !1 : n.test(o.post) ? !0 : CD(r);
  });
}, ND = "(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)", AD = "(that|which|whichever|who|whoever|whom|whose|whomever)", ID = function(e) {
  let n = e;
  return n.length === 1 || (n = n.if("#Verb"), n.length === 1) || (n = n.ifNo(ND), n = n.ifNo("^even (if|though)"), n = n.ifNo("^so that"), n = n.ifNo("^rather than"), n = n.ifNo("^provided that"), n.length === 1) || (n = n.ifNo(AD), n.length === 1) || (n = n.ifNo("(^despite|^during|^before|^through|^throughout)"), n.length === 1) || (n = n.ifNo("^#Gerund"), n.length === 1) ? n : (n.length === 0 && (n = e), n.eq(0));
}, ED = function(e) {
  let n = null;
  return e.has("#PastTense") ? n = "PastTense" : e.has("#FutureTense") ? n = "FutureTense" : e.has("#PresentTense") && (n = "PresentTense"), {
    tense: n
  };
}, hr = function(e) {
  let n = e.clauses(), r = ID(n).chunks(), a = e.none(), o = e.none(), i = e.none();
  return r.forEach((s, u) => {
    if (u === 0 && !s.has("<Verb>")) {
      a = s;
      return;
    }
    if (!o.found && s.has("<Verb>")) {
      o = s;
      return;
    }
    o.found && (i = i.concat(s));
  }), o.found && !a.found && (a = o.before("<Noun>+").first()), {
    subj: a,
    verb: o,
    pred: i,
    grammar: ED(o)
  };
}, TD = function(e) {
  let n = e.verbs(), t = n.eq(0);
  if (t.has("#PastTense"))
    return e;
  if (t.toPastTense(), n.length > 1) {
    n = n.slice(1), n = n.filter((a) => !a.lookBehind("to$").found), n = n.if("#PresentTense"), n = n.notIf("#Gerund");
    let r = e.match("to #Verb+ #Conjunction #Verb").terms();
    n = n.not(r), n.found && n.verbs().toPastTense();
  }
  return e;
}, PD = function(e) {
  let n = e.verbs();
  return n.eq(0).toPresentTense(), n.length > 1 && (n = n.slice(1), n = n.filter((r) => !r.lookBehind("to$").found), n = n.notIf("#Gerund"), n.found && n.verbs().toPresentTense()), e;
}, SD = function(e) {
  let n = e.verbs();
  if (n.eq(0).toFutureTense(), e = e.fullSentence(), n = e.verbs(), n.length > 1) {
    n = n.slice(1);
    let r = n.filter((a) => a.lookBehind("to$").found ? !1 : a.has("#Copula #Gerund") ? !0 : a.has("#Gerund") ? !1 : a.has("#Copula") ? !0 : !(a.has("#PresentTense") && !a.has("#Infinitive") && a.lookBefore("(he|she|it|that|which)$").found));
    r.found && r.forEach((a) => {
      if (a.has("#Copula")) {
        a.match("was").replaceWith("is"), a.match("is").replaceWith("will be");
        return;
      }
      a.toInfinitive();
    });
  }
  return e;
}, DD = function(e) {
  return e.verbs().first().toNegative().compute("chunks"), e;
}, OD = function(e) {
  return e.verbs().first().toPositive().compute("chunks"), e;
}, RD = function(e) {
  return e.verbs().toInfinitive(), e;
}, FD = function(e) {
  class n extends e {
    constructor(a, o, i) {
      super(a, o, i), this.viewType = "Sentences";
    }
    json(a = {}) {
      return this.map((o) => {
        let i = o.toView().json(a)[0] || {}, { subj: s, verb: u, pred: l, grammar: c } = hr(o);
        return i.sentence = {
          subject: s.text("normal"),
          verb: u.text("normal"),
          predicate: l.text("normal"),
          grammar: c
        }, i;
      }, []);
    }
    toPastTense(a) {
      return this.getNth(a).map((o) => (hr(o), TD(o)));
    }
    toPresentTense(a) {
      return this.getNth(a).map((o) => (hr(o), PD(o)));
    }
    toFutureTense(a) {
      return this.getNth(a).map((o) => (hr(o), o = SD(o), o));
    }
    toInfinitive(a) {
      return this.getNth(a).map((o) => (hr(o), RD(o)));
    }
    toNegative(a) {
      return this.getNth(a).map((o) => (hr(o), DD(o)));
    }
    toPositive(a) {
      return this.getNth(a).map((o) => (hr(o), OD(o)));
    }
    isQuestion(a) {
      return this.questions(a);
    }
    isExclamation(a) {
      return this.filter((i) => i.lastTerm().has("@hasExclamation")).getNth(a);
    }
    isStatement(a) {
      return this.filter((i) => !i.isExclamation().found && !i.isQuestion().found).getNth(a);
    }
    // overloaded - keep Sentences class
    update(a) {
      let o = new n(this.document, a);
      return o._cache = this._cache, o;
    }
  }
  n.prototype.toPresent = n.prototype.toPresentTense, n.prototype.toPast = n.prototype.toPastTense, n.prototype.toFuture = n.prototype.toFutureTense;
  const t = {
    sentences: function(r) {
      let a = this.map((o) => o.fullSentence());
      return a = a.getNth(r), new n(this.document, a.pointer);
    },
    questions: function(r) {
      return kD(this).getNth(r);
    }
  };
  Object.assign(e.prototype, t);
}, MD = { api: FD }, _D = function(e) {
  let n = e.splitAfter("@hasComma");
  n = n.match("#Honorific+? #Person+");
  let t = n.match("#Possessive").notIf("(his|her)");
  return n = n.splitAfter(t), n;
}, dd = function(e) {
  let n = {};
  n.firstName = e.match("#FirstName+"), n.lastName = e.match("#LastName+"), n.honorific = e.match("#Honorific+");
  let t = n.lastName, r = n.firstName;
  return (!r.found || !t.found) && !r.found && !t.found && e.has("^#Honorific .$") && (n.lastName = e.match(".$")), n;
}, Vt = "male", mt = "female", pd = {
  mr: Vt,
  mrs: mt,
  miss: mt,
  madam: mt,
  // british stuff
  king: Vt,
  queen: mt,
  duke: Vt,
  duchess: mt,
  baron: Vt,
  baroness: mt,
  count: Vt,
  countess: mt,
  prince: Vt,
  princess: mt,
  sire: Vt,
  dame: mt,
  lady: mt,
  ayatullah: Vt,
  //i think?
  congressman: Vt,
  congresswoman: mt,
  "first lady": mt,
  // marked as non-binary
  mx: null
}, BD = function(e, n) {
  let { firstName: t, honorific: r } = e;
  if (t.has("#FemaleName"))
    return mt;
  if (t.has("#MaleName"))
    return Vt;
  if (r.found) {
    let o = r.text("normal");
    if (o = o.replace(/\./g, ""), pd.hasOwnProperty(o))
      return pd[o];
    if (/^her /.test(o))
      return mt;
    if (/^his /.test(o))
      return Vt;
  }
  let a = n.after();
  if (!a.has("#Person") && a.has("#Pronoun")) {
    let o = a.match("#Pronoun");
    if (o.has("(they|their)"))
      return null;
    let i = o.has("(he|his)"), s = o.has("(she|her|hers)");
    if (i && !s)
      return Vt;
    if (s && !i)
      return mt;
  }
  return null;
}, jD = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "People";
    }
    parse(r) {
      return this.getNth(r).map(dd);
    }
    json(r) {
      let a = typeof r == "object" ? r : {};
      return this.getNth(r).map((o) => {
        let i = o.toView().json(a)[0], s = dd(o);
        return i.person = {
          firstName: s.firstName.text("normal"),
          lastName: s.lastName.text("normal"),
          honorific: s.honorific.text("normal"),
          presumed_gender: BD(s, o)
        }, i;
      }, []);
    }
    // used for co-reference resolution only
    presumedMale() {
      return this.filter((r) => r.has("(#MaleName|mr|mister|sr|jr|king|pope|prince|sir)"));
    }
    presumedFemale() {
      return this.filter((r) => r.has("(#FemaleName|mrs|miss|queen|princess|madam)"));
    }
    // overloaded - keep People class
    update(r) {
      let a = new n(this.document, r);
      return a._cache = this._cache, a;
    }
  }
  e.prototype.people = function(t) {
    let r = _D(this);
    return r = r.getNth(t), new n(this.document, r.pointer);
  };
}, VD = function(e) {
  let n = e.match("(#Place|#Address)+"), t = n.match("@hasComma");
  return t = t.filter((r) => r.has("(asia|africa|europe|america)$") ? !0 : !(r.has("(#City|#Region|#ProperNoun)$") && r.after("^(#Country|#Region)").found)), n = n.splitAfter(t), n;
}, LD = function(e) {
  e.prototype.places = function(n) {
    let t = VD(this);
    return t = t.getNth(n), new e(this.document, t.pointer);
  };
}, zD = function(e) {
  e.prototype.organizations = function(n) {
    return this.match("#Organization+").getNth(n);
  };
}, GD = function(e) {
  let n = this.clauses(), t = n.people();
  return t = t.concat(n.places()), t = t.concat(n.organizations()), t = t.not("(someone|man|woman|mother|brother|sister|father)"), t = t.sort("seq"), t = t.getNth(e), t;
}, HD = function(e) {
  e.prototype.topics = GD;
}, WD = function(e) {
  jD(e), LD(e), zD(e), HD(e);
}, $D = { api: WD }, UD = function(e) {
  let n = e.match("<Verb>");
  return n = n.not("#Conjunction"), n = n.not("#Preposition"), n = n.splitAfter("@hasComma"), n = n.splitAfter("[(do|did|am|was|is|will)] (is|was)", 0), n = n.splitBefore("(#Verb && !#Copula) [being] #Verb", 0), n = n.splitBefore("#Verb [to be] #Verb", 0), n = n.splitAfter("[help] #PresentTense", 0), n = n.splitBefore("(#PresentTense|#PastTense) [#Copula]$", 0), n = n.splitBefore("(#PresentTense|#PastTense) [will be]$", 0), n = n.splitBefore("(#PresentTense|#PastTense) [(had|has)]", 0), n = n.not("#Reflexive$"), n = n.not("#Adjective"), n = n.splitAfter("[#PastTense] #PastTense", 0), n = n.splitAfter("[#PastTense] #Auxiliary+ #PastTense", 0), n = n.splitAfter("#Copula [#Gerund] #PastTense", 0), n = n.if("#Verb"), n.has("(#Verb && !#Auxiliary) #Adverb+? #Copula") && (n = n.splitBefore("#Copula")), n;
}, KD = function(e) {
  let n = e;
  return e.wordCount() > 1 && (n = e.not("(#Negative|#Auxiliary|#Modal|#Adverb|#Prefix)")), n.length > 1 && !n.has("#Phrasal #Particle") && (n = n.last()), n = n.not("(want|wants|wanted) to"), n.found || (n = e.not("#Negative")), n;
}, qD = function(e, n) {
  let t = {
    pre: e.none(),
    post: e.none()
  };
  if (!e.has("#Adverb"))
    return t;
  let r = e.splitOn(n);
  return r.length === 3 ? {
    pre: r.eq(0).adverbs(),
    post: r.eq(2).adverbs()
  } : r.eq(0).isDoc(n) ? (t.post = r.eq(1).adverbs(), t) : (t.pre = r.eq(0).adverbs(), t);
}, JD = function(e, n) {
  let t = e.splitBefore(n);
  if (t.length <= 1)
    return e.none();
  let r = t.eq(0);
  return r = r.not("(#Adverb|#Negative|#Prefix)"), r;
}, XD = function(e) {
  return e.match("#Negative");
}, QD = function(e) {
  if (!e.has("(#Particle|#PhrasalVerb)"))
    return {
      verb: e.none(),
      particle: e.none()
    };
  let n = e.match("#Particle$");
  return {
    verb: e.not(n),
    particle: n
  };
}, Kt = function(e) {
  let n = e.clone();
  n.contractions().expand();
  const t = KD(n);
  return {
    root: t,
    prefix: n.match("#Prefix"),
    adverbs: qD(n, t),
    auxiliary: JD(n, t),
    negative: XD(n),
    phrasal: QD(t)
  };
}, Ut = { tense: "PresentTense" }, Do = { conditional: !0 }, Nn = { tense: "FutureTense" }, Ur = { progressive: !0 }, tt = { tense: "PastTense" }, Kr = { complete: !0, progressive: !1 }, Wn = { passive: !0 }, YD = { plural: !0 }, ZD = { plural: !1 }, e4 = function(e) {
  let n = {};
  return e.forEach((t) => {
    Object.assign(n, t);
  }), n;
}, fd = {
  // === Simple ===
  imperative: [
    // walk!
    ["#Imperative", []]
  ],
  "want-infinitive": [
    ["^(want|wants|wanted) to #Infinitive$", [Ut]],
    ["^wanted to #Infinitive$", [tt]],
    ["^will want to #Infinitive$", [Nn]]
  ],
  "gerund-phrase": [
    // started looking
    ["^#PastTense #Gerund$", [tt]],
    // starts looking
    ["^#PresentTense #Gerund$", [Ut]],
    // start looking
    ["^#Infinitive #Gerund$", [Ut]],
    // will start looking
    ["^will #Infinitive #Gerund$", [Nn]],
    // have started looking
    ["^have #PastTense #Gerund$", [tt]],
    // will have started looking
    ["^will have #PastTense #Gerund$", [tt]]
  ],
  "simple-present": [
    // he walks',
    ["^#PresentTense$", [Ut]],
    // we walk
    ["^#Infinitive$", [Ut]]
  ],
  "simple-past": [
    // he walked',
    ["^#PastTense$", [tt]]
  ],
  "simple-future": [
    // he will walk
    ["^will #Adverb? #Infinitive", [Nn]]
  ],
  // === Progressive ===
  "present-progressive": [
    // he is walking
    ["^(is|are|am) #Gerund$", [Ut, Ur]]
  ],
  "past-progressive": [
    // he was walking
    ["^(was|were) #Gerund$", [tt, Ur]]
  ],
  "future-progressive": [
    // he will be
    ["^will be #Gerund$", [Nn, Ur]]
  ],
  // === Perfect ===
  "present-perfect": [
    // he has walked
    ["^(has|have) #PastTense$", [tt, Kr]]
    //past?
  ],
  "past-perfect": [
    // he had walked
    ["^had #PastTense$", [tt, Kr]],
    // had been to see
    ["^had #PastTense to #Infinitive", [tt, Kr]]
  ],
  "future-perfect": [
    // he will have
    ["^will have #PastTense$", [Nn, Kr]]
  ],
  // === Progressive-perfect ===
  "present-perfect-progressive": [
    // he has been walking
    ["^(has|have) been #Gerund$", [tt, Ur]]
    //present?
  ],
  "past-perfect-progressive": [
    // he had been
    ["^had been #Gerund$", [tt, Ur]]
  ],
  "future-perfect-progressive": [
    // will have been
    ["^will have been #Gerund$", [Nn, Ur]]
  ],
  // ==== Passive ===
  "passive-past": [
    // got walked, was walked, were walked
    ["(got|were|was) #Passive", [tt, Wn]],
    // was being walked
    ["^(was|were) being #Passive", [tt, Wn]],
    // had been walked, have been eaten
    ["^(had|have) been #Passive", [tt, Wn]]
  ],
  "passive-present": [
    // is walked, are stolen
    ["^(is|are|am) #Passive", [Ut, Wn]],
    // is being walked
    ["^(is|are|am) being #Passive", [Ut, Wn]],
    // has been cleaned
    ["^has been #Passive", [Ut, Wn]]
  ],
  "passive-future": [
    // will have been walked
    ["will have been #Passive", [Nn, Wn, Do]],
    // will be cleaned
    ["will be being? #Passive", [Nn, Wn, Do]]
  ],
  // === Conditional ===
  "present-conditional": [
    // would be walked
    ["would be #PastTense", [Ut, Do]]
  ],
  "past-conditional": [
    // would have been walked
    ["would have been #PastTense", [tt, Do]]
  ],
  // ==== Auxiliary ===
  "auxiliary-future": [
    // going to drink
    ["(is|are|am|was) going to (#Infinitive|#PresentTense)", [Nn]]
  ],
  "auxiliary-past": [
    // he did walk
    ["^did #Infinitive$", [tt, ZD]],
    // used to walk
    ["^used to #Infinitive$", [tt, Kr]]
  ],
  "auxiliary-present": [
    // we do walk
    ["^(does|do) #Infinitive$", [Ut, Kr, YD]]
  ],
  // === modals ===
  "modal-past": [
    // he could have walked
    ["^(could|must|should|shall) have #PastTense$", [tt]]
  ],
  "modal-infinitive": [
    // he can walk
    ["^#Modal #Infinitive$", []]
  ],
  infinitive: [
    // walk
    ["^#Infinitive$", []]
  ]
};
let gu = [];
Object.keys(fd).map((e) => {
  fd[e].forEach((n) => {
    gu.push({
      name: e,
      match: n[0],
      data: e4(n[1])
    });
  });
});
const t4 = function(e, n) {
  return e = e.clone(), n.adverbs.post && n.adverbs.post.found && e.remove(n.adverbs.post), n.adverbs.pre && n.adverbs.pre.found && e.remove(n.adverbs.pre), e.has("#Negative") && (e = e.remove("#Negative")), e.has("#Prefix") && (e = e.remove("#Prefix")), n.root.has("#PhrasalVerb #Particle") && e.remove("#Particle$"), e = e.not("#Adverb"), e;
}, n4 = function(e) {
  return !!(e.has("#Infinitive") && e.growLeft("to").has("^to #Infinitive"));
}, In = function(e, n) {
  let t = {};
  e = t4(e, n);
  for (let r = 0; r < gu.length; r += 1) {
    let a = gu[r];
    if (e.has(a.match) === !0) {
      t.form = a.name, Object.assign(t, a.data);
      break;
    }
  }
  return t.form || e.has("^#Verb$") && (t.form = "infinitive"), t.tense || (t.tense = n.root.has("#PastTense") ? "PastTense" : "PresentTense"), t.copula = n.root.has("#Copula"), t.isInfinitive = n4(e), t;
}, md = function(e) {
  return e.length <= 1 ? !1 : (e.parse()[0] || {}).isSubordinate;
}, r4 = function(e) {
  let n = e.clauses();
  return n = n.filter((t, r) => !(t.has("^(if|unless|while|but|for|per|at|by|that|which|who|from)") || r > 0 && t.has("^#Verb . #Noun+$") || r > 0 && t.has("^#Adverb"))), n.length === 0 ? e : n;
}, a4 = function(e) {
  let n = e.before();
  n = r4(n);
  let t = n.nouns(), r = t.last(), a = r.match("(i|he|she|we|you|they)");
  if (a.found)
    return a.nouns();
  let o = t.if("^(that|this|those)");
  return o.found || t.found === !1 && (o = n.match("^(that|this|those)"), o.found) ? o : (r = t.last(), md(r) && (t.remove(r), r = t.last()), md(r) && (t.remove(r), r = t.last()), r);
}, o4 = function(e, n) {
  return n.has("(are|were|does)") || e.has("(those|they|we)") ? !0 : e.found && e.isPlural ? e.isPlural().found : !1;
}, cn = function(e) {
  let n = a4(e);
  return {
    subject: n,
    plural: o4(n, e)
  };
}, Se = (e) => e, Ra = (e, n) => {
  let t = cn(e), r = t.subject;
  return r.has("i") || r.has("we") ? !0 : t.plural;
}, i4 = (e, n) => {
  let { subject: t, plural: r } = cn(e);
  return r || t.has("we") ? "were" : "was";
}, Fa = function(e, n) {
  if (e.has("were"))
    return "are";
  let { subject: t, plural: r } = cn(e);
  return t.has("i") ? "am" : t.has("we") || r ? "are" : "is";
}, Tl = function(e, n) {
  let t = cn(e), r = t.subject;
  return r.has("i") || r.has("we") || t.plural ? "do" : "does";
}, Mt = function(e) {
  if (e.has("#Infinitive"))
    return "Infinitive";
  if (e.has("#Participle"))
    return "Participle";
  if (e.has("#PastTense"))
    return "PastTense";
  if (e.has("#Gerund"))
    return "Gerund";
  if (e.has("#PresentTense"))
    return "PresentTense";
}, vu = function(e, n) {
  const { toInfinitive: t } = e.methods.two.transform.verb;
  let r = n.root.text({ keepPunct: !1 });
  return r = t(r, e.model, Mt(e)), r && e.replace(n.root, r), e;
}, gd = (e) => e.has("will not") ? e.replace("will not", "have not") : e.remove("will"), vd = function(e) {
  if (!e || !e.isView)
    return [];
  const n = { normal: !0, terms: !1, text: !1 };
  return e.json(n).map((t) => t.normal);
}, yd = function(e) {
  return !e || !e.isView ? "" : e.text("normal");
}, s4 = function(e) {
  const { toInfinitive: n } = e.methods.two.transform.verb;
  let t = e.text("normal");
  return n(t, e.model, Mt(e));
}, u4 = function(e) {
  let n = Kt(e);
  e = e.clone().toView();
  const t = In(e, n);
  return {
    root: n.root.text(),
    preAdverbs: vd(n.adverbs.pre),
    postAdverbs: vd(n.adverbs.post),
    auxiliary: yd(n.auxiliary),
    negative: n.negative.found,
    prefix: yd(n.prefix),
    infinitive: s4(n.root),
    grammar: t
  };
}, l4 = { tags: !0 }, c4 = function(e, n) {
  const { toInfinitive: t } = e.methods.two.transform.verb, { root: r, auxiliary: a } = n;
  let o = a.terms().harden(), i = r.text("normal");
  if (i = t(i, e.model, Mt(r)), i && e.replace(r, i, l4).tag("Verb").firstTerm().tag("Infinitive"), o.found && e.remove(o), n.negative.found) {
    e.has("not") || e.prepend("not");
    let s = Tl(e);
    e.prepend(s);
  }
  return e.fullSentence().compute(["freeze", "lexicon", "preTagger", "postTagger", "unfreeze", "chunks"]), e;
}, jt = { tags: !0 }, En = {
  noAux: (e, n) => (n.auxiliary.found && (e = e.remove(n.auxiliary)), e),
  // walk->walked
  simple: (e, n) => {
    const { conjugate: t, toInfinitive: r } = e.methods.two.transform.verb, a = n.root;
    if (a.has("#Modal"))
      return e;
    let o = a.text({ keepPunct: !1 });
    return o = r(o, e.model, Mt(a)), o = t(o, e.model).PastTense, o = o === "been" ? "was" : o, o === "was" && (o = i4(e)), o && e.replace(a, o, jt), e;
  },
  both: function(e, n) {
    return n.negative.found ? (e.replace("will", "did"), e) : (e = En.simple(e, n), e = En.noAux(e, n), e);
  },
  hasHad: (e) => (e.replace("has", "had", jt), e),
  // some verbs have this weird past-tense form
  // drive -> driven, (!drove)
  hasParticiple: (e, n) => {
    const { conjugate: t, toInfinitive: r } = e.methods.two.transform.verb, a = n.root;
    let o = a.text("normal");
    return o = r(o, e.model, Mt(a)), t(o, e.model).Participle;
  }
}, bd = {
  // walk -> walked
  infinitive: En.simple,
  // he walks -> he walked
  "simple-present": En.simple,
  // he walked
  "simple-past": Se,
  // he will walk -> he walked
  "simple-future": En.both,
  // he is walking
  "present-progressive": (e) => (e.replace("are", "were", jt), e.replace("(is|are|am)", "was", jt), e),
  // he was walking
  "past-progressive": Se,
  // he will be walking
  "future-progressive": (e, n) => (e.match(n.root).insertBefore("was"), e.remove("(will|be)"), e),
  // has walked -> had walked (?)
  "present-perfect": En.hasHad,
  // had walked
  "past-perfect": Se,
  // will have walked -> had walked
  "future-perfect": (e, n) => (e.match(n.root).insertBefore("had"), e.has("will") && (e = gd(e)), e.remove("have"), e),
  // has been walking -> had been
  "present-perfect-progressive": En.hasHad,
  // had been walking
  "past-perfect-progressive": Se,
  // will have been -> had
  "future-perfect-progressive": (e) => (e.remove("will"), e.replace("have", "had", jt), e),
  // got walked
  "passive-past": (e) => (e.replace("have", "had", jt), e),
  // is being walked  -> 'was being walked'
  "passive-present": (e) => (e.replace("(is|are)", "was", jt), e),
  // will be walked -> had been walked
  "passive-future": (e, n) => (n.auxiliary.has("will be") && (e.match(n.root).insertBefore("had been"), e.remove("(will|be)")), n.auxiliary.has("will have been") && (e.replace("have", "had", jt), e.remove("will")), e),
  // would be walked -> 'would have been walked'
  "present-conditional": (e) => (e.replace("be", "have been"), e),
  // would have been walked
  "past-conditional": Se,
  // is going to drink -> was going to drink
  "auxiliary-future": (e) => (e.replace("(is|are|am)", "was", jt), e),
  // used to walk
  "auxiliary-past": Se,
  // we do walk -> we did walk
  "auxiliary-present": (e) => (e.replace("(do|does)", "did", jt), e),
  // must walk -> 'must have walked'
  "modal-infinitive": (e, n) => (e.has("can") ? e.replace("can", "could", jt) : (En.simple(e, n), e.match("#Modal").insertAfter("have").tag("Auxiliary")), e),
  // must have walked
  "modal-past": Se,
  // wanted to walk
  "want-infinitive": (e) => (e.replace("(want|wants)", "wanted", jt), e.remove("will"), e),
  // started looking
  "gerund-phrase": (e, n) => (n.root = n.root.not("#Gerund$"), En.simple(e, n), gd(e), e)
}, h4 = function(e, n, t) {
  return bd.hasOwnProperty(t) && (e = bd[t](e, n), e.fullSentence().compute(["tagger", "chunks"])), e;
}, yu = function(e, n) {
  let t = cn(e), r = t.subject;
  return r.has("(i|we|you)") ? "have" : t.plural === !1 || r.has("he") || r.has("she") || r.has("#Person") ? "has" : "have";
}, bu = (e, n) => {
  const { conjugate: t, toInfinitive: r } = e.methods.two.transform.verb, { root: a, auxiliary: o } = n;
  if (a.has("#Modal"))
    return e;
  let i = a.text({ keepPunct: !1 });
  i = r(i, e.model, Mt(a));
  let s = t(i, e.model);
  if (i = s.Participle || s.PastTense, i) {
    e = e.replace(a, i);
    let u = yu(e);
    e.prepend(u).match(u).tag("Auxiliary"), e.remove(o);
  }
  return e;
}, xd = {
  // walk -> walked
  infinitive: bu,
  // he walks -> he walked
  "simple-present": bu,
  // he walked
  // 'simple-past': noop,
  // he will walk -> he walked
  "simple-future": (e, n) => e.replace("will", yu(e)),
  // he is walking
  // 'present-progressive': noop,
  // he was walking
  // 'past-progressive': noop,
  // he will be walking
  // 'future-progressive': noop,
  // has walked -> had walked (?)
  "present-perfect": Se,
  // had walked
  "past-perfect": Se,
  // will have walked -> had walked
  "future-perfect": (e, n) => e.replace("will have", yu(e)),
  // has been walking -> had been
  "present-perfect-progressive": Se,
  // had been walking
  "past-perfect-progressive": Se,
  // will have been -> had
  "future-perfect-progressive": Se
  // got walked
  // 'passive-past': noop,
  // is being walked  -> 'was being walked'
  // 'passive-present': noop,
  // will be walked -> had been walked
  // 'passive-future': noop,
  // would be walked -> 'would have been walked'
  // 'present-conditional': noop,
  // would have been walked
  // 'past-conditional': noop,
  // is going to drink -> was going to drink
  // 'auxiliary-future': noop,
  // used to walk
  // 'auxiliary-past': noop,
  // we do walk -> we did walk
  // 'auxiliary-present': noop,
  // must walk -> 'must have walked'
  // 'modal-infinitive': noop,
  // must have walked
  // 'modal-past': noop,
  // wanted to walk
  // 'want-infinitive': noop,
  // started looking
  // 'gerund-phrase': noop,
}, d4 = function(e, n, t) {
  return xd.hasOwnProperty(t) ? (e = xd[t](e, n), e.fullSentence().compute(["tagger", "chunks"]), e) : (e = bu(e, n), e.fullSentence().compute(["tagger", "chunks"]), e);
}, Sn = { tags: !0 }, qr = (e, n) => {
  const { conjugate: t, toInfinitive: r } = e.methods.two.transform.verb, a = n.root;
  let o = a.text("normal");
  return o = r(o, e.model, Mt(a)), Ra(e) === !1 && (o = t(o, e.model).PresentTense), a.has("#Copula") && (o = Fa(e)), o && (e = e.replace(a, o, Sn), e.not("#Particle").tag("PresentTense")), e;
}, wd = (e, n) => {
  const { conjugate: t, toInfinitive: r } = e.methods.two.transform.verb, a = n.root;
  let o = a.text("normal");
  return o = r(o, e.model, Mt(a)), Ra(e) === !1 && (o = t(o, e.model).Gerund), o && (e = e.replace(a, o, Sn), e.not("#Particle").tag("Gerund")), e;
}, p4 = (e, n) => {
  const { toInfinitive: t } = e.methods.two.transform.verb, r = n.root;
  let a = n.root.text("normal");
  return a = t(a, e.model, Mt(r)), a && (e = e.replace(n.root, a, Sn)), e;
}, Cd = {
  // walk
  infinitive: qr,
  // he walks -> he walked
  "simple-present": (e, n) => {
    const { conjugate: t } = e.methods.two.transform.verb;
    let { root: r } = n;
    if (r.has("#Infinitive")) {
      let o = cn(e).subject;
      if (Ra(e) || o.has("i"))
        return e;
      let i = r.text("normal"), s = t(i, e.model).PresentTense;
      i !== s && e.replace(r, s, Sn);
    } else
      return qr(e, n);
    return e;
  },
  // he walked
  "simple-past": qr,
  // he will walk -> he walked
  "simple-future": (e, n) => {
    const { root: t, auxiliary: r } = n;
    if (r.has("will") && t.has("be")) {
      let a = Fa(e);
      e.replace(t, a), e = e.remove("will"), e.replace("not " + a, a + " not");
    } else
      qr(e, n), e = e.remove("will");
    return e;
  },
  // is walking ->
  "present-progressive": Se,
  // was walking -> is walking
  "past-progressive": (e, n) => {
    let t = Fa(e);
    return e.replace("(were|was)", t, Sn);
  },
  // will be walking -> is walking
  "future-progressive": (e) => (e.match("will").insertBefore("is"), e.remove("be"), e.remove("will")),
  // has walked ->  (?)
  "present-perfect": (e, n) => (qr(e, n), e = e.remove("(have|had|has)"), e),
  // had walked -> has walked
  "past-perfect": (e, n) => {
    let r = cn(e).subject;
    return Ra(e) || r.has("i") ? (e = vu(e, n), e.remove("had"), e) : (e.replace("had", "has", Sn), e);
  },
  // will have walked -> has walked
  "future-perfect": (e) => (e.match("will").insertBefore("has"), e.remove("have").remove("will")),
  // has been walking
  "present-perfect-progressive": Se,
  // had been walking
  "past-perfect-progressive": (e) => e.replace("had", "has", Sn),
  // will have been -> has been
  "future-perfect-progressive": (e) => (e.match("will").insertBefore("has"), e.remove("have").remove("will")),
  // got walked -> is walked
  // was walked -> is walked
  // had been walked -> is walked
  "passive-past": (e, n) => {
    let t = Fa(e);
    return e.has("(had|have|has)") && e.has("been") ? (e.replace("(had|have|has)", t, Sn), e.replace("been", "being"), e) : e.replace("(got|was|were)", t);
  },
  // is being walked  ->
  "passive-present": Se,
  // will be walked -> is being walked
  "passive-future": (e) => (e.replace("will", "is"), e.replace("be", "being")),
  // would be walked ->
  "present-conditional": Se,
  // would have been walked ->
  "past-conditional": (e) => (e.replace("been", "be"), e.remove("have")),
  // is going to drink -> is drinking
  "auxiliary-future": (e, n) => (wd(e, n), e.remove("(going|to)"), e),
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (e, n) => {
    if (n.auxiliary.has("did")) {
      let t = Tl(e);
      return e.replace(n.auxiliary, t), e;
    }
    return wd(e, n), e.replace(n.auxiliary, "is"), e;
  },
  // we do walk ->
  "auxiliary-present": Se,
  // must walk -> 'must have walked'
  "modal-infinitive": Se,
  // must have walked
  "modal-past": (e, n) => (p4(e, n), e.remove("have")),
  // started looking
  "gerund-phrase": (e, n) => (n.root = n.root.not("#Gerund$"), qr(e, n), e.remove("(will|have)")),
  // wanted to walk
  "want-infinitive": (e, n) => {
    let t = "wants";
    return Ra(e) && (t = "want"), e.replace("(want|wanted|wants)", t, Sn), e.remove("will"), e;
  }
}, f4 = function(e, n, t) {
  return Cd.hasOwnProperty(t) && (e = Cd[t](e, n), e.fullSentence().compute(["tagger", "chunks"])), e;
}, wg = { tags: !0 }, Oo = (e, n) => {
  const { toInfinitive: t } = e.methods.two.transform.verb, { root: r, auxiliary: a } = n;
  if (r.has("#Modal"))
    return e;
  let o = r.text("normal");
  return o = t(o, e.model, Mt(r)), o && (e = e.replace(r, o, wg), e.not("#Particle").tag("Verb")), e.prepend("will").match("will").tag("Auxiliary"), e.remove(a), e;
}, kd = (e, n) => {
  const { conjugate: t, toInfinitive: r } = e.methods.two.transform.verb, { root: a, auxiliary: o } = n;
  let i = a.text("normal");
  return i = r(i, e.model, Mt(a)), i && (i = t(i, e.model).Gerund, e.replace(a, i, wg), e.not("#Particle").tag("PresentTense")), e.remove(o), e.prepend("will be").match("will be").tag("Auxiliary"), e;
}, Nd = {
  // walk ->
  infinitive: Oo,
  // he walks ->
  "simple-present": Oo,
  // he walked
  "simple-past": Oo,
  // he will walk ->
  "simple-future": Se,
  // is walking ->
  "present-progressive": kd,
  // was walking ->
  "past-progressive": kd,
  // will be walking ->
  "future-progressive": Se,
  // has walked ->
  "present-perfect": (e) => (e.match("(have|has)").replaceWith("will have"), e),
  // had walked ->
  "past-perfect": (e) => e.replace("(had|has)", "will have"),
  // will have walked ->
  "future-perfect": Se,
  // has been walking
  "present-perfect-progressive": (e) => e.replace("has", "will have"),
  // had been walking
  "past-perfect-progressive": (e) => e.replace("had", "will have"),
  // will have been ->
  "future-perfect-progressive": Se,
  // got walked ->
  // was walked ->
  // was being walked ->
  // had been walked ->
  "passive-past": (e) => e.has("got") ? e.replace("got", "will get") : e.has("(was|were)") ? (e.replace("(was|were)", "will be"), e.remove("being")) : e.has("(have|has|had) been") ? e.replace("(have|has|had) been", "will be") : e,
  // is being walked  ->
  "passive-present": (e) => (e.replace("being", "will be"), e.remove("(is|are|am)"), e),
  // will be walked ->
  "passive-future": Se,
  // would be walked ->
  "present-conditional": (e) => e.replace("would", "will"),
  // would have been walked ->
  "past-conditional": (e) => e.replace("would", "will"),
  // is going to drink ->
  "auxiliary-future": Se,
  // used to walk -> is walking
  // did walk -> is walking
  "auxiliary-past": (e) => e.has("used") && e.has("to") ? (e.replace("used", "will"), e.remove("to")) : (e.replace("did", "will"), e),
  // we do walk ->
  // he does walk ->
  "auxiliary-present": (e) => e.replace("(do|does)", "will"),
  // must walk ->
  "modal-infinitive": Se,
  // must have walked
  "modal-past": Se,
  // started looking
  "gerund-phrase": (e, n) => (n.root = n.root.not("#Gerund$"), Oo(e, n), e.remove("(had|have)")),
  // wanted to walk
  "want-infinitive": (e) => (e.replace("(want|wants|wanted)", "will want"), e)
}, m4 = function(e, n, t) {
  return e.has("will") || e.has("going to") || Nd.hasOwnProperty(t) && (e = Nd[t](e, n), e.fullSentence().compute(["tagger", "chunks"])), e;
}, g4 = { tags: !0 }, v4 = function(e, n) {
  const { toInfinitive: t, conjugate: r } = e.methods.two.transform.verb, { root: a, auxiliary: o } = n;
  if (e.has("#Gerund"))
    return e;
  let i = a.text("normal");
  i = t(i, e.model, Mt(a));
  let s = r(i, e.model).Gerund;
  if (s) {
    let u = Fa(e);
    e.replace(a, s, g4), e.remove(o), e.prepend(u);
  }
  return e.replace("not is", "is not"), e.replace("not are", "are not"), e.fullSentence().compute(["tagger", "chunks"]), e;
}, Ad = { tags: !0 }, Cs = function(e, n) {
  let t = Tl(e);
  return e.prepend(t + " not"), e;
}, _o = function(e) {
  let n = e.match("be");
  return n.found ? (n.prepend("not"), e) : (n = e.match("(is|was|am|are|will|were)"), n.found && n.append("not"), e);
}, Bo = (e) => e.has("(is|was|am|are|will|were|be)"), Id = {
  // he walks' -> 'he does not walk'
  "simple-present": (e, n) => Bo(e) === !0 ? _o(e) : (e = vu(e, n), e = Cs(e), e),
  // 'he walked' -> 'he did not walk'
  "simple-past": (e, n) => Bo(e) === !0 ? _o(e) : (e = vu(e, n), e.prepend("did not"), e),
  // walk! -> 'do not walk'
  imperative: (e) => (e.prepend("do not"), e),
  // walk -> does not walk
  infinitive: (e, n) => Bo(e) === !0 ? _o(e) : Cs(e),
  "passive-past": (e) => {
    if (e.has("got"))
      return e.replace("got", "get", Ad), e.prepend("did not"), e;
    let n = e.match("(was|were|had|have)");
    return n.found && n.append("not"), e;
  },
  "auxiliary-past": (e) => {
    if (e.has("used"))
      return e.prepend("did not"), e;
    let n = e.match("(did|does|do)");
    return n.found && n.append("not"), e;
  },
  // wants to walk
  "want-infinitive": (e, n) => (e = Cs(e), e = e.replace("wants", "want", Ad), e)
}, y4 = function(e, n, t) {
  if (e.has("#Negative"))
    return e;
  if (Id.hasOwnProperty(t))
    return e = Id[t](e, n), e;
  let r = e.matchOne("be");
  return r.found ? (r.prepend("not"), e) : Bo(e) === !0 ? _o(e) : (r = e.matchOne("(will|had|have|has|did|does|do|#Modal)"), r.found && r.append("not"), e);
}, b4 = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Verbs";
    }
    parse(r) {
      return this.getNth(r).map(Kt);
    }
    json(r, a) {
      return this.getNth(a).map((s) => {
        let u = s.toView().json(r)[0] || {};
        return u.verb = u4(s), u;
      }, []);
    }
    subjects(r) {
      return this.getNth(r).map((a) => (Kt(a), cn(a).subject));
    }
    adverbs(r) {
      return this.getNth(r).map((a) => a.match("#Adverb"));
    }
    isSingular(r) {
      return this.getNth(r).filter((a) => cn(a).plural !== !0);
    }
    isPlural(r) {
      return this.getNth(r).filter((a) => cn(a).plural === !0);
    }
    isImperative(r) {
      return this.getNth(r).filter((a) => a.has("#Imperative"));
    }
    toInfinitive(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return c4(a, o, i.form);
      });
    }
    toPresentTense(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return i.isInfinitive ? a : f4(a, o, i.form);
      });
    }
    toPastTense(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return i.isInfinitive ? a : h4(a, o, i.form);
      });
    }
    toFutureTense(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return i.isInfinitive ? a : m4(a, o, i.form);
      });
    }
    toGerund(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return i.isInfinitive ? a : v4(a, o, i.form);
      });
    }
    toPastParticiple(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return i.isInfinitive ? a : d4(a, o, i.form);
      });
    }
    conjugate(r) {
      const { conjugate: a, toInfinitive: o } = this.world.methods.two.transform.verb;
      return this.getNth(r).map((i) => {
        let s = Kt(i), u = In(i, s);
        u.form === "imperative" && (u.form = "simple-present");
        let l = s.root.text("normal");
        if (!s.root.has("#Infinitive")) {
          let c = Mt(s.root);
          l = o(l, i.model, c) || l;
        }
        return a(l, i.model);
      }, []);
    }
    /** return only verbs with 'not'*/
    isNegative() {
      return this.if("#Negative");
    }
    /**  return only verbs without 'not'*/
    isPositive() {
      return this.ifNo("#Negative");
    }
    /** remove 'not' from these verbs */
    toPositive() {
      let r = this.match("do not #Verb");
      return r.found && r.remove("do not"), this.remove("#Negative");
    }
    toNegative(r) {
      return this.getNth(r).map((a) => {
        let o = Kt(a), i = In(a, o);
        return y4(a, o, i.form);
      });
    }
    // overloaded - keep Verb class
    update(r) {
      let a = new n(this.document, r);
      return a._cache = this._cache, a;
    }
  }
  n.prototype.toPast = n.prototype.toPastTense, n.prototype.toPresent = n.prototype.toPresentTense, n.prototype.toFuture = n.prototype.toFutureTense, e.prototype.verbs = function(t) {
    let r = UD(this);
    return r = r.getNth(t), new n(this.document, r.pointer);
  };
}, x4 = {
  api: b4
}, xu = function(e, n) {
  let t = n.match(e);
  if (t.found) {
    let r = t.pronouns().refersTo();
    if (r.found)
      return r;
  }
  return n.none();
}, Ed = function(e) {
  if (!e.found)
    return e;
  let [n] = e.fullPointer[0];
  return n && n > 0 ? e.update([[n - 1]]) : e.none();
}, w4 = function(e, n) {
  return n === "m" ? e.filter((t) => !t.presumedFemale().found) : n === "f" ? e.filter((t) => !t.presumedMale().found) : e;
}, Td = function(e, n) {
  let t = e.people();
  return t = w4(t, n), t.found || (t = e.nouns("#Actor"), t.found) ? t.last() : n === "f" ? xu("(she|her|hers)", e) : n === "m" ? xu("(he|him|his)", e) : e.none();
}, C4 = function(e) {
  let n = e.nouns(), t = n.isPlural().notIf("#Pronoun");
  if (t.found)
    return t.last();
  let r = xu("(they|their|theirs)", e);
  return r.found ? r : (t = n.match("(somebody|nobody|everybody|anybody|someone|noone|everyone|anyone)"), t.found ? t.last() : e.none());
}, k4 = function(e, n) {
  if (n && n.found) {
    let t = e.docs[0][0];
    t.reference = n.ptrs[0];
  }
}, ks = function(e, n) {
  let t = e.before(), r = n(t);
  return r.found || (t = Ed(e), r = n(t), r.found) || (t = Ed(t), r = n(t), r.found) ? r : e.none();
}, N4 = function(e) {
  e.pronouns().if("(he|him|his|she|her|hers|they|their|theirs|it|its)").forEach((t) => {
    let r = null;
    t.has("(he|him|his)") ? r = ks(t, (a) => Td(a, "m")) : t.has("(she|her|hers)") ? r = ks(t, (a) => Td(a, "f")) : t.has("(they|their|theirs)") && (r = ks(t, C4)), r && r.found && k4(t, r);
  });
}, A4 = function(e) {
  class n extends e {
    constructor(r, a, o) {
      super(r, a, o), this.viewType = "Pronouns";
    }
    hasReference() {
      return this.compute("coreference"), this.filter((r) => r.docs[0][0].reference);
    }
    // get the noun-phrase this pronoun refers to
    refersTo() {
      return this.compute("coreference"), this.map((r) => {
        if (!r.found)
          return r.none();
        let a = r.docs[0][0];
        return a.reference ? r.update([a.reference]) : r.none();
      });
    }
    // overloaded - keep Numbers class
    update(r) {
      let a = new n(this.document, r);
      return a._cache = this._cache, a;
    }
  }
  e.prototype.pronouns = function(t) {
    let r = this.match("#Pronoun");
    return r = r.getNth(t), new n(r.document, r.pointer);
  };
}, I4 = {
  compute: { coreference: N4 },
  api: A4
};
se.plugin(GP);
se.plugin($P);
se.plugin(iS);
se.plugin(I4);
se.plugin(AS);
se.plugin(PS);
se.plugin(HS);
se.plugin(yD);
se.plugin(wD);
se.plugin(MD);
se.plugin($D);
se.plugin(x4);
class E4 {
  constructor() {
    this.models = {
      toxicity: null,
      spam: null,
      sentiment: null,
      nlp: null
    }, this.lastUrl = window.location.href;
  }
  // Check if the extension is in a valid Gmail environment
  isValidEnvironment() {
    return window.location.hostname.includes("mail.google.com");
  }
  // Initialize the extension
  async initialize() {
    return this.isValidEnvironment() ? await this.loadModels() ? (this.setupObservers(), this.attachEventListeners(), !0) : (console.error("Failed to load security models"), !1) : (console.warn("Not in Gmail environment. Extension cannot initialize."), !1);
  }
  // Set up mutation observers to detect email changes
  setupObservers() {
    const n = new MutationObserver(async (r) => {
      await Promise.all(
        r.map(async (a) => a.type === "childList" && window.location.href !== this.lastUrl ? (this.lastUrl = window.location.href, await this.scanOpenEmail()) : Promise.resolve())
      );
    }), t = document.querySelector('div[role="main"]');
    t && n.observe(t, {
      childList: !0,
      subtree: !0
    });
  }
  // Attach event listeners for manual scanning
  attachEventListeners() {
    document.addEventListener("keydown", async (n) => {
      n.ctrlKey && n.shiftKey && n.key === "Q" && await this.scanOpenEmail();
    });
  }
  // Enhanced model loading with multiple threat detection models
  async loadModels() {
    try {
      console.log("Loading AI models..."), this.models.toxicity = await lw(0.7), this.models.nlp = se;
      const n = [
        // Financial scam keywords
        "urgent",
        "winner",
        "lottery",
        "inheritance",
        "million dollars",
        "bank details",
        "wire transfer",
        "prince",
        "unclaimed funds",
        "cash prize",
        "money transfer",
        "financial opportunity",
        "investment opportunity",
        "stock picks",
        "crypto giveaway",
        "high returns",
        "tax evasion",
        "offshore account",
        "guaranteed profits",
        "credit repair",
        "debt consolidation",
        "free money",
        "grant money",
        "secret fortune",
        "easy profits",
        "alternative investment",
        "forex trading",
        "Ponzi scheme",
        "pyramid scheme",
        "binary options",
        "pre-approved loan",
        "low interest rate",
        "reverse mortgage",
        "structured settlement",
        "gold investment",
        "silver investment",
        "diamond investment",
        "rare coins",
        "collectible items",
        "business opportunity",
        "franchise opportunity",
        "venture capital",
        "angel investor",
        "sponsorship offer",
        "charity donation",
        "crowdfunding campaign",
        "economic stimulus",
        "government bonds",
        "fast cash",
        // New
        "no risk investment",
        // New
        "double your money",
        // New
        "hidden assets",
        // New
        "treasure trove",
        // New
        "wealth transfer",
        // New
        "miracle savings plan",
        // New
        "secret wealth formula",
        // New
        "exclusive membership",
        // New
        "VIP investor program",
        // New
        "private equity fund",
        // New
        "real estate flipping",
        // New
        "luxury property deal",
        // New
        "off-market property",
        // New
        "land banking",
        // New
        "oil and gas drilling",
        // New
        "carbon credits",
        // New
        "green energy scheme",
        // New
        "renewable energy grants",
        // New
        "windfall profits",
        // New
        "asset protection",
        // New
        "trust fund",
        // New
        // Phishing attempt keywords
        "click here",
        "verify account",
        "reset password",
        "suspicious activity",
        "account locked",
        "confirm identity",
        "urgent action required",
        "security alert",
        "login required",
        "update your details",
        "payment failed",
        "invoice attached",
        "download now",
        "open this link",
        "your account has been compromised",
        "security notice",
        "important information",
        "critical update",
        "reactivate account",
        "form submission",
        "password change",
        "2FA bypass",
        "security question",
        "personal information",
        "SSN",
        "social security number",
        "credit card number",
        "CVV",
        "expiration date",
        "PIN",
        "one-time code",
        "verification code",
        "recovery email",
        "recovery phone",
        "digital signature",
        "encrypted message",
        "secure file transfer",
        "webmail access",
        "cloud storage",
        "document sharing",
        "account verification",
        // New
        "secure login",
        // New
        "fraud alert",
        // New
        "unauthorized access",
        // New
        "session expired",
        // New
        "log out detected",
        // New
        "sensitive data",
        // New
        "identity theft",
        // New
        "data breach",
        // New
        "compromised credentials",
        // New
        "secure portal",
        // New
        "password reset request",
        // New
        // Manipulation tactics
        "limited offer",
        "one-time opportunity",
        "exclusive deal",
        "act now",
        "don't miss out",
        "time-sensitive",
        "immediate response",
        "last chance",
        "final notice",
        "special offer",
        "you've been selected",
        "congratulations",
        "as a valued customer",
        "for a limited time only",
        "while supplies last",
        "risk-free trial",
        "no obligation",
        "pressure tactics",
        "emotional appeal",
        "fear-mongering",
        "sense of urgency",
        "false scarcity",
        "social proof",
        "authority bias",
        "reciprocity",
        "commitment and consistency",
        "liking",
        "scarcity",
        "unity",
        "bandwagon effect",
        "groupthink",
        "cult tactics",
        "brainwashing",
        "mind control",
        "gaslighting",
        "love bombing",
        "isolation",
        "information overload",
        "cognitive dissonance",
        "too good to be true",
        // New
        "life-changing opportunity",
        // New
        "once-in-a-lifetime",
        // New
        "exclusive access",
        // New
        "limited seats available",
        // New
        "early bird discount",
        // New
        "flash sale",
        // New
        "countdown timer",
        // New
        "bonus offer",
        // New
        "free upgrade",
        // New
        "instant approval",
        // New
        // Impersonation attempts
        "dear customer",
        "dear sir/madam",
        "official communication",
        "government agency",
        "tax refund",
        "legal department",
        "support team",
        "service provider",
        "your bank",
        "shipping company",
        "delivery notice",
        "police department",
        "court order",
        "social security",
        "IRS",
        "customs",
        "admin",
        "notice of violation",
        "from your friend",
        "CEO",
        "CFO",
        "CIO",
        "COO",
        "HR department",
        "IT department",
        "customer service",
        "technical support",
        "sales department",
        "marketing department",
        "vendor",
        "supplier",
        "partner",
        "affiliate",
        "representative",
        "agent",
        "ambassador",
        "spokesperson",
        "public figure",
        "celebrity",
        "influencer",
        "religious leader",
        "community leader",
        "foreign official",
        "international organization",
        "trusted advisor",
        // New
        "confidential source",
        // New
        "verified sender",
        // New
        "authorized representative",
        // New
        "official document",
        // New
        "legal compliance",
        // New
        "urgent correspondence",
        // New
        "priority message",
        // New
        "classified information",
        // New
        "restricted access",
        // New
        "confidential briefing",
        // New
        // Technical scam keywords
        "virus detected",
        "system error",
        "security breach",
        "malware warning",
        "computer infected",
        "urgent update",
        "remote access",
        "technical support",
        "fix your computer",
        "software download",
        "driver update",
        "your device is at risk",
        "internet security",
        "firewall alert",
        "data loss",
        "ransomware",
        "keylogger",
        "spyware",
        "adware",
        "rootkit",
        "botnet",
        "DDoS attack",
        "pharming",
        "vishing",
        "smishing",
        "SIM swapping",
        "account takeover",
        "man-in-the-middle attack",
        "zero-day exploit",
        "patch update",
        "system restore",
        "data backup",
        "cloud migration",
        "API access",
        "database error",
        "network outage",
        "server maintenance",
        "device compromise",
        // New
        "encryption failure",
        // New
        "cyber threat",
        // New
        "hardware malfunction",
        // New
        "software vulnerability",
        // New
        "emergency patch",
        // New
        "critical vulnerability",
        // New
        "unauthorized login",
        // New
        "data corruption",
        // New
        "file encryption",
        // New
        "system lockdown",
        // New
        // Romance/personal scam keywords
        "lonely",
        "looking for love",
        "secret admirer",
        "personal connection",
        "private message",
        "confidential offer",
        "long distance",
        "trust me",
        "true love",
        "destiny",
        "soulmate",
        "need your help",
        "emergency situation",
        "family tragedy",
        "travel expenses",
        "financial hardship",
        "sick relative",
        "military service",
        "foreign country",
        "widow",
        "widower",
        "orphan",
        "refugee",
        "doctor",
        "engineer",
        "artist",
        "entrepreneur",
        "humanitarian",
        "missionary",
        "online dating",
        "matchmaking service",
        "pen pal",
        "virtual friend",
        "emotional support",
        "financial support",
        "visa assistance",
        "legal assistance",
        "inheritance claim",
        "missing person",
        "heartbroken",
        // New
        "desperate for love",
        // New
        "divorce recovery",
        // New
        "single parent",
        // New
        "lost connection",
        // New
        "rekindle romance",
        // New
        "fate brought us together",
        // New
        "spiritual bond",
        // New
        "urgent companionship",
        // New
        "emotional healing",
        // New
        // Job/employment scam keywords
        "work from home",
        "easy money",
        "instant income",
        "no experience needed",
        "unlimited earning potential",
        "get rich quick",
        "mystery shopper",
        "package forwarding",
        "data entry",
        "online surveys",
        "make money online",
        "start immediately",
        "high salary",
        "part-time job",
        "full-time job",
        "flexible hours",
        "recruiters",
        "hiring now",
        "job offer",
        "application form",
        "commission-based",
        "referral program",
        "multi-level marketing",
        "MLM",
        "direct sales",
        "home-based business",
        "freelance opportunity",
        "contract work",
        "remote position",
        "virtual assistant",
        "content creator",
        "social media manager",
        "affiliate marketing",
        "e-commerce",
        "drop shipping",
        "business owner",
        "entrepreneurship",
        "startup",
        "investment opportunity",
        "training program",
        "certification course",
        "license required",
        "background check",
        "quick hire",
        // New
        "immediate start",
        // New
        "guaranteed income",
        // New
        "residual income",
        // New
        "passive earnings",
        // New
        "career advancement",
        // New
        "dream job",
        // New
        "side hustle",
        // New
        "income stream",
        // New
        "lucrative opportunity"
        // New
      ];
      return this.models.spam = {
        predict: async (t) => {
          const r = n.reduce(
            (c, h) => t.toLowerCase().includes(h.toLowerCase()) ? c + 0.2 : c,
            0
          ), o = this.models.nlp(t).people().found, i = /[!]{2,}|\${2,}|[%]{2,}/.test(t), s = /\b(free|win|cash|prize)\.[a-z]{3}\b/i.test(t), l = r + [
            o ? 0.2 : 0,
            i ? 0.3 : 0,
            s ? 0.4 : 0
          ].reduce((c, h) => c + h, 0);
          return Math.min(l, 1);
        }
      }, this.models.localThreat = {
        predict: async (t) => {
          try {
            const a = (await this.models.toxicity.classify([t])).filter((o) => o.results[0].match).reduce((o, i) => o + i.results[0].probabilities[1], 0);
            return Math.min(a, 1);
          } catch (r) {
            return console.warn("Local threat detection failed", r), 0;
          }
        }
      }, console.log("✅ AI models loaded successfully"), !0;
    } catch (n) {
      return console.error("❌ Failed to load models:", n), !1;
    }
  }
  // Scan the currently open email
  async scanOpenEmail() {
    const n = document.querySelector('div[role="main"]');
    if (!n) return;
    const t = n.querySelector(".a3s");
    !t || t.dataset.scanned || (this.createBanner({ status: "loading" }, n), setTimeout(async () => {
      const r = t.textContent || "", a = await this.analyzeEmail(r);
      this.createBanner(a, n), a.isMalicious && (t.dataset.scanned = "true");
    }, 500));
  }
  // Create banner for different statuses
  createBanner(n, t) {
    t.querySelectorAll(
      ".gmail-security-banner"
    ).forEach((c) => c.remove());
    const a = document.createElement("div");
    a.className = "gmail-security-banner";
    let o, i, s, u;
    switch (n.status) {
      case "loading":
        o = "#fff3e0", i = "#ff9800", s = "⏳", u = "Analyzing Email Security...";
        break;
      case "threat":
        o = "#ffebee", i = "#ef5350", s = "⚠️", u = "Potential Email Threat Detected";
        break;
      case "safe":
        o = "#e8f5e9", i = "#4caf50", s = "✅", u = "Email Appears Safe";
        break;
      default:
        o = "#f5f5f5", i = "#9e9e9e", s = "ℹ️", u = "Security Analysis Complete";
    }
    a.style.cssText = `
      width: 100%;
      background: ${o};
      border: 2px solid ${i};
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      z-index: 1000;
      position: relative;
    `, a.innerHTML = `
      <h3 style="color:${i};margin:0 0 10px;font-size:16px;">${s} ${u}</h3>
      ${n.status !== "loading" ? `
        <p style="margin:5px 0;font-weight:bold;">
          ${n.status === "threat" ? "Threat Confidence:" : "Safety Confidence:"} 
          ${n.confidence || 0}%
        </p>
      ` : ""}
      ${n.reasons && n.reasons.length > 0 ? `
        <ul style="padding-left:20px;margin:5px 0;">
          ${n.reasons.map((c) => `<li style="font-size:14px;">${c}</li>`).join("")}
        </ul>
      ` : ""}
    `;
    const l = t.firstChild;
    l ? t.insertBefore(a, l) : t.appendChild(a);
  }
  // Comprehensive threat analysis
  async analyzeEmail(n) {
    if (!this.models.toxicity)
      return console.warn("Models not loaded"), {
        status: "loading",
        confidence: 0,
        reasons: ["Initializing security models..."]
      };
    try {
      console.log("Starting comprehensive analysis...");
      const [t, r, a] = await Promise.all([
        this.models.toxicity.classify([n]),
        this.models.spam.predict(n),
        this.models.localThreat.predict(n)
      ]), o = t.filter(
        (c) => c.results[0].match
      ), i = [
        ...o.map((c) => c.results[0].probabilities[1]),
        r,
        a
      ];
      console.log("Confidence scores:", i);
      const s = i.reduce((c, h) => c + h, 0) / i.length, u = Math.round(s * 100), l = u > 10;
      return console.log("Confidence %:", u), {
        status: l ? "threat" : "safe",
        isMalicious: l,
        confidence: u,
        reasons: [
          ...o.map(
            (c) => `Detected ${c.label} content with ${Math.round(
              c.results[0].probabilities[1] * 100
            )}% confidence`
          ),
          ...r > 0.5 ? [
            `Potential spam indicators detected (${Math.round(
              r * 100
            )}%)`
          ] : [],
          ...a > 0.5 ? [
            `Local threat detection raised concerns (${Math.round(
              a * 100
            )}%)`
          ] : []
        ]
      };
    } catch (t) {
      return console.error("Comprehensive analysis failed:", t), {
        status: "error",
        isMalicious: !1,
        confidence: 0,
        reasons: ["Analysis failed due to an unexpected error"]
      };
    } finally {
      console.log("Finished analysis.");
    }
  }
}
async function T4() {
  const e = new E4();
  try {
    await e.initialize();
  } catch (n) {
    console.error("Failed to initialize Gmail Security Extension:", n);
  }
}
T4();
